

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>casatools.coordsys &mdash; Pipeline 0.0.dev0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css?v=4ae1632d" />
      <link rel="stylesheet" type="text/css" href="../../_static/sphinx_astrorefs.css?v=4d4a2fdb" />
      <link rel="stylesheet" type="text/css" href="../../_static/custom_theme.css?v=30144f19" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=51d40e3f"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: gray" >

          
          
          <a href="../../index.html" class="icon icon-home">
            Pipeline
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Basics</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../develdocmd/ways_to_run_the_pipeline.html">Ways to run the Pipeline</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../develdocmd/recipes.html">Pipeline Recipes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dependencies.html">Dependencies of <code class="docutils literal notranslate"><span class="pre">Pipeline</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../releases.html">Past Releases</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../apisummary.html">Full APIs (autosummary)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../apisummary.html#pipeline-tasks-autosummary">Pipeline Tasks (autosummary)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../apisummary.html#pipeline-domain-context-autosummary">Pipeline domain/context (autosummary)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../apisummary.html#pipeline-domain-infrastructure-modules-automodapi">Pipeline domain/infrastructure modules (automodapi)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../apisummary.html#pipeline-h-tasks-modules-autmodapi"><code class="docutils literal notranslate"><span class="pre">pipeline.h*.tasks</span></code> modules (autmodapi)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../apisummary.html#inheritance-diagrams-for-pipeline-task-inputs-results-classes">Inheritance Diagrams for Pipeline <code class="docutils literal notranslate"><span class="pre">Task</span></code>/<code class="docutils literal notranslate"><span class="pre">Inputs</span></code>/<code class="docutils literal notranslate"><span class="pre">Results</span></code> Classes</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Developer Notes</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../develdocmd/ALMA-Imaging-Workflow.html">ALMA interferometry imaging workflow</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../develdocmd/VLA-Imaging-Workflow.html">VLA interferometry imaging workflow</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../develdocmd/VLASS-SE-CONT-Imaging-Workflow.html">VLASS-SE-CONT imaging workflow</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../develdocmd/VLASS-SE-CUBE-Imaging-Workflow.html">VLASS-SE-CUBE imaging workflow</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../develdocmd/selfcal_workflow.html">VLASS Selfcal &amp; Restore workflows</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../develdocmd/comparing_pipeline_executions.html">Comparing pipeline executions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../develdocmd/building_the_pipeline.html">Building the pipeline</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modular.html">Run the Pipeline in a Conda environment</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../develdocmd/pipeline_tests.html">Pipeline testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../develdocmd/DataType_Testing.html">DataType Testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../develdocmd/QA_scores.html">Pipeline Quality Assurance (QA) Score Class Design</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../develdocmd/DeveloperDocumentation.html">Pipeline developer documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../develdocmd/python3_conversion_notes.html">Python 3 conversion notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../heuristics/field_parameter.html">Field parameter</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../heuristics/FlaggingTasks.html">Pipeline Flagging Tasks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../notebooks/context.html">Pipeline Context</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../notebooks/tier0dask.html">“Tier0” Parallelization with Dask/Futures</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: gray" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Pipeline</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">casatools.coordsys</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for casatools.coordsys</h1><div class="highlight"><pre>
<span></span><span class="c1">##################### generated by xml-casa (v2) from coordsys.xml ##################</span>
<span class="c1">##################### c2b79b049eed021d6e3447da1327c9c2 ##############################</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">absolute_import</span> 
<span class="kn">from</span> <span class="nn">.__casac__.coordsys</span> <span class="kn">import</span> <span class="n">coordsys</span> <span class="k">as</span> <span class="n">_coordsys</span>

<span class="kn">from</span> <span class="nn">.errors</span> <span class="kn">import</span> <span class="n">create_error_string</span>
<span class="kn">from</span> <span class="nn">.typecheck</span> <span class="kn">import</span> <span class="n">CasaValidator</span> <span class="k">as</span> <span class="n">_validator</span>
<span class="n">_pc</span> <span class="o">=</span> <span class="n">_validator</span><span class="p">(</span> <span class="p">)</span>
<span class="kn">from</span> <span class="nn">.coercetype</span> <span class="kn">import</span> <span class="n">coerce</span> <span class="k">as</span> <span class="n">_coerce</span>
<span class="n">_wrap_coordsys</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">swig_object</span><span class="p">:</span> <span class="n">coordsys</span><span class="p">(</span><span class="n">swig_object</span><span class="o">=</span><span class="n">swig_object</span><span class="p">)</span>

<div class="viewcode-block" id="coordsys">
<a class="viewcode-back" href="../../_autosummary/pipeline.hsd.tasks.imaging.imaging_params.coordsys.html#pipeline.hsd.tasks.imaging.imaging_params.coordsys">[docs]</a>
<span class="k">class</span> <span class="nc">coordsys</span><span class="p">:</span>
    <span class="n">_info_group_</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;images&quot;&quot;&quot;</span>
    <span class="n">_info_desc_</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;Operations on CoordinateSystems&quot;&quot;&quot;</span>
    <span class="c1">### self</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;swig_object&#39;</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span> <span class="o">=</span> <span class="n">_coordsys</span><span class="p">()</span>

<div class="viewcode-block" id="coordsys.newcoordsys">
<a class="viewcode-back" href="../../_autosummary/pipeline.hsd.tasks.imaging.imaging_params.coordsys.html#pipeline.hsd.tasks.imaging.imaging_params.coordsys.newcoordsys">[docs]</a>
    <span class="k">def</span> <span class="nf">newcoordsys</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">spectral</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">stokes</span><span class="o">=</span><span class="p">[</span>  <span class="p">],</span> <span class="n">linear</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">tabular</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;By default, this constructor makes an empty Coordsys tool.  You can ask</span>
<span class="sd">        it to include various sorts of coordinates through the arguments.</span>
<span class="sd">        Except for Stokes, you don&#39;t have any control over the coordinate</span>
<span class="sd">        contents (e.g.  reference value etc.) it does make for you on request.</span>
<span class="sd">        But you can edit the Coordinate System after creation if you wish.</span>
<span class="sd">        </span>
<span class="sd">        If you wish to make a Stokes coordinate, then you assign</span>
<span class="sd">        {stfaf stokes} to a string (or a vector of strings) saying</span>
<span class="sd">        which Stokes you want.  casa allows rather</span>
<span class="sd">        a lot of potential Stokes types.</span>
<span class="sd">        </span>
<span class="sd">        Probably most useful is some combination of the</span>
<span class="sd">        basic I, Q, U, V, XX, YY, XY, YX, RR, LL, RL, and LR.</span>
<span class="sd">        </span>
<span class="sd">        However, a more esoteric choice is also possible:</span>
<span class="sd">        RX, RY, LX, LY, XR, XL, YR, YL (these are mixed</span>
<span class="sd">        linear and circular),  PP, PQ, QP, QQ (general quasi-orthogonal correlation products)</span>
<span class="sd">        RCircular, LCircular, Linear  (single dish polarization types).</span>
<span class="sd">        </span>
<span class="sd">        You can also specify some polarization `Stokes&#39; types:</span>
<span class="sd">        Ptotal (Polarized intensity ($(Q^2+U^2+V^2)^{1/2}$),</span>
<span class="sd">        Plinear (Linearly Polarized intensity ($(Q^2+U^2)^{1/2}$),</span>
<span class="sd">        PFtotal (Polarization Fraction (Ptotal/I)),</span>
<span class="sd">        PFlinear  (Linear Polarization Fraction (Plinear/I)), and</span>
<span class="sd">        Pangle  (Linear Polarization Angle ($0.5~arctan(U/Q)$ in radians)).</span>
<span class="sd">        </span>
<span class="sd">        Probably you will find the more unusual types aren&#39;t fully</span>
<span class="sd">        supported throughout the system.</span>
<span class="sd">        </span>
<span class="sd">        You can make a LinearCoordinate with as many uncoupled axes as you like.</span>
<span class="sd">        Thus, {stfaf linear=2} makes one LinearCoordinate with 2 axes (think</span>
<span class="sd">        of it like a DirectionCoordinate which also has 2 axes [but coupled in</span>
<span class="sd">        this case], a longitude and a latitude).</span>
<span class="sd">        </span>
<span class="sd">        If you make a TabularCoordinate, it is linear to start with.</span>
<span class="sd">        You can change it to a non-linear one by providing</span>
<span class="sd">        a list of pixel and world values to function</span>
<span class="sd">        settabular.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_wrap_coordsys</span><span class="p">(</span><span class="n">swig_object</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">newcoordsys</span><span class="p">(</span><span class="n">direction</span><span class="p">,</span> <span class="n">spectral</span><span class="p">,</span> <span class="n">stokes</span><span class="p">,</span> <span class="n">linear</span><span class="p">,</span> <span class="n">tabular</span><span class="p">))</span></div>


<div class="viewcode-block" id="coordsys.addcoordinate">
<a class="viewcode-back" href="../../_autosummary/pipeline.hsd.tasks.imaging.imaging_params.coordsys.html#pipeline.hsd.tasks.imaging.imaging_params.coordsys.addcoordinate">[docs]</a>
    <span class="k">def</span> <span class="nf">addcoordinate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">spectral</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">stokes</span><span class="o">=</span><span class="p">[</span>  <span class="p">],</span> <span class="n">linear</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">tabular</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add default coordinates of the specified types.  This function allows</span>
<span class="sd">        multiple coordinates of the same type which are not well supported.</span>
<span class="sd">        Use only for assay tests.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">addcoordinate</span><span class="p">(</span><span class="n">direction</span><span class="p">,</span> <span class="n">spectral</span><span class="p">,</span> <span class="n">stokes</span><span class="p">,</span> <span class="n">linear</span><span class="p">,</span> <span class="n">tabular</span><span class="p">)</span></div>


<div class="viewcode-block" id="coordsys.axesmap">
<a class="viewcode-back" href="../../_autosummary/pipeline.hsd.tasks.imaging.imaging_params.coordsys.html#pipeline.hsd.tasks.imaging.imaging_params.coordsys.axesmap">[docs]</a>
    <span class="k">def</span> <span class="nf">axesmap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">toworld</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function returns a vector describing the mapping from pixel to</span>
<span class="sd">        world or world to pixel axes.  It is not for general user use.</span>
<span class="sd">        </span>
<span class="sd">        See the htmlref{discussion}{COORDSYS:PWAXES} about pixel and world axis</span>
<span class="sd">        ordering.  Generally they will be in the same order.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">axesmap</span><span class="p">(</span><span class="n">toworld</span><span class="p">)</span></div>


<div class="viewcode-block" id="coordsys.axiscoordinatetypes">
<a class="viewcode-back" href="../../_autosummary/pipeline.hsd.tasks.imaging.imaging_params.coordsys.html#pipeline.hsd.tasks.imaging.imaging_params.coordsys.axiscoordinatetypes">[docs]</a>
    <span class="k">def</span> <span class="nf">axiscoordinatetypes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">world</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function  returns a vector string</span>
<span class="sd">        giving the coordinate type for each axis (world or pixel)</span>
<span class="sd">        in the Coordinate System.</span>
<span class="sd">        </span>
<span class="sd">        See the htmlref{discussion}{COORDSYS:PWAXES} about pixel and world axis</span>
<span class="sd">        ordering.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">axiscoordinatetypes</span><span class="p">(</span><span class="n">world</span><span class="p">)</span></div>


<div class="viewcode-block" id="coordsys.conversiontype">
<a class="viewcode-back" href="../../_autosummary/pipeline.hsd.tasks.imaging.imaging_params.coordsys.html#pipeline.hsd.tasks.imaging.imaging_params.coordsys.conversiontype">[docs]</a>
    <span class="k">def</span> <span class="nf">conversiontype</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s1">&#39;direction&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Some coordinates contain a reference code.  Examples of reference codes</span>
<span class="sd">        are B1950 and J2000 for direction coordinates, or LSRK and BARY for</span>
<span class="sd">        spectral coordinates.  When you do conversions between pixel and world</span>
<span class="sd">        coordinate, the coordinates are in the reference frame corresponding to</span>
<span class="sd">        these codes.</span>
<span class="sd">        </span>
<span class="sd">        Function  setconversiontype</span>
<span class="sd">        allows you to specify a different reference frame</span>
<span class="sd">        which is used when converting between world and pixel coordinate.</span>
<span class="sd">        </span>
<span class="sd">        This function allows you to recover those conversion types.  If no extra</span>
<span class="sd">        conversion layer has been set, you get back the native reference types.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">conversiontype</span><span class="p">(</span><span class="nb">type</span><span class="p">)</span></div>


<div class="viewcode-block" id="coordsys.convert">
<a class="viewcode-back" href="../../_autosummary/pipeline.hsd.tasks.imaging.imaging_params.coordsys.html#pipeline.hsd.tasks.imaging.imaging_params.coordsys.convert">[docs]</a>
    <span class="k">def</span> <span class="nf">convert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coordin</span><span class="p">,</span> <span class="n">absin</span><span class="o">=</span><span class="p">[</span> <span class="nb">bool</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span> <span class="p">],</span> <span class="n">dopplerin</span><span class="o">=</span><span class="s1">&#39;radio&#39;</span><span class="p">,</span> <span class="n">unitsin</span><span class="o">=</span><span class="p">[</span> <span class="s1">&#39;Native&#39;</span> <span class="p">],</span> <span class="n">absout</span><span class="o">=</span><span class="p">[</span> <span class="nb">bool</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span> <span class="p">],</span> <span class="n">dopplerout</span><span class="o">=</span><span class="s1">&#39;radio&#39;</span><span class="p">,</span> <span class="n">unitsout</span><span class="o">=</span><span class="p">[</span> <span class="s1">&#39;Native&#39;</span> <span class="p">],</span> <span class="n">shape</span><span class="o">=</span><span class="p">[</span> <span class="nb">int</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function converts between mixed pixel/world/abs/rel numeric</span>
<span class="sd">        coordinates.  The input and output coordinates are specified via a</span>
<span class="sd">        numeric vector giving coordinate values, a string vector giving units, a</span>
<span class="sd">        boolean vector specifying whether the coordinate is absolute or relative</span>
<span class="sd">        (to the reference pixel) and doppler strings specifying the doppler</span>
<span class="sd">        convention for velocities.</span>
<span class="sd">        </span>
<span class="sd">        The units string may include {cf pix} for pixel coordinates and</span>
<span class="sd">        velocity units (i.e. any unit consistent with {cf m/s}).</span>
<span class="sd">        </span>
<span class="sd">        The allowed doppler strings and definition are described</span>
<span class="sd">        in function summary.</span>
<span class="sd">        </span>
<span class="sd">        The {stfaf shape} argument is optional.  If your Coordinate</span>
<span class="sd">        System is from an image, then assign the image shape to this</span>
<span class="sd">        argument.  It is used only when making mixed (pixel/world) conversions</span>
<span class="sd">        for Direction Coordinates to resolve ambiguity.</span>
<span class="sd">        </span>
<span class="sd">        The example clarifies the use of this function.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">coordin</span><span class="p">,</span> <span class="n">absin</span><span class="p">,</span> <span class="n">dopplerin</span><span class="p">,</span> <span class="n">unitsin</span><span class="p">,</span> <span class="n">absout</span><span class="p">,</span> <span class="n">dopplerout</span><span class="p">,</span> <span class="n">unitsout</span><span class="p">,</span> <span class="n">shape</span><span class="p">)</span></div>


<div class="viewcode-block" id="coordsys.convertdirection">
<a class="viewcode-back" href="../../_autosummary/pipeline.hsd.tasks.imaging.imaging_params.coordsys.html#pipeline.hsd.tasks.imaging.imaging_params.coordsys.convertdirection">[docs]</a>
    <span class="k">def</span> <span class="nf">convertdirection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">frame</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert the direction coordinate in the coordinate system to the specified frame by</span>
<span class="sd">        rotating about the reference pixel so that the resulting coordinate axes are parallel</span>
<span class="sd">        to the cardinal directions. The resulting coordinate will not have a conversion layer,</span>
<span class="sd">        even if the input direction coordinate does. A conversion layer can be set after by</span>
<span class="sd">        running cs.setconversiontype(). Be aware that if you attach the resulting coordinate</span>
<span class="sd">        system to an image whose pixels have not been rotated around the reference pixel in</span>
<span class="sd">        the same manner, you will likely get an image for which the pixels do not match</span>
<span class="sd">        up to world coordinate values. This method should only be used by experienced users who</span>
<span class="sd">        know what they are doing. It was written originally to facilitate rotating the</span>
<span class="sd">        direction coordinate since the implementation of imregrid requires this in certain</span>
<span class="sd">        circumstances. The conversion is done in place; a new coordinate system tool is not</span>
<span class="sd">        created. The returned record represents an angular quantity through which the old</span>
<span class="sd">        direction coordinate was rotated to create the new coordinate.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">convertdirection</span><span class="p">(</span><span class="n">frame</span><span class="p">)</span></div>


<div class="viewcode-block" id="coordsys.convertmany">
<a class="viewcode-back" href="../../_autosummary/pipeline.hsd.tasks.imaging.imaging_params.coordsys.html#pipeline.hsd.tasks.imaging.imaging_params.coordsys.convertmany">[docs]</a>
    <span class="k">def</span> <span class="nf">convertmany</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coordin</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">absin</span><span class="o">=</span><span class="p">[</span> <span class="nb">bool</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span> <span class="p">],</span> <span class="n">dopplerin</span><span class="o">=</span><span class="s1">&#39;radio&#39;</span><span class="p">,</span> <span class="n">unitsin</span><span class="o">=</span><span class="p">[</span> <span class="s1">&#39;Native&#39;</span> <span class="p">],</span> <span class="n">absout</span><span class="o">=</span><span class="p">[</span> <span class="nb">bool</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span> <span class="p">],</span> <span class="n">dopplerout</span><span class="o">=</span><span class="s1">&#39;radio&#39;</span><span class="p">,</span> <span class="n">unitsout</span><span class="o">=</span><span class="p">[</span> <span class="s1">&#39;Native&#39;</span> <span class="p">],</span> <span class="n">shape</span><span class="o">=</span><span class="p">[</span> <span class="nb">int</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function converts between many mixed pixel/world/abs/rel numeric</span>
<span class="sd">        coordinates.   See function convert</span>
<span class="sd">        for more information.</span>
<span class="sd">        </span>
<span class="sd">        The only diffference with that function is that you</span>
<span class="sd">        provide a matrix holding many coordinates to convert</span>
<span class="sd">        and a matrix of many converted coordinates is returned.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">convertmany</span><span class="p">(</span><span class="n">coordin</span><span class="p">,</span> <span class="n">absin</span><span class="p">,</span> <span class="n">dopplerin</span><span class="p">,</span> <span class="n">unitsin</span><span class="p">,</span> <span class="n">absout</span><span class="p">,</span> <span class="n">dopplerout</span><span class="p">,</span> <span class="n">unitsout</span><span class="p">,</span> <span class="n">shape</span><span class="p">)</span></div>


<div class="viewcode-block" id="coordsys.coordinatetype">
<a class="viewcode-back" href="../../_autosummary/pipeline.hsd.tasks.imaging.imaging_params.coordsys.html#pipeline.hsd.tasks.imaging.imaging_params.coordsys.coordinatetype">[docs]</a>
    <span class="k">def</span> <span class="nf">coordinatetype</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function  returns a string describing</span>
<span class="sd">        the type of the specified coordinate.  If {stfaf which=unset} the types</span>
<span class="sd">        for all coordinates are returned.</span>
<span class="sd">        </span>
<span class="sd">        Possible output values are &#39;Direction&#39;, &#39;Spectral&#39;, &#39;Stokes&#39;, &#39;Linear&#39;, and</span>
<span class="sd">        &#39;Tabular&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">coordinatetype</span><span class="p">(</span><span class="n">which</span><span class="p">)</span></div>


<div class="viewcode-block" id="coordsys.copy">
<a class="viewcode-back" href="../../_autosummary/pipeline.hsd.tasks.imaging.imaging_params.coordsys.html#pipeline.hsd.tasks.imaging.imaging_params.coordsys.copy">[docs]</a>
    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function returns a copy, not a reference, of the Coordsys tool.</span>
<span class="sd">        It is your responsibility to call the {stff done} function</span>
<span class="sd">        on the new tool.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_wrap_coordsys</span><span class="p">(</span><span class="n">swig_object</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span></div>


<div class="viewcode-block" id="coordsys.done">
<a class="viewcode-back" href="../../_autosummary/pipeline.hsd.tasks.imaging.imaging_params.coordsys.html#pipeline.hsd.tasks.imaging.imaging_params.coordsys.done">[docs]</a>
    <span class="k">def</span> <span class="nf">done</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;If you no longer need to use a Coordsys tool calling this function</span>
<span class="sd">        will free up its resources and restore the default coordsys tool.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">done</span><span class="p">()</span></div>


<div class="viewcode-block" id="coordsys.epoch">
<a class="viewcode-back" href="../../_autosummary/pipeline.hsd.tasks.imaging.imaging_params.coordsys.html#pipeline.hsd.tasks.imaging.imaging_params.coordsys.epoch">[docs]</a>
    <span class="k">def</span> <span class="nf">epoch</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function  returns the epoch of the observation as a</span>
<span class="sd">        Measure.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">epoch</span><span class="p">()</span></div>


<div class="viewcode-block" id="coordsys.findaxis">
<a class="viewcode-back" href="../../_autosummary/pipeline.hsd.tasks.imaging.imaging_params.coordsys.html#pipeline.hsd.tasks.imaging.imaging_params.coordsys.findaxis">[docs]</a>
    <span class="k">def</span> <span class="nf">findaxis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">world</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">0</span><span class="p">)):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function  finds the specified axis in</span>
<span class="sd">        the Coordinate System. If the axis does not exist, it throws an exception.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">findaxis</span><span class="p">(</span><span class="n">world</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span></div>


<div class="viewcode-block" id="coordsys.findaxisbyname">
<a class="viewcode-back" href="../../_autosummary/pipeline.hsd.tasks.imaging.imaging_params.coordsys.html#pipeline.hsd.tasks.imaging.imaging_params.coordsys.findaxisbyname">[docs]</a>
    <span class="k">def</span> <span class="nf">findaxisbyname</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axisname</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">allowfriendlyname</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Find the world axis based on its name. Matching is not case sensitive and minimal match is supported, eg &quot;dec&quot; will match &quot;Declination&quot;.</span>
<span class="sd">        In addition, if allowfriendlyname is True, other common terms will match the expected axis. Currently supported are:</span>
<span class="sd">        &quot;spectral&quot; matches frequency type axes, eg &quot;Frequency&quot; or &quot;Velocity&quot;,</span>
<span class="sd">        &quot;ra&quot; matches &quot;Right Ascension&quot;. These names must be spelled out completely; eg &quot;spectral&quot; rather than simply &quot;spec&quot;.</span>
<span class="sd">        The first matching axis (zero-based) number is returned. If no axis can be matched, an exception is thrown.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">findaxisbyname</span><span class="p">(</span><span class="n">axisname</span><span class="p">,</span> <span class="n">allowfriendlyname</span><span class="p">)</span></div>


<div class="viewcode-block" id="coordsys.findcoordinate">
<a class="viewcode-back" href="../../_autosummary/pipeline.hsd.tasks.imaging.imaging_params.coordsys.html#pipeline.hsd.tasks.imaging.imaging_params.coordsys.findcoordinate">[docs]</a>
    <span class="k">def</span> <span class="nf">findcoordinate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s1">&#39;direction&#39;</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">0</span><span class="p">)):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function finds the axes in the</span>
<span class="sd">        Coordinate System for the specified coordinate (minimum match is active</span>
<span class="sd">        for argument {stfaf type}).  By default it finds the first coordinate,</span>
<span class="sd">        but if there is more than one (can happen for linear coordinates), you</span>
<span class="sd">        can specify which.  It returns a dictionary with &#39;return&#39;, &#39;pixel&#39;, and</span>
<span class="sd">        &#39;world&#39; as keys. The associated value of &#39;return&#39; is a boolean indicating if</span>
<span class="sd">        the specified coordinate was found. The values of &#39;pixel&#39; and &#39;world&#39; are</span>
<span class="sd">        arrays indicating the indices of the associated pixel and world axes, respectively,</span>
<span class="sd">        of the specified coordinate. If the coordinate does not exist, these arrays</span>
<span class="sd">        will be empty.</span>
<span class="sd">        </span>
<span class="sd">        See also the function axesmap</span>
<span class="sd">        which returns the mapping between pixel and world axes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">findcoordinate</span><span class="p">(</span><span class="nb">type</span><span class="p">,</span> <span class="n">which</span><span class="p">)</span></div>


<div class="viewcode-block" id="coordsys.frequencytofrequency">
<a class="viewcode-back" href="../../_autosummary/pipeline.hsd.tasks.imaging.imaging_params.coordsys.html#pipeline.hsd.tasks.imaging.imaging_params.coordsys.frequencytofrequency">[docs]</a>
    <span class="k">def</span> <span class="nf">frequencytofrequency</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">frequnit</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">velocity</span><span class="o">=</span><span class="p">[</span> <span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function converts frequencies to frequencies by applying a</span>
<span class="sd">        relativistic Doppler shift:</span>
<span class="sd">        fout = fin * sqrt((1.-v/c)/(1.+v/c)) .</span>
<span class="sd">        </span>
<span class="sd">        The input frequencies are specified via a vector of numeric values and</span>
<span class="sd">        a specified unit ({stfaf frequnit}).  If you don&#39;t give a frequency</span>
<span class="sd">        unit, it is assumed that the units are those given by function coordsys units() for</span>
<span class="sd">        the spectral coordinate.</span>
<span class="sd">        </span>
<span class="sd">        This function does not make any frame conversions (e.g.  LSR to BARY).</span>
<span class="sd">        </span>
<span class="sd">        This function fails if there is no spectral coordinate</span>
<span class="sd">        in the Coordinate System. See also function</span>
<span class="sd">        frequencytovelocity.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">frequencytofrequency</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">frequnit</span><span class="p">,</span> <span class="n">velocity</span><span class="p">)</span></div>


<div class="viewcode-block" id="coordsys.frequencytovelocity">
<a class="viewcode-back" href="../../_autosummary/pipeline.hsd.tasks.imaging.imaging_params.coordsys.html#pipeline.hsd.tasks.imaging.imaging_params.coordsys.frequencytovelocity">[docs]</a>
    <span class="k">def</span> <span class="nf">frequencytovelocity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">frequnit</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">doppler</span><span class="o">=</span><span class="s1">&#39;radio&#39;</span><span class="p">,</span> <span class="n">velunit</span><span class="o">=</span><span class="s1">&#39;km/s&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function  converts frequencies to</span>
<span class="sd">        velocities.</span>
<span class="sd">        </span>
<span class="sd">        The input frequencies are specified via a vector of numeric values and</span>
<span class="sd">        a specified unit ({stfaf frequnit}).  If you don&#39;t give a frequency</span>
<span class="sd">        unit, it is assumed that the units are those given by function coordsys units() for</span>
<span class="sd">        the spectral coordinate.</span>
<span class="sd">        </span>
<span class="sd">        This function does not make any frame conversions (e.g. LSR to BARY)</span>
<span class="sd">        but you can specifiy the velocity doppler definition via the {stfaf</span>
<span class="sd">        doppler} argument (see image summary() for</span>
<span class="sd">        possible values).</span>
<span class="sd">        </span>
<span class="sd">        The velocities are returned in a vector for which you specify the</span>
<span class="sd">        units ({stfaf velunit} - default is km/s).</span>
<span class="sd">        </span>
<span class="sd">        This function will return a fail if there is no spectral coordinate</span>
<span class="sd">        in the Coordinate System. See also function</span>
<span class="sd">        velocitytofrequency.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">frequencytovelocity</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">frequnit</span><span class="p">,</span> <span class="n">doppler</span><span class="p">,</span> <span class="n">velunit</span><span class="p">)</span></div>


<div class="viewcode-block" id="coordsys.fromrecord">
<a class="viewcode-back" href="../../_autosummary/pipeline.hsd.tasks.imaging.imaging_params.coordsys.html#pipeline.hsd.tasks.imaging.imaging_params.coordsys.fromrecord">[docs]</a>
    <span class="k">def</span> <span class="nf">fromrecord</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">record</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;You can convert a Coordinate System to a record</span>
<span class="sd">        (torecord).  This function</span>
<span class="sd">        (fromrecord) allows you to set the contents of an existing Coordinate</span>
<span class="sd">        System from such a record.   In doing so, you overwrite its current</span>
<span class="sd">        contents.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">fromrecord</span><span class="p">(</span><span class="n">record</span><span class="p">)</span></div>


<div class="viewcode-block" id="coordsys.increment">
<a class="viewcode-back" href="../../_autosummary/pipeline.hsd.tasks.imaging.imaging_params.coordsys.html#pipeline.hsd.tasks.imaging.imaging_params.coordsys.increment">[docs]</a>
    <span class="k">def</span> <span class="nf">increment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;n&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Each axis associated with the Coordinate System has a reference value,</span>
<span class="sd">        reference pixel and an increment (per pixel).  These are used in the</span>
<span class="sd">        mapping from pixel to world coordinate.</span>
<span class="sd">        </span>
<span class="sd">        This function  returns the increment (in</span>
<span class="sd">        world axis order). You can recover  the increments either for all</span>
<span class="sd">        coordinates (leave {stfaf type} unset) or for a specific coordinate</span>
<span class="sd">        type (mimumum match of the allowed types will do).  If you ask for a</span>
<span class="sd">        non-existent coordinate an exception is generated.</span>
<span class="sd">        </span>
<span class="sd">        See the htmlref{discussion}{COORDSYS:FORMATTING} regarding the</span>
<span class="sd">        formatting possibilities available via argument {stfaf format}.</span>
<span class="sd">        </span>
<span class="sd">        You can set the increment with function</span>
<span class="sd">        setincrement.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">increment</span><span class="p">(</span><span class="nb">format</span><span class="p">,</span> <span class="nb">type</span><span class="p">)</span></div>


<div class="viewcode-block" id="coordsys.lineartransform">
<a class="viewcode-back" href="../../_autosummary/pipeline.hsd.tasks.imaging.imaging_params.coordsys.html#pipeline.hsd.tasks.imaging.imaging_params.coordsys.lineartransform">[docs]</a>
    <span class="k">def</span> <span class="nf">lineartransform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Recover the linear transform component for the specified coordinate type.</span>
<span class="sd">        </span>
<span class="sd">        You can set the linear transform with function</span>
<span class="sd">        setlineartransform.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">lineartransform</span><span class="p">(</span><span class="nb">type</span><span class="p">)</span></div>


<div class="viewcode-block" id="coordsys.names">
<a class="viewcode-back" href="../../_autosummary/pipeline.hsd.tasks.imaging.imaging_params.coordsys.html#pipeline.hsd.tasks.imaging.imaging_params.coordsys.names">[docs]</a>
    <span class="k">def</span> <span class="nf">names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Each axis associated with the Coordinate System has a name (they don&#39;t</span>
<span class="sd">        mean anything fundamental).  This function returns those names in</span>
<span class="sd">        world axis order.</span>
<span class="sd">        </span>
<span class="sd">        You can recover the names either for all coordinates (leave {stfaf</span>
<span class="sd">        type} unset) or for a specific coordinate type (mimumum match of the</span>
<span class="sd">        allowed types will do).  If you ask for a non-existent coordinate an</span>
<span class="sd">        exception is generated.</span>
<span class="sd">        </span>
<span class="sd">        You can set the names with function</span>
<span class="sd">        setnames.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">names</span><span class="p">(</span><span class="nb">type</span><span class="p">)</span></div>


<div class="viewcode-block" id="coordsys.naxes">
<a class="viewcode-back" href="../../_autosummary/pipeline.hsd.tasks.imaging.imaging_params.coordsys.html#pipeline.hsd.tasks.imaging.imaging_params.coordsys.naxes">[docs]</a>
    <span class="k">def</span> <span class="nf">naxes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">world</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Find the number of axes  in the Coordinate System.</span>
<span class="sd">        </span>
<span class="sd">        You may find the number of world or pixel axes; these are generally the</span>
<span class="sd">        same and general users can ignore the distinction.  See the</span>
<span class="sd">        htmlref{discussion}{COORDSYS:PWAXES} about pixel and world axis</span>
<span class="sd">        ordering.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">naxes</span><span class="p">(</span><span class="n">world</span><span class="p">)</span></div>


<div class="viewcode-block" id="coordsys.ncoordinates">
<a class="viewcode-back" href="../../_autosummary/pipeline.hsd.tasks.imaging.imaging_params.coordsys.html#pipeline.hsd.tasks.imaging.imaging_params.coordsys.ncoordinates">[docs]</a>
    <span class="k">def</span> <span class="nf">ncoordinates</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function  recovers the number of</span>
<span class="sd">        coordinates in the Coordinate System.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">ncoordinates</span><span class="p">()</span></div>


<div class="viewcode-block" id="coordsys.observer">
<a class="viewcode-back" href="../../_autosummary/pipeline.hsd.tasks.imaging.imaging_params.coordsys.html#pipeline.hsd.tasks.imaging.imaging_params.coordsys.observer">[docs]</a>
    <span class="k">def</span> <span class="nf">observer</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function returns the name of the observer.</span>
<span class="sd">        You can set it with the function setobserver.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">observer</span><span class="p">()</span></div>


<div class="viewcode-block" id="coordsys.projection">
<a class="viewcode-back" href="../../_autosummary/pipeline.hsd.tasks.imaging.imaging_params.coordsys.html#pipeline.hsd.tasks.imaging.imaging_params.coordsys.projection">[docs]</a>
    <span class="k">def</span> <span class="nf">projection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;If the Coordinate System contains a direction coordinate, this function</span>
<span class="sd">        can be used to recover information about the</span>
<span class="sd">        projection.  For discussion about celestial coordinate systems,</span>
<span class="sd">        including projections, see the papers by Mark Calabretta and Eric</span>
<span class="sd">        Greisen. The initial draft  from 1996 (implemented in</span>
<span class="sd">        casa.  Background information can be</span>
<span class="sd">        found</span>
<span class="sd">        htmladdnormallink{here}{http://www.atnf.csiro.au/people/mark.calabretta/WCS}.</span>
<span class="sd">        </span>
<span class="sd">        What this function returns depends upon the value</span>
<span class="sd">        you assign to {stfaf type}.</span>
<span class="sd">        </span>
<span class="sd">        begin{itemize}</span>
<span class="sd">        </span>
<span class="sd">        item {stfaf type=unset}.  In this case (the default), the actual</span>
<span class="sd">        projection type and projection parameters are returned in a</span>
<span class="sd">        record with fields {cf type} and {cf parameters}, respectively.</span>
<span class="sd">        </span>
<span class="sd">        item {stfaf type=&#39;all&#39;}.  In this case, a vector of strings</span>
<span class="sd">        containing all of the possible projection codes is returned.</span>
<span class="sd">        </span>
<span class="sd">        item {stfaf type=code}.  If you specify a valid</span>
<span class="sd">        projection type code (see list by setting {stfaf type=&#39;all&#39;})</span>
<span class="sd">        then what is returned is the number of parameters required</span>
<span class="sd">        to describe that projection (useful in function</span>
<span class="sd">        setprojection).</span>
<span class="sd">        </span>
<span class="sd">        end{itemize}</span>
<span class="sd">        </span>
<span class="sd">        You can change the projection with</span>
<span class="sd">        setprojection.</span>
<span class="sd">        </span>
<span class="sd">        If the Coordinate System does not contain a direction coordinate,</span>
<span class="sd">        an exception is generated.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">projection</span><span class="p">(</span><span class="nb">type</span><span class="p">)</span></div>


<div class="viewcode-block" id="coordsys.referencecode">
<a class="viewcode-back" href="../../_autosummary/pipeline.hsd.tasks.imaging.imaging_params.coordsys.html#pipeline.hsd.tasks.imaging.imaging_params.coordsys.referencecode">[docs]</a>
    <span class="k">def</span> <span class="nf">referencecode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="nb">list</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function  returns the reference code</span>
<span class="sd">        for all, or the specified coordinate type.    Examples of the reference</span>
<span class="sd">        code are B1950 and J2000 for direction coordinates, or LSRK and BARY for</span>
<span class="sd">        spectral coordinates.</span>
<span class="sd">        </span>
<span class="sd">        If {stfaf type} is left unset, then a vector of strings is returned,</span>
<span class="sd">        one code for each coordinate type in the Coordinate System.</span>
<span class="sd">        </span>
<span class="sd">        If you specify {stfaf type} then select from</span>
<span class="sd">        &#39;direction&#39;, &#39;spectral&#39;, &#39;stokes&#39;, and &#39;linear&#39;</span>
<span class="sd">        (the first two letters will do).  However, only the first two</span>
<span class="sd">        coordinate types will return a non-empty string.</span>
<span class="sd">        If the Coordinate System does not contain a coordinate of</span>
<span class="sd">        the type you specify, an exception is generated.</span>
<span class="sd">        </span>
<span class="sd">        The argument {stfaf list} is ignored unless you specify a specific {stfaf type}.</span>
<span class="sd">        If {stfaf list=T}, then this function returns the list of all possible</span>
<span class="sd">        reference  codes for the specified coordinate type.  Otherwise, it just</span>
<span class="sd">        returns the actual code current set in the Coordinate System.</span>
<span class="sd">        </span>
<span class="sd">        The list of all possible types is returned as a record  (it is</span>
<span class="sd">        actually generated by the</span>
<span class="sd">        listcodes function in the</span>
<span class="sd">        measures system). This record has two</span>
<span class="sd">        fields.  These are called &#39;normal&#39;</span>
<span class="sd">        (containing all normal codes) and &#39;extra&#39; (maybe empty, with all extra</span>
<span class="sd">        codes like planets).</span>
<span class="sd">        </span>
<span class="sd">        You can set the reference code with</span>
<span class="sd">        setreferencecode.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">referencecode</span><span class="p">(</span><span class="nb">type</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span></div>


<div class="viewcode-block" id="coordsys.referencepixel">
<a class="viewcode-back" href="../../_autosummary/pipeline.hsd.tasks.imaging.imaging_params.coordsys.html#pipeline.hsd.tasks.imaging.imaging_params.coordsys.referencepixel">[docs]</a>
    <span class="k">def</span> <span class="nf">referencepixel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Each axis associated with the Coordinate System has a reference value,</span>
<span class="sd">        reference pixel and an increment (per pixel).  These are used in the</span>
<span class="sd">        mapping from pixel to world coordinate.</span>
<span class="sd">        </span>
<span class="sd">        This function  returns the reference pixel</span>
<span class="sd">        (in pixel axis order). You can recover  the reference pixel either for</span>
<span class="sd">        all coordinates (leave {stfaf type} unset) or for a specific coordinate</span>
<span class="sd">        type (mimumum match of the allowed types will do).  If you ask for a</span>
<span class="sd">        non-existent coordinate an exception is generated.</span>
<span class="sd">        </span>
<span class="sd">        You can set the reference pixel with function</span>
<span class="sd">        setreferencepixel.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">referencepixel</span><span class="p">(</span><span class="nb">type</span><span class="p">)</span></div>


<div class="viewcode-block" id="coordsys.referencevalue">
<a class="viewcode-back" href="../../_autosummary/pipeline.hsd.tasks.imaging.imaging_params.coordsys.html#pipeline.hsd.tasks.imaging.imaging_params.coordsys.referencevalue">[docs]</a>
    <span class="k">def</span> <span class="nf">referencevalue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;n&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Each axis associated with the Coordinate System has a reference value,</span>
<span class="sd">        reference pixel and an increment (per pixel).  These are used in the</span>
<span class="sd">        mapping from pixel to world coordinate.</span>
<span class="sd">        </span>
<span class="sd">        This function  returns the reference value</span>
<span class="sd">        (in world axis order). You can recover  the reference value either for all</span>
<span class="sd">        coordinates (leave {stfaf type} unset) or for a specific coordinate</span>
<span class="sd">        type (mimumum match of the allowed types will do).  If you ask for a</span>
<span class="sd">        non-existent coordinate an exception is generated.</span>
<span class="sd">        </span>
<span class="sd">        See the htmlref{discussion}{COORDSYS:FORMATTING} regarding the</span>
<span class="sd">        formatting possibilities available via argument {stfaf format}.</span>
<span class="sd">        </span>
<span class="sd">        You can set the reference value with function</span>
<span class="sd">        setreferencevalue.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">referencevalue</span><span class="p">(</span><span class="nb">format</span><span class="p">,</span> <span class="nb">type</span><span class="p">)</span></div>


<div class="viewcode-block" id="coordsys.reorder">
<a class="viewcode-back" href="../../_autosummary/pipeline.hsd.tasks.imaging.imaging_params.coordsys.html#pipeline.hsd.tasks.imaging.imaging_params.coordsys.reorder">[docs]</a>
    <span class="k">def</span> <span class="nf">reorder</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function reorders the coordinates in the Coordinate System.</span>
<span class="sd">        You specify the new order of the coordinates in terms of their old</span>
<span class="sd">        order.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">reorder</span><span class="p">(</span><span class="n">order</span><span class="p">)</span></div>


<div class="viewcode-block" id="coordsys.transpose">
<a class="viewcode-back" href="../../_autosummary/pipeline.hsd.tasks.imaging.imaging_params.coordsys.html#pipeline.hsd.tasks.imaging.imaging_params.coordsys.transpose">[docs]</a>
    <span class="k">def</span> <span class="nf">transpose</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This method transposes the axes (both world and pixel) in the coordinate system.</span>
<span class="sd">        You specify the new order of the axes in terms of their old</span>
<span class="sd">        order, so eg order=[1,0,3,2] means reorder the axes so that the zeroth</span>
<span class="sd">        axis becomes the first axis, the first axis becomes the zeroth axis,</span>
<span class="sd">        the second axis becomes the third axis, and the third axis becomes the</span>
<span class="sd">        second axis.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">order</span><span class="p">)</span></div>


<div class="viewcode-block" id="coordsys.replace">
<a class="viewcode-back" href="../../_autosummary/pipeline.hsd.tasks.imaging.imaging_params.coordsys.html#pipeline.hsd.tasks.imaging.imaging_params.coordsys.replace">[docs]</a>
    <span class="k">def</span> <span class="nf">replace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">csys</span><span class="p">,</span> <span class="n">whichin</span><span class="p">,</span> <span class="n">whichout</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function replaces one coordinate in the current Coordinate System by</span>
<span class="sd">        one coordinate in the given Coordinate System.  The specified</span>
<span class="sd">        coordinates must have the same number of axes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">csys</span><span class="p">,</span> <span class="n">whichin</span><span class="p">,</span> <span class="n">whichout</span><span class="p">)</span></div>


<div class="viewcode-block" id="coordsys.restfrequency">
<a class="viewcode-back" href="../../_autosummary/pipeline.hsd.tasks.imaging.imaging_params.coordsys.html#pipeline.hsd.tasks.imaging.imaging_params.coordsys.restfrequency">[docs]</a>
    <span class="k">def</span> <span class="nf">restfrequency</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;If the Coordinate System contains a spectral coordinate, then</span>
<span class="sd">        it has a rest frequency.  In fact, the spectral coordinate</span>
<span class="sd">        can hold several rest frequencies (to handle for example,</span>
<span class="sd">        an observation where the band covers many lines), although</span>
<span class="sd">        only one is active (for velocity conversions) at a time.</span>
<span class="sd">        </span>
<span class="sd">        This function  recovers the rest frequencies</span>
<span class="sd">        as a quantity vector.   The first frequency is the active one.</span>
<span class="sd">        </span>
<span class="sd">        You can change the rest frequencies with</span>
<span class="sd">        setrestfrequency.</span>
<span class="sd">        </span>
<span class="sd">        If the Coordinate System does not contain a frequency coordinate,</span>
<span class="sd">        an exception is generated.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">restfrequency</span><span class="p">()</span></div>


<div class="viewcode-block" id="coordsys.setconversiontype">
<a class="viewcode-back" href="../../_autosummary/pipeline.hsd.tasks.imaging.imaging_params.coordsys.html#pipeline.hsd.tasks.imaging.imaging_params.coordsys.setconversiontype">[docs]</a>
    <span class="k">def</span> <span class="nf">setconversiontype</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">spectral</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Some coordinates contain a reference code.  Examples of reference codes</span>
<span class="sd">        are B1950 and J2000 for direction coordinates, or LSRK and BARY for</span>
<span class="sd">        spectral coordinates.  When you do conversions between pixel and world</span>
<span class="sd">        coordinate, the coordinates are in the reference frame corresponding to</span>
<span class="sd">        these codes.</span>
<span class="sd">        </span>
<span class="sd">        This function allows you to specify a different reference frame which</span>
<span class="sd">        is used when converting between world and pixel coordinate (see</span>
<span class="sd">        function conversiontype</span>
<span class="sd">        to recover the conversion types).  If it returns F, it means that</span>
<span class="sd">        although the conversion machines were successfully created, a trial</span>
<span class="sd">        conversion failed.  This usually means the REST frame was involved</span>
<span class="sd">        which requires a radial velocity (not yet implemented).  If this</span>
<span class="sd">        happens, the conversion type will be left as it was. The function</span>
<span class="sd">        fails if more blatant things are wrong like a missing coordinate, or</span>
<span class="sd">        an incorrect reference code.</span>
<span class="sd">        </span>
<span class="sd">        The list of possible reference codes can be obtained via function</span>
<span class="sd">        referencecode.</span>
<span class="sd">        </span>
<span class="sd">        With this function, you specify the desired reference code.  Then,</span>
<span class="sd">        when a conversion between pixel and world is requested, an extra</span>
<span class="sd">        conversion is done to ({stff toWorld}) or from ({stff toPixel}) the</span>
<span class="sd">        specified reference frame.</span>
<span class="sd">        </span>
<span class="sd">        The summary</span>
<span class="sd">        function shows the extra conversion reference system to the right of</span>
<span class="sd">        the native reference system (if it is different) and in parentheses.</span>
<span class="sd">        </span>
<span class="sd">        Note that to convert between different spectral reference frames, you</span>
<span class="sd">        need a position, epoch and direction.  The position (telescope) and</span>
<span class="sd">        epoch (date of observation), if not in your coordinate system can be set</span>
<span class="sd">        with functions settelescope and</span>
<span class="sd">        setepoch.  The direction is the</span>
<span class="sd">        reference direction of the {it required} direction coordinate in the</span>
<span class="sd">        coordinate system.</span>
<span class="sd">        </span>
<span class="sd">        bigskipgoodbreak</span>
<span class="sd">        As an example, let us say you are working with a spectral coordinate</span>
<span class="sd">        which was constructed with the LSRK reference frame.  You want to convert</span>
<span class="sd">        some pixel coordinates to barycentric velocities (reference code BARY).</span>
<span class="sd">        </span>
<span class="sd">        begin{verbatim}</span>
<span class="sd">        </span>
<span class="sd">        #</span>
<span class="sd">        print &quot;t----t setconversiontype Ex 1 t----&quot;</span>
<span class="sd">        csys = cs.newcoordsys(direction=True, spectral=True); # Create coordinate system</span>
<span class="sd">        rtn=csys.findcoordinate(&#39;spectral&#39;)             # Find spectral coordinate</span>
<span class="sd">        wa=rtn[&#39;world&#39;]</span>
<span class="sd">        pa=rtn[&#39;pixel&#39;]</span>
<span class="sd">        u = csys.units()[wa]                            # Spectral unit</span>
<span class="sd">        print csys.referencecode(type=&#39;spectral&#39;)       # Which is  in LSRK reference frame</span>
<span class="sd">        #LSRK</span>
<span class="sd">        p = [10,20,30]</span>
<span class="sd">        w = csys.toworld(p, format=&#39;n&#39;)           # Convert a pixel to LSRK world</span>
<span class="sd">        print &#39;pixel, world = &#39;, p, w[&#39;numeric&#39;]</span>
<span class="sd">        #pixel, world =  [10, 20, 30] [21589.999816660376, 20.000112822985134, 1415030000.0]</span>
<span class="sd">        p2 = csys.topixel(w)                      # and back to pixel</span>
<span class="sd">        print &#39;world, pixel = &#39;, w[&#39;numeric&#39;], p2</span>
<span class="sd">        #world, pixel =  [21589.999816660376, 20.000112822985134, 1415030000.0]</span>
<span class="sd">        # [10.00000000000248, 19.999999999999801, 30.0]</span>
<span class="sd">        # Convert LSRK frequency to LSRK velocity</span>
<span class="sd">        v = csys.frequencytovelocity(value=w[&#39;numeric&#39;][wa], frequnit=u,</span>
<span class="sd">        doppler=&#39;RADIO&#39;, velunit=&#39;m/s&#39;);</span>
<span class="sd">        print &#39;pixel, frequency, velocity = &#39;, p[pa], w[&#39;numeric&#39;][wa], v</span>
<span class="sd">        #pixel, frequency, velocity =  30 1415030000.0 1134612.30321</span>
<span class="sd">        csys.setconversiontype(spectral=&#39;BARY&#39;)   # Specify BARY reference code</span>
<span class="sd">        w = csys.toworld(p, format=&#39;n&#39;)           # Convert a pixel to BARY world</span>
<span class="sd">        print &#39;pixel, world = &#39;, p, w[&#39;numeric&#39;]</span>
<span class="sd">        #pixel, world =  [10, 20, 30] [21589.999816660376, 20.000112822985134, 1415031369.0081882]</span>
<span class="sd">        p2 = csys.topixel(w)                      # and back to pixel</span>
<span class="sd">        print &#39;world, pixel = &#39;, w[&#39;numeric&#39;], p2</span>
<span class="sd">        #world, pixel =  [21589.999816660376, 20.000112822985134, 1415031369.0081882]</span>
<span class="sd">        # [10.00000000000248, 19.999999999999801, 30.0]</span>
<span class="sd">        # Convert BARY frequency to BARY velocity</span>
<span class="sd">        v = csys.frequencytovelocity(value=w[&#39;numeric&#39;][wa], frequnit=u,</span>
<span class="sd">        doppler=&#39;RADIO&#39;, velunit=&#39;m/s&#39;);</span>
<span class="sd">        print &#39;pixel, frequency, velocity = &#39;, p[pa], w[&#39;numeric&#39;][wa], v</span>
<span class="sd">        #pixel, frequency, velocity =  30 1415031369.01 1134323.35878</span>
<span class="sd">        #</span>
<span class="sd">        </span>
<span class="sd">        end{verbatim}</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        You must also be aware of when this extra layer is active and when it is</span>
<span class="sd">        not.  It&#39;s a bit nasty.</span>
<span class="sd">        </span>
<span class="sd">        begin{itemize}</span>
<span class="sd">        </span>
<span class="sd">        item - Whenever you use {stff toWorld}, {stff toPixel}</span>
<span class="sd">        {stff toWorldMany}, or {stff toPixelMany} the layer is active.</span>
<span class="sd">        </span>
<span class="sd">        item - Whenever you use {stff convert} or {stff convertMany}</span>
<span class="sd">        the layer {it may} be active.   Here are the rules !</span>
<span class="sd">        </span>
<span class="sd">        It is only relevant to spectral and direction coordinates.</span>
<span class="sd">        </span>
<span class="sd">        For the direction coordinate part of your conversion, if you request a</span>
<span class="sd">        pure world or pixel conversion it is active.  Any pixel/world mix will</span>
<span class="sd">        not invoke it (because it is ill defined).</span>
<span class="sd">        </span>
<span class="sd">        For the spectral coordinate part it is always active (only one axis</span>
<span class="sd">        so must be pixel or world).</span>
<span class="sd">        </span>
<span class="sd">        item - This layer is irrelevant to all functions converting between</span>
<span class="sd">        frequency and velocity, and absolute and relative.  The values are in</span>
<span class="sd">        whatever frame you are working with.</span>
<span class="sd">        </span>
<span class="sd">        end{itemize}</span>
<span class="sd">        </span>
<span class="sd">        The summary function</span>
<span class="sd">        lists the reference frame for direction and spectral coordinates.  If</span>
<span class="sd">        you have also set a conversion reference code it also lists that (to</span>
<span class="sd">        the right in parentheses).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">setconversiontype</span><span class="p">(</span><span class="n">direction</span><span class="p">,</span> <span class="n">spectral</span><span class="p">)</span></div>


<div class="viewcode-block" id="coordsys.getconversiontype">
<a class="viewcode-back" href="../../_autosummary/pipeline.hsd.tasks.imaging.imaging_params.coordsys.html#pipeline.hsd.tasks.imaging.imaging_params.coordsys.getconversiontype">[docs]</a>
    <span class="k">def</span> <span class="nf">getconversiontype</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">showconversion</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;See conversiontype for more complete description.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">getconversiontype</span><span class="p">(</span><span class="nb">type</span><span class="p">,</span> <span class="n">showconversion</span><span class="p">)</span></div>


<div class="viewcode-block" id="coordsys.setdirection">
<a class="viewcode-back" href="../../_autosummary/pipeline.hsd.tasks.imaging.imaging_params.coordsys.html#pipeline.hsd.tasks.imaging.imaging_params.coordsys.setdirection">[docs]</a>
    <span class="k">def</span> <span class="nf">setdirection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">refcode</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">proj</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">projpar</span><span class="o">=</span><span class="p">[</span> <span class="nb">float</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">],</span> <span class="n">refpix</span><span class="o">=</span><span class="p">[</span> <span class="nb">float</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">],</span> <span class="n">refval</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">incr</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">xform</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">poles</span><span class="o">=</span><span class="p">[</span> <span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;When you construct a Coordsys tool, if you include a Direction</span>
<span class="sd">        Coordinate, it  will have some default parameters.</span>
<span class="sd">        This function simply allows you to</span>
<span class="sd">        replace the values of the Direction Coordinate.</span>
<span class="sd">        </span>
<span class="sd">        You can also change almost all of those parameters (such as projection, reference value</span>
<span class="sd">        etc.) via the individual functions</span>
<span class="sd">        setreferencecode,</span>
<span class="sd">        setprojection,</span>
<span class="sd">        setreferencepixel,</span>
<span class="sd">        setreferencevalue,</span>
<span class="sd">        setincrement, and</span>
<span class="sd">        setlineartransform</span>
<span class="sd">        provided by the Coordsys tool.    See those functions for more details</span>
<span class="sd">        about the formatting of the above function arguments.</span>
<span class="sd">        </span>
<span class="sd">        Bear in mind, that if your Coordinate System came from a real image, then</span>
<span class="sd">        the reference pixel is special and you should not change it.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">setdirection</span><span class="p">(</span><span class="n">refcode</span><span class="p">,</span> <span class="n">proj</span><span class="p">,</span> <span class="n">projpar</span><span class="p">,</span> <span class="n">refpix</span><span class="p">,</span> <span class="n">refval</span><span class="p">,</span> <span class="n">incr</span><span class="p">,</span> <span class="n">xform</span><span class="p">,</span> <span class="n">poles</span><span class="p">)</span></div>


<div class="viewcode-block" id="coordsys.setepoch">
<a class="viewcode-back" href="../../_autosummary/pipeline.hsd.tasks.imaging.imaging_params.coordsys.html#pipeline.hsd.tasks.imaging.imaging_params.coordsys.setepoch">[docs]</a>
    <span class="k">def</span> <span class="nf">setepoch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function  sets a new epoch (supplied as an</span>
<span class="sd">        epoch measure) of the observation. You</span>
<span class="sd">        can get the current epoch with function</span>
<span class="sd">        epoch.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">setepoch</span><span class="p">(</span><span class="n">value</span><span class="p">)</span></div>


<div class="viewcode-block" id="coordsys.setincrement">
<a class="viewcode-back" href="../../_autosummary/pipeline.hsd.tasks.imaging.imaging_params.coordsys.html#pipeline.hsd.tasks.imaging.imaging_params.coordsys.setincrement">[docs]</a>
    <span class="k">def</span> <span class="nf">setincrement</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="nb">type</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Each axis associated with the Coordinate System has a reference value,</span>
<span class="sd">        reference pixel and an increment (per pixel).  These are used in the</span>
<span class="sd">        mapping from pixel to world coordinate.</span>
<span class="sd">        </span>
<span class="sd">        This function  allows you to set a new</span>
<span class="sd">        increment.   You should not do this on &quot;stokes&quot; axes unless you are an</span>
<span class="sd">        adept or a big risk taker.</span>
<span class="sd">        </span>
<span class="sd">        You can set the increments either for all axes ({stfaf</span>
<span class="sd">        type=unset}) or for just the axes associated with a particular</span>
<span class="sd">        coordinate type.</span>
<span class="sd">        </span>
<span class="sd">        You may supply the increments in all of the formats described in</span>
<span class="sd">        the htmlref{formatting}{COORDSYS:FORMATTING} discussion.</span>
<span class="sd">        </span>
<span class="sd">        In addition, you can also supply the increments as  a quantity of vector</span>
<span class="sd">        of doubles.  For example {stfaf qa.quantity([-1,2],&#39;arcsec&#39;)}.</span>
<span class="sd">        </span>
<span class="sd">        You can recover the current increments with function</span>
<span class="sd">        increment.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">setincrement</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">type</span><span class="p">)</span></div>


<div class="viewcode-block" id="coordsys.setlineartransform">
<a class="viewcode-back" href="../../_autosummary/pipeline.hsd.tasks.imaging.imaging_params.coordsys.html#pipeline.hsd.tasks.imaging.imaging_params.coordsys.setlineartransform">[docs]</a>
    <span class="k">def</span> <span class="nf">setlineartransform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="p">[</span> <span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function set the linear transform component.  For Stokes Coordinates</span>
<span class="sd">        this function will return T but do nothing.</span>
<span class="sd">        </span>
<span class="sd">        You can recover the current linear transform with function</span>
<span class="sd">        lineartransform.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">setlineartransform</span><span class="p">(</span><span class="nb">type</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span></div>


<div class="viewcode-block" id="coordsys.setnames">
<a class="viewcode-back" href="../../_autosummary/pipeline.hsd.tasks.imaging.imaging_params.coordsys.html#pipeline.hsd.tasks.imaging.imaging_params.coordsys.setnames">[docs]</a>
    <span class="k">def</span> <span class="nf">setnames</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Each axis associated with the Coordinate System has a name.</span>
<span class="sd">        It isn&#39;t used in any fundamental way.</span>
<span class="sd">        </span>
<span class="sd">        This function  allows you to set</span>
<span class="sd">        new axis names.</span>
<span class="sd">        </span>
<span class="sd">        You can set the names either for all axes ({stfaf</span>
<span class="sd">        type=unset}) or for just the axes associated with a particular</span>
<span class="sd">        coordinate type.</span>
<span class="sd">        </span>
<span class="sd">        You can recover the current axis names with function</span>
<span class="sd">        names.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">setnames</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">type</span><span class="p">)</span></div>


<div class="viewcode-block" id="coordsys.setobserver">
<a class="viewcode-back" href="../../_autosummary/pipeline.hsd.tasks.imaging.imaging_params.coordsys.html#pipeline.hsd.tasks.imaging.imaging_params.coordsys.setobserver">[docs]</a>
    <span class="k">def</span> <span class="nf">setobserver</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;If you want to grab all the glory, or transfer the blame, this function</span>
<span class="sd">        sets a new observer of the</span>
<span class="sd">        observation. You can get the current observer with function observer.  The</span>
<span class="sd">        observer&#39;s name is not fundamental to the Coordinate System !</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">setobserver</span><span class="p">(</span><span class="n">value</span><span class="p">)</span></div>


<div class="viewcode-block" id="coordsys.setprojection">
<a class="viewcode-back" href="../../_autosummary/pipeline.hsd.tasks.imaging.imaging_params.coordsys.html#pipeline.hsd.tasks.imaging.imaging_params.coordsys.setprojection">[docs]</a>
    <span class="k">def</span> <span class="nf">setprojection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="p">,</span> <span class="n">parameters</span><span class="o">=</span><span class="p">[</span> <span class="nb">float</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;If the Coordinate System contains a direction coordinate, this</span>
<span class="sd">        function  can be used to set the</span>
<span class="sd">        projection.  For discussion about celestial coordinate systems,</span>
<span class="sd">        including projections, see the papers by Mark Calabretta and Eric</span>
<span class="sd">        Greisen. The initial draft from 1996 (implemented in casa) can be</span>
<span class="sd">        found</span>
<span class="sd">        htmladdnormallink{here}{http://www.atnf.csiro.au/people/mark.calabretta/WCS}.</span>
<span class="sd">        </span>
<span class="sd">        You can use the function projection</span>
<span class="sd">        to find out all the possible types of projection.  You can also use it</span>
<span class="sd">        to find out how many parameters you need to describe a particular</span>
<span class="sd">        projection.  See Calabretta and Greisen for details about those</span>
<span class="sd">        parameters (see section 4 of their paper); in FITS terms these</span>
<span class="sd">        parameters are what are labelled as PROJP.</span>
<span class="sd">        </span>
<span class="sd">        Some brief help here on the more common projections in astronomy.</span>
<span class="sd">        </span>
<span class="sd">        begin{itemize}</span>
<span class="sd">        </span>
<span class="sd">        item SIN has either 0 parameters or 2.  For coplanar arrays like</span>
<span class="sd">        East-West arrays, one can use what is widely termed the NCP projection.</span>
<span class="sd">        This is actually a SIN projection where the parameters are 0 and</span>
<span class="sd">        $1/tan(delta_0)$ where $delta_0$ is the reference declination.  Images</span>
<span class="sd">        made from the ATNF&#39;s Compact Array with casa will have such a</span>
<span class="sd">        projection.  Otherwise, the SIN projection requires no parameters (but</span>
<span class="sd">        you can give it two each of which is zero if you wish).</span>
<span class="sd">        </span>
<span class="sd">        item TAN is used widely in optical astronomy.  It requires 0</span>
<span class="sd">        parameters.</span>
<span class="sd">        </span>
<span class="sd">        item ZEA (zenithal equal area) is used widely in survey work.</span>
<span class="sd">        It requires 0 parameters.</span>
<span class="sd">        </span>
<span class="sd">        end{itemize}</span>
<span class="sd">        </span>
<span class="sd">        If the Coordinate System does not contain a direction coordinate,</span>
<span class="sd">        an exception is generated.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">setprojection</span><span class="p">(</span><span class="nb">type</span><span class="p">,</span> <span class="n">parameters</span><span class="p">)</span></div>


<div class="viewcode-block" id="coordsys.setreferencecode">
<a class="viewcode-back" href="../../_autosummary/pipeline.hsd.tasks.imaging.imaging_params.coordsys.html#pipeline.hsd.tasks.imaging.imaging_params.coordsys.setreferencecode">[docs]</a>
    <span class="k">def</span> <span class="nf">setreferencecode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s1">&#39;direction&#39;</span><span class="p">,</span> <span class="n">adjust</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function  sets the reference</span>
<span class="sd">        code for the specified coordinate type.  Examples of reference codes</span>
<span class="sd">        are B1950 and J2000 for direction coordinates, or LSRK and BARY for</span>
<span class="sd">        spectral coordinates.</span>
<span class="sd">        </span>
<span class="sd">        You must specify {stfaf type}, selecting from &#39;direction&#39;,  or</span>
<span class="sd">        &#39;spectral&#39; (the first two letters will do).   If the Coordinate System</span>
<span class="sd">        does not contain a coordinate of the type you specify, an exception is</span>
<span class="sd">        generated.</span>
<span class="sd">        </span>
<span class="sd">        Specify the new code with argument {stfaf value}.  To see the list of</span>
<span class="sd">        possible codes, use the function referencecode</span>
<span class="sd">        (see example).</span>
<span class="sd">        </span>
<span class="sd">        If {stfaf adjust} is T, then the reference value is recomputed.</span>
<span class="sd">        This is invariably the correct thing to do.  If {stfaf adjust} is F,</span>
<span class="sd">        then the reference code is simply overwritten; do this very carefully.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">setreferencecode</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">type</span><span class="p">,</span> <span class="n">adjust</span><span class="p">)</span></div>


<div class="viewcode-block" id="coordsys.setreferencelocation">
<a class="viewcode-back" href="../../_autosummary/pipeline.hsd.tasks.imaging.imaging_params.coordsys.html#pipeline.hsd.tasks.imaging.imaging_params.coordsys.setreferencelocation">[docs]</a>
    <span class="k">def</span> <span class="nf">setreferencelocation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pixel</span><span class="o">=</span><span class="p">[</span> <span class="nb">int</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">],</span> <span class="n">world</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">mask</span><span class="o">=</span><span class="p">[</span> <span class="nb">bool</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span> <span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function sets the reference pixel and</span>
<span class="sd">        reference value to the specified values.  The world coordinate can be</span>
<span class="sd">        specified in any of the formats that the output world coordinate is</span>
<span class="sd">        returned in by the toworld function.</span>
<span class="sd">        </span>
<span class="sd">        You can specify a mask (argument {stfaf mask}) indicating which pixel</span>
<span class="sd">        axes are set (T) and which are left unchanged (F).  This function will</span>
<span class="sd">        refuse to change the reference location of a Stokes axis (gets you into</span>
<span class="sd">        trouble otherwise).</span>
<span class="sd">        </span>
<span class="sd">        This function can be rather useful when regridding</span>
<span class="sd">        images.  It allows you to keep easily a particular feature centered in the</span>
<span class="sd">        regridded image.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">setreferencelocation</span><span class="p">(</span><span class="n">pixel</span><span class="p">,</span> <span class="n">world</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span></div>


<div class="viewcode-block" id="coordsys.setreferencepixel">
<a class="viewcode-back" href="../../_autosummary/pipeline.hsd.tasks.imaging.imaging_params.coordsys.html#pipeline.hsd.tasks.imaging.imaging_params.coordsys.setreferencepixel">[docs]</a>
    <span class="k">def</span> <span class="nf">setreferencepixel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Each axis associated with the Coordinate System has a reference value,</span>
<span class="sd">        reference pixel and an increment (per pixel).  These are used in the</span>
<span class="sd">        mapping from pixel to world coordinate.</span>
<span class="sd">        </span>
<span class="sd">        This function allows you to set a new reference pixel.   You should not</span>
<span class="sd">        do this on &quot;stokes&quot; axes unless you are an adept or a big risk taker.</span>
<span class="sd">        </span>
<span class="sd">        You can set the reference pixel either for all axes ({stfaf</span>
<span class="sd">        type=unset}) or for just the axes associated with a particular</span>
<span class="sd">        coordinate type.</span>
<span class="sd">        </span>
<span class="sd">        Bear in mind, that if your Coordinate System came from a real image,</span>
<span class="sd">        then the reference pixel is special and you should not change it for</span>
<span class="sd">        Direction Coordinates.</span>
<span class="sd">        </span>
<span class="sd">        You can recover the current reference pixel with function</span>
<span class="sd">        referencepixel.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">setreferencepixel</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">type</span><span class="p">)</span></div>


<div class="viewcode-block" id="coordsys.setreferencevalue">
<a class="viewcode-back" href="../../_autosummary/pipeline.hsd.tasks.imaging.imaging_params.coordsys.html#pipeline.hsd.tasks.imaging.imaging_params.coordsys.setreferencevalue">[docs]</a>
    <span class="k">def</span> <span class="nf">setreferencevalue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="nb">type</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Each axis associated with the Coordinate System has a reference value,</span>
<span class="sd">        reference pixel and an increment (per pixel).  These are used in the</span>
<span class="sd">        mapping from pixel to world coordinate.</span>
<span class="sd">        </span>
<span class="sd">        This function allows you to set a new</span>
<span class="sd">        reference value.  You should not do this on &quot;stokes&quot; axes unless you</span>
<span class="sd">        are an adept or a big risk taker.</span>
<span class="sd">        </span>
<span class="sd">        You may supply the reference value in all of the formats described in</span>
<span class="sd">        the htmlref{formatting}{COORDSYS:FORMATTING} discussion.</span>
<span class="sd">        </span>
<span class="sd">        You can recover the current reference value with function</span>
<span class="sd">        referencevalue.</span>
<span class="sd">        </span>
<span class="sd">        Note that the value argument should be one of the specified</span>
<span class="sd">        possibilitioes. Especially a {stff measure} will be accepted, but</span>
<span class="sd">        will have a null effect, due to the interpretation as a generic</span>
<span class="sd">        record.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">setreferencevalue</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">type</span><span class="p">)</span></div>


<div class="viewcode-block" id="coordsys.setrestfrequency">
<a class="viewcode-back" href="../../_autosummary/pipeline.hsd.tasks.imaging.imaging_params.coordsys.html#pipeline.hsd.tasks.imaging.imaging_params.coordsys.setrestfrequency">[docs]</a>
    <span class="k">def</span> <span class="nf">setrestfrequency</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">which</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">append</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;If the Coordinate System contains a spectral coordinate, then</span>
<span class="sd">        it has a rest frequency.  In fact, the spectral coordinate</span>
<span class="sd">        can hold several rest frequencies (to handle for example,</span>
<span class="sd">        an observation where the band covers many lines), although</span>
<span class="sd">        only one is active (for velocity conversions) at a time.</span>
<span class="sd">        </span>
<span class="sd">        This function allows you to set new rest</span>
<span class="sd">        frequencies.  You can provide the rest frequency as a quantity, or as</span>
<span class="sd">        a quantity string, or a double (units of current rest frequency assumed).</span>
<span class="sd">        </span>
<span class="sd">        You specify whether the list of frequencies will be appended</span>
<span class="sd">        to the current list or whether it will replace that list.</span>
<span class="sd">        You must select which of the frequencies will become the active</span>
<span class="sd">        one.  By default its the first in the list.  The index refers</span>
<span class="sd">        to the final list (either appended or replaced).</span>
<span class="sd">        </span>
<span class="sd">        You can recover the current rest frequencies with</span>
<span class="sd">        restfrequency.</span>
<span class="sd">        </span>
<span class="sd">        If the Coordinate System does not contain a frequency coordinate,</span>
<span class="sd">        an exception is generated.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">setrestfrequency</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">which</span><span class="p">,</span> <span class="n">append</span><span class="p">)</span></div>


<div class="viewcode-block" id="coordsys.setspectral">
<a class="viewcode-back" href="../../_autosummary/pipeline.hsd.tasks.imaging.imaging_params.coordsys.html#pipeline.hsd.tasks.imaging.imaging_params.coordsys.setspectral">[docs]</a>
    <span class="k">def</span> <span class="nf">setspectral</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">refcode</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">restfreq</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">frequencies</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">doppler</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">velocities</span><span class="o">=</span><span class="p">[</span> <span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;When you construct a Coordsys tool, if you include a Spectral Coordinate, it</span>
<span class="sd">        will be linear in frequency.  This function allows you to replace the</span>
<span class="sd">        Spectral Coordinate by a finite table of values.  Coordinate</span>
<span class="sd">        conversions between pixel and world are then done by interpolation.</span>
<span class="sd">        </span>
<span class="sd">        You may specify either a vector of frequencies or velocities.  If you specify</span>
<span class="sd">        frequencies, you can optionally specify a (new) reference code (see</span>
<span class="sd">        function setreferencecode</span>
<span class="sd">        for more details) and rest frequency (else the existing ones will be used).</span>
<span class="sd">        </span>
<span class="sd">        If you specify velocities, you can optionally specify a (new) reference code</span>
<span class="sd">        and rest frequency (else the existing ones will be used).  You must also give</span>
<span class="sd">        the doppler type (see</span>
<span class="sd">        function summary for more</span>
<span class="sd">        details).  The velocities are then converted to frequency for creation of the</span>
<span class="sd">        Spectral Coordinate (which is fundamentally described by frequency).</span>
<span class="sd">        </span>
<span class="sd">        You may specify the rest frequency as a Quantum or a double (native units</span>
<span class="sd">        of Spectral Coordinate used).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">setspectral</span><span class="p">(</span><span class="n">refcode</span><span class="p">,</span> <span class="n">restfreq</span><span class="p">,</span> <span class="n">frequencies</span><span class="p">,</span> <span class="n">doppler</span><span class="p">,</span> <span class="n">velocities</span><span class="p">)</span></div>


<div class="viewcode-block" id="coordsys.setstokes">
<a class="viewcode-back" href="../../_autosummary/pipeline.hsd.tasks.imaging.imaging_params.coordsys.html#pipeline.hsd.tasks.imaging.imaging_params.coordsys.setstokes">[docs]</a>
    <span class="k">def</span> <span class="nf">setstokes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stokes</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;If the Coordinate System contains a Stokes Coordinate, this function allows</span>
<span class="sd">        you to change the Stokes types defining it.  If there is no Stokes</span>
<span class="sd">        Coordinate, an exception is generated.</span>
<span class="sd">        </span>
<span class="sd">        See the coordsys constructor</span>
<span class="sd">        to see the possible Stokes types you can set.</span>
<span class="sd">        </span>
<span class="sd">        You can set the Stokes types with function</span>
<span class="sd">        setstokes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">setstokes</span><span class="p">(</span><span class="n">stokes</span><span class="p">)</span></div>


<div class="viewcode-block" id="coordsys.settabular">
<a class="viewcode-back" href="../../_autosummary/pipeline.hsd.tasks.imaging.imaging_params.coordsys.html#pipeline.hsd.tasks.imaging.imaging_params.coordsys.settabular">[docs]</a>
    <span class="k">def</span> <span class="nf">settabular</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pixel</span><span class="o">=</span><span class="p">[</span> <span class="nb">float</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">],</span> <span class="n">world</span><span class="o">=</span><span class="p">[</span> <span class="nb">float</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">],</span> <span class="n">which</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">0</span><span class="p">)):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;When you construct a Coordsys tool, if you include a Tabular</span>
<span class="sd">        Coordinate, it will be linear.  This function allows you to replace the</span>
<span class="sd">        Tabular Coordinate by a finite table of values.  Coordinate conversions</span>
<span class="sd">        between pixel and world are then done by interpolation (or extrapolation</span>
<span class="sd">        beyond the end).  The table of values must be at least of length 2</span>
<span class="sd">        or an exception will occur.</span>
<span class="sd">        </span>
<span class="sd">        You may specify a vector of pixel and world values (in the current units</span>
<span class="sd">        of the Tabular Coordinate).  These vectors must be the same length.  If</span>
<span class="sd">        you leave one of them unset, then the old values are used, but again,</span>
<span class="sd">        ultimately, the pixel and world vectors must be the same length.</span>
<span class="sd">        </span>
<span class="sd">        The new reference pixel will be the first pixel value.</span>
<span class="sd">        The new reference value will be the first world value.</span>
<span class="sd">        </span>
<span class="sd">        Presently, there is no way for you to recover the lookup table</span>
<span class="sd">        once you have set it.</span>
<span class="sd">        </span>
<span class="sd">        If you have more than one Tabular Coordinate, use argument</span>
<span class="sd">        {stfaf which} to specify which one you want to modify.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">settabular</span><span class="p">(</span><span class="n">pixel</span><span class="p">,</span> <span class="n">world</span><span class="p">,</span> <span class="n">which</span><span class="p">)</span></div>


<div class="viewcode-block" id="coordsys.settelescope">
<a class="viewcode-back" href="../../_autosummary/pipeline.hsd.tasks.imaging.imaging_params.coordsys.html#pipeline.hsd.tasks.imaging.imaging_params.coordsys.settelescope">[docs]</a>
    <span class="k">def</span> <span class="nf">settelescope</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function sets a new telescope of the observation.   The telescope</span>
<span class="sd">        position may be needed for reference code conversions; this is why it is</span>
<span class="sd">        maintained in the Coordinate System.    So it is fundamental</span>
<span class="sd">        to the Coordinate System and should be correct.</span>
<span class="sd">        </span>
<span class="sd">        You can find a list of the observatory names know to casa with the</span>
<span class="sd">        Measures obslist function.</span>
<span class="sd">        </span>
<span class="sd">        You can  get the current telescope with function</span>
<span class="sd">        telescope.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">settelescope</span><span class="p">(</span><span class="n">value</span><span class="p">)</span></div>


<div class="viewcode-block" id="coordsys.setunits">
<a class="viewcode-back" href="../../_autosummary/pipeline.hsd.tasks.imaging.imaging_params.coordsys.html#pipeline.hsd.tasks.imaging.imaging_params.coordsys.setunits">[docs]</a>
    <span class="k">def</span> <span class="nf">setunits</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">)):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Each axis associated with the Coordinate System has a unit. This</span>
<span class="sd">        function allows you to set new axis units.</span>
<span class="sd">        </span>
<span class="sd">        You can set the units either for all axes ({stfaf</span>
<span class="sd">        type=unset}) or for just the axes associated with a particular</span>
<span class="sd">        coordinate type.</span>
<span class="sd">        </span>
<span class="sd">        In general, the units must be consistent with the old units. When you</span>
<span class="sd">        change the units, the increment and reference value will be adjusted</span>
<span class="sd">        appropriately.  However, for a linear or tabular coordinate, and only</span>
<span class="sd">        when you specify {stfaf type=&#39;linear&#39;} or {stfaf type=&#39;tabular&#39;}</span>
<span class="sd">        (i.e. you supply units only for the specified linear of tabular</span>
<span class="sd">        coordinate), and if you set {stfaf overwrite=T}, you can just overwrite</span>
<span class="sd">        the units with no further adjustments.   Otherwise, the {stfaf</span>
<span class="sd">        overwrite} argument will be silently ignored.  Use argument</span>
<span class="sd">        {stfaf which} to specify which coordinate if you have more</span>
<span class="sd">        than one of the specified type.</span>
<span class="sd">        </span>
<span class="sd">        You can recover the current axis units with function</span>
<span class="sd">        units.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">setunits</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">type</span><span class="p">,</span> <span class="n">overwrite</span><span class="p">,</span> <span class="n">which</span><span class="p">)</span></div>


<div class="viewcode-block" id="coordsys.stokes">
<a class="viewcode-back" href="../../_autosummary/pipeline.hsd.tasks.imaging.imaging_params.coordsys.html#pipeline.hsd.tasks.imaging.imaging_params.coordsys.stokes">[docs]</a>
    <span class="k">def</span> <span class="nf">stokes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;If the Coordinate System contains a Stokes Coordinate, this function recovers the</span>
<span class="sd">        Stokes types defining it.  If there is no Stokes</span>
<span class="sd">        Coordinate, an exception is generated.</span>
<span class="sd">        </span>
<span class="sd">        You can set the Stokes types with function</span>
<span class="sd">        setstokes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">stokes</span><span class="p">()</span></div>


<div class="viewcode-block" id="coordsys.summary">
<a class="viewcode-back" href="../../_autosummary/pipeline.hsd.tasks.imaging.imaging_params.coordsys.html#pipeline.hsd.tasks.imaging.imaging_params.coordsys.summary">[docs]</a>
    <span class="k">def</span> <span class="nf">summary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">doppler</span><span class="o">=</span><span class="s1">&#39;RADIO&#39;</span><span class="p">,</span> <span class="nb">list</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function summarizes the information</span>
<span class="sd">        contained in the Coordinate System.</span>
<span class="sd">        </span>
<span class="sd">        For spectral coordinates, the information is listed as a velocity as well as a</span>
<span class="sd">        frequency.  The argument {stfaf doppler} allows you to specify what</span>
<span class="sd">        doppler convention it is listed in.  You can choose from {stfaf radio,</span>
<span class="sd">        optical} and {stfaf beta}.  Alternative names are {stfaf z} for</span>
<span class="sd">        {stfaf optical}, and {stfaf relativistic} for {stfaf</span>
<span class="sd">        beta}.  The default is {stfaf radio}.  The definitions are</span>
<span class="sd">        </span>
<span class="sd">        begin{itemize}</span>
<span class="sd">        item radio: $1 - F$</span>
<span class="sd">        item optical: $-1 + 1/F$</span>
<span class="sd">        item beta: $(1 - F^2)/(1 + F^2)$</span>
<span class="sd">        end{itemize}</span>
<span class="sd">        where $F = nu/nu_0$ and $nu_0$ is the rest frequency.  If the rest</span>
<span class="sd">        frequency has not been set in your image, you can set it with</span>
<span class="sd">        the function setrestfrequency.</span>
<span class="sd">        </span>
<span class="sd">        These velocity definitions are provided by the measures</span>
<span class="sd">        system via the Doppler measure (see example).</span>
<span class="sd">        </span>
<span class="sd">        If you  set {stfaf list=F}, then the summary will not be written</span>
<span class="sd">        to the global logger.     However, the return value will be a vector of strings</span>
<span class="sd">        holding the summary information, one string per line of the summary.</span>
<span class="sd">        </span>
<span class="sd">        For direction and spectral coordinates, the reference frame (e.g.  J2000</span>
<span class="sd">        or LSRK) is also listed.  Along side this, in parentheses, will be the</span>
<span class="sd">        conversion reference frame as well (if it is different from the native</span>
<span class="sd">        reference frame).  See function</span>
<span class="sd">        setconversion to see what this</span>
<span class="sd">        means.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">summary</span><span class="p">(</span><span class="n">doppler</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span></div>


<div class="viewcode-block" id="coordsys.telescope">
<a class="viewcode-back" href="../../_autosummary/pipeline.hsd.tasks.imaging.imaging_params.coordsys.html#pipeline.hsd.tasks.imaging.imaging_params.coordsys.telescope">[docs]</a>
    <span class="k">def</span> <span class="nf">telescope</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function returns the telescope</span>
<span class="sd">        contained in the Coordinate System  as a</span>
<span class="sd">        simple string.</span>
<span class="sd">        </span>
<span class="sd">        The telescope position may be needed for reference code conversions; this is</span>
<span class="sd">        why it is maintained in the Coordinate System.</span>
<span class="sd">        </span>
<span class="sd">        The conversion from string to position is done with</span>
<span class="sd">        Measures observatory.</span>
<span class="sd">        The example shows how.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">telescope</span><span class="p">()</span></div>


<div class="viewcode-block" id="coordsys.toabs">
<a class="viewcode-back" href="../../_autosummary/pipeline.hsd.tasks.imaging.imaging_params.coordsys.html#pipeline.hsd.tasks.imaging.imaging_params.coordsys.toabs">[docs]</a>
    <span class="k">def</span> <span class="nf">toabs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">isworld</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function converts a relative coordinate to an absolute coordinate.</span>
<span class="sd">        The coordinate may be a pixel coordinate or a world coordinate.</span>
<span class="sd">        </span>
<span class="sd">        If the coordinate is a pixel coordinate, it is supplied as a numeric</span>
<span class="sd">        vector. If the coordinate is a world coordinate,  you may give it in all</span>
<span class="sd">        of the formats described in the</span>
<span class="sd">        htmlref{formatting}{COORDSYS:FORMATTING} discussion.</span>
<span class="sd">        </span>
<span class="sd">        If the coordinate value is supplied by a Coordsys tool function (e.g.</span>
<span class="sd">        toworld) then the coordinate &#39;knows&#39;</span>
<span class="sd">        whether it is world or pixel (and absolute or relative). However, you</span>
<span class="sd">        might supply the value from some other source as a numeric vector (which</span>
<span class="sd">        could be world or pixel) in which case you must specify whether it is a</span>
<span class="sd">        world or pixel coordinate via the {stfaf isworld} argument.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">toabs</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">isworld</span><span class="p">)</span></div>


<div class="viewcode-block" id="coordsys.toabsmany">
<a class="viewcode-back" href="../../_autosummary/pipeline.hsd.tasks.imaging.imaging_params.coordsys.html#pipeline.hsd.tasks.imaging.imaging_params.coordsys.toabsmany">[docs]</a>
    <span class="k">def</span> <span class="nf">toabsmany</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">isworld</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function converts many relative coordinates to absolute. It exists</span>
<span class="sd">        so you can efficiently make many conversions (which would be rather slow</span>
<span class="sd">        if you did them all with toabs). Because</span>
<span class="sd">        speed is the object, the interface is purely in terms of numeric</span>
<span class="sd">        matrices, rather than being able to accept strings and quanta etc. like</span>
<span class="sd">        toabs can.</span>
<span class="sd">        </span>
<span class="sd">        When dealing with world coordinates, the units of the numeric</span>
<span class="sd">        values must be the native units, given by function</span>
<span class="sd">        units.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">toabsmany</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">isworld</span><span class="p">)</span></div>


<div class="viewcode-block" id="coordsys.topixel">
<a class="viewcode-back" href="../../_autosummary/pipeline.hsd.tasks.imaging.imaging_params.coordsys.html#pipeline.hsd.tasks.imaging.imaging_params.coordsys.topixel">[docs]</a>
    <span class="k">def</span> <span class="nf">topixel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="p">[</span> <span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function converts between world (physical) coordinate and absolute pixel</span>
<span class="sd">        coordinate (0-rel).</span>
<span class="sd">        </span>
<span class="sd">        The world coordinate can be provided in one of four formats via the</span>
<span class="sd">        argument {stfaf world}.  These match the output formats of function</span>
<span class="sd">        toworld.</span>
<span class="sd">        </span>
<span class="sd">        If you supply fewer world values than there are axes in the  Coordinate</span>
<span class="sd">        System, your coordinate vector will be padded out with the reference</span>
<span class="sd">        value for the missing axes. Excess values will be silently ignored.</span>
<span class="sd">        </span>
<span class="sd">        You may supply the world coordinate in all of the formats described in</span>
<span class="sd">        the htmlref{formatting}{COORDSYS:FORMATTING} discussion.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">topixel</span><span class="p">(</span><span class="n">value</span><span class="p">)</span></div>


<div class="viewcode-block" id="coordsys.topixelmany">
<a class="viewcode-back" href="../../_autosummary/pipeline.hsd.tasks.imaging.imaging_params.coordsys.html#pipeline.hsd.tasks.imaging.imaging_params.coordsys.topixelmany">[docs]</a>
    <span class="k">def</span> <span class="nf">topixelmany</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="p">[</span> <span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function converts many absolute world coordinates to pixel coordinates. It exists</span>
<span class="sd">        so you can efficiently make many conversions (which would be rather slow</span>
<span class="sd">        if you did them all with topixel). Because</span>
<span class="sd">        speed is the object, the interface is purely in terms of numeric</span>
<span class="sd">        matrices, rather than being able to accept strings and quanta etc. like</span>
<span class="sd">        topixel can.</span>
<span class="sd">        </span>
<span class="sd">        The units of the numeric values must be the native units, given by</span>
<span class="sd">        function units.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">topixelmany</span><span class="p">(</span><span class="n">value</span><span class="p">)</span></div>


<div class="viewcode-block" id="coordsys.torecord">
<a class="viewcode-back" href="../../_autosummary/pipeline.hsd.tasks.imaging.imaging_params.coordsys.html#pipeline.hsd.tasks.imaging.imaging_params.coordsys.torecord">[docs]</a>
    <span class="k">def</span> <span class="nf">torecord</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;You can convert a Coordinate System to a record with this function.</span>
<span class="sd">        There is also fromrecord</span>
<span class="sd">        to set a Coordinate System from a record.</span>
<span class="sd">        </span>
<span class="sd">        These functions  allow</span>
<span class="sd">        Coordsys tools to be used as parameters in the methods of other tools.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">torecord</span><span class="p">()</span></div>


<div class="viewcode-block" id="coordsys.subimage">
<a class="viewcode-back" href="../../_autosummary/pipeline.hsd.tasks.imaging.imaging_params.coordsys.html#pipeline.hsd.tasks.imaging.imaging_params.coordsys.subimage">[docs]</a>
    <span class="k">def</span> <span class="nf">subimage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">originshft</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">newshape</span><span class="o">=</span><span class="p">[</span>  <span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;You can convert a Coordinate System to another coordinatesystem applicable to a</span>
<span class="sd">        subImage. The newshape does not matter as this is the coordinatesystem not the</span>
<span class="sd">        image except for Stokes axis; therefore you can ignore {tt newshape} except</span>
<span class="sd">        when your sub-image you are considering has only a section of your original Stokes</span>
<span class="sd">        axis.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">subimage</span><span class="p">(</span><span class="n">originshft</span><span class="p">,</span> <span class="n">newshape</span><span class="p">)</span></div>


<div class="viewcode-block" id="coordsys.torel">
<a class="viewcode-back" href="../../_autosummary/pipeline.hsd.tasks.imaging.imaging_params.coordsys.html#pipeline.hsd.tasks.imaging.imaging_params.coordsys.torel">[docs]</a>
    <span class="k">def</span> <span class="nf">torel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">isworld</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function converts an absolute coordinate to a relative coordinate.</span>
<span class="sd">        The coordinate may be a pixel coordinate or a world coordinate.</span>
<span class="sd">        </span>
<span class="sd">        Relative coordinates are relative to the reference pixel (pixel coordinates)</span>
<span class="sd">        or the reference value (world coordinates) in the sense</span>
<span class="sd">        $relative = absolute - reference$.</span>
<span class="sd">        </span>
<span class="sd">        If the coordinate is a pixel coordinate, it is supplied as a numeric</span>
<span class="sd">        vector. If the coordinate is a world coordinate,  you may give it in all</span>
<span class="sd">        of the formats described in the</span>
<span class="sd">        htmlref{formatting}{COORDSYS:FORMATTING} discussion.</span>
<span class="sd">        </span>
<span class="sd">        If the coordinate value is supplied by a Coordsys tool function (e.g.</span>
<span class="sd">        toworld) then the coordinate &#39;knows&#39;</span>
<span class="sd">        whether it is world or pixel (and absolute or relative). However, you</span>
<span class="sd">        might supply the value from some other source as a numeric vector (which</span>
<span class="sd">        could be world or pixel) in which case you must specify whether it is a</span>
<span class="sd">        world or pixel coordinate via the {stfaf isworld} argument.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">torel</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">isworld</span><span class="p">)</span></div>


<div class="viewcode-block" id="coordsys.torelmany">
<a class="viewcode-back" href="../../_autosummary/pipeline.hsd.tasks.imaging.imaging_params.coordsys.html#pipeline.hsd.tasks.imaging.imaging_params.coordsys.torelmany">[docs]</a>
    <span class="k">def</span> <span class="nf">torelmany</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">isworld</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function converts many absolute coordinates to relative. It exists</span>
<span class="sd">        so you can efficiently make many conversions (which would be rather slow</span>
<span class="sd">        if you did them all with torel). Because</span>
<span class="sd">        speed is the object, the interface is purely in terms of numeric</span>
<span class="sd">        matrices, rather than being able to accept strings and quanta etc. like</span>
<span class="sd">        torel can.</span>
<span class="sd">        </span>
<span class="sd">        When dealing with world coordinates, the units of the numeric</span>
<span class="sd">        values must be the native units, given by function</span>
<span class="sd">        units.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">torelmany</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">isworld</span><span class="p">)</span></div>


<div class="viewcode-block" id="coordsys.toworld">
<a class="viewcode-back" href="../../_autosummary/pipeline.hsd.tasks.imaging.imaging_params.coordsys.html#pipeline.hsd.tasks.imaging.imaging_params.coordsys.toworld">[docs]</a>
    <span class="k">def</span> <span class="nf">toworld</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;n&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function converts between absolute pixel coordinate (0-rel)</span>
<span class="sd">        and absolute world (physical coordinate).</span>
<span class="sd">        </span>
<span class="sd">        If you supply fewer pixel values than there are axes in the  Coordinate</span>
<span class="sd">        System, your coordinate vector will be padded out with the reference</span>
<span class="sd">        pixel for the missing axes. Excess values will be silently ignored.</span>
<span class="sd">        </span>
<span class="sd">        You may ask for the world coordinate in all of the formats described in</span>
<span class="sd">        the htmlref{discussion}{COORDSYS:FORMATTING} regarding the</span>
<span class="sd">        formatting possibilities available via argument {stfaf format}.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">toworld</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">format</span><span class="p">)</span></div>


<div class="viewcode-block" id="coordsys.toworldmany">
<a class="viewcode-back" href="../../_autosummary/pipeline.hsd.tasks.imaging.imaging_params.coordsys.html#pipeline.hsd.tasks.imaging.imaging_params.coordsys.toworldmany">[docs]</a>
    <span class="k">def</span> <span class="nf">toworldmany</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="p">[</span> <span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function converts many absolute pixel coordinates to world coordinates. It exists</span>
<span class="sd">        so you can efficiently make many conversions (which would be rather slow</span>
<span class="sd">        if you did them all with toworld). Because</span>
<span class="sd">        speed is the object, the interface is purely in terms of numeric</span>
<span class="sd">        matrices, rather than being able to produce strings and quanta etc. like</span>
<span class="sd">        toworld can.</span>
<span class="sd">        </span>
<span class="sd">        The units of the output world values are the native units given by</span>
<span class="sd">        function units.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">toworldmany</span><span class="p">(</span><span class="n">value</span><span class="p">)</span></div>


<div class="viewcode-block" id="coordsys.type">
<a class="viewcode-back" href="../../_autosummary/pipeline.hsd.tasks.imaging.imaging_params.coordsys.html#pipeline.hsd.tasks.imaging.imaging_params.coordsys.type">[docs]</a>
    <span class="k">def</span> <span class="nf">type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function returns the string `coordsys&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">type</span><span class="p">()</span></div>


<div class="viewcode-block" id="coordsys.units">
<a class="viewcode-back" href="../../_autosummary/pipeline.hsd.tasks.imaging.imaging_params.coordsys.html#pipeline.hsd.tasks.imaging.imaging_params.coordsys.units">[docs]</a>
    <span class="k">def</span> <span class="nf">units</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Each axis associated with the Coordinate System has a unit.</span>
<span class="sd">        This function returns those units</span>
<span class="sd">        (in world axis order).</span>
<span class="sd">        </span>
<span class="sd">        You can recover the units either for all coordinates (leave {stfaf</span>
<span class="sd">        type} unset) or for a specific coordinate type (mimumum match of the</span>
<span class="sd">        allowed types will do).  If you ask for a non-existent coordinate an</span>
<span class="sd">        exception is generated.</span>
<span class="sd">        </span>
<span class="sd">        You can set the units with function</span>
<span class="sd">        setunits.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">units</span><span class="p">(</span><span class="nb">type</span><span class="p">)</span></div>


<div class="viewcode-block" id="coordsys.velocitytofrequency">
<a class="viewcode-back" href="../../_autosummary/pipeline.hsd.tasks.imaging.imaging_params.coordsys.html#pipeline.hsd.tasks.imaging.imaging_params.coordsys.velocitytofrequency">[docs]</a>
    <span class="k">def</span> <span class="nf">velocitytofrequency</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">frequnit</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">doppler</span><span class="o">=</span><span class="s1">&#39;radio&#39;</span><span class="p">,</span> <span class="n">velunit</span><span class="o">=</span><span class="s1">&#39;km/s&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function converts velocities</span>
<span class="sd">        to frequencies.</span>
<span class="sd">        </span>
<span class="sd">        The input velocities are specified via a vector of numeric values, a</span>
<span class="sd">        specified unit ({stfaf velunit}), and a  velocity doppler definition ({stfaf</span>
<span class="sd">        doppler}).</span>
<span class="sd">        </span>
<span class="sd">        The frequencies are returned in a vector for which you specify the</span>
<span class="sd">        units ({stfaf frequnit}).  If you don&#39;t give the unit, it is assumed that</span>
<span class="sd">        the units are those given by function units</span>
<span class="sd">        for the spectral coordinate.</span>
<span class="sd">        </span>
<span class="sd">        This function will return a fail if there is no spectral coordinate</span>
<span class="sd">        in the Coordinate System. See also the function</span>
<span class="sd">        frequencytovelocity.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">velocitytofrequency</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">frequnit</span><span class="p">,</span> <span class="n">doppler</span><span class="p">,</span> <span class="n">velunit</span><span class="p">)</span></div>


<div class="viewcode-block" id="coordsys.parentname">
<a class="viewcode-back" href="../../_autosummary/pipeline.hsd.tasks.imaging.imaging_params.coordsys.html#pipeline.hsd.tasks.imaging.imaging_params.coordsys.parentname">[docs]</a>
    <span class="k">def</span> <span class="nf">parentname</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function returns the parent image name for `coordsys&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">parentname</span><span class="p">()</span></div>


<div class="viewcode-block" id="coordsys.setparentname">
<a class="viewcode-back" href="../../_autosummary/pipeline.hsd.tasks.imaging.imaging_params.coordsys.html#pipeline.hsd.tasks.imaging.imaging_params.coordsys.setparentname">[docs]</a>
    <span class="k">def</span> <span class="nf">setparentname</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">imagename</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">setparentname</span><span class="p">(</span><span class="n">imagename</span><span class="p">)</span></div>
</div>


</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020–2024, Pipeline Dev. Team.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>