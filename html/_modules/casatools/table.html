

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>casatools.table &mdash; Pipeline unknown documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css?v=4ae1632d" />
      <link rel="stylesheet" type="text/css" href="../../_static/sphinx_astrorefs.css?v=4d4a2fdb" />
      <link rel="stylesheet" type="text/css" href="../../_static/custom_theme.css?v=30144f19" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=3f1b9271"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: gray" >

          
          
          <a href="../../index.html" class="icon icon-home">
            Pipeline
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Basics</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../develdocmd/ways_to_run_the_pipeline.html">Ways to run the Pipeline</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../develdocmd/recipes.html">Pipeline Recipes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dependencies.html">Dependencies of <code class="docutils literal notranslate"><span class="pre">Pipeline</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../releases.html">Past Releases</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../apisummary.html">Full APIs (autosummary)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../apisummary.html#pipeline-tasks-autosummary">Pipeline Tasks (autosummary)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../apisummary.html#pipeline-domain-context-autosummary">Pipeline domain/context (autosummary)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../apisummary.html#pipeline-domain-infrastructure-modules-automodapi">Pipeline domain/infrastructure modules (automodapi)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../apisummary.html#pipeline-h-tasks-modules-autmodapi"><code class="docutils literal notranslate"><span class="pre">pipeline.h*.tasks</span></code> modules (autmodapi)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../apisummary.html#inheritance-diagrams-for-pipeline-task-inputs-results-classes">Inheritance Diagrams for Pipeline <code class="docutils literal notranslate"><span class="pre">Task</span></code>/<code class="docutils literal notranslate"><span class="pre">Inputs</span></code>/<code class="docutils literal notranslate"><span class="pre">Results</span></code> Classes</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Developer Notes</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../develdocmd/ALMA-Imaging-Workflow.html">ALMA interferometry imaging workflow</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../develdocmd/VLA-Imaging-Workflow.html">VLA interferometry imaging workflow</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../develdocmd/VLASS-SE-CONT-Imaging-Workflow.html">VLASS-SE-CONT imaging workflow</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../develdocmd/VLASS-SE-CUBE-Imaging-Workflow.html">VLASS-SE-CUBE imaging workflow</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../develdocmd/selfcal_workflow.html">VLASS Selfcal &amp; Restore workflows</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../develdocmd/comparing_pipeline_executions.html">Comparing pipeline executions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../develdocmd/building_the_pipeline.html">Building the pipeline</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modular.html">Run the Pipeline in a Conda environment</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../develdocmd/pipeline_tests.html">Pipeline testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../develdocmd/DataType_Testing.html">DataType Testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../develdocmd/QA_scores.html">Pipeline Quality Assurance (QA) Score Class Design</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../develdocmd/DeveloperDocumentation.html">Pipeline developer documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../develdocmd/python3_conversion_notes.html">Python 3 conversion notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../heuristics/field_parameter.html">Field parameter</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../heuristics/FlaggingTasks.html">Pipeline Flagging Tasks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../notebooks/context.html">Pipeline Context</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../notebooks/tier0dask.html">“Tier0” Parallelization with Dask/Futures</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: gray" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Pipeline</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">casatools.table</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for casatools.table</h1><div class="highlight"><pre>
<span></span><span class="c1">##################### generated by xml-casa (v2) from table.xml #####################</span>
<span class="c1">##################### c398d2c9adbb49acd894b261c1ce3ac6 ##############################</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">absolute_import</span> 
<span class="kn">from</span> <span class="nn">.__casac__.table</span> <span class="kn">import</span> <span class="n">table</span> <span class="k">as</span> <span class="n">_table</span>

<span class="kn">from</span> <span class="nn">.errors</span> <span class="kn">import</span> <span class="n">create_error_string</span>
<span class="kn">from</span> <span class="nn">.typecheck</span> <span class="kn">import</span> <span class="n">CasaValidator</span> <span class="k">as</span> <span class="n">_validator</span>
<span class="n">_pc</span> <span class="o">=</span> <span class="n">_validator</span><span class="p">(</span> <span class="p">)</span>
<span class="kn">from</span> <span class="nn">.coercetype</span> <span class="kn">import</span> <span class="n">coerce</span> <span class="k">as</span> <span class="n">_coerce</span>
<span class="kn">from</span> <span class="nn">.tablerow</span> <span class="kn">import</span> <span class="n">tablerow</span> <span class="k">as</span> <span class="n">_wrap_tablerow</span>
<span class="n">_wrap_table</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">swig_object</span><span class="p">:</span> <span class="n">table</span><span class="p">(</span><span class="n">swig_object</span><span class="o">=</span><span class="n">swig_object</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">table</span><span class="p">:</span>
    <span class="n">_info_group_</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;table&quot;&quot;&quot;</span>
    <span class="n">_info_desc_</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;Access tables from casapy&quot;&quot;&quot;</span>
    <span class="c1">### self, tablename=&#39;&#39;, lockoptions={ }, nomodify=True</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tablename</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">lockoptions</span><span class="o">=</span><span class="p">{</span> <span class="p">},</span> <span class="n">nomodify</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Use this constructor to construct a table tool inside casapy from</span>
<span class="sd">        the name of a disk file containing a casa Table. A</span>
<span class="sd">        new table may also be created from a table descriptor</span>
<span class="sd">        (see tablecreatedesc).</span>
<span class="sd">        When creating a new table, detailed data manager information can be</span>
<span class="sd">        given using the texttt{dminfo} argument. This is a record as</span>
<span class="sd">        returned by the getdminfo</span>
<span class="sd">        function.</span>
<span class="sd">        </span>
<span class="sd">        Most of the arguments are rarely used: most of the time, you&#39;ll</span>
<span class="sd">        just need to use the tablename, and perhaps nomodify.</span>
<span class="sd">        </span>
<span class="sd">        A table can be shared by multiple processes by using the appropriate</span>
<span class="sd">        locking options. The possible options are:</span>
<span class="sd">        - auto: let the system take care of locking. At regular time</span>
<span class="sd">        intervals these autolocks are released to give other processes the</span>
<span class="sd">        opportunity to access the table. The aipsrc variable</span>
<span class="sd">        texttt{table.relinquish.reqautolocks.interval} defines the number</span>
<span class="sd">        of seconds between releasing autolocks on tables needed in another process.</span>
<span class="sd">        texttt{table.relinquish.allautolocks.interval} defines the number</span>
<span class="sd">        of seconds between releasing all autolocks.</span>
<span class="sd">        - autonoread: as auto, but no read locking is needed. This must be</span>
<span class="sd">        used with care, because it means that reading can be done while</span>
<span class="sd">        the table tool is not synchronized with the table file (as is</span>
<span class="sd">        normally done when a lock is acquired). The function texttt{resync}</span>
<span class="sd">        can be used to explicitly synchronize the table tool</span>
<span class="sd">        - user: the user takes care by explicit calls to lock and unlock</span>
<span class="sd">        - usernoread: as user and the no readlocking behaviour of autonoread.</span>
<span class="sd">        - permanent: use a permanent lock; the constructor fails when the table is</span>
<span class="sd">        already in use in another process</span>
<span class="sd">        - permanentwait: as above, but wait until the other process</span>
<span class="sd">        releases its lock</span>
<span class="sd">        - default: this is the default option.</span>
<span class="sd">        If the given table is already open, the locking option in use is not</span>
<span class="sd">        changed. Otherwise it reverts to auto.</span>
<span class="sd">        When auto locking is used, it is possible to give a record containing</span>
<span class="sd">        the fields option, interval, and/or maxwait. In this way advanced</span>
<span class="sd">        users have full control over the locking options. In practice this is</span>
<span class="sd">        hardly ever needed.</span>
<span class="sd">        </span>
<span class="sd">        When creating a new table, the endian format in which the</span>
<span class="sd">        data should be stored, can be specified. The possible values are:</span>
<span class="sd">        - big: big endian format (as used on e.g. SUN)</span>
<span class="sd">        - little: little endian format (as used on e.g. PC)</span>
<span class="sd">        - local: use the endian format of the machine being used</span>
<span class="sd">        - aipsrc: use the endian format specified in aipsrc variable</span>
<span class="sd">        table.endianformat (which defaults to big).</span>
<span class="sd">        The default is aipsrc.</span>
<span class="sd">        Note that usually it is best to store data in local endian format,</span>
<span class="sd">        because that requires the least amount of byte swapping. However,</span>
<span class="sd">        if the table must be accessible with AIPS++ version 1.7 or before,</span>
<span class="sd">        big endian should be used.</span>
<span class="sd">        </span>
<span class="sd">        When creating a new table, the table will normally reside on disk. It</span>
<span class="sd">        is, however, possible to specify that the table should be held in</span>
<span class="sd">        memory. In such a case the table is process specific, thus cannot be</span>
<span class="sd">        seen by other processes. Note that a memory table uses the MemoryStMan</span>
<span class="sd">        storage manager for all its stored columns, but it is still possible</span>
<span class="sd">        to use virtual columns as well.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">schema</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;tablename&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;cPath&#39;</span><span class="p">,</span> <span class="s1">&#39;coerce&#39;</span><span class="p">:</span> <span class="n">_coerce</span><span class="o">.</span><span class="n">expand_path</span><span class="p">},</span> <span class="s1">&#39;lockoptions&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;cDict&#39;</span><span class="p">},</span> <span class="s1">&#39;nomodify&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;cBool&#39;</span><span class="p">}}</span>
        <span class="n">doc</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;tablename&#39;</span><span class="p">:</span> <span class="n">tablename</span><span class="p">,</span> <span class="s1">&#39;lockoptions&#39;</span><span class="p">:</span> <span class="n">lockoptions</span><span class="p">,</span> <span class="s1">&#39;nomodify&#39;</span><span class="p">:</span> <span class="n">nomodify</span><span class="p">}</span>
        <span class="k">assert</span> <span class="n">_pc</span><span class="o">.</span><span class="n">validate</span><span class="p">(</span><span class="n">doc</span><span class="p">,</span><span class="n">schema</span><span class="p">),</span> <span class="n">create_error_string</span><span class="p">(</span><span class="n">_pc</span><span class="o">.</span><span class="n">errors</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;swig_object&#39;</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span> <span class="o">=</span> <span class="n">_table</span><span class="p">(</span><span class="n">_pc</span><span class="o">.</span><span class="n">document</span><span class="p">[</span><span class="s1">&#39;tablename&#39;</span><span class="p">],</span> <span class="n">_pc</span><span class="o">.</span><span class="n">document</span><span class="p">[</span><span class="s1">&#39;lockoptions&#39;</span><span class="p">],</span> <span class="n">_pc</span><span class="o">.</span><span class="n">document</span><span class="p">[</span><span class="s1">&#39;nomodify&#39;</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">fromfits</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tablename</span><span class="p">,</span> <span class="n">fitsfile</span><span class="p">,</span> <span class="n">whichhdu</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">storage</span><span class="o">=</span><span class="s1">&#39;standard&#39;</span><span class="p">,</span> <span class="n">convention</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">,</span> <span class="n">nomodify</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">ack</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a table from binary FITS format. This generates a CASA table</span>
<span class="sd">        from the binary FITS table in the given HDU (header unit) of the</span>
<span class="sd">        FITS file. Note that other FITS formats ({em e.g.}</span>
<span class="sd">        Image FITS and UVFITS) are read by other means.</span>
<span class="sd">        It is possible to specify the storage manager to use for the table:</span>
<span class="sd">        texttt{standard} is the default storage manager.</span>
<span class="sd">        texttt{incremental} is efficient for slowly varying data.</span>
<span class="sd">        texttt{memort} is for in memory use for e.g to grab given columns via getcol.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_wrap_table</span><span class="p">(</span><span class="n">swig_object</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">fromfits</span><span class="p">(</span><span class="n">tablename</span><span class="p">,</span> <span class="n">fitsfile</span><span class="p">,</span> <span class="n">whichhdu</span><span class="p">,</span> <span class="n">storage</span><span class="p">,</span> <span class="n">convention</span><span class="p">,</span> <span class="n">nomodify</span><span class="p">,</span> <span class="n">ack</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">fromascii</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tablename</span><span class="p">,</span> <span class="n">asciifile</span><span class="p">,</span> <span class="n">headerfile</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">autoheader</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">autoshape</span><span class="o">=</span><span class="p">[</span> <span class="nb">int</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">],</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">commentmarker</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">firstline</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">lastline</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">nomodify</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">columnnames</span><span class="o">=</span><span class="p">[</span>  <span class="p">],</span> <span class="n">datatypes</span><span class="o">=</span><span class="p">[</span>  <span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a table from an ASCII file. Columnar data as well as</span>
<span class="sd">        table and column keywords may be specified.</span>
<span class="sd">        Once the table is created from the ASCII data, it is opened in the</span>
<span class="sd">        specified mode by the table tool.</span>
<span class="sd">        </span>
<span class="sd">        The table columns are filled from a file containing the data values</span>
<span class="sd">        separated by a separator (one line per table row). The default</span>
<span class="sd">        separator is a blank. Blanks after the separator are ignored.</span>
<span class="sd">        If a non-blank separator is used, values can be empty. Such values</span>
<span class="sd">        default to 0, empty string, or F depending on the data type. E.g.</span>
<span class="sd">        1,,2, has 4 values of which the 2nd and 4th are empty and default to 0.</span>
<span class="sd">        Similarly if fewer values are given than needed, the missing values</span>
<span class="sd">        get the default value.</span>
<span class="sd">        </span>
<span class="sd">        Either the data format can be explicitly specified or it can be found</span>
<span class="sd">        automatically. The former gives more control in ambiguous situations.</span>
<span class="sd">        Both scalar and array columns can be generated from the ASCII input.</span>
<span class="sd">        The format string determines the type and optional shape.</span>
<span class="sd">        </span>
<span class="sd">        In automatic mode (texttt{autoheader=True}) the first line</span>
<span class="sd">        of the ASCII data is analyzed</span>
<span class="sd">        to deduce the data types. Only the types I, D, and A can be</span>
<span class="sd">        recognized. A number without decimal point or exponent is I (integer),</span>
<span class="sd">        otherwise it is D (double). Any other string is A (string).</span>
<span class="sd">        Note that a number may contain a leading sign (+ or -).</span>
<span class="sd">        The texttt{autoshape} argument can be used to specify if the input</span>
<span class="sd">        should be stored as multiple scalars (the default) or as a single</span>
<span class="sd">        array. In the latter case one axis in the shape can be defined as</span>
<span class="sd">        variable length by giving it the value 0. It means that the actual</span>
<span class="sd">        array shape in a row is determined by the number of values in the</span>
<span class="sd">        corresponding input line.</span>
<span class="sd">        Columns get the names texttt{Column1}, texttt{Column2}, etc..</span>
<span class="sd">        For example:</span>
<span class="sd">        begin{enumerate}</span>
<span class="sd">        item</span>
<span class="sd">        texttt{autoshape=[]} (which is the default) means that all values</span>
<span class="sd">        are to be stored as scalar columns.</span>
<span class="sd">        item</span>
<span class="sd">        texttt{autoshape=0} means that all values in a row are to be stored as</span>
<span class="sd">        a variable length vector.</span>
<span class="sd">        item</span>
<span class="sd">        texttt{autoshape=10} defines a fixed length vector. If an input</span>
<span class="sd">        line contains less than 10 values, the vector is filled with default</span>
<span class="sd">        values. If more than 10 values, the latter values are ignored.</span>
<span class="sd">        item</span>
<span class="sd">        texttt{autoshape=[5,0]} defines a 2-dim array of which the 2nd axis is</span>
<span class="sd">        variable. Note that if an input line does not contain a multiple of 5</span>
<span class="sd">        values, the array is filled with default values.</span>
<span class="sd">        end{enumerate}</span>
<span class="sd">        </span>
<span class="sd">        If the format of the table is explicitly specified, it has to be done</span>
<span class="sd">        either in the first two lines of the data file (named by the</span>
<span class="sd">        argument filename), or in a separate header file (named by the</span>
<span class="sd">        argument headerfile). In both forms, table keywords may also be</span>
<span class="sd">        specified before the column definitions.</span>
<span class="sd">        The column names and types can be described by two lines:</span>
<span class="sd">        </span>
<span class="sd">        begin{enumerate}</span>
<span class="sd">        item The first line contains the names of the columns.</span>
<span class="sd">        These names may be enclosed in quotes (either single or double).</span>
<span class="sd">        item The second line contains the data type and optionally the shape</span>
<span class="sd">        of each column. Valid types are:</span>
<span class="sd">        begin{itemize}</span>
<span class="sd">        item S for Short data</span>
<span class="sd">        item I for Integer data</span>
<span class="sd">        item R for Real data</span>
<span class="sd">        item D for Double Precision data</span>
<span class="sd">        item X for Complex data (Real followed by Imaginary)</span>
<span class="sd">        item Z for Complex data (Amplitude then Phase)</span>
<span class="sd">        item DX for Double Precision Complex data (Real followed by Imaginary)</span>
<span class="sd">        item DZ for Double Precision Complex data (Amplitude then Phase)</span>
<span class="sd">        item A for ASCII data (a value must be enclosed in single or double quotes</span>
<span class="sd">        if it contains whitespace)</span>
<span class="sd">        item B for Boolean data (False are empty string, 0, or any string</span>
<span class="sd">        starting with F, f, N, or n).</span>
<span class="sd">        end{itemize}</span>
<span class="sd">        end{enumerate}</span>
<span class="sd">        If a column is an array, the shape has to be given after the data type</span>
<span class="sd">        without any whitespace. E.g. texttt{I10} defines an integer vector</span>
<span class="sd">        of length 10. texttt{A2,5} defines a 2-dim string array with shape</span>
<span class="sd">        [2,5]. Note that texttt{I} is not the same as texttt{I1} as the</span>
<span class="sd">        first one defines a scalar and the other one a vector with length 1.</span>
<span class="sd">        The last column can have one variable length axis denoted by the value</span>
<span class="sd">        0. It &quot;consumes&quot; the remainder of the input line.</span>
<span class="sd">        </span>
<span class="sd">        If the argument headerfile is set then the header information is</span>
<span class="sd">        read from that file instead of the first lines of the data file.</span>
<span class="sd">        </span>
<span class="sd">        To give a simple example of the form where the header information</span>
<span class="sd">        is located at the top of the data file:</span>
<span class="sd">        </span>
<span class="sd">        begin{verbatim}</span>
<span class="sd">        COLI   COLF   COLD       COLX        COLZ       COLS</span>
<span class="sd">        I      R      D          X           Z          A</span>
<span class="sd">        1      1.1    1.11       1.12 1.13   1.14 1.15  Str1</span>
<span class="sd">        10     11     12         13   14     15   16    &quot;&quot;</span>
<span class="sd">        end{verbatim}</span>
<span class="sd">        Note that a complex number consists of 2 numbers.</span>
<span class="sd">        Also note that an empty string can be given.</span>
<span class="sd">        </span>
<span class="sd">        Let us now give an example of a separate header file that one might use to get</span>
<span class="sd">        interferometer data into casa:</span>
<span class="sd">        </span>
<span class="sd">        begin{verbatim}</span>
<span class="sd">        U     V      W         TIME        ANT1       ANT2      DATA</span>
<span class="sd">        R     R      R          D           I          I        X1,0</span>
<span class="sd">        end{verbatim}</span>
<span class="sd">        </span>
<span class="sd">        The data file would then look like:</span>
<span class="sd">        </span>
<span class="sd">        begin{verbatim}</span>
<span class="sd">        124.011 54560.0  3477.1  43456789.0990    1      2        4.327 -0.1132</span>
<span class="sd">        34561.0 45629.3  3900.5  43456789.0990    1      3        5.398 0.4521</span>
<span class="sd">        end{verbatim}</span>
<span class="sd">        Note that the DATA column is defined as a 2-dim array of 1</span>
<span class="sd">        correlation and a variable number of channels, so the actual number of</span>
<span class="sd">        channels is determined by the input. In this example both rows will</span>
<span class="sd">        have 1 channel (note that a complex value contains 2 values).</span>
<span class="sd">        </span>
<span class="sd">        Tables may have keywords in addition to the columns. The keywords</span>
<span class="sd">        are useful for holding information that is global to the entire</span>
<span class="sd">        table (such as author, revision, history, {em etc,}).</span>
<span class="sd">        The keywords in the header definitions must preceed the column descriptions.</span>
<span class="sd">        They must be enclosed between a line that starts with &quot;.key...&quot; and</span>
<span class="sd">        a line that starts with &quot;.endkey...&quot; (where ... can be anything).</span>
<span class="sd">        Between these two lines each</span>
<span class="sd">        line should contain the following as listed below.</span>
<span class="sd">        A table keywordset and column keywordsets can be specified.</span>
<span class="sd">        The latter can be specified by specifying the column name after the</span>
<span class="sd">        .keywords string.</span>
<span class="sd">        </span>
<span class="sd">        begin{itemize}</span>
<span class="sd">        item The keyword name, e.g., ANYKEY</span>
<span class="sd">        item The datatype and optional  shape of the keyword</span>
<span class="sd">        (cf. list of valid types above)</span>
<span class="sd">        item The value or values for the keyword (the keyword may contain</span>
<span class="sd">        a scalar or an array of values). e.g., 3.14159 21.78945</span>
<span class="sd">        end{itemize}</span>
<span class="sd">        </span>
<span class="sd">        Thus to continue the example above, one might wish to add keywords</span>
<span class="sd">        as follows:</span>
<span class="sd">        </span>
<span class="sd">        begin{verbatim}</span>
<span class="sd">        .keywords</span>
<span class="sd">        DATE        A  &quot;97/1/16&quot;</span>
<span class="sd">        REVISION    D 2.01</span>
<span class="sd">        AUTHOR      A &quot;Tim Cornwell&quot;</span>
<span class="sd">        INSTRUMENT  A &quot;VLA&quot;</span>
<span class="sd">        .endkeywords</span>
<span class="sd">        .keywords TIME</span>
<span class="sd">        UNIT A &quot;s&quot;</span>
<span class="sd">        .endkeywords</span>
<span class="sd">        U     V      W         TIME        ANT1       ANT2      DATA</span>
<span class="sd">        R     R      R          D           I          I        X1,0</span>
<span class="sd">        end{verbatim}</span>
<span class="sd">        Similarly to the column format string, the keyword formats can also</span>
<span class="sd">        contain shape information. The only difference is that if no shape is</span>
<span class="sd">        given, a keyword can have multiple values (making it a vector).</span>
<span class="sd">        </span>
<span class="sd">        It is possible to ignore comment lines in the header and data file</span>
<span class="sd">        by giving the texttt{commentmarker}. It indicates that lines</span>
<span class="sd">        starting with the given marker are ignored. Note that the marker can</span>
<span class="sd">        be a regular expression (e.g. texttt{&#39; *//&#39;} tells that lines starting</span>
<span class="sd">        with // and optionally preceeded by blanks have to be ignored).</span>
<span class="sd">        </span>
<span class="sd">        With the arguments texttt{firstline} and texttt{lastline} one can</span>
<span class="sd">        specify which lines have to be taken from the input file. A negative value</span>
<span class="sd">        means 1 for texttt{firstline} or end-of-file for texttt{lastline}.</span>
<span class="sd">        Note that if the headers and data are combined in one file,</span>
<span class="sd">        these line arguments apply to the whole file. If headers and data are in</span>
<span class="sd">        separate files, these line arguments apply to the data file only.</span>
<span class="sd">        </span>
<span class="sd">        Also note that ignored comment lines are counted, thus are used to</span>
<span class="sd">        determine which lines are in the line range.</span>
<span class="sd">        </span>
<span class="sd">        The number of rows is determined by the number of lines read from the data</span>
<span class="sd">        file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">fromascii</span><span class="p">(</span><span class="n">tablename</span><span class="p">,</span> <span class="n">asciifile</span><span class="p">,</span> <span class="n">headerfile</span><span class="p">,</span> <span class="n">autoheader</span><span class="p">,</span> <span class="n">autoshape</span><span class="p">,</span> <span class="n">sep</span><span class="p">,</span> <span class="n">commentmarker</span><span class="p">,</span> <span class="n">firstline</span><span class="p">,</span> <span class="n">lastline</span><span class="p">,</span> <span class="n">nomodify</span><span class="p">,</span> <span class="n">columnnames</span><span class="p">,</span> <span class="n">datatypes</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">open</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tablename</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">lockoptions</span><span class="o">=</span><span class="p">{</span> <span class="p">},</span> <span class="n">nomodify</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Opens a disk file containing an existing casa Table.</span>
<span class="sd">        </span>
<span class="sd">        Most of the time you just need to specify the tablename and perhaps</span>
<span class="sd">        nomodify.</span>
<span class="sd">        </span>
<span class="sd">        A table can be shared by multiple processes by using the appropriate</span>
<span class="sd">        locking options. The possible options are:</span>
<span class="sd">        - auto: let the system take care of locking. At regular time</span>
<span class="sd">        intervals these autolocks are released to give other processes the</span>
<span class="sd">        opportunity to access the table.</span>
<span class="sd">        - autonoread: as auto, but no read locking is needed. This must be</span>
<span class="sd">        used with care, because it means that reading can be done while</span>
<span class="sd">        the table tool is not synchronized with the table file (as is</span>
<span class="sd">        normally done when a lock is acquired). The function texttt{resync}</span>
<span class="sd">        can be used to explicitly synchronize the table tool</span>
<span class="sd">        - user: the user takes care by explicit calls to lock and unlock</span>
<span class="sd">        - usernoread: as user and the no readlocking behaviour of autonoread.</span>
<span class="sd">        - permanent: use a permanent lock; the constructor fails when the table is</span>
<span class="sd">        already in use in another process</span>
<span class="sd">        - permanentwait: as above, but wait until the other process</span>
<span class="sd">        releases its lock</span>
<span class="sd">        - default: this is the default option.</span>
<span class="sd">        If the given table is already open, the locking option in use is not</span>
<span class="sd">        changed. Otherwise it reverts to auto.</span>
<span class="sd">        When auto locking is used, it is possible to give a record containing</span>
<span class="sd">        the fields option, interval, and/or maxwait. In this way advanced</span>
<span class="sd">        users have full control over the locking options. In practice this is</span>
<span class="sd">        hardly ever needed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">tablename</span><span class="p">,</span> <span class="n">lockoptions</span><span class="p">,</span> <span class="n">nomodify</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">create</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tablename</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">tabledesc</span><span class="o">=</span><span class="p">{</span> <span class="p">},</span> <span class="n">lockoptions</span><span class="o">=</span><span class="p">{</span> <span class="p">},</span> <span class="n">endianformat</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">memtype</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">nrow</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">dminfo</span><span class="o">=</span><span class="p">{</span> <span class="p">}):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a new casa Table.</span>
<span class="sd">        </span>
<span class="sd">        Most of the time you just need to specify the table&#39;s name and a description of</span>
<span class="sd">        its format.</span>
<span class="sd">        </span>
<span class="sd">        A table can be shared by multiple processes by using the appropriate</span>
<span class="sd">        locking options. The possible options are:</span>
<span class="sd">        - auto: let the system take care of locking. At regular time</span>
<span class="sd">        intervals these autolocks are released to give other processes the</span>
<span class="sd">        opportunity to access the table.</span>
<span class="sd">        - autonoread: as auto, but no read locking is needed. This must be</span>
<span class="sd">        used with care, because it means that reading can be done while</span>
<span class="sd">        the table tool is not synchronized with the table file (as is</span>
<span class="sd">        normally done when a lock is acquired). The function texttt{resync}</span>
<span class="sd">        can be used to explicitly synchronize the table tool</span>
<span class="sd">        - user: the user takes care by explicit calls to lock and unlock</span>
<span class="sd">        - usernoread: as user and the no readlocking behaviour of autonoread.</span>
<span class="sd">        - permanent: use a permanent lock; the constructor fails when the table is</span>
<span class="sd">        already in use in another process</span>
<span class="sd">        - permanentwait: as above, but wait until the other process</span>
<span class="sd">        releases its lock</span>
<span class="sd">        - default: this is the default option.</span>
<span class="sd">        If the given table is already open, the locking option in use is not</span>
<span class="sd">        changed. Otherwise it reverts to auto.</span>
<span class="sd">        When auto locking is used, it is possible to give a record containing</span>
<span class="sd">        the fields option, interval, and/or maxwait. In this way advanced</span>
<span class="sd">        users have full control over the locking options. In practice this is</span>
<span class="sd">        hardly ever needed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">tablename</span><span class="p">,</span> <span class="n">tabledesc</span><span class="p">,</span> <span class="n">lockoptions</span><span class="p">,</span> <span class="n">endianformat</span><span class="p">,</span> <span class="n">memtype</span><span class="p">,</span> <span class="n">nrow</span><span class="p">,</span> <span class="n">dminfo</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">flush</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Until a flush is performed, the results of all operations</span>
<span class="sd">        are not reflected in any change to the</span>
<span class="sd">        disk file. Hence you {em must} do a flush to write the changes</span>
<span class="sd">        to disk.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">fromASDM</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tablename</span><span class="p">,</span> <span class="n">xmlfile</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;.keywords</span>
<span class="sd">        DATE        A  &quot;07/7/23&quot;</span>
<span class="sd">        REVISION    D 0</span>
<span class="sd">        AUTHOR      A &quot;Paulo C. Cortes&quot;</span>
<span class="sd">        INSTRUMENT  A &quot;ALMA&quot;</span>
<span class="sd">        .endkeywords</span>
<span class="sd">        </span>
<span class="sd">        The main function for this task is to create a CASA::Table from a XML  ASDM Table. The classes asdmCasaXMLUtil and asdmCasaSaxHandler are the main objects which</span>
<span class="sd">        implement the task. The asdmCasaSaxHandler encapsulate all the operations</span>
<span class="sd">        returning a reference to a CASA::Table. The class uses xerces-c to parse the</span>
<span class="sd">        XML table and creates the CASA::Table. The implementation assumes the integrity</span>
<span class="sd">        of the XML data, it not attempting to check whether the XML  data meets a</span>
<span class="sd">        column format or not. In detail, an ArrayString column should agree with</span>
<span class="sd">        the following format: nd nx ... data, where nd is the number of dimensions,</span>
<span class="sd">        nx is the size of the first dimension (implemented upto a cube, i.e. nx,ny,nz),</span>
<span class="sd">        and data is the array itself which should have the appropiate number of</span>
<span class="sd">        elements. For example, a VectorString column could be: 1 2 &quot;I&quot; &quot;Q&quot; or</span>
<span class="sd">        dimension 1, size 2, and two string elements. Due to the lack of data type</span>
<span class="sd">        spefication in the XML tables, the column names are hardcoded into the</span>
<span class="sd">        asdmCasaSaxHandler based on the ASDM specification (see</span>
<span class="sd">        http://aramis.obspm.fr/~alma/ASDM/ASDMEntities/index.html).</span>
<span class="sd">        While missing data from a table column will be accepted by the task,</span>
<span class="sd">        any new column beyond the specification has to be added into the class, also,</span>
<span class="sd">        any change in data types form the specificatin will produce a crash, CASA</span>
<span class="sd">        is picky with data types integrity. So far, the list of tables included in</span>
<span class="sd">        the class is:</span>
<span class="sd">        </span>
<span class="sd">        AlmaCorrelatorMode.xml,</span>
<span class="sd">        Antenna.xml</span>
<span class="sd">        ConfigDescription.xml,</span>
<span class="sd">        DataDescription.xml,</span>
<span class="sd">        ExecBlock.xml,</span>
<span class="sd">        Feed.xml,</span>
<span class="sd">        Field.xml,</span>
<span class="sd">        Main.xml,</span>
<span class="sd">        Polarization.xml,</span>
<span class="sd">        Processor.xml,</span>
<span class="sd">        Receiver.xml,</span>
<span class="sd">        SBSummary.xml,</span>
<span class="sd">        Scan.xml,</span>
<span class="sd">        Source.xml,</span>
<span class="sd">        SpectralWindow.xml,</span>
<span class="sd">        State.xml,</span>
<span class="sd">        Station.xml,</span>
<span class="sd">        Subscan.xml,</span>
<span class="sd">        SwitchCycle.xml,</span>
<span class="sd">        CalCurve.xml,</span>
<span class="sd">        CalData.xml,</span>
<span class="sd">        CalPhase.xml</span>
<span class="sd">        </span>
<span class="sd">        more tables will follow. The usage of fromASDM is simple, it gets two</span>
<span class="sd">        string, tablename and xmlfile, where tablename is the CASA::Table to be</span>
<span class="sd">        written and xmlfile represents the ASDM XML table. To call it do:</span>
<span class="sd">        tb.fromasdm(tablename,xmlfile)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">fromASDM</span><span class="p">(</span><span class="n">tablename</span><span class="p">,</span> <span class="n">xmlfile</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">resync</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Acquiring a read or write lock automatically synchronizes the internals</span>
<span class="sd">        of the table tool with the actual contents of the table files.</span>
<span class="sd">        In this way different processes accessing the same table always</span>
<span class="sd">        use the same table data.</span>
<span class="sd">        However, a table can be used without read locking. In that case</span>
<span class="sd">        the table tool internals are not synchronized automatically.</span>
<span class="sd">        The resync function offers a way to do explicit synchronization.</span>
<span class="sd">        It is only useful if the table is opened with locking mode</span>
<span class="sd">        texttt{autonoread} or texttt{usernoread}.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">resync</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;First a flush is done, then the table is closed inside casapy and</span>
<span class="sd">        is no longer available for use.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newtablename</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">valuecopy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">dminfo</span><span class="o">=</span><span class="p">{</span> <span class="p">},</span> <span class="n">endian</span><span class="o">=</span><span class="s1">&#39;aipsrc&#39;</span><span class="p">,</span> <span class="n">memorytable</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">returnobject</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">norows</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Copy the table. All subtables are also copied.</span>
<span class="sd">        References to another table are preserved.</span>
<span class="sd">        </span>
<span class="sd">        The argument texttt{deep} determines how a reference table (i.e. the</span>
<span class="sd">        result of a query) is copied. By default</span>
<span class="sd">        a file copy is made, thus the resulting table still contains</span>
<span class="sd">        references and no actual data. If, however, texttt{deep=True} is given,</span>
<span class="sd">        a deep copy is made which means that the actual data are copied. Also</span>
<span class="sd">        all subtables are copied.</span>
<span class="sd">        Normally a plain table is copied by copying the files. However,</span>
<span class="sd">        if texttt{deep=True} and texttt{valuecopy=True} are given, a plain table is</span>
<span class="sd">        copied by copying all its values and subtables. This is useful to</span>
<span class="sd">        reorganize the tables, i.e. to regain file space that is wasted by</span>
<span class="sd">        frequent updates to a table.</span>
<span class="sd">        The argument texttt{dminfo} can be used to specify explicit data</span>
<span class="sd">        manager info for the columns in the new plain table. It can be used to</span>
<span class="sd">        change, for example, a storage manager from IncrStMan to StandardStMan.</span>
<span class="sd">        The texttt{dminfo} is a record as returned by the</span>
<span class="sd">        getdminfo</span>
<span class="sd">        If texttt{dminfo} is a non-empty record, it forces texttt{valuecopy=True}.</span>
<span class="sd">        </span>
<span class="sd">        The standard operation is make the copy to a plain table. It is,</span>
<span class="sd">        however, possible to copy to a memory table by giving texttt{memorytable=True}.</span>
<span class="sd">        </span>
<span class="sd">        The endian format for the newly created table can be specified. This</span>
<span class="sd">        is only meaningful if a deep copy is made to a plain table.</span>
<span class="sd">        The possible values are:</span>
<span class="sd">        - big: big endian format (as used on e.g. SUN)</span>
<span class="sd">        - little: little endian format (as used on e.g. PC)</span>
<span class="sd">        - local: use the endian format of the machine being used</span>
<span class="sd">        - aipsrc: use the endian format specified in aipsrc variable</span>
<span class="sd">        table.endianformat (which defaults to big).</span>
<span class="sd">        The default is aipsrc.</span>
<span class="sd">        </span>
<span class="sd">        Normally the texttt{copy} function only copies the table and does not</span>
<span class="sd">        create a new table tool object. The user can do that by opening the newly</span>
<span class="sd">        created table in the standard way. However, it is possible to get an</span>
<span class="sd">        object back by using texttt{returnobject=True}. An object is always</span>
<span class="sd">        returned if the copy is made to a memory table.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_wrap_table</span><span class="p">(</span><span class="n">swig_object</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">newtablename</span><span class="p">,</span> <span class="n">deep</span><span class="p">,</span> <span class="n">valuecopy</span><span class="p">,</span> <span class="n">dminfo</span><span class="p">,</span> <span class="n">endian</span><span class="p">,</span> <span class="n">memorytable</span><span class="p">,</span> <span class="n">returnobject</span><span class="p">,</span> <span class="n">norows</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">copyrows</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outtable</span><span class="p">,</span> <span class="n">startrowin</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">startrowout</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">nrow</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Copy rows from this table to another. By default all rows of this</span>
<span class="sd">        table are appended to the output table. It is possible though to</span>
<span class="sd">        control which rows are copied.</span>
<span class="sd">        Rows are added to the output table as needed.</span>
<span class="sd">        Because no rows can be added to a reference table, it is only possible</span>
<span class="sd">        to overwrite existing rows in such tables.</span>
<span class="sd">        </span>
<span class="sd">        Only the data of columns existing in both tables will be copied.</span>
<span class="sd">        Thus by making a reference table consisting of a few columns, it</span>
<span class="sd">        is possible to copy those columns only.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">copyrows</span><span class="p">(</span><span class="n">outtable</span><span class="p">,</span> <span class="n">startrowin</span><span class="p">,</span> <span class="n">startrowout</span><span class="p">,</span> <span class="n">nrow</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">done</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Effectively a synonym for function close.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">done</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">iswritable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Test if the table is opened for write.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">iswritable</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">isopened</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tablename</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Test if the table is opened in the  process this function is invoked</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">isopened</span><span class="p">(</span><span class="n">tablename</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">endianformat</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the endian format used for this table.</span>
<span class="sd">        It returns a string with value &#39;big&#39; or &#39;little&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">endianformat</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">lock</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">write</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">nattempts</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">0</span><span class="p">)):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Try to acquire a read or write lock on the table. Nothing will be</span>
<span class="sd">        done if the table is already correctly locked by this process.</span>
<span class="sd">        It is only needed when user locking is used.</span>
<span class="sd">        When the lock is acquired, the internal caches will be synchronized</span>
<span class="sd">        with the (possibly changed) contents of the table.</span>
<span class="sd">        It is possible to specify the number of attempts to do (1 per</span>
<span class="sd">        second) in case the table is locked by another process. The default 0</span>
<span class="sd">        is trying indefinitely.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">lock</span><span class="p">(</span><span class="n">write</span><span class="p">,</span> <span class="n">nattempts</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">unlock</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The table is flushed and the lock on the table is released.</span>
<span class="sd">        This function is only needed when user locking is used.</span>
<span class="sd">        However, it is also possible to use it with auto locking. In that case</span>
<span class="sd">        the lock will automatically be re-acquired before the next table operation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">unlock</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">datachanged</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function tests if data in the table have changed (by another</span>
<span class="sd">        process) since the last call to this function.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">datachanged</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">haslock</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">write</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Has this process a read or write lock on the table?</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">haslock</span><span class="p">(</span><span class="n">write</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">lockoptions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the lock options used for this table.</span>
<span class="sd">        It returns a record with the fields: option, interval and maxwait.</span>
<span class="sd">        The record can be used as the lockoptions argument when opening a table.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">lockoptions</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">ismultiused</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">checksubtables</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Is the table still in use in another process?</span>
<span class="sd">        If so, the table cannot be deleted.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">ismultiused</span><span class="p">(</span><span class="n">checksubtables</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">browse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;To start the browser, the environment variable</span>
<span class="sd">        DISPLAY must be set.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">browse</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Gives the name of the casa table on disk that the</span>
<span class="sd">        table tool has open.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">name</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">createmultitable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outputTableName</span><span class="p">,</span> <span class="n">tables</span><span class="p">,</span> <span class="n">subdirname</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">createmultitable</span><span class="p">(</span><span class="n">outputTableName</span><span class="p">,</span> <span class="n">tables</span><span class="p">,</span> <span class="n">subdirname</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">toasciifmt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">asciifile</span><span class="p">,</span> <span class="n">headerfile</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span>  <span class="p">],</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Write a table into an ASCII format approximately compatible with fromascii except that in order to permit variable shaped arrays (as they often occur in MSs), array values are output enclosed in square brackets.</span>
<span class="sd">        The separator between values can be specified and defaults to a blank. Note that columns containing</span>
<span class="sd">        invalid data or record type data are ignored and a warning is issued.</span>
<span class="sd">        </span>
<span class="sd">        If the argument headerfile is set then the header information is</span>
<span class="sd">        written to that file instead of the first two lines of the data file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">toasciifmt</span><span class="p">(</span><span class="n">asciifile</span><span class="p">,</span> <span class="n">headerfile</span><span class="p">,</span> <span class="n">columns</span><span class="p">,</span> <span class="n">sep</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">taql</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">taqlcommand</span><span class="o">=</span><span class="s1">&#39;TaQL expression&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This method Expose TaQL to the user.</span>
<span class="sd">        Details on TaQL maybe found at https://casacore.github.io/casacore-notes/199.html</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_wrap_table</span><span class="p">(</span><span class="n">swig_object</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">taql</span><span class="p">(</span><span class="n">taqlcommand</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">query</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query</span><span class="o">=</span><span class="s1">&#39;String&#39;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">sortlist</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">style</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Make a table from a query applied to the current table.  It is possible to</span>
<span class="sd">        specify column(s) and/or expressions to sort on and to specify the</span>
<span class="sd">        columns to be contained in the output table.  See the example below.</span>
<span class="sd">        A new &quot;on-the-fly&quot; table tool is returned. The new (reference) table</span>
<span class="sd">        can be given a name and will then be written to disk. Note that the</span>
<span class="sd">        resulting table is just a reference to the original table.  One can</span>
<span class="sd">        make a deep copy of the query result using the copy function (see example).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_wrap_table</span><span class="p">(</span><span class="n">swig_object</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">sortlist</span><span class="p">,</span> <span class="n">columns</span><span class="p">,</span> <span class="n">style</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">calc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="s1">&#39;using style base0, endincl, fortranorder&#39;</span><span class="p">,</span> <span class="n">showtaql</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the result from the calculation of an expression on a table</span>
<span class="sd">        </span>
<span class="sd">        The expression can be any expression that can be given in the WHERE</span>
<span class="sd">        clause of a SELECT expression (thus including subqueries).</span>
<span class="sd">        The given expression determines if the result is a scalar, a vector,</span>
<span class="sd">        or a record containing arrays. See the examples below.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">calc</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">prefix</span><span class="p">,</span> <span class="n">showtaql</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">selectrows</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rownrs</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a (reference) table containing a given subset of rows.</span>
<span class="sd">        It is, for instance, useful when a selection is done</span>
<span class="sd">        on another table containing the row numbers in the main table.</span>
<span class="sd">        It can be useful to apply the casapy function unique to those</span>
<span class="sd">        row numbers, otherwise the same row might be included multiple</span>
<span class="sd">        times (see example).</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        It is possible to give a name to the resulting table. If given,</span>
<span class="sd">        the resulting table is made persistent with that table name.</span>
<span class="sd">        Otherwise the table is transient and disappears when closed or when</span>
<span class="sd">        casapy exits.</span>
<span class="sd">        </span>
<span class="sd">        The rownumbers function returns a</span>
<span class="sd">        vector containing the row number in the main table for each row in the</span>
<span class="sd">        selection table.</span>
<span class="sd">        Thus given a row number vector texttt{rownrs}, the following is</span>
<span class="sd">        always true.</span>
<span class="sd">        begin{verbatim}</span>
<span class="sd">        rownrs == tb.selectrows(rownrs).rownumbers()</span>
<span class="sd">        end{verbatim}</span>
<span class="sd">        However, it is not true when selectrows is used on a selection table.</span>
<span class="sd">        because texttt{rownumbers} does not return the row number in that</span>
<span class="sd">        selection table but in the main table.</span>
<span class="sd">        It means that one has to take great care when using</span>
<span class="sd">        texttt{selectrows} on a selection table.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_wrap_table</span><span class="p">(</span><span class="n">swig_object</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">selectrows</span><span class="p">(</span><span class="n">rownrs</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">info</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The info record contains information on the table.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">info</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">putinfo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The info record contains information on the table. It is</span>
<span class="sd">        written by applications, and used  to determine what type of</span>
<span class="sd">        information is stored in a table.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">putinfo</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">addreadmeline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A readme line is part of the info record associated with a table.</span>
<span class="sd">        It is to inform the user, and is not used by any application directly.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">addreadmeline</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">summary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">recurse</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A (terse) summary of the table contents is sent to the defaultlogger.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">summary</span><span class="p">(</span><span class="n">recurse</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">colnames</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The names of the columns in the table are returned as a vector</span>
<span class="sd">        of Strings.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">colnames</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">rownumbers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tab</span><span class="o">=</span><span class="p">{</span> <span class="p">},</span> <span class="n">nbytes</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">0</span><span class="p">)):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;!!!NOTE INPUT PARAMETERS IGNORED!!!</span>
<span class="sd">        </span>
<span class="sd">        This function can be useful after a selection or a sort.</span>
<span class="sd">        It returns the row numbers of the rows in this table with respect</span>
<span class="sd">        to the given table. If no table is given, the original table is used.</span>
<span class="sd">        For example:</span>
<span class="sd">        begin {verbatim}</span>
<span class="sd">        !!!NOTE INPUT PARAMETERS IGNORED!!!</span>
<span class="sd">        </span>
<span class="sd">        tb.open(&#39;3C273XC1.MS&#39;)</span>
<span class="sd">        t1=tb.selectrows([1,3,5,7,9])</span>
<span class="sd">        t1.rownumbers()</span>
<span class="sd">        # [1L, 3L, 5L, 7L, 9L]</span>
<span class="sd">        t2=t1.selectrows([2,4])</span>
<span class="sd">        t2.rownumbers(t1)</span>
<span class="sd">        # [2L, 4L]</span>
<span class="sd">        t2.rownumbers(tb.name())</span>
<span class="sd">        # [5L, 9L]</span>
<span class="sd">        t2.rownumbers()</span>
<span class="sd">        # [5L, 9L]</span>
<span class="sd">        end{verbatim}</span>
<span class="sd">        The last statements show that the function returns the row numbers</span>
<span class="sd">        referring to the given table. Table t2 contains rows 2 and 4 in table t1,</span>
<span class="sd">        which are rows 5 and 9 in table &#39;3C273XC1.MS&#39;.</span>
<span class="sd">        </span>
<span class="sd">        Note that when a table is opened using its name, that table can</span>
<span class="sd">        be a reference table. Thus in the example above</span>
<span class="sd">        the last 2 statements may give different results depending on the fact</span>
<span class="sd">        if 3C273XC1.MS is a reference table or not.</span>
<span class="sd">        The function should always be called with a table argument.</span>
<span class="sd">        The ability of omitting the argument is only present for backward</span>
<span class="sd">        compatibility.</span>
<span class="sd">        </span>
<span class="sd">        The function can be useful to get the correct values from the result of a</span>
<span class="sd">        getcol or getcolslice on the original table.</span>
<span class="sd">        </span>
<span class="sd">        !!!NOTE INPUT PARAMETERS IGNORED!!!</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">rownumbers</span><span class="p">(</span><span class="n">tab</span><span class="p">,</span> <span class="n">nbytes</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">setmaxcachesize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">columnname</span><span class="p">,</span> <span class="n">nbytes</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;It can sometimes be useful to limit the size of the cache used by</span>
<span class="sd">        a column stored with the tiled storage manager.</span>
<span class="sd">        This function requires some more knowledge about the table system</span>
<span class="sd">        and is not meant for the casual user.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">setmaxcachesize</span><span class="p">(</span><span class="n">columnname</span><span class="p">,</span> <span class="n">nbytes</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">isscalarcol</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">columnname</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A column may contain either scalars or arrays in each cell.</span>
<span class="sd">        This tool function tests if the specified column has scalar contents.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">isscalarcol</span><span class="p">(</span><span class="n">columnname</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">isvarcol</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">columnname</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This functions tells if the column contains variable shaped arrays.</span>
<span class="sd">        If so, the function texttt{getvarcol} should be used to get the</span>
<span class="sd">        entire column. Otherwise texttt{getcol} can be used.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">isvarcol</span><span class="p">(</span><span class="n">columnname</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">coldatatype</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">columnname</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A column may contain various data types. This tool function returns the</span>
<span class="sd">        type of the column as a string.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">coldatatype</span><span class="p">(</span><span class="n">columnname</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">colarraytype</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">columnname</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The possible column array types are defined as:</span>
<span class="sd">        begin{description}</span>
<span class="sd">        item[FixedShape]  FixedShape means that the shape of the array must be the</span>
<span class="sd">        same in each cell of the column. If not given, the array</span>
<span class="sd">        shape may vary. Option Direct forces FixedShape.</span>
<span class="sd">        item[Direct] Direct means that the data is directly stored in the</span>
<span class="sd">        table. Direct forces option FixedShape. If not given, the array is</span>
<span class="sd">        indirect, which implies that the data will be stored in a</span>
<span class="sd">        separate file.</span>
<span class="sd">        end{description}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">colarraytype</span><span class="p">(</span><span class="n">columnname</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ncols</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">ncols</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">nrows</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Note that rows are numbered starting at 0.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">nrows</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">addrows</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nrow</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">1</span><span class="p">)):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Rows can be added to the end of a table that was opened nomodify=False.</span>
<span class="sd">        The new rows are empty.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">addrows</span><span class="p">(</span><span class="n">nrow</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">removerows</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rownrs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Remove the row numbers specified in the vector from the table.</span>
<span class="sd">        It fails when the table does not support row removal.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">removerows</span><span class="p">(</span><span class="n">rownrs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">addcols</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">desc</span><span class="p">,</span> <span class="n">dminfo</span><span class="o">=</span><span class="p">{</span> <span class="p">}):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Columns can be added to a table that was opened nomodify=False.</span>
<span class="sd">        The new columns will be filled with a default value (0 or blank).</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        !!!THESE COLUMN DESCRIPTION FUNCTIONS HAVE NOT BEEN IMPLEMENTED!!!</span>
<span class="sd">        For each column to be added a column description has to be setup</span>
<span class="sd">        using function</span>
<span class="sd">        tablecreatescalarcoldesc or</span>
<span class="sd">        tablecreatearraycoldesc.</span>
<span class="sd">        When multiple columns are used, they have to be combined in a single</span>
<span class="sd">        record using</span>
<span class="sd">        tablecreatedesc.</span>
<span class="sd">        It is possible to specify data manager info in order to define a</span>
<span class="sd">        data manager (storage manager or virtual column engine) for the</span>
<span class="sd">        columns to be added.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">addcols</span><span class="p">(</span><span class="n">desc</span><span class="p">,</span> <span class="n">dminfo</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">renamecol</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">oldname</span><span class="p">,</span> <span class="n">newname</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A column can be renamed in a table that was opened nomodify=False.</span>
<span class="sd">        However, renaming is not possible in a (reference) table resulting</span>
<span class="sd">        from a select or sort operation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">renamecol</span><span class="p">(</span><span class="n">oldname</span><span class="p">,</span> <span class="n">newname</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">removecols</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">columnames</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Columns can be removed from a table that was opened nomodify=False.</span>
<span class="sd">        It may not always be possible to remove a column, because some data</span>
<span class="sd">        managers do not support column removal. However, if all columns of</span>
<span class="sd">        a data manager are removed, it will always succeed. It results in the</span>
<span class="sd">        removal of the entire data manager (and its possible files).</span>
<span class="sd">        Note that function getdminfo</span>
<span class="sd">        can be used to find which columns are served by which data manager.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">removecols</span><span class="p">(</span><span class="n">columnames</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">iscelldefined</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">columnname</span><span class="p">,</span> <span class="n">rownr</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">0</span><span class="p">)):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A column containing variable shaped arrays can have an empty cell</span>
<span class="sd">        (if no array has been put into it). This function tests if a cell</span>
<span class="sd">        is defined (thus is not empty).</span>
<span class="sd">        Note that a scalar column and a fixed shape array column cannot have</span>
<span class="sd">        empty cells.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">iscelldefined</span><span class="p">(</span><span class="n">columnname</span><span class="p">,</span> <span class="n">rownr</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">getcell</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">columnname</span><span class="p">,</span> <span class="n">rownr</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">0</span><span class="p">)):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A cell is the value at one row in one column. It may be a scalar</span>
<span class="sd">        or an array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">getcell</span><span class="p">(</span><span class="n">columnname</span><span class="p">,</span> <span class="n">rownr</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">getcellslice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">columnname</span><span class="p">,</span> <span class="n">rownr</span><span class="p">,</span> <span class="n">blc</span><span class="p">,</span> <span class="n">trc</span><span class="p">,</span> <span class="n">incr</span><span class="o">=</span><span class="p">[</span> <span class="nb">int</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A cell is the value at one row in one column. It must be an array.</span>
<span class="sd">        The slice must be specified as blc, trc with an optional stride.</span>
<span class="sd">        In blc and trc -1 can be used to indicate all values for a dimension</span>
<span class="sd">        (-1 in blc is equivalent to 0, so -1 is especially useful for trc).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">getcellslice</span><span class="p">(</span><span class="n">columnname</span><span class="p">,</span> <span class="n">rownr</span><span class="p">,</span> <span class="n">blc</span><span class="p">,</span> <span class="n">trc</span><span class="p">,</span> <span class="n">incr</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">getcol</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">columnname</span><span class="p">,</span> <span class="n">startrow</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">nrow</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">rowincr</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">1</span><span class="p">)):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The entire column (or part of it) is returned. Warning: it might be big!</span>
<span class="sd">        The functions can only be used if all arrays in the column have the</span>
<span class="sd">        same shape. That is guaranteed for columns containing scalars or fixed</span>
<span class="sd">        shaped arrays. For columns containing variable shaped arrays it only</span>
<span class="sd">        succeeds if all those arrays happen to have the same shape.</span>
<span class="sd">        Note that function texttt{getvarcol} can be used to get a column of</span>
<span class="sd">        arbitrary shaped arrays, which also handles empty cells correctly.</span>
<span class="sd">        Function texttt{isvarcol} tells if a column contains variable shaped arrays.</span>
<span class="sd">        shaped</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">getcol</span><span class="p">(</span><span class="n">columnname</span><span class="p">,</span> <span class="n">startrow</span><span class="p">,</span> <span class="n">nrow</span><span class="p">,</span> <span class="n">rowincr</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">getvarcol</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">columnname</span><span class="p">,</span> <span class="n">startrow</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">nrow</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">rowincr</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">1</span><span class="p">)):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Function texttt{getcol} can only used if values in the column cells to get</span>
<span class="sd">        have the same shape. Function texttt{getvarcol} addresses this limitation by</span>
<span class="sd">        returning the values as a record instead of an array. Each field in</span>
<span class="sd">        the record contains the value for a column cell. If the value is</span>
<span class="sd">        undefined (i.e. the cell does not contain a value), the unset value is</span>
<span class="sd">        put in the record. Each field name is the letter r followed by the</span>
<span class="sd">        row number. The length of the record is the number of rows to get.</span>
<span class="sd">        Note that the function texttt{isvarcol} tells if a column contains</span>
<span class="sd">        variable shaped arrays.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">getvarcol</span><span class="p">(</span><span class="n">columnname</span><span class="p">,</span> <span class="n">startrow</span><span class="p">,</span> <span class="n">nrow</span><span class="p">,</span> <span class="n">rowincr</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">getcolslice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">columnname</span><span class="p">,</span> <span class="n">blc</span><span class="p">,</span> <span class="n">trc</span><span class="p">,</span> <span class="n">incr</span><span class="p">,</span> <span class="n">startrow</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">nrow</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">rowincr</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">1</span><span class="p">)):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A slice from the entire column (or part of it) is returned.</span>
<span class="sd">        Warning: it might be big!</span>
<span class="sd">        In blc and trc -1 can be used to indicate all values for a dimension</span>
<span class="sd">        (-1 in blc is equivalent to 1, so -1 is especially useful for trc).</span>
<span class="sd">        Note that blc and trc should not contain the row number, only the</span>
<span class="sd">        blc and trc of the arrays in the column.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">getcolslice</span><span class="p">(</span><span class="n">columnname</span><span class="p">,</span> <span class="n">blc</span><span class="p">,</span> <span class="n">trc</span><span class="p">,</span> <span class="n">incr</span><span class="p">,</span> <span class="n">startrow</span><span class="p">,</span> <span class="n">nrow</span><span class="p">,</span> <span class="n">rowincr</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">getcoliter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">columnname</span><span class="p">,</span> <span class="n">startrow</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">nrow</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">rowincr</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">torecord</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function returns an iterator that will allow for retrieval of the elements</span>
<span class="sd">        of one or more table columns (or a subset of the columns).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">getcoliter</span><span class="p">(</span><span class="n">columnname</span><span class="p">,</span> <span class="n">startrow</span><span class="p">,</span> <span class="n">nrow</span><span class="p">,</span> <span class="n">rowincr</span><span class="p">,</span> <span class="n">torecord</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">putcell</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">columnname</span><span class="p">,</span> <span class="n">rownr</span><span class="p">,</span> <span class="n">thevalue</span><span class="o">=</span><span class="p">[</span> <span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A cell is the the value at one row in one column. It</span>
<span class="sd">        may be a scalar or an array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">putcell</span><span class="p">(</span><span class="n">columnname</span><span class="p">,</span> <span class="n">rownr</span><span class="p">,</span> <span class="n">thevalue</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">putcellslice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">columnname</span><span class="p">,</span> <span class="n">rownr</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">blc</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">trc</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">incr</span><span class="o">=</span><span class="p">[</span> <span class="nb">int</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A cell is the value at one row in one column. It must be an array.</span>
<span class="sd">        The slice must be specified as blc, trc with an optional stride.</span>
<span class="sd">        In blc and trc -1 can be used to indicate all values for a dimension</span>
<span class="sd">        (-1 in blc is equivalent to 0, so -1 is especially useful for trc).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">putcellslice</span><span class="p">(</span><span class="n">columnname</span><span class="p">,</span> <span class="n">rownr</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">blc</span><span class="p">,</span> <span class="n">trc</span><span class="p">,</span> <span class="n">incr</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">putcol</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">columnname</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">startrow</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">nrow</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">rowincr</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">1</span><span class="p">)):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">putcol</span><span class="p">(</span><span class="n">columnname</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">startrow</span><span class="p">,</span> <span class="n">nrow</span><span class="p">,</span> <span class="n">rowincr</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">putvarcol</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">columnname</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">startrow</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">nrow</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">rowincr</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">1</span><span class="p">)):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;texttt{putcol} can only used if values in the column cells to put</span>
<span class="sd">        have the same shape. texttt{putvarcol} addresses this limitation by</span>
<span class="sd">        passing the values as a record instead of an array. Each field in</span>
<span class="sd">        the record contains the value for a column cell. So the length of the</span>
<span class="sd">        record has to match the number of rows to put. If a value is the unset</span>
<span class="sd">        value, no put is done for that row.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">putvarcol</span><span class="p">(</span><span class="n">columnname</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">startrow</span><span class="p">,</span> <span class="n">nrow</span><span class="p">,</span> <span class="n">rowincr</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">putcolslice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">columnname</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">blc</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">trc</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">incr</span><span class="o">=</span><span class="p">[</span> <span class="nb">int</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">],</span> <span class="n">startrow</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">nrow</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">rowincr</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">1</span><span class="p">)):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;In blc and trc, -1 can be used to indicate all values for a dimension</span>
<span class="sd">        (-1 in blc is equivalent to 0, so -1 is especially useful for trc).</span>
<span class="sd">        Note that blc and trc should not contain the row number, only the</span>
<span class="sd">        blc and trc of the arrays in the column.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">putcolslice</span><span class="p">(</span><span class="n">columnname</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">blc</span><span class="p">,</span> <span class="n">trc</span><span class="p">,</span> <span class="n">incr</span><span class="p">,</span> <span class="n">startrow</span><span class="p">,</span> <span class="n">nrow</span><span class="p">,</span> <span class="n">rowincr</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">getcolshapestring</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">columnname</span><span class="p">,</span> <span class="n">startrow</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">nrow</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">rowincr</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">1</span><span class="p">)):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The shapes of the arrays in the entire column (or part of it) are</span>
<span class="sd">        returned as strings like [20,3]. When the column contains fixed shaped</span>
<span class="sd">        arrays, a single string is returned. Otherwise a vector of strings is</span>
<span class="sd">        returned.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">getcolshapestring</span><span class="p">(</span><span class="n">columnname</span><span class="p">,</span> <span class="n">startrow</span><span class="p">,</span> <span class="n">nrow</span><span class="p">,</span> <span class="n">rowincr</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">getkeyword</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keyword</span><span class="o">=</span><span class="p">[</span> <span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The value of the given table keyword is returned. The value can be of any</span>
<span class="sd">        type, including a record and a table.</span>
<span class="sd">        If a keyword is a table, its value is returned as a string containing</span>
<span class="sd">        the table name prefixed by &#39;Table: &#39;.</span>
<span class="sd">        It is possible that the value of a keyword is a record itself</span>
<span class="sd">        (arbitrarily deeply nested). A field in such a subrecord can be</span>
<span class="sd">        read by separating the name with dots.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">getkeyword</span><span class="p">(</span><span class="n">keyword</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">getkeywords</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The values of all table keywords are returned. The values can be of any</span>
<span class="sd">        type, including a record and a table.</span>
<span class="sd">        If a keyword is a table, its value is returned as a string containing</span>
<span class="sd">        the table name prefixed by &#39;Table: &#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">getkeywords</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">getcolkeyword</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">columnname</span><span class="p">,</span> <span class="n">keyword</span><span class="o">=</span><span class="p">[</span> <span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The value of the given column keyword is returned. The value can be of any</span>
<span class="sd">        type, including a record and a table.</span>
<span class="sd">        If a keyword is a table, its value is returned as a string containing</span>
<span class="sd">        the table name prefixed by &#39;Table: &#39;.</span>
<span class="sd">        It is possible that the value of a keyword is a record itself</span>
<span class="sd">        (arbitrarily deeply nested). A field in such a subrecord can be</span>
<span class="sd">        read by separating the name with dots.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">getcolkeyword</span><span class="p">(</span><span class="n">columnname</span><span class="p">,</span> <span class="n">keyword</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">getcolkeywords</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">columnname</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The values of all keywords for the given column are returned.</span>
<span class="sd">        The values can be of any type, including a record and a table.</span>
<span class="sd">        If a keyword is a table, its value is returned as a string containing</span>
<span class="sd">        the table name prefixed by &#39;Table: &#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">getcolkeywords</span><span class="p">(</span><span class="n">columnname</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">putkeyword</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keyword</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">value</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">makesubrecord</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Put a table keyword. The value of the keyword can be a scalar or</span>
<span class="sd">        an array of any type or it can be a record.</span>
<span class="sd">        It is possible to define a keyword holding a subtable. In that</span>
<span class="sd">        case a special string containing the name of the subtable will be</span>
<span class="sd">        passed to the table client.</span>
<span class="sd">        It is possible that the value of a keyword is a record itself</span>
<span class="sd">        (arbitrarily deeply nested). A field in such a subrecord can be</span>
<span class="sd">        written by separating the name with dots. If a subrecord does not</span>
<span class="sd">        exist, an error is returned unless texttt{makesubrecord=True} is given.</span>
<span class="sd">        In such a case intermediate records are created when needed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">putkeyword</span><span class="p">(</span><span class="n">keyword</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">makesubrecord</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">putkeywords</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Put multiple table keywords. All fields in the given record are put</span>
<span class="sd">        as table keywords. The value of each field can be a scalar or</span>
<span class="sd">        an array of any type or it can be a record.</span>
<span class="sd">        It is also possible to define a keyword holding a subtable.</span>
<span class="sd">        This can be done by giving the keyword a string value consisting of</span>
<span class="sd">        the subtable name prefixed by &#39;Table: &#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">putkeywords</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">putcolkeyword</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">columnname</span><span class="p">,</span> <span class="n">keyword</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">value</span><span class="o">=</span><span class="p">[</span> <span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Put a keyword in the given column.</span>
<span class="sd">        The value of the keyword can be a scalar or</span>
<span class="sd">        an array of any type or it can be a record.</span>
<span class="sd">        It is possible to define a keyword holding a subtable. In that</span>
<span class="sd">        case a special string containing the name of the subtable will be</span>
<span class="sd">        passed to the table client.</span>
<span class="sd">        It is possible that the value of a keyword is a record itself</span>
<span class="sd">        (arbitrarily deeply nested). A field in such a subrecord can be</span>
<span class="sd">        written by separating the name with dots. If a subrecord does not</span>
<span class="sd">        exist, an error is returned unless texttt{makesubrecord=True} is given.</span>
<span class="sd">        In such a case intermediate records are created when needed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">putcolkeyword</span><span class="p">(</span><span class="n">columnname</span><span class="p">,</span> <span class="n">keyword</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">putcolkeywords</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">columnname</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Put multiple keywords in the given column.</span>
<span class="sd">        All fields in the given record are put</span>
<span class="sd">        as column keywords. The value of each field can be a scalar or</span>
<span class="sd">        an array of any type or it can be a record.</span>
<span class="sd">        It is also possible to define a keyword holding a subtable.</span>
<span class="sd">        This can be done by giving the keyword a string value consisting of</span>
<span class="sd">        the subtable name prefixed by &#39;Table: &#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">putcolkeywords</span><span class="p">(</span><span class="n">columnname</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">removekeyword</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keyword</span><span class="o">=</span><span class="p">[</span> <span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">removekeyword</span><span class="p">(</span><span class="n">keyword</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">removecolkeyword</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">columnname</span><span class="p">,</span> <span class="n">keyword</span><span class="o">=</span><span class="p">[</span> <span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">removecolkeyword</span><span class="p">(</span><span class="n">columnname</span><span class="p">,</span> <span class="n">keyword</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">getdminfo</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function returns the types and names of the data managers used.</span>
<span class="sd">        For each data manager it also returns the names of the columns served by it.</span>
<span class="sd">        The information is returned as a record containing a subrecord for</span>
<span class="sd">        each data manager. Each subrecord contains the fields TYPE, NAME and</span>
<span class="sd">        COLUMNS.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">getdminfo</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">keywordnames</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function returns a vector of strings containing the names</span>
<span class="sd">        of all table keywords.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">keywordnames</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">fieldnames</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keyword</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function returns a vector of strings containing the names</span>
<span class="sd">        of all fields in the given table keyword.</span>
<span class="sd">        It is only valid if the keyword value is a record.</span>
<span class="sd">        If no keyword name is given, the names of all table keywords are returned.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">fieldnames</span><span class="p">(</span><span class="n">keyword</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">colkeywordnames</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">columnname</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function returns a vector of strings containing the names</span>
<span class="sd">        of all keywords in the column with the given name..</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">colkeywordnames</span><span class="p">(</span><span class="n">columnname</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">colfieldnames</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">columnname</span><span class="p">,</span> <span class="n">keyword</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function returns a vector of strings containing the names</span>
<span class="sd">        of all fields in the given keyword in the given column.</span>
<span class="sd">        It is only valid if the keyword value is a record.</span>
<span class="sd">        If no keyword name is given, the names of all keywords in the column</span>
<span class="sd">        are returned.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">colfieldnames</span><span class="p">(</span><span class="n">columnname</span><span class="p">,</span> <span class="n">keyword</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">getdesc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">actual</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The table description is a casapy record that contains a complete</span>
<span class="sd">        description of the layout</span>
<span class="sd">        of the table (except for the number of rows).</span>
<span class="sd">        </span>
<span class="sd">        By default the actual table description is returned (thus telling the</span>
<span class="sd">        actual shapes and data managers used). It is also possible to get</span>
<span class="sd">        the table description used when creating the table.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">getdesc</span><span class="p">(</span><span class="n">actual</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">getcoldesc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">columnname</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The column description is a casapy record that contains a complete</span>
<span class="sd">        description of the layout</span>
<span class="sd">        of a specified column (except for the number of rows). It can be used</span>
<span class="sd">        to construct a table description.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">getcoldesc</span><span class="p">(</span><span class="n">columnname</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ok</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Perform a number of sanity checks and return T if ok.</span>
<span class="sd">        Failure (returning F) is a sign of a bug.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">ok</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">clearlocks</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Occasionally a table will be inretrievably locked to another process no matter how much closing is done.</span>
<span class="sd">        So clearLocks will unlock all the files in the table cache that use AutoLocking.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">clearlocks</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">listlocks</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Occasionally a table will be inretrievably locked to another process no matter how much closing is done.</span>
<span class="sd">        So listLocks will list the offending tables (and unoffending ones, too), so we can figure out where the problem might be.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">listlocks</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">statistics</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">column</span><span class="p">,</span> <span class="n">complex_value</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function computes descriptive statistics on the table column.</span>
<span class="sd">        It returns the statistical values as a dictionary.  The given</span>
<span class="sd">        column name must be a numerical column.</span>
<span class="sd">        If it is a complex valued column, the parameter complex_value defines</span>
<span class="sd">        which derived real value is used for the statistics computation.</span>
<span class="sd">        This method does not honor any flags in the input table.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">statistics</span><span class="p">(</span><span class="n">column</span><span class="p">,</span> <span class="n">complex_value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">showcache</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Show the contents of the table cache.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">showcache</span><span class="p">(</span><span class="n">verbose</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">testincrstman</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">column</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Checks consistency of an Incremental Store Manager bucket layout</span>
<span class="sd">        </span>
<span class="sd">        In case of corruption it returns False and a SEVERE msg is posted containing information about the location of the corrupted bucket</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">testincrstman</span><span class="p">(</span><span class="n">column</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">row</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">columnnames</span><span class="o">=</span><span class="p">[</span>  <span class="p">],</span> <span class="n">exclude</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a table accessor object which allows for accessing one or more rows from the table. A single</span>
<span class="sd">        row is returned as a dictionary and multiple rows are returned as a list of dictionaries. The contents</span>
<span class="sd">        of the dictionary by default includes all table columns, but it can be limited by using ``columnnames``</span>
<span class="sd">        parameter. The ``exclude`` parameter, which is ``False`` by default, indicates whether ``columnnames``</span>
<span class="sd">        lists the columns to *exclude* (``exclude=True``) or the columns to include (``exclude=False``).</span>
<span class="sd">        </span>
<span class="sd">        The returned table accessor object can also be used to store changes to a single row using the ``put``</span>
<span class="sd">        method. This accessor object remains connected to the table object that created it. Closing or deleting</span>
<span class="sd">        a table object invalidates any accessor objects that it created.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_wrap_tablerow</span><span class="p">(</span><span class="n">swig_object</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">row</span><span class="p">(</span><span class="n">columnnames</span><span class="p">,</span> <span class="n">exclude</span><span class="p">))</span>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020–2024, Pipeline Dev. Team.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>