

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>scipy.special._orthogonal &mdash; Pipeline 
 (2024.2.0.4)  documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css?v=4ae1632d" />
      <link rel="stylesheet" type="text/css" href="../../../_static/sphinx_astrorefs.css?v=4d4a2fdb" />
      <link rel="stylesheet" type="text/css" href="../../../_static/copybutton.css?v=76b2166b" />
      <link rel="stylesheet" type="text/css" href="../../../_static/custom_theme.css?v=30144f19" />

  
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=9eb32ce0"></script>
      <script src="../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="../../../_static/clipboard.min.js?v=a7894cd8"></script>
      <script src="../../../_static/copybutton.js?v=0729d509"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: gray" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            Pipeline 
 (2024.2.0.4)
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Basics</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../develdocmd/ways_to_run_the_pipeline.html">Ways to run the Pipeline</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../develdocmd/recipes.html">Pipeline Recipes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../dependencies.html">Dependencies of <code class="docutils literal notranslate"><span class="pre">Pipeline</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../releases.html">Past Releases</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../apisummary.html">Full APIs (autosummary)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../apisummary.html#pipeline-tasks-autosummary">Pipeline Tasks (autosummary)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../apisummary.html#pipeline-domain-context-autosummary">Pipeline domain/context (autosummary)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../apisummary.html#pipeline-domain-infrastructure-modules-automodapi">Pipeline domain/infrastructure modules (automodapi)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../apisummary.html#pipeline-h-tasks-modules-autmodapi"><code class="docutils literal notranslate"><span class="pre">pipeline.h*.tasks</span></code> modules (autmodapi)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../apisummary.html#inheritance-diagrams-for-pipeline-task-inputs-results-classes">Inheritance Diagrams for Pipeline <code class="docutils literal notranslate"><span class="pre">Task</span></code>/<code class="docutils literal notranslate"><span class="pre">Inputs</span></code>/<code class="docutils literal notranslate"><span class="pre">Results</span></code> Classes</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Developer Notes</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../develdocmd/ALMA-Imaging-Workflow.html">ALMA interferometry imaging workflow</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../develdocmd/VLA-Imaging-Workflow.html">VLA interferometry imaging workflow</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../develdocmd/VLASS-SE-CONT-Imaging-Workflow.html">VLASS-SE-CONT imaging workflow</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../develdocmd/VLASS-SE-CUBE-Imaging-Workflow.html">VLASS-SE-CUBE imaging workflow</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../develdocmd/selfcal_workflow.html">VLASS Selfcal &amp; Restore workflows</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../develdocmd/comparing_pipeline_executions.html">Comparing pipeline executions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../develdocmd/building_the_pipeline.html">Building the pipeline</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../modular.html">Run the Pipeline in a Conda environment</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../develdocmd/pipeline_tests.html">Pipeline testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../develdocmd/DataType_Testing.html">DataType Testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../develdocmd/QA_scores.html">Pipeline Quality Assurance (QA) Score Class Design</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../develdocmd/DeveloperDocumentation.html">Pipeline developer documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../develdocmd/python3_conversion_notes.html">Python 3 conversion notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../heuristics/field_parameter.html">Field parameter</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../heuristics/FlaggingTasks.html">Pipeline Flagging Tasks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notebooks/context.html">Pipeline Context</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notebooks/tier0dask.html">“Tier0” Parallelization with Dask/Futures</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: gray" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">Pipeline 
 (2024.2.0.4)</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">scipy.special._orthogonal</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for scipy.special._orthogonal</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">A collection of functions to find the weights and abscissas for</span>
<span class="sd">Gaussian Quadrature.</span>

<span class="sd">These calculations are done by finding the eigenvalues of a</span>
<span class="sd">tridiagonal matrix whose entries are dependent on the coefficients</span>
<span class="sd">in the recursion formula for the orthogonal polynomials with the</span>
<span class="sd">corresponding weighting function over the interval.</span>

<span class="sd">Many recursion relations for orthogonal polynomials are given:</span>

<span class="sd">.. math::</span>

<span class="sd">    a1n f_{n+1} (x) = (a2n + a3n x ) f_n (x) - a4n f_{n-1} (x)</span>

<span class="sd">The recursion relation of interest is</span>

<span class="sd">.. math::</span>

<span class="sd">    P_{n+1} (x) = (x - A_n) P_n (x) - B_n P_{n-1} (x)</span>

<span class="sd">where :math:`P` has a different normalization than :math:`f`.</span>

<span class="sd">The coefficients can be found as:</span>

<span class="sd">.. math::</span>

<span class="sd">    A_n = -a2n / a3n</span>
<span class="sd">    \\qquad</span>
<span class="sd">    B_n = ( a4n / a3n \\sqrt{h_n-1 / h_n})^2</span>

<span class="sd">where</span>

<span class="sd">.. math::</span>

<span class="sd">    h_n = \\int_a^b w(x) f_n(x)^2</span>

<span class="sd">assume:</span>

<span class="sd">.. math::</span>

<span class="sd">    P_0 (x) = 1</span>
<span class="sd">    \\qquad</span>
<span class="sd">    P_{-1} (x) == 0</span>

<span class="sd">For the mathematical background, see [golub.welsch-1969-mathcomp]_ and</span>
<span class="sd">[abramowitz.stegun-1965]_.</span>

<span class="sd">References</span>
<span class="sd">----------</span>
<span class="sd">.. [golub.welsch-1969-mathcomp]</span>
<span class="sd">   Golub, Gene H, and John H Welsch. 1969. Calculation of Gauss</span>
<span class="sd">   Quadrature Rules. *Mathematics of Computation* 23, 221-230+s1--s10.</span>

<span class="sd">.. [abramowitz.stegun-1965]</span>
<span class="sd">   Abramowitz, Milton, and Irene A Stegun. (1965) *Handbook of</span>
<span class="sd">   Mathematical Functions: with Formulas, Graphs, and Mathematical</span>
<span class="sd">   Tables*. Gaithersburg, MD: National Bureau of Standards.</span>
<span class="sd">   http://www.math.sfu.ca/~cbm/aands/</span>

<span class="sd">.. [townsend.trogdon.olver-2014]</span>
<span class="sd">   Townsend, A. and Trogdon, T. and Olver, S. (2014)</span>
<span class="sd">   *Fast computation of Gauss quadrature nodes and</span>
<span class="sd">   weights on the whole real line*. :arXiv:`1410.5286`.</span>

<span class="sd">.. [townsend.trogdon.olver-2015]</span>
<span class="sd">   Townsend, A. and Trogdon, T. and Olver, S. (2015)</span>
<span class="sd">   *Fast computation of Gauss quadrature nodes and</span>
<span class="sd">   weights on the whole real line*.</span>
<span class="sd">   IMA Journal of Numerical Analysis</span>
<span class="sd">   :doi:`10.1093/imanum/drv002`.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="c1">#</span>
<span class="c1"># Author:  Travis Oliphant 2000</span>
<span class="c1"># Updated Sep. 2003 (fixed bugs --- tested to be accurate)</span>

<span class="c1"># SciPy imports.</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="p">(</span><span class="n">exp</span><span class="p">,</span> <span class="n">inf</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> <span class="n">sqrt</span><span class="p">,</span> <span class="n">floor</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">cos</span><span class="p">,</span> <span class="n">around</span><span class="p">,</span>
                   <span class="n">hstack</span><span class="p">,</span> <span class="n">arccos</span><span class="p">,</span> <span class="n">arange</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">linalg</span>
<span class="kn">from</span> <span class="nn">scipy.special</span> <span class="kn">import</span> <span class="n">airy</span>

<span class="c1"># Local imports.</span>
<span class="c1"># There is no .pyi file for _specfun</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">_specfun</span>  <span class="c1"># type: ignore</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">_ufuncs</span>
<span class="n">_gam</span> <span class="o">=</span> <span class="n">_ufuncs</span><span class="o">.</span><span class="n">gamma</span>

<span class="n">_polyfuns</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;legendre&#39;</span><span class="p">,</span> <span class="s1">&#39;chebyt&#39;</span><span class="p">,</span> <span class="s1">&#39;chebyu&#39;</span><span class="p">,</span> <span class="s1">&#39;chebyc&#39;</span><span class="p">,</span> <span class="s1">&#39;chebys&#39;</span><span class="p">,</span>
             <span class="s1">&#39;jacobi&#39;</span><span class="p">,</span> <span class="s1">&#39;laguerre&#39;</span><span class="p">,</span> <span class="s1">&#39;genlaguerre&#39;</span><span class="p">,</span> <span class="s1">&#39;hermite&#39;</span><span class="p">,</span>
             <span class="s1">&#39;hermitenorm&#39;</span><span class="p">,</span> <span class="s1">&#39;gegenbauer&#39;</span><span class="p">,</span> <span class="s1">&#39;sh_legendre&#39;</span><span class="p">,</span> <span class="s1">&#39;sh_chebyt&#39;</span><span class="p">,</span>
             <span class="s1">&#39;sh_chebyu&#39;</span><span class="p">,</span> <span class="s1">&#39;sh_jacobi&#39;</span><span class="p">]</span>

<span class="c1"># Correspondence between new and old names of root functions</span>
<span class="n">_rootfuns_map</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;roots_legendre&#39;</span><span class="p">:</span> <span class="s1">&#39;p_roots&#39;</span><span class="p">,</span>
                 <span class="s1">&#39;roots_chebyt&#39;</span><span class="p">:</span> <span class="s1">&#39;t_roots&#39;</span><span class="p">,</span>
                 <span class="s1">&#39;roots_chebyu&#39;</span><span class="p">:</span> <span class="s1">&#39;u_roots&#39;</span><span class="p">,</span>
                 <span class="s1">&#39;roots_chebyc&#39;</span><span class="p">:</span> <span class="s1">&#39;c_roots&#39;</span><span class="p">,</span>
                 <span class="s1">&#39;roots_chebys&#39;</span><span class="p">:</span> <span class="s1">&#39;s_roots&#39;</span><span class="p">,</span>
                 <span class="s1">&#39;roots_jacobi&#39;</span><span class="p">:</span> <span class="s1">&#39;j_roots&#39;</span><span class="p">,</span>
                 <span class="s1">&#39;roots_laguerre&#39;</span><span class="p">:</span> <span class="s1">&#39;l_roots&#39;</span><span class="p">,</span>
                 <span class="s1">&#39;roots_genlaguerre&#39;</span><span class="p">:</span> <span class="s1">&#39;la_roots&#39;</span><span class="p">,</span>
                 <span class="s1">&#39;roots_hermite&#39;</span><span class="p">:</span> <span class="s1">&#39;h_roots&#39;</span><span class="p">,</span>
                 <span class="s1">&#39;roots_hermitenorm&#39;</span><span class="p">:</span> <span class="s1">&#39;he_roots&#39;</span><span class="p">,</span>
                 <span class="s1">&#39;roots_gegenbauer&#39;</span><span class="p">:</span> <span class="s1">&#39;cg_roots&#39;</span><span class="p">,</span>
                 <span class="s1">&#39;roots_sh_legendre&#39;</span><span class="p">:</span> <span class="s1">&#39;ps_roots&#39;</span><span class="p">,</span>
                 <span class="s1">&#39;roots_sh_chebyt&#39;</span><span class="p">:</span> <span class="s1">&#39;ts_roots&#39;</span><span class="p">,</span>
                 <span class="s1">&#39;roots_sh_chebyu&#39;</span><span class="p">:</span> <span class="s1">&#39;us_roots&#39;</span><span class="p">,</span>
                 <span class="s1">&#39;roots_sh_jacobi&#39;</span><span class="p">:</span> <span class="s1">&#39;js_roots&#39;</span><span class="p">}</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="n">_polyfuns</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">_rootfuns_map</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>


<span class="k">class</span> <span class="nc">orthopoly1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">poly1d</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">roots</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">hn</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">kn</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">wfunc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">limits</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">monic</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">eval_func</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">equiv_weights</span> <span class="o">=</span> <span class="p">[</span><span class="n">weights</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">/</span> <span class="n">wfunc</span><span class="p">(</span><span class="n">roots</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="k">for</span>
                         <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">roots</span><span class="p">))]</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">hn</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">monic</span><span class="p">:</span>
            <span class="n">evf</span> <span class="o">=</span> <span class="n">eval_func</span>
            <span class="k">if</span> <span class="n">evf</span><span class="p">:</span>
                <span class="n">knn</span> <span class="o">=</span> <span class="n">kn</span>
                <span class="k">def</span> <span class="nf">eval_func</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">evf</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">/</span> <span class="n">knn</span>
            <span class="n">mu</span> <span class="o">=</span> <span class="n">mu</span> <span class="o">/</span> <span class="nb">abs</span><span class="p">(</span><span class="n">kn</span><span class="p">)</span>
            <span class="n">kn</span> <span class="o">=</span> <span class="mf">1.0</span>

        <span class="c1"># compute coefficients from roots, then scale</span>
        <span class="n">poly</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">poly1d</span><span class="p">(</span><span class="n">roots</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">np</span><span class="o">.</span><span class="n">poly1d</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">poly</span><span class="o">.</span><span class="n">coeffs</span> <span class="o">*</span> <span class="nb">float</span><span class="p">(</span><span class="n">kn</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">roots</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">equiv_weights</span><span class="p">)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weight_func</span> <span class="o">=</span> <span class="n">wfunc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">limits</span> <span class="o">=</span> <span class="n">limits</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">normcoef</span> <span class="o">=</span> <span class="n">mu</span>

        <span class="c1"># Note: eval_func will be discarded on arithmetic</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_eval_func</span> <span class="o">=</span> <span class="n">eval_func</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_func</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">poly1d</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_func</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">poly1d</span><span class="o">.</span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_scale</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">p</span> <span class="o">==</span> <span class="mf">1.0</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_coeffs</span> <span class="o">*=</span> <span class="n">p</span>

        <span class="n">evf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_func</span>
        <span class="k">if</span> <span class="n">evf</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_eval_func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">evf</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="n">p</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">normcoef</span> <span class="o">*=</span> <span class="n">p</span>


<span class="k">def</span> <span class="nf">_gen_roots_and_weights</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">mu0</span><span class="p">,</span> <span class="n">an_func</span><span class="p">,</span> <span class="n">bn_func</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">symmetrize</span><span class="p">,</span> <span class="n">mu</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;[x,w] = gen_roots_and_weights(n,an_func,sqrt_bn_func,mu)</span>

<span class="sd">    Returns the roots (x) of an nth order orthogonal polynomial,</span>
<span class="sd">    and weights (w) to use in appropriate Gaussian quadrature with that</span>
<span class="sd">    orthogonal polynomial.</span>

<span class="sd">    The polynomials have the recurrence relation</span>
<span class="sd">          P_n+1(x) = (x - A_n) P_n(x) - B_n P_n-1(x)</span>

<span class="sd">    an_func(n)          should return A_n</span>
<span class="sd">    sqrt_bn_func(n)     should return sqrt(B_n)</span>
<span class="sd">    mu ( = h_0 )        is the integral of the weight over the orthogonal</span>
<span class="sd">                        interval</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;d&#39;</span><span class="p">)</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
    <span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">bn_func</span><span class="p">(</span><span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
    <span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">an_func</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">eigvals_banded</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">overwrite_a_band</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># improve roots by one application of Newton&#39;s method</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="n">dy</span> <span class="o">=</span> <span class="n">df</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">-=</span> <span class="n">y</span><span class="o">/</span><span class="n">dy</span>

    <span class="c1"># fm and dy may contain very large/small values, so we</span>
    <span class="c1"># log-normalize them to maintain precision in the product fm*dy</span>
    <span class="n">fm</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="n">log_fm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">fm</span><span class="p">))</span>
    <span class="n">log_dy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">dy</span><span class="p">))</span>
    <span class="n">fm</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">((</span><span class="n">log_fm</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">+</span> <span class="n">log_fm</span><span class="o">.</span><span class="n">min</span><span class="p">())</span> <span class="o">/</span> <span class="mf">2.</span><span class="p">)</span>
    <span class="n">dy</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">((</span><span class="n">log_dy</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">+</span> <span class="n">log_dy</span><span class="o">.</span><span class="n">min</span><span class="p">())</span> <span class="o">/</span> <span class="mf">2.</span><span class="p">)</span>
    <span class="n">w</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">fm</span> <span class="o">*</span> <span class="n">dy</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">symmetrize</span><span class="p">:</span>
        <span class="n">w</span> <span class="o">=</span> <span class="p">(</span><span class="n">w</span> <span class="o">+</span> <span class="n">w</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">x</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span>

    <span class="n">w</span> <span class="o">*=</span> <span class="n">mu0</span> <span class="o">/</span> <span class="n">w</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">mu</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">mu0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">w</span>

<span class="c1"># Jacobi Polynomials 1               P^(alpha,beta)_n(x)</span>


<span class="k">def</span> <span class="nf">roots_jacobi</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Gauss-Jacobi quadrature.</span>

<span class="sd">    Compute the sample points and weights for Gauss-Jacobi</span>
<span class="sd">    quadrature. The sample points are the roots of the nth degree</span>
<span class="sd">    Jacobi polynomial, :math:`P^{\alpha, \beta}_n(x)`. These sample</span>
<span class="sd">    points and weights correctly integrate polynomials of degree</span>
<span class="sd">    :math:`2n - 1` or less over the interval :math:`[-1, 1]` with</span>
<span class="sd">    weight function :math:`w(x) = (1 - x)^{\alpha} (1 +</span>
<span class="sd">    x)^{\beta}`. See 22.2.1 in [AS]_ for details.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : int</span>
<span class="sd">        quadrature order</span>
<span class="sd">    alpha : float</span>
<span class="sd">        alpha must be &gt; -1</span>
<span class="sd">    beta : float</span>
<span class="sd">        beta must be &gt; -1</span>
<span class="sd">    mu : bool, optional</span>
<span class="sd">        If True, return the sum of the weights, optional.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    x : ndarray</span>
<span class="sd">        Sample points</span>
<span class="sd">    w : ndarray</span>
<span class="sd">        Weights</span>
<span class="sd">    mu : float</span>
<span class="sd">        Sum of the weights</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    scipy.integrate.quadrature</span>
<span class="sd">    scipy.integrate.fixed_quad</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [AS] Milton Abramowitz and Irene A. Stegun, eds.</span>
<span class="sd">        Handbook of Mathematical Functions with Formulas,</span>
<span class="sd">        Graphs, and Mathematical Tables. New York: Dover, 1972.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">m</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">n</span> <span class="o">!=</span> <span class="n">m</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;n must be a positive integer.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">alpha</span> <span class="o">&lt;=</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">beta</span> <span class="o">&lt;=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;alpha and beta must be greater than -1.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">alpha</span> <span class="o">==</span> <span class="mf">0.0</span> <span class="ow">and</span> <span class="n">beta</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">roots_legendre</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">mu</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">alpha</span> <span class="o">==</span> <span class="n">beta</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">roots_gegenbauer</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">alpha</span><span class="o">+</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">mu</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">alpha</span> <span class="o">+</span> <span class="n">beta</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1000</span><span class="p">:</span>
        <span class="n">mu0</span> <span class="o">=</span> <span class="mf">2.0</span><span class="o">**</span><span class="p">(</span><span class="n">alpha</span><span class="o">+</span><span class="n">beta</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">_ufuncs</span><span class="o">.</span><span class="n">beta</span><span class="p">(</span><span class="n">alpha</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">beta</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Avoid overflows in pow and beta for very large parameters</span>
        <span class="n">mu0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">((</span><span class="n">alpha</span> <span class="o">+</span> <span class="n">beta</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">2.0</span><span class="p">)</span>
                     <span class="o">+</span> <span class="n">_ufuncs</span><span class="o">.</span><span class="n">betaln</span><span class="p">(</span><span class="n">alpha</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">beta</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">alpha</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">beta</span>
    <span class="k">if</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">an_func</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">+</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">an_func</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                <span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span>
                <span class="p">(</span><span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">+</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">),</span>
                <span class="p">(</span><span class="n">b</span> <span class="o">*</span> <span class="n">b</span> <span class="o">-</span> <span class="n">a</span> <span class="o">*</span> <span class="n">a</span><span class="p">)</span> <span class="o">/</span> <span class="p">((</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">k</span> <span class="o">+</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">k</span> <span class="o">+</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">+</span> <span class="mi">2</span><span class="p">))</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">bn_func</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="mf">2.0</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">k</span> <span class="o">+</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span>
            <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">k</span> <span class="o">+</span> <span class="n">a</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">k</span> <span class="o">+</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
            <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">k</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">k</span> <span class="o">*</span> <span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">k</span> <span class="o">+</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)))</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_ufuncs</span><span class="o">.</span><span class="n">eval_jacobi</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">df</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">_ufuncs</span><span class="o">.</span><span class="n">eval_jacobi</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_gen_roots_and_weights</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">mu0</span><span class="p">,</span> <span class="n">an_func</span><span class="p">,</span> <span class="n">bn_func</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">mu</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">jacobi</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">monic</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Jacobi polynomial.</span>

<span class="sd">    Defined to be the solution of</span>

<span class="sd">    .. math::</span>
<span class="sd">        (1 - x^2)\frac{d^2}{dx^2}P_n^{(\alpha, \beta)}</span>
<span class="sd">          + (\beta - \alpha - (\alpha + \beta + 2)x)</span>
<span class="sd">            \frac{d}{dx}P_n^{(\alpha, \beta)}</span>
<span class="sd">          + n(n + \alpha + \beta + 1)P_n^{(\alpha, \beta)} = 0</span>

<span class="sd">    for :math:`\alpha, \beta &gt; -1`; :math:`P_n^{(\alpha, \beta)}` is a</span>
<span class="sd">    polynomial of degree :math:`n`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : int</span>
<span class="sd">        Degree of the polynomial.</span>
<span class="sd">    alpha : float</span>
<span class="sd">        Parameter, must be greater than -1.</span>
<span class="sd">    beta : float</span>
<span class="sd">        Parameter, must be greater than -1.</span>
<span class="sd">    monic : bool, optional</span>
<span class="sd">        If `True`, scale the leading coefficient to be 1. Default is</span>
<span class="sd">        `False`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    P : orthopoly1d</span>
<span class="sd">        Jacobi polynomial.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    For fixed :math:`\alpha, \beta`, the polynomials</span>
<span class="sd">    :math:`P_n^{(\alpha, \beta)}` are orthogonal over :math:`[-1, 1]`</span>
<span class="sd">    with weight function :math:`(1 - x)^\alpha(1 + x)^\beta`.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [AS] Milton Abramowitz and Irene A. Stegun, eds.</span>
<span class="sd">        Handbook of Mathematical Functions with Formulas,</span>
<span class="sd">        Graphs, and Mathematical Tables. New York: Dover, 1972.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The Jacobi polynomials satisfy the recurrence relation:</span>

<span class="sd">    .. math::</span>
<span class="sd">        P_n^{(\alpha, \beta-1)}(x) - P_n^{(\alpha-1, \beta)}(x)</span>
<span class="sd">          = P_{n-1}^{(\alpha, \beta)}(x)</span>

<span class="sd">    This can be verified, for example, for :math:`\alpha = \beta = 2`</span>
<span class="sd">    and :math:`n = 1` over the interval :math:`[-1, 1]`:</span>

<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; from scipy.special import jacobi</span>
<span class="sd">    &gt;&gt;&gt; x = np.arange(-1.0, 1.0, 0.01)</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(jacobi(0, 2, 2)(x),</span>
<span class="sd">    ...             jacobi(1, 2, 1)(x) - jacobi(1, 1, 2)(x))</span>
<span class="sd">    True</span>

<span class="sd">    Plot of the Jacobi polynomial :math:`P_5^{(\alpha, -0.5)}` for</span>
<span class="sd">    different values of :math:`\alpha`:</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; x = np.arange(-1.0, 1.0, 0.01)</span>
<span class="sd">    &gt;&gt;&gt; fig, ax = plt.subplots()</span>
<span class="sd">    &gt;&gt;&gt; ax.set_ylim(-2.0, 2.0)</span>
<span class="sd">    &gt;&gt;&gt; ax.set_title(r&#39;Jacobi polynomials $P_5^{(\alpha, -0.5)}$&#39;)</span>
<span class="sd">    &gt;&gt;&gt; for alpha in np.arange(0, 4, 1):</span>
<span class="sd">    ...     ax.plot(x, jacobi(5, alpha, -0.5)(x), label=rf&#39;$\alpha={alpha}$&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.legend(loc=&#39;best&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;n must be nonnegative.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">wfunc</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">x</span><span class="p">)</span> <span class="o">**</span> <span class="n">alpha</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span><span class="p">)</span> <span class="o">**</span> <span class="n">beta</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">orthopoly1d</span><span class="p">([],</span> <span class="p">[],</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">wfunc</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">monic</span><span class="p">,</span>
                           <span class="n">eval_func</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">)</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">mu</span> <span class="o">=</span> <span class="n">roots_jacobi</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">ab1</span> <span class="o">=</span> <span class="n">alpha</span> <span class="o">+</span> <span class="n">beta</span> <span class="o">+</span> <span class="mf">1.0</span>
    <span class="n">hn</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="n">ab1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">n</span> <span class="o">+</span> <span class="n">ab1</span><span class="p">)</span> <span class="o">*</span> <span class="n">_gam</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="n">alpha</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">hn</span> <span class="o">*=</span> <span class="n">_gam</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="n">beta</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">/</span> <span class="n">_gam</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">_gam</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="n">ab1</span><span class="p">)</span>
    <span class="n">kn</span> <span class="o">=</span> <span class="n">_gam</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">n</span> <span class="o">+</span> <span class="n">ab1</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span><span class="o">**</span><span class="n">n</span> <span class="o">/</span> <span class="n">_gam</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">_gam</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="n">ab1</span><span class="p">)</span>
    <span class="c1"># here kn = coefficient on x^n term</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">orthopoly1d</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">hn</span><span class="p">,</span> <span class="n">kn</span><span class="p">,</span> <span class="n">wfunc</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">monic</span><span class="p">,</span>
                    <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">_ufuncs</span><span class="o">.</span><span class="n">eval_jacobi</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">p</span>

<span class="c1"># Jacobi Polynomials shifted         G_n(p,q,x)</span>


<span class="k">def</span> <span class="nf">roots_sh_jacobi</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">q1</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Gauss-Jacobi (shifted) quadrature.</span>

<span class="sd">    Compute the sample points and weights for Gauss-Jacobi (shifted)</span>
<span class="sd">    quadrature. The sample points are the roots of the nth degree</span>
<span class="sd">    shifted Jacobi polynomial, :math:`G^{p,q}_n(x)`. These sample</span>
<span class="sd">    points and weights correctly integrate polynomials of degree</span>
<span class="sd">    :math:`2n - 1` or less over the interval :math:`[0, 1]` with</span>
<span class="sd">    weight function :math:`w(x) = (1 - x)^{p-q} x^{q-1}`. See 22.2.2</span>
<span class="sd">    in [AS]_ for details.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : int</span>
<span class="sd">        quadrature order</span>
<span class="sd">    p1 : float</span>
<span class="sd">        (p1 - q1) must be &gt; -1</span>
<span class="sd">    q1 : float</span>
<span class="sd">        q1 must be &gt; 0</span>
<span class="sd">    mu : bool, optional</span>
<span class="sd">        If True, return the sum of the weights, optional.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    x : ndarray</span>
<span class="sd">        Sample points</span>
<span class="sd">    w : ndarray</span>
<span class="sd">        Weights</span>
<span class="sd">    mu : float</span>
<span class="sd">        Sum of the weights</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    scipy.integrate.quadrature</span>
<span class="sd">    scipy.integrate.fixed_quad</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [AS] Milton Abramowitz and Irene A. Stegun, eds.</span>
<span class="sd">        Handbook of Mathematical Functions with Formulas,</span>
<span class="sd">        Graphs, and Mathematical Tables. New York: Dover, 1972.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">p1</span><span class="o">-</span><span class="n">q1</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">q1</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;(p - q) must be greater than -1, and q must be greater than 0.&quot;</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="n">roots_jacobi</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">p1</span><span class="o">-</span><span class="n">q1</span><span class="p">,</span> <span class="n">q1</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="n">scale</span> <span class="o">=</span> <span class="mf">2.0</span><span class="o">**</span><span class="n">p1</span>
    <span class="n">w</span> <span class="o">/=</span> <span class="n">scale</span>
    <span class="n">m</span> <span class="o">/=</span> <span class="n">scale</span>
    <span class="k">if</span> <span class="n">mu</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">m</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">w</span>


<span class="k">def</span> <span class="nf">sh_jacobi</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">monic</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Shifted Jacobi polynomial.</span>

<span class="sd">    Defined by</span>

<span class="sd">    .. math::</span>

<span class="sd">        G_n^{(p, q)}(x)</span>
<span class="sd">          = \binom{2n + p - 1}{n}^{-1}P_n^{(p - q, q - 1)}(2x - 1),</span>

<span class="sd">    where :math:`P_n^{(\cdot, \cdot)}` is the nth Jacobi polynomial.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : int</span>
<span class="sd">        Degree of the polynomial.</span>
<span class="sd">    p : float</span>
<span class="sd">        Parameter, must have :math:`p &gt; q - 1`.</span>
<span class="sd">    q : float</span>
<span class="sd">        Parameter, must be greater than 0.</span>
<span class="sd">    monic : bool, optional</span>
<span class="sd">        If `True`, scale the leading coefficient to be 1. Default is</span>
<span class="sd">        `False`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    G : orthopoly1d</span>
<span class="sd">        Shifted Jacobi polynomial.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    For fixed :math:`p, q`, the polynomials :math:`G_n^{(p, q)}` are</span>
<span class="sd">    orthogonal over :math:`[0, 1]` with weight function :math:`(1 -</span>
<span class="sd">    x)^{p - q}x^{q - 1}`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;n must be nonnegative.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">wfunc</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">x</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="n">q</span><span class="p">)</span> <span class="o">*</span> <span class="n">x</span> <span class="o">**</span> <span class="p">(</span><span class="n">q</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">orthopoly1d</span><span class="p">([],</span> <span class="p">[],</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">wfunc</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">monic</span><span class="p">,</span>
                           <span class="n">eval_func</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">)</span>
    <span class="n">n1</span> <span class="o">=</span> <span class="n">n</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">roots_sh_jacobi</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
    <span class="n">hn</span> <span class="o">=</span> <span class="n">_gam</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">_gam</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="n">q</span><span class="p">)</span> <span class="o">*</span> <span class="n">_gam</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="n">p</span><span class="p">)</span> <span class="o">*</span> <span class="n">_gam</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="n">p</span> <span class="o">-</span> <span class="n">q</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">hn</span> <span class="o">/=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">n</span> <span class="o">+</span> <span class="n">p</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">_gam</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">n</span> <span class="o">+</span> <span class="n">p</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="c1"># kn = 1.0 in standard form so monic is redundant. Kept for compatibility.</span>
    <span class="n">kn</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="n">pp</span> <span class="o">=</span> <span class="n">orthopoly1d</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">hn</span><span class="p">,</span> <span class="n">kn</span><span class="p">,</span> <span class="n">wfunc</span><span class="o">=</span><span class="n">wfunc</span><span class="p">,</span> <span class="n">limits</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">monic</span><span class="o">=</span><span class="n">monic</span><span class="p">,</span>
                     <span class="n">eval_func</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">_ufuncs</span><span class="o">.</span><span class="n">eval_sh_jacobi</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">pp</span>

<span class="c1"># Generalized Laguerre               L^(alpha)_n(x)</span>


<span class="k">def</span> <span class="nf">roots_genlaguerre</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Gauss-generalized Laguerre quadrature.</span>

<span class="sd">    Compute the sample points and weights for Gauss-generalized</span>
<span class="sd">    Laguerre quadrature. The sample points are the roots of the nth</span>
<span class="sd">    degree generalized Laguerre polynomial, :math:`L^{\alpha}_n(x)`.</span>
<span class="sd">    These sample points and weights correctly integrate polynomials of</span>
<span class="sd">    degree :math:`2n - 1` or less over the interval :math:`[0,</span>
<span class="sd">    \infty]` with weight function :math:`w(x) = x^{\alpha}</span>
<span class="sd">    e^{-x}`. See 22.3.9 in [AS]_ for details.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : int</span>
<span class="sd">        quadrature order</span>
<span class="sd">    alpha : float</span>
<span class="sd">        alpha must be &gt; -1</span>
<span class="sd">    mu : bool, optional</span>
<span class="sd">        If True, return the sum of the weights, optional.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    x : ndarray</span>
<span class="sd">        Sample points</span>
<span class="sd">    w : ndarray</span>
<span class="sd">        Weights</span>
<span class="sd">    mu : float</span>
<span class="sd">        Sum of the weights</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    scipy.integrate.quadrature</span>
<span class="sd">    scipy.integrate.fixed_quad</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [AS] Milton Abramowitz and Irene A. Stegun, eds.</span>
<span class="sd">        Handbook of Mathematical Functions with Formulas,</span>
<span class="sd">        Graphs, and Mathematical Tables. New York: Dover, 1972.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">m</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">n</span> <span class="o">!=</span> <span class="n">m</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;n must be a positive integer.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">alpha</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;alpha must be greater than -1.&quot;</span><span class="p">)</span>

    <span class="n">mu0</span> <span class="o">=</span> <span class="n">_ufuncs</span><span class="o">.</span><span class="n">gamma</span><span class="p">(</span><span class="n">alpha</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">m</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">alpha</span><span class="o">+</span><span class="mf">1.0</span><span class="p">],</span> <span class="s1">&#39;d&#39;</span><span class="p">)</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">mu0</span><span class="p">],</span> <span class="s1">&#39;d&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mu</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">mu0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">w</span>

    <span class="k">def</span> <span class="nf">an_func</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">k</span> <span class="o">+</span> <span class="n">alpha</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">def</span> <span class="nf">bn_func</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">k</span> <span class="o">*</span> <span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="n">alpha</span><span class="p">))</span>
    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_ufuncs</span><span class="o">.</span><span class="n">eval_genlaguerre</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">df</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="n">_ufuncs</span><span class="o">.</span><span class="n">eval_genlaguerre</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
                <span class="o">-</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="n">alpha</span><span class="p">)</span> <span class="o">*</span> <span class="n">_ufuncs</span><span class="o">.</span><span class="n">eval_genlaguerre</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span> <span class="o">/</span> <span class="n">x</span>
    <span class="k">return</span> <span class="n">_gen_roots_and_weights</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">mu0</span><span class="p">,</span> <span class="n">an_func</span><span class="p">,</span> <span class="n">bn_func</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">mu</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">genlaguerre</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">monic</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Generalized (associated) Laguerre polynomial.</span>

<span class="sd">    Defined to be the solution of</span>

<span class="sd">    .. math::</span>
<span class="sd">        x\frac{d^2}{dx^2}L_n^{(\alpha)}</span>
<span class="sd">          + (\alpha + 1 - x)\frac{d}{dx}L_n^{(\alpha)}</span>
<span class="sd">          + nL_n^{(\alpha)} = 0,</span>

<span class="sd">    where :math:`\alpha &gt; -1`; :math:`L_n^{(\alpha)}` is a polynomial</span>
<span class="sd">    of degree :math:`n`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : int</span>
<span class="sd">        Degree of the polynomial.</span>
<span class="sd">    alpha : float</span>
<span class="sd">        Parameter, must be greater than -1.</span>
<span class="sd">    monic : bool, optional</span>
<span class="sd">        If `True`, scale the leading coefficient to be 1. Default is</span>
<span class="sd">        `False`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    L : orthopoly1d</span>
<span class="sd">        Generalized Laguerre polynomial.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    laguerre : Laguerre polynomial.</span>
<span class="sd">    hyp1f1 : confluent hypergeometric function</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    For fixed :math:`\alpha`, the polynomials :math:`L_n^{(\alpha)}`</span>
<span class="sd">    are orthogonal over :math:`[0, \infty)` with weight function</span>
<span class="sd">    :math:`e^{-x}x^\alpha`.</span>

<span class="sd">    The Laguerre polynomials are the special case where :math:`\alpha</span>
<span class="sd">    = 0`.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [AS] Milton Abramowitz and Irene A. Stegun, eds.</span>
<span class="sd">        Handbook of Mathematical Functions with Formulas,</span>
<span class="sd">        Graphs, and Mathematical Tables. New York: Dover, 1972.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The generalized Laguerre polynomials are closely related to the confluent</span>
<span class="sd">    hypergeometric function :math:`{}_1F_1`:</span>

<span class="sd">        .. math::</span>
<span class="sd">            L_n^{(\alpha)} = \binom{n + \alpha}{n} {}_1F_1(-n, \alpha +1, x)</span>

<span class="sd">    This can be verified, for example,  for :math:`n = \alpha = 3` over the</span>
<span class="sd">    interval :math:`[-1, 1]`:</span>

<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; from scipy.special import binom</span>
<span class="sd">    &gt;&gt;&gt; from scipy.special import genlaguerre</span>
<span class="sd">    &gt;&gt;&gt; from scipy.special import hyp1f1</span>
<span class="sd">    &gt;&gt;&gt; x = np.arange(-1.0, 1.0, 0.01)</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(genlaguerre(3, 3)(x), binom(6, 3) * hyp1f1(-3, 4, x))</span>
<span class="sd">    True</span>

<span class="sd">    This is the plot of the generalized Laguerre polynomials</span>
<span class="sd">    :math:`L_3^{(\alpha)}` for some values of :math:`\alpha`:</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; x = np.arange(-4.0, 12.0, 0.01)</span>
<span class="sd">    &gt;&gt;&gt; fig, ax = plt.subplots()</span>
<span class="sd">    &gt;&gt;&gt; ax.set_ylim(-5.0, 10.0)</span>
<span class="sd">    &gt;&gt;&gt; ax.set_title(r&#39;Generalized Laguerre polynomials $L_3^{\alpha}$&#39;)</span>
<span class="sd">    &gt;&gt;&gt; for alpha in np.arange(0, 5):</span>
<span class="sd">    ...     ax.plot(x, genlaguerre(3, alpha)(x), label=rf&#39;$L_3^{(alpha)}$&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.legend(loc=&#39;best&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">alpha</span> <span class="o">&lt;=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;alpha must be &gt; -1&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;n must be nonnegative.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="n">n</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">roots_genlaguerre</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">alpha</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">wfunc</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="n">x</span> <span class="o">**</span> <span class="n">alpha</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
    <span class="n">hn</span> <span class="o">=</span> <span class="n">_gam</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="n">alpha</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">_gam</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">kn</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="n">n</span> <span class="o">/</span> <span class="n">_gam</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">orthopoly1d</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">hn</span><span class="p">,</span> <span class="n">kn</span><span class="p">,</span> <span class="n">wfunc</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">inf</span><span class="p">),</span> <span class="n">monic</span><span class="p">,</span>
                    <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">_ufuncs</span><span class="o">.</span><span class="n">eval_genlaguerre</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">p</span>

<span class="c1"># Laguerre                      L_n(x)</span>


<span class="k">def</span> <span class="nf">roots_laguerre</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Gauss-Laguerre quadrature.</span>

<span class="sd">    Compute the sample points and weights for Gauss-Laguerre</span>
<span class="sd">    quadrature. The sample points are the roots of the nth degree</span>
<span class="sd">    Laguerre polynomial, :math:`L_n(x)`. These sample points and</span>
<span class="sd">    weights correctly integrate polynomials of degree :math:`2n - 1`</span>
<span class="sd">    or less over the interval :math:`[0, \infty]` with weight function</span>
<span class="sd">    :math:`w(x) = e^{-x}`. See 22.2.13 in [AS]_ for details.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : int</span>
<span class="sd">        quadrature order</span>
<span class="sd">    mu : bool, optional</span>
<span class="sd">        If True, return the sum of the weights, optional.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    x : ndarray</span>
<span class="sd">        Sample points</span>
<span class="sd">    w : ndarray</span>
<span class="sd">        Weights</span>
<span class="sd">    mu : float</span>
<span class="sd">        Sum of the weights</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    scipy.integrate.quadrature</span>
<span class="sd">    scipy.integrate.fixed_quad</span>
<span class="sd">    numpy.polynomial.laguerre.laggauss</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [AS] Milton Abramowitz and Irene A. Stegun, eds.</span>
<span class="sd">        Handbook of Mathematical Functions with Formulas,</span>
<span class="sd">        Graphs, and Mathematical Tables. New York: Dover, 1972.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">roots_genlaguerre</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">mu</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">laguerre</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">monic</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Laguerre polynomial.</span>

<span class="sd">    Defined to be the solution of</span>

<span class="sd">    .. math::</span>
<span class="sd">        x\frac{d^2}{dx^2}L_n + (1 - x)\frac{d}{dx}L_n + nL_n = 0;</span>

<span class="sd">    :math:`L_n` is a polynomial of degree :math:`n`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : int</span>
<span class="sd">        Degree of the polynomial.</span>
<span class="sd">    monic : bool, optional</span>
<span class="sd">        If `True`, scale the leading coefficient to be 1. Default is</span>
<span class="sd">        `False`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    L : orthopoly1d</span>
<span class="sd">        Laguerre Polynomial.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    genlaguerre : Generalized (associated) Laguerre polynomial.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The polynomials :math:`L_n` are orthogonal over :math:`[0,</span>
<span class="sd">    \infty)` with weight function :math:`e^{-x}`.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [AS] Milton Abramowitz and Irene A. Stegun, eds.</span>
<span class="sd">        Handbook of Mathematical Functions with Formulas,</span>
<span class="sd">        Graphs, and Mathematical Tables. New York: Dover, 1972.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The Laguerre polynomials :math:`L_n` are the special case</span>
<span class="sd">    :math:`\alpha = 0` of the generalized Laguerre polynomials</span>
<span class="sd">    :math:`L_n^{(\alpha)}`.</span>
<span class="sd">    Let&#39;s verify it on the interval :math:`[-1, 1]`:</span>

<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; from scipy.special import genlaguerre</span>
<span class="sd">    &gt;&gt;&gt; from scipy.special import laguerre</span>
<span class="sd">    &gt;&gt;&gt; x = np.arange(-1.0, 1.0, 0.01)</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(genlaguerre(3, 0)(x), laguerre(3)(x))</span>
<span class="sd">    True</span>

<span class="sd">    The polynomials :math:`L_n` also satisfy the recurrence relation:</span>

<span class="sd">    .. math::</span>
<span class="sd">        (n + 1)L_{n+1}(x) = (2n +1 -x)L_n(x) - nL_{n-1}(x)</span>

<span class="sd">    This can be easily checked on :math:`[0, 1]` for :math:`n = 3`:</span>

<span class="sd">    &gt;&gt;&gt; x = np.arange(0.0, 1.0, 0.01)</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(4 * laguerre(4)(x),</span>
<span class="sd">    ...             (7 - x) * laguerre(3)(x) - 3 * laguerre(2)(x))</span>
<span class="sd">    True</span>

<span class="sd">    This is the plot of the first few Laguerre polynomials :math:`L_n`:</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; x = np.arange(-1.0, 5.0, 0.01)</span>
<span class="sd">    &gt;&gt;&gt; fig, ax = plt.subplots()</span>
<span class="sd">    &gt;&gt;&gt; ax.set_ylim(-5.0, 5.0)</span>
<span class="sd">    &gt;&gt;&gt; ax.set_title(r&#39;Laguerre polynomials $L_n$&#39;)</span>
<span class="sd">    &gt;&gt;&gt; for n in np.arange(0, 5):</span>
<span class="sd">    ...     ax.plot(x, laguerre(n)(x), label=rf&#39;$L_{n}$&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.legend(loc=&#39;best&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;n must be nonnegative.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="n">n</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">roots_laguerre</span><span class="p">(</span><span class="n">n1</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
    <span class="n">hn</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="n">kn</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="n">n</span> <span class="o">/</span> <span class="n">_gam</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">orthopoly1d</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">hn</span><span class="p">,</span> <span class="n">kn</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">inf</span><span class="p">),</span> <span class="n">monic</span><span class="p">,</span>
                    <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">_ufuncs</span><span class="o">.</span><span class="n">eval_laguerre</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">p</span>

<span class="c1"># Hermite  1                         H_n(x)</span>


<span class="k">def</span> <span class="nf">roots_hermite</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Gauss-Hermite (physicist&#39;s) quadrature.</span>

<span class="sd">    Compute the sample points and weights for Gauss-Hermite</span>
<span class="sd">    quadrature. The sample points are the roots of the nth degree</span>
<span class="sd">    Hermite polynomial, :math:`H_n(x)`. These sample points and</span>
<span class="sd">    weights correctly integrate polynomials of degree :math:`2n - 1`</span>
<span class="sd">    or less over the interval :math:`[-\infty, \infty]` with weight</span>
<span class="sd">    function :math:`w(x) = e^{-x^2}`. See 22.2.14 in [AS]_ for</span>
<span class="sd">    details.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : int</span>
<span class="sd">        quadrature order</span>
<span class="sd">    mu : bool, optional</span>
<span class="sd">        If True, return the sum of the weights, optional.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    x : ndarray</span>
<span class="sd">        Sample points</span>
<span class="sd">    w : ndarray</span>
<span class="sd">        Weights</span>
<span class="sd">    mu : float</span>
<span class="sd">        Sum of the weights</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    scipy.integrate.quadrature</span>
<span class="sd">    scipy.integrate.fixed_quad</span>
<span class="sd">    numpy.polynomial.hermite.hermgauss</span>
<span class="sd">    roots_hermitenorm</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    For small n up to 150 a modified version of the Golub-Welsch</span>
<span class="sd">    algorithm is used. Nodes are computed from the eigenvalue</span>
<span class="sd">    problem and improved by one step of a Newton iteration.</span>
<span class="sd">    The weights are computed from the well-known analytical formula.</span>

<span class="sd">    For n larger than 150 an optimal asymptotic algorithm is applied</span>
<span class="sd">    which computes nodes and weights in a numerically stable manner.</span>
<span class="sd">    The algorithm has linear runtime making computation for very</span>
<span class="sd">    large n (several thousand or more) feasible.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [townsend.trogdon.olver-2014]</span>
<span class="sd">        Townsend, A. and Trogdon, T. and Olver, S. (2014)</span>
<span class="sd">        *Fast computation of Gauss quadrature nodes and</span>
<span class="sd">        weights on the whole real line*. :arXiv:`1410.5286`.</span>
<span class="sd">    .. [townsend.trogdon.olver-2015]</span>
<span class="sd">        Townsend, A. and Trogdon, T. and Olver, S. (2015)</span>
<span class="sd">        *Fast computation of Gauss quadrature nodes and</span>
<span class="sd">        weights on the whole real line*.</span>
<span class="sd">        IMA Journal of Numerical Analysis</span>
<span class="sd">        :doi:`10.1093/imanum/drv002`.</span>
<span class="sd">    .. [AS] Milton Abramowitz and Irene A. Stegun, eds.</span>
<span class="sd">        Handbook of Mathematical Functions with Formulas,</span>
<span class="sd">        Graphs, and Mathematical Tables. New York: Dover, 1972.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">m</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">n</span> <span class="o">!=</span> <span class="n">m</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;n must be a positive integer.&quot;</span><span class="p">)</span>

    <span class="n">mu0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">150</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">an_func</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
            <span class="k">return</span> <span class="mf">0.0</span> <span class="o">*</span> <span class="n">k</span>
        <span class="k">def</span> <span class="nf">bn_func</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">k</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">)</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">_ufuncs</span><span class="o">.</span><span class="n">eval_hermite</span>
        <span class="k">def</span> <span class="nf">df</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
            <span class="k">return</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">n</span> <span class="o">*</span> <span class="n">_ufuncs</span><span class="o">.</span><span class="n">eval_hermite</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_gen_roots_and_weights</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">mu0</span><span class="p">,</span> <span class="n">an_func</span><span class="p">,</span> <span class="n">bn_func</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">mu</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">nodes</span><span class="p">,</span> <span class="n">weights</span> <span class="o">=</span> <span class="n">_roots_hermite_asy</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mu</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">mu0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">weights</span>


<span class="k">def</span> <span class="nf">_compute_tauk</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">maxit</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Helper function for Tricomi initial guesses</span>

<span class="sd">    For details, see formula 3.1 in lemma 3.1 in the</span>
<span class="sd">    original paper.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : int</span>
<span class="sd">        Quadrature order</span>
<span class="sd">    k : ndarray of type int</span>
<span class="sd">        Index of roots :math:`\tau_k` to compute</span>
<span class="sd">    maxit : int</span>
<span class="sd">        Number of Newton maxit performed, the default</span>
<span class="sd">        value of 5 is sufficient.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tauk : ndarray</span>
<span class="sd">        Roots of equation 3.1</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    initial_nodes_a</span>
<span class="sd">    roots_hermite_asy</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">-</span> <span class="mf">0.5</span>
    <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="mf">4.0</span><span class="o">*</span><span class="n">floor</span><span class="p">(</span><span class="n">n</span><span class="o">/</span><span class="mf">2.0</span><span class="p">)</span> <span class="o">-</span> <span class="mf">4.0</span><span class="o">*</span><span class="n">k</span> <span class="o">+</span> <span class="mf">3.0</span><span class="p">)</span><span class="o">*</span><span class="n">pi</span> <span class="o">/</span> <span class="p">(</span><span class="mf">4.0</span><span class="o">*</span><span class="n">floor</span><span class="p">(</span><span class="n">n</span><span class="o">/</span><span class="mf">2.0</span><span class="p">)</span> <span class="o">+</span> <span class="mf">2.0</span><span class="o">*</span><span class="n">a</span> <span class="o">+</span> <span class="mf">2.0</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span> <span class="o">-</span> <span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">c</span>
    <span class="k">def</span> <span class="nf">df</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">xi</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">pi</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">maxit</span><span class="p">):</span>
        <span class="n">xi</span> <span class="o">=</span> <span class="n">xi</span> <span class="o">-</span> <span class="n">f</span><span class="p">(</span><span class="n">xi</span><span class="p">)</span><span class="o">/</span><span class="n">df</span><span class="p">(</span><span class="n">xi</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">xi</span>


<span class="k">def</span> <span class="nf">_initial_nodes_a</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Tricomi initial guesses</span>

<span class="sd">    Computes an initial approximation to the square of the `k`-th</span>
<span class="sd">    (positive) root :math:`x_k` of the Hermite polynomial :math:`H_n`</span>
<span class="sd">    of order :math:`n`. The formula is the one from lemma 3.1 in the</span>
<span class="sd">    original paper. The guesses are accurate except in the region</span>
<span class="sd">    near :math:`\sqrt{2n + 1}`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : int</span>
<span class="sd">        Quadrature order</span>
<span class="sd">    k : ndarray of type int</span>
<span class="sd">        Index of roots to compute</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    xksq : ndarray</span>
<span class="sd">        Square of the approximate roots</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    initial_nodes</span>
<span class="sd">    roots_hermite_asy</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">tauk</span> <span class="o">=</span> <span class="n">_compute_tauk</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
    <span class="n">sigk</span> <span class="o">=</span> <span class="n">cos</span><span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="n">tauk</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">-</span> <span class="mf">0.5</span>
    <span class="n">nu</span> <span class="o">=</span> <span class="mf">4.0</span><span class="o">*</span><span class="n">floor</span><span class="p">(</span><span class="n">n</span><span class="o">/</span><span class="mf">2.0</span><span class="p">)</span> <span class="o">+</span> <span class="mf">2.0</span><span class="o">*</span><span class="n">a</span> <span class="o">+</span> <span class="mf">2.0</span>
    <span class="c1"># Initial approximation of Hermite roots (square)</span>
    <span class="n">xksq</span> <span class="o">=</span> <span class="n">nu</span><span class="o">*</span><span class="n">sigk</span> <span class="o">-</span> <span class="mf">1.0</span><span class="o">/</span><span class="p">(</span><span class="mf">3.0</span><span class="o">*</span><span class="n">nu</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mf">5.0</span><span class="o">/</span><span class="p">(</span><span class="mf">4.0</span><span class="o">*</span><span class="p">(</span><span class="mf">1.0</span><span class="o">-</span><span class="n">sigk</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="mf">1.0</span><span class="o">/</span><span class="p">(</span><span class="mf">1.0</span><span class="o">-</span><span class="n">sigk</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.25</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">xksq</span>


<span class="k">def</span> <span class="nf">_initial_nodes_b</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Gatteschi initial guesses</span>

<span class="sd">    Computes an initial approximation to the square of the kth</span>
<span class="sd">    (positive) root :math:`x_k` of the Hermite polynomial :math:`H_n`</span>
<span class="sd">    of order :math:`n`. The formula is the one from lemma 3.2 in the</span>
<span class="sd">    original paper. The guesses are accurate in the region just</span>
<span class="sd">    below :math:`\sqrt{2n + 1}`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : int</span>
<span class="sd">        Quadrature order</span>
<span class="sd">    k : ndarray of type int</span>
<span class="sd">        Index of roots to compute</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    xksq : ndarray</span>
<span class="sd">        Square of the approximate root</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    initial_nodes</span>
<span class="sd">    roots_hermite_asy</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">-</span> <span class="mf">0.5</span>
    <span class="n">nu</span> <span class="o">=</span> <span class="mf">4.0</span><span class="o">*</span><span class="n">floor</span><span class="p">(</span><span class="n">n</span><span class="o">/</span><span class="mf">2.0</span><span class="p">)</span> <span class="o">+</span> <span class="mf">2.0</span><span class="o">*</span><span class="n">a</span> <span class="o">+</span> <span class="mf">2.0</span>
    <span class="c1"># Airy roots by approximation</span>
    <span class="n">ak</span> <span class="o">=</span> <span class="n">_specfun</span><span class="o">.</span><span class="n">airyzo</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="c1"># Initial approximation of Hermite roots (square)</span>
    <span class="n">xksq</span> <span class="o">=</span> <span class="p">(</span><span class="n">nu</span>
            <span class="o">+</span> <span class="mf">2.0</span><span class="o">**</span><span class="p">(</span><span class="mf">2.0</span><span class="o">/</span><span class="mf">3.0</span><span class="p">)</span> <span class="o">*</span> <span class="n">ak</span> <span class="o">*</span> <span class="n">nu</span><span class="o">**</span><span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="mf">3.0</span><span class="p">)</span>
            <span class="o">+</span> <span class="mf">1.0</span><span class="o">/</span><span class="mf">5.0</span> <span class="o">*</span> <span class="mf">2.0</span><span class="o">**</span><span class="p">(</span><span class="mf">4.0</span><span class="o">/</span><span class="mf">3.0</span><span class="p">)</span> <span class="o">*</span> <span class="n">ak</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">nu</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="o">/</span><span class="mf">3.0</span><span class="p">)</span>
            <span class="o">+</span> <span class="p">(</span><span class="mf">9.0</span><span class="o">/</span><span class="mf">140.0</span> <span class="o">-</span> <span class="mf">12.0</span><span class="o">/</span><span class="mf">175.0</span> <span class="o">*</span> <span class="n">ak</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="n">nu</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="p">)</span>
            <span class="o">+</span> <span class="p">(</span><span class="mf">16.0</span><span class="o">/</span><span class="mf">1575.0</span> <span class="o">*</span> <span class="n">ak</span> <span class="o">+</span> <span class="mf">92.0</span><span class="o">/</span><span class="mf">7875.0</span> <span class="o">*</span> <span class="n">ak</span><span class="o">**</span><span class="mi">4</span><span class="p">)</span> <span class="o">*</span> <span class="mf">2.0</span><span class="o">**</span><span class="p">(</span><span class="mf">2.0</span><span class="o">/</span><span class="mf">3.0</span><span class="p">)</span> <span class="o">*</span> <span class="n">nu</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mf">5.0</span><span class="o">/</span><span class="mf">3.0</span><span class="p">)</span>
            <span class="o">-</span> <span class="p">(</span><span class="mf">15152.0</span><span class="o">/</span><span class="mf">3031875.0</span> <span class="o">*</span> <span class="n">ak</span><span class="o">**</span><span class="mi">5</span> <span class="o">+</span> <span class="mf">1088.0</span><span class="o">/</span><span class="mf">121275.0</span> <span class="o">*</span> <span class="n">ak</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
              <span class="o">*</span> <span class="mf">2.0</span><span class="o">**</span><span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="mf">3.0</span><span class="p">)</span> <span class="o">*</span> <span class="n">nu</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mf">7.0</span><span class="o">/</span><span class="mf">3.0</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">xksq</span>


<span class="k">def</span> <span class="nf">_initial_nodes</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Initial guesses for the Hermite roots</span>

<span class="sd">    Computes an initial approximation to the non-negative</span>
<span class="sd">    roots :math:`x_k` of the Hermite polynomial :math:`H_n`</span>
<span class="sd">    of order :math:`n`. The Tricomi and Gatteschi initial</span>
<span class="sd">    guesses are used in the region where they are accurate.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : int</span>
<span class="sd">        Quadrature order</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    xk : ndarray</span>
<span class="sd">        Approximate roots</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    roots_hermite_asy</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Turnover point</span>
    <span class="c1"># linear polynomial fit to error of 10, 25, 40, ..., 1000 point rules</span>
    <span class="n">fit</span> <span class="o">=</span> <span class="mf">0.49082003</span><span class="o">*</span><span class="n">n</span> <span class="o">-</span> <span class="mf">4.37859653</span>
    <span class="n">turnover</span> <span class="o">=</span> <span class="n">around</span><span class="p">(</span><span class="n">fit</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="c1"># Compute all approximations</span>
    <span class="n">ia</span> <span class="o">=</span> <span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">floor</span><span class="p">(</span><span class="n">n</span><span class="o">*</span><span class="mf">0.5</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">ib</span> <span class="o">=</span> <span class="n">ia</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">xasq</span> <span class="o">=</span> <span class="n">_initial_nodes_a</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">ia</span><span class="p">[:</span><span class="n">turnover</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">xbsq</span> <span class="o">=</span> <span class="n">_initial_nodes_b</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">ib</span><span class="p">[</span><span class="n">turnover</span><span class="o">+</span><span class="mi">1</span><span class="p">:])</span>
    <span class="c1"># Combine</span>
    <span class="n">iv</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">hstack</span><span class="p">([</span><span class="n">xasq</span><span class="p">,</span> <span class="n">xbsq</span><span class="p">]))</span>
    <span class="c1"># Central node is always zero</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">iv</span> <span class="o">=</span> <span class="n">hstack</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">iv</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">iv</span>


<span class="k">def</span> <span class="nf">_pbcf</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Asymptotic series expansion of parabolic cylinder function</span>

<span class="sd">    The implementation is based on sections 3.2 and 3.3 from the</span>
<span class="sd">    original paper. Compared to the published version this code</span>
<span class="sd">    adds one more term to the asymptotic series. The detailed</span>
<span class="sd">    formulas can be found at [parabolic-asymptotics]_. The evaluation</span>
<span class="sd">    is done in a transformed variable :math:`\theta := \arccos(t)`</span>
<span class="sd">    where :math:`t := x / \mu` and :math:`\mu := \sqrt{2n + 1}`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : int</span>
<span class="sd">        Quadrature order</span>
<span class="sd">    theta : ndarray</span>
<span class="sd">        Transformed position variable</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    U : ndarray</span>
<span class="sd">        Value of the parabolic cylinder function :math:`U(a, \theta)`.</span>
<span class="sd">    Ud : ndarray</span>
<span class="sd">        Value of the derivative :math:`U^{\prime}(a, \theta)` of</span>
<span class="sd">        the parabolic cylinder function.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    roots_hermite_asy</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [parabolic-asymptotics]</span>
<span class="sd">       https://dlmf.nist.gov/12.10#vii</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">st</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
    <span class="n">ct</span> <span class="o">=</span> <span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
    <span class="c1"># https://dlmf.nist.gov/12.10#vii</span>
    <span class="n">mu</span> <span class="o">=</span> <span class="mf">2.0</span><span class="o">*</span><span class="n">n</span> <span class="o">+</span> <span class="mf">1.0</span>
    <span class="c1"># https://dlmf.nist.gov/12.10#E23</span>
    <span class="n">eta</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">theta</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">st</span><span class="o">*</span><span class="n">ct</span>
    <span class="c1"># https://dlmf.nist.gov/12.10#E39</span>
    <span class="n">zeta</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="mf">3.0</span><span class="o">*</span><span class="n">eta</span><span class="o">/</span><span class="mf">2.0</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="mf">2.0</span><span class="o">/</span><span class="mf">3.0</span><span class="p">)</span>
    <span class="c1"># https://dlmf.nist.gov/12.10#E40</span>
    <span class="n">phi</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">zeta</span> <span class="o">/</span> <span class="n">st</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="mf">0.25</span><span class="p">)</span>
    <span class="c1"># Coefficients</span>
    <span class="c1"># https://dlmf.nist.gov/12.10#E43</span>
    <span class="n">a0</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="n">a1</span> <span class="o">=</span> <span class="mf">0.10416666666666666667</span>
    <span class="n">a2</span> <span class="o">=</span> <span class="mf">0.08355034722222222222</span>
    <span class="n">a3</span> <span class="o">=</span> <span class="mf">0.12822657455632716049</span>
    <span class="n">a4</span> <span class="o">=</span> <span class="mf">0.29184902646414046425</span>
    <span class="n">a5</span> <span class="o">=</span> <span class="mf">0.88162726744375765242</span>
    <span class="n">b0</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="n">b1</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.14583333333333333333</span>
    <span class="n">b2</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.09874131944444444444</span>
    <span class="n">b3</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.14331205391589506173</span>
    <span class="n">b4</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.31722720267841354810</span>
    <span class="n">b5</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.94242914795712024914</span>
    <span class="c1"># Polynomials</span>
    <span class="c1"># https://dlmf.nist.gov/12.10#E9</span>
    <span class="c1"># https://dlmf.nist.gov/12.10#E10</span>
    <span class="n">ctp</span> <span class="o">=</span> <span class="n">ct</span> <span class="o">**</span> <span class="n">arange</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">u0</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="n">u1</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span><span class="o">*</span><span class="n">ctp</span><span class="p">[</span><span class="mi">3</span><span class="p">,:]</span> <span class="o">-</span> <span class="mf">6.0</span><span class="o">*</span><span class="n">ct</span><span class="p">)</span> <span class="o">/</span> <span class="mf">24.0</span>
    <span class="n">u2</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mf">9.0</span><span class="o">*</span><span class="n">ctp</span><span class="p">[</span><span class="mi">4</span><span class="p">,:]</span> <span class="o">+</span> <span class="mf">249.0</span><span class="o">*</span><span class="n">ctp</span><span class="p">[</span><span class="mi">2</span><span class="p">,:]</span> <span class="o">+</span> <span class="mf">145.0</span><span class="p">)</span> <span class="o">/</span> <span class="mf">1152.0</span>
    <span class="n">u3</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mf">4042.0</span><span class="o">*</span><span class="n">ctp</span><span class="p">[</span><span class="mi">9</span><span class="p">,:]</span> <span class="o">+</span> <span class="mf">18189.0</span><span class="o">*</span><span class="n">ctp</span><span class="p">[</span><span class="mi">7</span><span class="p">,:]</span> <span class="o">-</span> <span class="mf">28287.0</span><span class="o">*</span><span class="n">ctp</span><span class="p">[</span><span class="mi">5</span><span class="p">,:]</span>
          <span class="o">-</span> <span class="mf">151995.0</span><span class="o">*</span><span class="n">ctp</span><span class="p">[</span><span class="mi">3</span><span class="p">,:]</span> <span class="o">-</span> <span class="mf">259290.0</span><span class="o">*</span><span class="n">ct</span><span class="p">)</span> <span class="o">/</span> <span class="mf">414720.0</span>
    <span class="n">u4</span> <span class="o">=</span> <span class="p">(</span><span class="mf">72756.0</span><span class="o">*</span><span class="n">ctp</span><span class="p">[</span><span class="mi">10</span><span class="p">,:]</span> <span class="o">-</span> <span class="mf">321339.0</span><span class="o">*</span><span class="n">ctp</span><span class="p">[</span><span class="mi">8</span><span class="p">,:]</span> <span class="o">-</span> <span class="mf">154982.0</span><span class="o">*</span><span class="n">ctp</span><span class="p">[</span><span class="mi">6</span><span class="p">,:]</span>
          <span class="o">+</span> <span class="mf">50938215.0</span><span class="o">*</span><span class="n">ctp</span><span class="p">[</span><span class="mi">4</span><span class="p">,:]</span> <span class="o">+</span> <span class="mf">122602962.0</span><span class="o">*</span><span class="n">ctp</span><span class="p">[</span><span class="mi">2</span><span class="p">,:]</span> <span class="o">+</span> <span class="mf">12773113.0</span><span class="p">)</span> <span class="o">/</span> <span class="mf">39813120.0</span>
    <span class="n">u5</span> <span class="o">=</span> <span class="p">(</span><span class="mf">82393456.0</span><span class="o">*</span><span class="n">ctp</span><span class="p">[</span><span class="mi">15</span><span class="p">,:]</span> <span class="o">-</span> <span class="mf">617950920.0</span><span class="o">*</span><span class="n">ctp</span><span class="p">[</span><span class="mi">13</span><span class="p">,:]</span> <span class="o">+</span> <span class="mf">1994971575.0</span><span class="o">*</span><span class="n">ctp</span><span class="p">[</span><span class="mi">11</span><span class="p">,:]</span>
          <span class="o">-</span> <span class="mf">3630137104.0</span><span class="o">*</span><span class="n">ctp</span><span class="p">[</span><span class="mi">9</span><span class="p">,:]</span> <span class="o">+</span> <span class="mf">4433574213.0</span><span class="o">*</span><span class="n">ctp</span><span class="p">[</span><span class="mi">7</span><span class="p">,:]</span> <span class="o">-</span> <span class="mf">37370295816.0</span><span class="o">*</span><span class="n">ctp</span><span class="p">[</span><span class="mi">5</span><span class="p">,:]</span>
          <span class="o">-</span> <span class="mf">119582875013.0</span><span class="o">*</span><span class="n">ctp</span><span class="p">[</span><span class="mi">3</span><span class="p">,:]</span> <span class="o">-</span> <span class="mf">34009066266.0</span><span class="o">*</span><span class="n">ct</span><span class="p">)</span> <span class="o">/</span> <span class="mf">6688604160.0</span>
    <span class="n">v0</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="n">v1</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span><span class="o">*</span><span class="n">ctp</span><span class="p">[</span><span class="mi">3</span><span class="p">,:]</span> <span class="o">+</span> <span class="mf">6.0</span><span class="o">*</span><span class="n">ct</span><span class="p">)</span> <span class="o">/</span> <span class="mf">24.0</span>
    <span class="n">v2</span> <span class="o">=</span> <span class="p">(</span><span class="mf">15.0</span><span class="o">*</span><span class="n">ctp</span><span class="p">[</span><span class="mi">4</span><span class="p">,:]</span> <span class="o">-</span> <span class="mf">327.0</span><span class="o">*</span><span class="n">ctp</span><span class="p">[</span><span class="mi">2</span><span class="p">,:]</span> <span class="o">-</span> <span class="mf">143.0</span><span class="p">)</span> <span class="o">/</span> <span class="mf">1152.0</span>
    <span class="n">v3</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mf">4042.0</span><span class="o">*</span><span class="n">ctp</span><span class="p">[</span><span class="mi">9</span><span class="p">,:]</span> <span class="o">+</span> <span class="mf">18189.0</span><span class="o">*</span><span class="n">ctp</span><span class="p">[</span><span class="mi">7</span><span class="p">,:]</span> <span class="o">-</span> <span class="mf">36387.0</span><span class="o">*</span><span class="n">ctp</span><span class="p">[</span><span class="mi">5</span><span class="p">,:]</span> 
          <span class="o">+</span> <span class="mf">238425.0</span><span class="o">*</span><span class="n">ctp</span><span class="p">[</span><span class="mi">3</span><span class="p">,:]</span> <span class="o">+</span> <span class="mf">259290.0</span><span class="o">*</span><span class="n">ct</span><span class="p">)</span> <span class="o">/</span> <span class="mf">414720.0</span>
    <span class="n">v4</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mf">121260.0</span><span class="o">*</span><span class="n">ctp</span><span class="p">[</span><span class="mi">10</span><span class="p">,:]</span> <span class="o">+</span> <span class="mf">551733.0</span><span class="o">*</span><span class="n">ctp</span><span class="p">[</span><span class="mi">8</span><span class="p">,:]</span> <span class="o">-</span> <span class="mf">151958.0</span><span class="o">*</span><span class="n">ctp</span><span class="p">[</span><span class="mi">6</span><span class="p">,:]</span>
          <span class="o">-</span> <span class="mf">57484425.0</span><span class="o">*</span><span class="n">ctp</span><span class="p">[</span><span class="mi">4</span><span class="p">,:]</span> <span class="o">-</span> <span class="mf">132752238.0</span><span class="o">*</span><span class="n">ctp</span><span class="p">[</span><span class="mi">2</span><span class="p">,:]</span> <span class="o">-</span> <span class="mi">12118727</span><span class="p">)</span> <span class="o">/</span> <span class="mf">39813120.0</span>
    <span class="n">v5</span> <span class="o">=</span> <span class="p">(</span><span class="mf">82393456.0</span><span class="o">*</span><span class="n">ctp</span><span class="p">[</span><span class="mi">15</span><span class="p">,:]</span> <span class="o">-</span> <span class="mf">617950920.0</span><span class="o">*</span><span class="n">ctp</span><span class="p">[</span><span class="mi">13</span><span class="p">,:]</span> <span class="o">+</span> <span class="mf">2025529095.0</span><span class="o">*</span><span class="n">ctp</span><span class="p">[</span><span class="mi">11</span><span class="p">,:]</span>
          <span class="o">-</span> <span class="mf">3750839308.0</span><span class="o">*</span><span class="n">ctp</span><span class="p">[</span><span class="mi">9</span><span class="p">,:]</span> <span class="o">+</span> <span class="mf">3832454253.0</span><span class="o">*</span><span class="n">ctp</span><span class="p">[</span><span class="mi">7</span><span class="p">,:]</span> <span class="o">+</span> <span class="mf">35213253348.0</span><span class="o">*</span><span class="n">ctp</span><span class="p">[</span><span class="mi">5</span><span class="p">,:]</span>
          <span class="o">+</span> <span class="mf">130919230435.0</span><span class="o">*</span><span class="n">ctp</span><span class="p">[</span><span class="mi">3</span><span class="p">,:]</span> <span class="o">+</span> <span class="mi">34009066266</span><span class="o">*</span><span class="n">ct</span><span class="p">)</span> <span class="o">/</span> <span class="mf">6688604160.0</span>
    <span class="c1"># Airy Evaluation (Bi and Bip unused)</span>
    <span class="n">Ai</span><span class="p">,</span> <span class="n">Aip</span><span class="p">,</span> <span class="n">Bi</span><span class="p">,</span> <span class="n">Bip</span> <span class="o">=</span> <span class="n">airy</span><span class="p">(</span><span class="n">mu</span><span class="o">**</span><span class="p">(</span><span class="mf">4.0</span><span class="o">/</span><span class="mf">6.0</span><span class="p">)</span> <span class="o">*</span> <span class="n">zeta</span><span class="p">)</span>
    <span class="c1"># Prefactor for U</span>
    <span class="n">P</span> <span class="o">=</span> <span class="mf">2.0</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span><span class="n">pi</span><span class="p">)</span> <span class="o">*</span> <span class="n">mu</span><span class="o">**</span><span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="mf">6.0</span><span class="p">)</span> <span class="o">*</span> <span class="n">phi</span>
    <span class="c1"># Terms for U</span>
    <span class="c1"># https://dlmf.nist.gov/12.10#E42</span>
    <span class="n">phip</span> <span class="o">=</span> <span class="n">phi</span> <span class="o">**</span> <span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">A0</span> <span class="o">=</span> <span class="n">b0</span><span class="o">*</span><span class="n">u0</span>
    <span class="n">A1</span> <span class="o">=</span> <span class="p">(</span><span class="n">b2</span><span class="o">*</span><span class="n">u0</span> <span class="o">+</span> <span class="n">phip</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span><span class="o">*</span><span class="n">b1</span><span class="o">*</span><span class="n">u1</span> <span class="o">+</span> <span class="n">phip</span><span class="p">[</span><span class="mi">1</span><span class="p">,:]</span><span class="o">*</span><span class="n">b0</span><span class="o">*</span><span class="n">u2</span><span class="p">)</span> <span class="o">/</span> <span class="n">zeta</span><span class="o">**</span><span class="mi">3</span>
    <span class="n">A2</span> <span class="o">=</span> <span class="p">(</span><span class="n">b4</span><span class="o">*</span><span class="n">u0</span> <span class="o">+</span> <span class="n">phip</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span><span class="o">*</span><span class="n">b3</span><span class="o">*</span><span class="n">u1</span> <span class="o">+</span> <span class="n">phip</span><span class="p">[</span><span class="mi">1</span><span class="p">,:]</span><span class="o">*</span><span class="n">b2</span><span class="o">*</span><span class="n">u2</span> <span class="o">+</span> <span class="n">phip</span><span class="p">[</span><span class="mi">2</span><span class="p">,:]</span><span class="o">*</span><span class="n">b1</span><span class="o">*</span><span class="n">u3</span>
          <span class="o">+</span> <span class="n">phip</span><span class="p">[</span><span class="mi">3</span><span class="p">,:]</span><span class="o">*</span><span class="n">b0</span><span class="o">*</span><span class="n">u4</span><span class="p">)</span> <span class="o">/</span> <span class="n">zeta</span><span class="o">**</span><span class="mi">6</span>
    <span class="n">B0</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">a1</span><span class="o">*</span><span class="n">u0</span> <span class="o">+</span> <span class="n">phip</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span><span class="o">*</span><span class="n">a0</span><span class="o">*</span><span class="n">u1</span><span class="p">)</span> <span class="o">/</span> <span class="n">zeta</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">B1</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">a3</span><span class="o">*</span><span class="n">u0</span> <span class="o">+</span> <span class="n">phip</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span><span class="o">*</span><span class="n">a2</span><span class="o">*</span><span class="n">u1</span> <span class="o">+</span> <span class="n">phip</span><span class="p">[</span><span class="mi">1</span><span class="p">,:]</span><span class="o">*</span><span class="n">a1</span><span class="o">*</span><span class="n">u2</span> <span class="o">+</span> <span class="n">phip</span><span class="p">[</span><span class="mi">2</span><span class="p">,:]</span><span class="o">*</span><span class="n">a0</span><span class="o">*</span><span class="n">u3</span><span class="p">)</span> <span class="o">/</span> <span class="n">zeta</span><span class="o">**</span><span class="mi">5</span>
    <span class="n">B2</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">a5</span><span class="o">*</span><span class="n">u0</span> <span class="o">+</span> <span class="n">phip</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span><span class="o">*</span><span class="n">a4</span><span class="o">*</span><span class="n">u1</span> <span class="o">+</span> <span class="n">phip</span><span class="p">[</span><span class="mi">1</span><span class="p">,:]</span><span class="o">*</span><span class="n">a3</span><span class="o">*</span><span class="n">u2</span> <span class="o">+</span> <span class="n">phip</span><span class="p">[</span><span class="mi">2</span><span class="p">,:]</span><span class="o">*</span><span class="n">a2</span><span class="o">*</span><span class="n">u3</span>
           <span class="o">+</span> <span class="n">phip</span><span class="p">[</span><span class="mi">3</span><span class="p">,:]</span><span class="o">*</span><span class="n">a1</span><span class="o">*</span><span class="n">u4</span> <span class="o">+</span> <span class="n">phip</span><span class="p">[</span><span class="mi">4</span><span class="p">,:]</span><span class="o">*</span><span class="n">a0</span><span class="o">*</span><span class="n">u5</span><span class="p">)</span> <span class="o">/</span> <span class="n">zeta</span><span class="o">**</span><span class="mi">8</span>
    <span class="c1"># U</span>
    <span class="c1"># https://dlmf.nist.gov/12.10#E35</span>
    <span class="n">U</span> <span class="o">=</span> <span class="n">P</span> <span class="o">*</span> <span class="p">(</span><span class="n">Ai</span> <span class="o">*</span> <span class="p">(</span><span class="n">A0</span> <span class="o">+</span> <span class="n">A1</span><span class="o">/</span><span class="n">mu</span><span class="o">**</span><span class="mf">2.0</span> <span class="o">+</span> <span class="n">A2</span><span class="o">/</span><span class="n">mu</span><span class="o">**</span><span class="mf">4.0</span><span class="p">)</span> <span class="o">+</span>
             <span class="n">Aip</span> <span class="o">*</span> <span class="p">(</span><span class="n">B0</span> <span class="o">+</span> <span class="n">B1</span><span class="o">/</span><span class="n">mu</span><span class="o">**</span><span class="mf">2.0</span> <span class="o">+</span> <span class="n">B2</span><span class="o">/</span><span class="n">mu</span><span class="o">**</span><span class="mf">4.0</span><span class="p">)</span> <span class="o">/</span> <span class="n">mu</span><span class="o">**</span><span class="p">(</span><span class="mf">8.0</span><span class="o">/</span><span class="mf">6.0</span><span class="p">))</span>
    <span class="c1"># Prefactor for derivative of U</span>
    <span class="n">Pd</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">pi</span><span class="p">)</span> <span class="o">*</span> <span class="n">mu</span><span class="o">**</span><span class="p">(</span><span class="mf">2.0</span><span class="o">/</span><span class="mf">6.0</span><span class="p">)</span> <span class="o">/</span> <span class="n">phi</span>
    <span class="c1"># Terms for derivative of U</span>
    <span class="c1"># https://dlmf.nist.gov/12.10#E46</span>
    <span class="n">C0</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">b1</span><span class="o">*</span><span class="n">v0</span> <span class="o">+</span> <span class="n">phip</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span><span class="o">*</span><span class="n">b0</span><span class="o">*</span><span class="n">v1</span><span class="p">)</span> <span class="o">/</span> <span class="n">zeta</span>
    <span class="n">C1</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">b3</span><span class="o">*</span><span class="n">v0</span> <span class="o">+</span> <span class="n">phip</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span><span class="o">*</span><span class="n">b2</span><span class="o">*</span><span class="n">v1</span> <span class="o">+</span> <span class="n">phip</span><span class="p">[</span><span class="mi">1</span><span class="p">,:]</span><span class="o">*</span><span class="n">b1</span><span class="o">*</span><span class="n">v2</span> <span class="o">+</span> <span class="n">phip</span><span class="p">[</span><span class="mi">2</span><span class="p">,:]</span><span class="o">*</span><span class="n">b0</span><span class="o">*</span><span class="n">v3</span><span class="p">)</span> <span class="o">/</span> <span class="n">zeta</span><span class="o">**</span><span class="mi">4</span>
    <span class="n">C2</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">b5</span><span class="o">*</span><span class="n">v0</span> <span class="o">+</span> <span class="n">phip</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span><span class="o">*</span><span class="n">b4</span><span class="o">*</span><span class="n">v1</span> <span class="o">+</span> <span class="n">phip</span><span class="p">[</span><span class="mi">1</span><span class="p">,:]</span><span class="o">*</span><span class="n">b3</span><span class="o">*</span><span class="n">v2</span> <span class="o">+</span> <span class="n">phip</span><span class="p">[</span><span class="mi">2</span><span class="p">,:]</span><span class="o">*</span><span class="n">b2</span><span class="o">*</span><span class="n">v3</span>
           <span class="o">+</span> <span class="n">phip</span><span class="p">[</span><span class="mi">3</span><span class="p">,:]</span><span class="o">*</span><span class="n">b1</span><span class="o">*</span><span class="n">v4</span> <span class="o">+</span> <span class="n">phip</span><span class="p">[</span><span class="mi">4</span><span class="p">,:]</span><span class="o">*</span><span class="n">b0</span><span class="o">*</span><span class="n">v5</span><span class="p">)</span> <span class="o">/</span> <span class="n">zeta</span><span class="o">**</span><span class="mi">7</span>
    <span class="n">D0</span> <span class="o">=</span> <span class="n">a0</span><span class="o">*</span><span class="n">v0</span>
    <span class="n">D1</span> <span class="o">=</span> <span class="p">(</span><span class="n">a2</span><span class="o">*</span><span class="n">v0</span> <span class="o">+</span> <span class="n">phip</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span><span class="o">*</span><span class="n">a1</span><span class="o">*</span><span class="n">v1</span> <span class="o">+</span> <span class="n">phip</span><span class="p">[</span><span class="mi">1</span><span class="p">,:]</span><span class="o">*</span><span class="n">a0</span><span class="o">*</span><span class="n">v2</span><span class="p">)</span> <span class="o">/</span> <span class="n">zeta</span><span class="o">**</span><span class="mi">3</span>
    <span class="n">D2</span> <span class="o">=</span> <span class="p">(</span><span class="n">a4</span><span class="o">*</span><span class="n">v0</span> <span class="o">+</span> <span class="n">phip</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span><span class="o">*</span><span class="n">a3</span><span class="o">*</span><span class="n">v1</span> <span class="o">+</span> <span class="n">phip</span><span class="p">[</span><span class="mi">1</span><span class="p">,:]</span><span class="o">*</span><span class="n">a2</span><span class="o">*</span><span class="n">v2</span> <span class="o">+</span> <span class="n">phip</span><span class="p">[</span><span class="mi">2</span><span class="p">,:]</span><span class="o">*</span><span class="n">a1</span><span class="o">*</span><span class="n">v3</span>
          <span class="o">+</span> <span class="n">phip</span><span class="p">[</span><span class="mi">3</span><span class="p">,:]</span><span class="o">*</span><span class="n">a0</span><span class="o">*</span><span class="n">v4</span><span class="p">)</span> <span class="o">/</span> <span class="n">zeta</span><span class="o">**</span><span class="mi">6</span>
    <span class="c1"># Derivative of U</span>
    <span class="c1"># https://dlmf.nist.gov/12.10#E36</span>
    <span class="n">Ud</span> <span class="o">=</span> <span class="n">Pd</span> <span class="o">*</span> <span class="p">(</span><span class="n">Ai</span> <span class="o">*</span> <span class="p">(</span><span class="n">C0</span> <span class="o">+</span> <span class="n">C1</span><span class="o">/</span><span class="n">mu</span><span class="o">**</span><span class="mf">2.0</span> <span class="o">+</span> <span class="n">C2</span><span class="o">/</span><span class="n">mu</span><span class="o">**</span><span class="mf">4.0</span><span class="p">)</span> <span class="o">/</span> <span class="n">mu</span><span class="o">**</span><span class="p">(</span><span class="mf">4.0</span><span class="o">/</span><span class="mf">6.0</span><span class="p">)</span> <span class="o">+</span>
               <span class="n">Aip</span> <span class="o">*</span> <span class="p">(</span><span class="n">D0</span> <span class="o">+</span> <span class="n">D1</span><span class="o">/</span><span class="n">mu</span><span class="o">**</span><span class="mf">2.0</span> <span class="o">+</span> <span class="n">D2</span><span class="o">/</span><span class="n">mu</span><span class="o">**</span><span class="mf">4.0</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">U</span><span class="p">,</span> <span class="n">Ud</span>


<span class="k">def</span> <span class="nf">_newton</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">x_initial</span><span class="p">,</span> <span class="n">maxit</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Newton iteration for polishing the asymptotic approximation</span>
<span class="sd">    to the zeros of the Hermite polynomials.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : int</span>
<span class="sd">        Quadrature order</span>
<span class="sd">    x_initial : ndarray</span>
<span class="sd">        Initial guesses for the roots</span>
<span class="sd">    maxit : int</span>
<span class="sd">        Maximal number of Newton iterations.</span>
<span class="sd">        The default 5 is sufficient, usually</span>
<span class="sd">        only one or two steps are needed.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    nodes : ndarray</span>
<span class="sd">        Quadrature nodes</span>
<span class="sd">    weights : ndarray</span>
<span class="sd">        Quadrature weights</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    roots_hermite_asy</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Variable transformation</span>
    <span class="n">mu</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">n</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">x_initial</span> <span class="o">/</span> <span class="n">mu</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="n">arccos</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="c1"># Newton iteration</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">maxit</span><span class="p">):</span>
        <span class="n">u</span><span class="p">,</span> <span class="n">ud</span> <span class="o">=</span> <span class="n">_pbcf</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span>
        <span class="n">dtheta</span> <span class="o">=</span> <span class="n">u</span> <span class="o">/</span> <span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">2.0</span><span class="p">)</span> <span class="o">*</span> <span class="n">mu</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">*</span> <span class="n">ud</span><span class="p">)</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">theta</span> <span class="o">+</span> <span class="n">dtheta</span>
        <span class="k">if</span> <span class="nb">max</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">dtheta</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mf">1e-14</span><span class="p">:</span>
            <span class="k">break</span>
    <span class="c1"># Undo variable transformation</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">mu</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
    <span class="c1"># Central node is always zero</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="c1"># Compute weights</span>
    <span class="n">w</span> <span class="o">=</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">ud</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">w</span>


<span class="k">def</span> <span class="nf">_roots_hermite_asy</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Gauss-Hermite (physicist&#39;s) quadrature for large n.</span>

<span class="sd">    Computes the sample points and weights for Gauss-Hermite quadrature.</span>
<span class="sd">    The sample points are the roots of the nth degree Hermite polynomial,</span>
<span class="sd">    :math:`H_n(x)`. These sample points and weights correctly integrate</span>
<span class="sd">    polynomials of degree :math:`2n - 1` or less over the interval</span>
<span class="sd">    :math:`[-\infty, \infty]` with weight function :math:`f(x) = e^{-x^2}`.</span>

<span class="sd">    This method relies on asymptotic expansions which work best for n &gt; 150.</span>
<span class="sd">    The algorithm has linear runtime making computation for very large n</span>
<span class="sd">    feasible.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : int</span>
<span class="sd">        quadrature order</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    nodes : ndarray</span>
<span class="sd">        Quadrature nodes</span>
<span class="sd">    weights : ndarray</span>
<span class="sd">        Quadrature weights</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    roots_hermite</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [townsend.trogdon.olver-2014]</span>
<span class="sd">       Townsend, A. and Trogdon, T. and Olver, S. (2014)</span>
<span class="sd">       *Fast computation of Gauss quadrature nodes and</span>
<span class="sd">       weights on the whole real line*. :arXiv:`1410.5286`.</span>

<span class="sd">    .. [townsend.trogdon.olver-2015]</span>
<span class="sd">       Townsend, A. and Trogdon, T. and Olver, S. (2015)</span>
<span class="sd">       *Fast computation of Gauss quadrature nodes and</span>
<span class="sd">       weights on the whole real line*.</span>
<span class="sd">       IMA Journal of Numerical Analysis</span>
<span class="sd">       :doi:`10.1093/imanum/drv002`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">iv</span> <span class="o">=</span> <span class="n">_initial_nodes</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="n">nodes</span><span class="p">,</span> <span class="n">weights</span> <span class="o">=</span> <span class="n">_newton</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">iv</span><span class="p">)</span>
    <span class="c1"># Combine with negative parts</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="n">hstack</span><span class="p">([</span><span class="o">-</span><span class="n">nodes</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">nodes</span><span class="p">])</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">hstack</span><span class="p">([</span><span class="n">weights</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">weights</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="n">hstack</span><span class="p">([</span><span class="o">-</span><span class="n">nodes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">nodes</span><span class="p">])</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">hstack</span><span class="p">([</span><span class="n">weights</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">weights</span><span class="p">])</span>
    <span class="c1"># Scale weights</span>
    <span class="n">weights</span> <span class="o">*=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">pi</span><span class="p">)</span> <span class="o">/</span> <span class="nb">sum</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">weights</span>


<span class="k">def</span> <span class="nf">hermite</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">monic</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Physicist&#39;s Hermite polynomial.</span>

<span class="sd">    Defined by</span>

<span class="sd">    .. math::</span>

<span class="sd">        H_n(x) = (-1)^ne^{x^2}\frac{d^n}{dx^n}e^{-x^2};</span>

<span class="sd">    :math:`H_n` is a polynomial of degree :math:`n`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : int</span>
<span class="sd">        Degree of the polynomial.</span>
<span class="sd">    monic : bool, optional</span>
<span class="sd">        If `True`, scale the leading coefficient to be 1. Default is</span>
<span class="sd">        `False`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    H : orthopoly1d</span>
<span class="sd">        Hermite polynomial.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The polynomials :math:`H_n` are orthogonal over :math:`(-\infty,</span>
<span class="sd">    \infty)` with weight function :math:`e^{-x^2}`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy import special</span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>

<span class="sd">    &gt;&gt;&gt; p_monic = special.hermite(3, monic=True)</span>
<span class="sd">    &gt;&gt;&gt; p_monic</span>
<span class="sd">    poly1d([ 1. ,  0. , -1.5,  0. ])</span>
<span class="sd">    &gt;&gt;&gt; p_monic(1)</span>
<span class="sd">    -0.49999999999999983</span>
<span class="sd">    &gt;&gt;&gt; x = np.linspace(-3, 3, 400)</span>
<span class="sd">    &gt;&gt;&gt; y = p_monic(x)</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(x, y)</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&quot;Monic Hermite polynomial of degree 3&quot;)</span>
<span class="sd">    &gt;&gt;&gt; plt.xlabel(&quot;x&quot;)</span>
<span class="sd">    &gt;&gt;&gt; plt.ylabel(&quot;H_3(x)&quot;)</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;n must be nonnegative.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="n">n</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">roots_hermite</span><span class="p">(</span><span class="n">n1</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">wfunc</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
    <span class="n">hn</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="n">n</span> <span class="o">*</span> <span class="n">_gam</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">pi</span><span class="p">)</span>
    <span class="n">kn</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="n">n</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">orthopoly1d</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">hn</span><span class="p">,</span> <span class="n">kn</span><span class="p">,</span> <span class="n">wfunc</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="n">inf</span><span class="p">,</span> <span class="n">inf</span><span class="p">),</span> <span class="n">monic</span><span class="p">,</span>
                    <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">_ufuncs</span><span class="o">.</span><span class="n">eval_hermite</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">p</span>

<span class="c1"># Hermite  2                         He_n(x)</span>


<span class="k">def</span> <span class="nf">roots_hermitenorm</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Gauss-Hermite (statistician&#39;s) quadrature.</span>

<span class="sd">    Compute the sample points and weights for Gauss-Hermite</span>
<span class="sd">    quadrature. The sample points are the roots of the nth degree</span>
<span class="sd">    Hermite polynomial, :math:`He_n(x)`. These sample points and</span>
<span class="sd">    weights correctly integrate polynomials of degree :math:`2n - 1`</span>
<span class="sd">    or less over the interval :math:`[-\infty, \infty]` with weight</span>
<span class="sd">    function :math:`w(x) = e^{-x^2/2}`. See 22.2.15 in [AS]_ for more</span>
<span class="sd">    details.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : int</span>
<span class="sd">        quadrature order</span>
<span class="sd">    mu : bool, optional</span>
<span class="sd">        If True, return the sum of the weights, optional.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    x : ndarray</span>
<span class="sd">        Sample points</span>
<span class="sd">    w : ndarray</span>
<span class="sd">        Weights</span>
<span class="sd">    mu : float</span>
<span class="sd">        Sum of the weights</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    scipy.integrate.quadrature</span>
<span class="sd">    scipy.integrate.fixed_quad</span>
<span class="sd">    numpy.polynomial.hermite_e.hermegauss</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    For small n up to 150 a modified version of the Golub-Welsch</span>
<span class="sd">    algorithm is used. Nodes are computed from the eigenvalue</span>
<span class="sd">    problem and improved by one step of a Newton iteration.</span>
<span class="sd">    The weights are computed from the well-known analytical formula.</span>

<span class="sd">    For n larger than 150 an optimal asymptotic algorithm is used</span>
<span class="sd">    which computes nodes and weights in a numerical stable manner.</span>
<span class="sd">    The algorithm has linear runtime making computation for very</span>
<span class="sd">    large n (several thousand or more) feasible.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [AS] Milton Abramowitz and Irene A. Stegun, eds.</span>
<span class="sd">        Handbook of Mathematical Functions with Formulas,</span>
<span class="sd">        Graphs, and Mathematical Tables. New York: Dover, 1972.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">m</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">n</span> <span class="o">!=</span> <span class="n">m</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;n must be a positive integer.&quot;</span><span class="p">)</span>

    <span class="n">mu0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">150</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">an_func</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
            <span class="k">return</span> <span class="mf">0.0</span> <span class="o">*</span> <span class="n">k</span>
        <span class="k">def</span> <span class="nf">bn_func</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">_ufuncs</span><span class="o">.</span><span class="n">eval_hermitenorm</span>
        <span class="k">def</span> <span class="nf">df</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">n</span> <span class="o">*</span> <span class="n">_ufuncs</span><span class="o">.</span><span class="n">eval_hermitenorm</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_gen_roots_and_weights</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">mu0</span><span class="p">,</span> <span class="n">an_func</span><span class="p">,</span> <span class="n">bn_func</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">mu</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">nodes</span><span class="p">,</span> <span class="n">weights</span> <span class="o">=</span> <span class="n">_roots_hermite_asy</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
        <span class="c1"># Transform</span>
        <span class="n">nodes</span> <span class="o">*=</span> <span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">weights</span> <span class="o">*=</span> <span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mu</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">mu0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">weights</span>


<span class="k">def</span> <span class="nf">hermitenorm</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">monic</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Normalized (probabilist&#39;s) Hermite polynomial.</span>

<span class="sd">    Defined by</span>

<span class="sd">    .. math::</span>

<span class="sd">        He_n(x) = (-1)^ne^{x^2/2}\frac{d^n}{dx^n}e^{-x^2/2};</span>

<span class="sd">    :math:`He_n` is a polynomial of degree :math:`n`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : int</span>
<span class="sd">        Degree of the polynomial.</span>
<span class="sd">    monic : bool, optional</span>
<span class="sd">        If `True`, scale the leading coefficient to be 1. Default is</span>
<span class="sd">        `False`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    He : orthopoly1d</span>
<span class="sd">        Hermite polynomial.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>

<span class="sd">    The polynomials :math:`He_n` are orthogonal over :math:`(-\infty,</span>
<span class="sd">    \infty)` with weight function :math:`e^{-x^2/2}`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;n must be nonnegative.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="n">n</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">roots_hermitenorm</span><span class="p">(</span><span class="n">n1</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">wfunc</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">x</span> <span class="o">*</span> <span class="n">x</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
    <span class="n">hn</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">pi</span><span class="p">)</span> <span class="o">*</span> <span class="n">_gam</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">kn</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">orthopoly1d</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">hn</span><span class="p">,</span> <span class="n">kn</span><span class="p">,</span> <span class="n">wfunc</span><span class="o">=</span><span class="n">wfunc</span><span class="p">,</span> <span class="n">limits</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="n">inf</span><span class="p">,</span> <span class="n">inf</span><span class="p">),</span> <span class="n">monic</span><span class="o">=</span><span class="n">monic</span><span class="p">,</span>
                    <span class="n">eval_func</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">_ufuncs</span><span class="o">.</span><span class="n">eval_hermitenorm</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">p</span>

<span class="c1"># The remainder of the polynomials can be derived from the ones above.</span>

<span class="c1"># Ultraspherical (Gegenbauer)        C^(alpha)_n(x)</span>


<span class="k">def</span> <span class="nf">roots_gegenbauer</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Gauss-Gegenbauer quadrature.</span>

<span class="sd">    Compute the sample points and weights for Gauss-Gegenbauer</span>
<span class="sd">    quadrature. The sample points are the roots of the nth degree</span>
<span class="sd">    Gegenbauer polynomial, :math:`C^{\alpha}_n(x)`. These sample</span>
<span class="sd">    points and weights correctly integrate polynomials of degree</span>
<span class="sd">    :math:`2n - 1` or less over the interval :math:`[-1, 1]` with</span>
<span class="sd">    weight function :math:`w(x) = (1 - x^2)^{\alpha - 1/2}`. See</span>
<span class="sd">    22.2.3 in [AS]_ for more details.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : int</span>
<span class="sd">        quadrature order</span>
<span class="sd">    alpha : float</span>
<span class="sd">        alpha must be &gt; -0.5</span>
<span class="sd">    mu : bool, optional</span>
<span class="sd">        If True, return the sum of the weights, optional.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    x : ndarray</span>
<span class="sd">        Sample points</span>
<span class="sd">    w : ndarray</span>
<span class="sd">        Weights</span>
<span class="sd">    mu : float</span>
<span class="sd">        Sum of the weights</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    scipy.integrate.quadrature</span>
<span class="sd">    scipy.integrate.fixed_quad</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [AS] Milton Abramowitz and Irene A. Stegun, eds.</span>
<span class="sd">        Handbook of Mathematical Functions with Formulas,</span>
<span class="sd">        Graphs, and Mathematical Tables. New York: Dover, 1972.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">m</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">n</span> <span class="o">!=</span> <span class="n">m</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;n must be a positive integer.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">alpha</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;alpha must be greater than -0.5.&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">alpha</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
        <span class="c1"># C(n,0,x) == 0 uniformly, however, as alpha-&gt;0, C(n,alpha,x)-&gt;T(n,x)</span>
        <span class="c1"># strictly, we should just error out here, since the roots are not</span>
        <span class="c1"># really defined, but we used to return something useful, so let&#39;s</span>
        <span class="c1"># keep doing so.</span>
        <span class="k">return</span> <span class="n">roots_chebyt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">mu</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">alpha</span> <span class="o">&lt;=</span> <span class="mi">170</span><span class="p">:</span>
        <span class="n">mu0</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">*</span> <span class="n">_ufuncs</span><span class="o">.</span><span class="n">gamma</span><span class="p">(</span><span class="n">alpha</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">))</span> \
              <span class="o">/</span> <span class="n">_ufuncs</span><span class="o">.</span><span class="n">gamma</span><span class="p">(</span><span class="n">alpha</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># For large alpha we use a Taylor series expansion around inf,</span>
        <span class="c1"># expressed as a 6th order polynomial of a^-1 and using Horner&#39;s</span>
        <span class="c1"># method to minimize computation and maximize precision</span>
        <span class="n">inv_alpha</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">/</span> <span class="n">alpha</span>
        <span class="n">coeffs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.000207186</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.00152206</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.000640869</span><span class="p">,</span>
                           <span class="mf">0.00488281</span><span class="p">,</span> <span class="mf">0.0078125</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.125</span><span class="p">,</span> <span class="mf">1.</span><span class="p">])</span>
        <span class="n">mu0</span> <span class="o">=</span> <span class="n">coeffs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">coeffs</span><span class="p">)):</span>
            <span class="n">mu0</span> <span class="o">=</span> <span class="n">mu0</span> <span class="o">*</span> <span class="n">inv_alpha</span> <span class="o">+</span> <span class="n">coeffs</span><span class="p">[</span><span class="n">term</span><span class="p">]</span>
        <span class="n">mu0</span> <span class="o">=</span> <span class="n">mu0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="n">alpha</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">an_func</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
        <span class="k">return</span> <span class="mf">0.0</span> <span class="o">*</span> <span class="n">k</span>
    <span class="k">def</span> <span class="nf">bn_func</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">k</span> <span class="o">*</span> <span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">alpha</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="n">alpha</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="n">alpha</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)))</span>
    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_ufuncs</span><span class="o">.</span><span class="n">eval_gegenbauer</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">df</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="o">-</span><span class="n">n</span> <span class="o">*</span> <span class="n">x</span> <span class="o">*</span> <span class="n">_ufuncs</span><span class="o">.</span><span class="n">eval_gegenbauer</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
            <span class="o">+</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">alpha</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">_ufuncs</span><span class="o">.</span><span class="n">eval_gegenbauer</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
        <span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">x</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_gen_roots_and_weights</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">mu0</span><span class="p">,</span> <span class="n">an_func</span><span class="p">,</span> <span class="n">bn_func</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">mu</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">gegenbauer</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">monic</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Gegenbauer (ultraspherical) polynomial.</span>

<span class="sd">    Defined to be the solution of</span>

<span class="sd">    .. math::</span>
<span class="sd">        (1 - x^2)\frac{d^2}{dx^2}C_n^{(\alpha)}</span>
<span class="sd">          - (2\alpha + 1)x\frac{d}{dx}C_n^{(\alpha)}</span>
<span class="sd">          + n(n + 2\alpha)C_n^{(\alpha)} = 0</span>

<span class="sd">    for :math:`\alpha &gt; -1/2`; :math:`C_n^{(\alpha)}` is a polynomial</span>
<span class="sd">    of degree :math:`n`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : int</span>
<span class="sd">        Degree of the polynomial.</span>
<span class="sd">    alpha : float</span>
<span class="sd">        Parameter, must be greater than -0.5.</span>
<span class="sd">    monic : bool, optional</span>
<span class="sd">        If `True`, scale the leading coefficient to be 1. Default is</span>
<span class="sd">        `False`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    C : orthopoly1d</span>
<span class="sd">        Gegenbauer polynomial.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The polynomials :math:`C_n^{(\alpha)}` are orthogonal over</span>
<span class="sd">    :math:`[-1,1]` with weight function :math:`(1 - x^2)^{(\alpha -</span>
<span class="sd">    1/2)}`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; from scipy import special</span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>

<span class="sd">    We can initialize a variable ``p`` as a Gegenbauer polynomial using the</span>
<span class="sd">    `gegenbauer` function and evaluate at a point ``x = 1``.</span>

<span class="sd">    &gt;&gt;&gt; p = special.gegenbauer(3, 0.5, monic=False)</span>
<span class="sd">    &gt;&gt;&gt; p</span>
<span class="sd">    poly1d([ 2.5,  0. , -1.5,  0. ])</span>
<span class="sd">    &gt;&gt;&gt; p(1)</span>
<span class="sd">    1.0</span>

<span class="sd">    To evaluate ``p`` at various points ``x`` in the interval ``(-3, 3)``,</span>
<span class="sd">    simply pass an array ``x`` to ``p`` as follows:</span>

<span class="sd">    &gt;&gt;&gt; x = np.linspace(-3, 3, 400)</span>
<span class="sd">    &gt;&gt;&gt; y = p(x)</span>

<span class="sd">    We can then visualize ``x, y`` using `matplotlib.pyplot`.</span>

<span class="sd">    &gt;&gt;&gt; fig, ax = plt.subplots()</span>
<span class="sd">    &gt;&gt;&gt; ax.plot(x, y)</span>
<span class="sd">    &gt;&gt;&gt; ax.set_title(&quot;Gegenbauer (ultraspherical) polynomial of degree 3&quot;)</span>
<span class="sd">    &gt;&gt;&gt; ax.set_xlabel(&quot;x&quot;)</span>
<span class="sd">    &gt;&gt;&gt; ax.set_ylabel(&quot;G_3(x)&quot;)</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">base</span> <span class="o">=</span> <span class="n">jacobi</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">alpha</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">alpha</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">monic</span><span class="o">=</span><span class="n">monic</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">monic</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">base</span>
    <span class="c1">#  Abrahmowitz and Stegan 22.5.20</span>
    <span class="n">factor</span> <span class="o">=</span> <span class="p">(</span><span class="n">_gam</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">alpha</span> <span class="o">+</span> <span class="n">n</span><span class="p">)</span> <span class="o">*</span> <span class="n">_gam</span><span class="p">(</span><span class="n">alpha</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">/</span>
              <span class="n">_gam</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">alpha</span><span class="p">)</span> <span class="o">/</span> <span class="n">_gam</span><span class="p">(</span><span class="n">alpha</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">+</span> <span class="n">n</span><span class="p">))</span>
    <span class="n">base</span><span class="o">.</span><span class="n">_scale</span><span class="p">(</span><span class="n">factor</span><span class="p">)</span>
    <span class="n">base</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s1">&#39;_eval_func&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">_ufuncs</span><span class="o">.</span><span class="n">eval_gegenbauer</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">n</span><span class="p">),</span>
                                                                    <span class="n">alpha</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">base</span>

<span class="c1"># Chebyshev of the first kind: T_n(x) =</span>
<span class="c1">#     n! sqrt(pi) / _gam(n+1./2)* P^(-1/2,-1/2)_n(x)</span>
<span class="c1"># Computed anew.</span>


<span class="k">def</span> <span class="nf">roots_chebyt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Gauss-Chebyshev (first kind) quadrature.</span>

<span class="sd">    Computes the sample points and weights for Gauss-Chebyshev</span>
<span class="sd">    quadrature. The sample points are the roots of the nth degree</span>
<span class="sd">    Chebyshev polynomial of the first kind, :math:`T_n(x)`. These</span>
<span class="sd">    sample points and weights correctly integrate polynomials of</span>
<span class="sd">    degree :math:`2n - 1` or less over the interval :math:`[-1, 1]`</span>
<span class="sd">    with weight function :math:`w(x) = 1/\sqrt{1 - x^2}`. See 22.2.4</span>
<span class="sd">    in [AS]_ for more details.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : int</span>
<span class="sd">        quadrature order</span>
<span class="sd">    mu : bool, optional</span>
<span class="sd">        If True, return the sum of the weights, optional.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    x : ndarray</span>
<span class="sd">        Sample points</span>
<span class="sd">    w : ndarray</span>
<span class="sd">        Weights</span>
<span class="sd">    mu : float</span>
<span class="sd">        Sum of the weights</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    scipy.integrate.quadrature</span>
<span class="sd">    scipy.integrate.fixed_quad</span>
<span class="sd">    numpy.polynomial.chebyshev.chebgauss</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [AS] Milton Abramowitz and Irene A. Stegun, eds.</span>
<span class="sd">        Handbook of Mathematical Functions with Formulas,</span>
<span class="sd">        Graphs, and Mathematical Tables. New York: Dover, 1972.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">m</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">n</span> <span class="o">!=</span> <span class="n">m</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;n must be a positive integer.&#39;</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">_ufuncs</span><span class="o">.</span><span class="n">_sinpi</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">m</span><span class="p">))</span>
    <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">pi</span><span class="o">/</span><span class="n">m</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">mu</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">pi</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">w</span>


<span class="k">def</span> <span class="nf">chebyt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">monic</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Chebyshev polynomial of the first kind.</span>

<span class="sd">    Defined to be the solution of</span>

<span class="sd">    .. math::</span>
<span class="sd">        (1 - x^2)\frac{d^2}{dx^2}T_n - x\frac{d}{dx}T_n + n^2T_n = 0;</span>

<span class="sd">    :math:`T_n` is a polynomial of degree :math:`n`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : int</span>
<span class="sd">        Degree of the polynomial.</span>
<span class="sd">    monic : bool, optional</span>
<span class="sd">        If `True`, scale the leading coefficient to be 1. Default is</span>
<span class="sd">        `False`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    T : orthopoly1d</span>
<span class="sd">        Chebyshev polynomial of the first kind.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    chebyu : Chebyshev polynomial of the second kind.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The polynomials :math:`T_n` are orthogonal over :math:`[-1, 1]`</span>
<span class="sd">    with weight function :math:`(1 - x^2)^{-1/2}`.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [AS] Milton Abramowitz and Irene A. Stegun, eds.</span>
<span class="sd">        Handbook of Mathematical Functions with Formulas,</span>
<span class="sd">        Graphs, and Mathematical Tables. New York: Dover, 1972.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Chebyshev polynomials of the first kind of order :math:`n` can</span>
<span class="sd">    be obtained as the determinant of specific :math:`n \times n`</span>
<span class="sd">    matrices. As an example we can check how the points obtained from</span>
<span class="sd">    the determinant of the following :math:`3 \times 3` matrix</span>
<span class="sd">    lay exactly on :math:`T_3`:</span>

<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; from scipy.linalg import det</span>
<span class="sd">    &gt;&gt;&gt; from scipy.special import chebyt</span>
<span class="sd">    &gt;&gt;&gt; x = np.arange(-1.0, 1.0, 0.01)</span>
<span class="sd">    &gt;&gt;&gt; fig, ax = plt.subplots()</span>
<span class="sd">    &gt;&gt;&gt; ax.set_ylim(-2.0, 2.0)</span>
<span class="sd">    &gt;&gt;&gt; ax.set_title(r&#39;Chebyshev polynomial $T_3$&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax.plot(x, chebyt(3)(x), label=rf&#39;$T_3$&#39;)</span>
<span class="sd">    &gt;&gt;&gt; for p in np.arange(-1.0, 1.0, 0.1):</span>
<span class="sd">    ...     ax.plot(p,</span>
<span class="sd">    ...             det(np.array([[p, 1, 0], [1, 2*p, 1], [0, 1, 2*p]])),</span>
<span class="sd">    ...             &#39;rx&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.legend(loc=&#39;best&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    They are also related to the Jacobi Polynomials</span>
<span class="sd">    :math:`P_n^{(-0.5, -0.5)}` through the relation:</span>

<span class="sd">    .. math::</span>
<span class="sd">        P_n^{(-0.5, -0.5)}(x) = \frac{1}{4^n} \binom{2n}{n} T_n(x)</span>

<span class="sd">    Let&#39;s verify it for :math:`n = 3`:</span>

<span class="sd">    &gt;&gt;&gt; from scipy.special import binom</span>
<span class="sd">    &gt;&gt;&gt; from scipy.special import jacobi</span>
<span class="sd">    &gt;&gt;&gt; x = np.arange(-1.0, 1.0, 0.01)</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(jacobi(3, -0.5, -0.5)(x),</span>
<span class="sd">    ...             1/64 * binom(6, 3) * chebyt(3)(x))</span>
<span class="sd">    True</span>

<span class="sd">    We can plot the Chebyshev polynomials :math:`T_n` for some values</span>
<span class="sd">    of :math:`n`:</span>

<span class="sd">    &gt;&gt;&gt; x = np.arange(-1.5, 1.5, 0.01)</span>
<span class="sd">    &gt;&gt;&gt; fig, ax = plt.subplots()</span>
<span class="sd">    &gt;&gt;&gt; ax.set_ylim(-4.0, 4.0)</span>
<span class="sd">    &gt;&gt;&gt; ax.set_title(r&#39;Chebyshev polynomials $T_n$&#39;)</span>
<span class="sd">    &gt;&gt;&gt; for n in np.arange(2,5):</span>
<span class="sd">    ...     ax.plot(x, chebyt(n)(x), label=rf&#39;$T_n={n}$&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.legend(loc=&#39;best&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;n must be nonnegative.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">wfunc</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">orthopoly1d</span><span class="p">([],</span> <span class="p">[],</span> <span class="n">pi</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">wfunc</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">monic</span><span class="p">,</span>
                           <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">_ufuncs</span><span class="o">.</span><span class="n">eval_chebyt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span>
    <span class="n">n1</span> <span class="o">=</span> <span class="n">n</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">mu</span> <span class="o">=</span> <span class="n">roots_chebyt</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">hn</span> <span class="o">=</span> <span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="n">kn</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">orthopoly1d</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">hn</span><span class="p">,</span> <span class="n">kn</span><span class="p">,</span> <span class="n">wfunc</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">monic</span><span class="p">,</span>
                    <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">_ufuncs</span><span class="o">.</span><span class="n">eval_chebyt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">p</span>

<span class="c1"># Chebyshev of the second kind</span>
<span class="c1">#    U_n(x) = (n+1)! sqrt(pi) / (2*_gam(n+3./2)) * P^(1/2,1/2)_n(x)</span>


<span class="k">def</span> <span class="nf">roots_chebyu</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Gauss-Chebyshev (second kind) quadrature.</span>

<span class="sd">    Computes the sample points and weights for Gauss-Chebyshev</span>
<span class="sd">    quadrature. The sample points are the roots of the nth degree</span>
<span class="sd">    Chebyshev polynomial of the second kind, :math:`U_n(x)`. These</span>
<span class="sd">    sample points and weights correctly integrate polynomials of</span>
<span class="sd">    degree :math:`2n - 1` or less over the interval :math:`[-1, 1]`</span>
<span class="sd">    with weight function :math:`w(x) = \sqrt{1 - x^2}`. See 22.2.5 in</span>
<span class="sd">    [AS]_ for details.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : int</span>
<span class="sd">        quadrature order</span>
<span class="sd">    mu : bool, optional</span>
<span class="sd">        If True, return the sum of the weights, optional.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    x : ndarray</span>
<span class="sd">        Sample points</span>
<span class="sd">    w : ndarray</span>
<span class="sd">        Weights</span>
<span class="sd">    mu : float</span>
<span class="sd">        Sum of the weights</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    scipy.integrate.quadrature</span>
<span class="sd">    scipy.integrate.fixed_quad</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [AS] Milton Abramowitz and Irene A. Stegun, eds.</span>
<span class="sd">        Handbook of Mathematical Functions with Formulas,</span>
<span class="sd">        Graphs, and Mathematical Tables. New York: Dover, 1972.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">m</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">n</span> <span class="o">!=</span> <span class="n">m</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;n must be a positive integer.&#39;</span><span class="p">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">pi</span> <span class="o">/</span> <span class="p">(</span><span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="n">w</span> <span class="o">=</span> <span class="n">pi</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">mu</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">w</span>


<span class="k">def</span> <span class="nf">chebyu</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">monic</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Chebyshev polynomial of the second kind.</span>

<span class="sd">    Defined to be the solution of</span>

<span class="sd">    .. math::</span>
<span class="sd">        (1 - x^2)\frac{d^2}{dx^2}U_n - 3x\frac{d}{dx}U_n</span>
<span class="sd">          + n(n + 2)U_n = 0;</span>

<span class="sd">    :math:`U_n` is a polynomial of degree :math:`n`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : int</span>
<span class="sd">        Degree of the polynomial.</span>
<span class="sd">    monic : bool, optional</span>
<span class="sd">        If `True`, scale the leading coefficient to be 1. Default is</span>
<span class="sd">        `False`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    U : orthopoly1d</span>
<span class="sd">        Chebyshev polynomial of the second kind.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    chebyt : Chebyshev polynomial of the first kind.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The polynomials :math:`U_n` are orthogonal over :math:`[-1, 1]`</span>
<span class="sd">    with weight function :math:`(1 - x^2)^{1/2}`.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [AS] Milton Abramowitz and Irene A. Stegun, eds.</span>
<span class="sd">        Handbook of Mathematical Functions with Formulas,</span>
<span class="sd">        Graphs, and Mathematical Tables. New York: Dover, 1972.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Chebyshev polynomials of the second kind of order :math:`n` can</span>
<span class="sd">    be obtained as the determinant of specific :math:`n \times n`</span>
<span class="sd">    matrices. As an example we can check how the points obtained from</span>
<span class="sd">    the determinant of the following :math:`3 \times 3` matrix</span>
<span class="sd">    lay exactly on :math:`U_3`:</span>

<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; from scipy.linalg import det</span>
<span class="sd">    &gt;&gt;&gt; from scipy.special import chebyu</span>
<span class="sd">    &gt;&gt;&gt; x = np.arange(-1.0, 1.0, 0.01)</span>
<span class="sd">    &gt;&gt;&gt; fig, ax = plt.subplots()</span>
<span class="sd">    &gt;&gt;&gt; ax.set_ylim(-2.0, 2.0)</span>
<span class="sd">    &gt;&gt;&gt; ax.set_title(r&#39;Chebyshev polynomial $U_3$&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax.plot(x, chebyu(3)(x), label=rf&#39;$U_3$&#39;)</span>
<span class="sd">    &gt;&gt;&gt; for p in np.arange(-1.0, 1.0, 0.1):</span>
<span class="sd">    ...     ax.plot(p,</span>
<span class="sd">    ...             det(np.array([[2*p, 1, 0], [1, 2*p, 1], [0, 1, 2*p]])),</span>
<span class="sd">    ...             &#39;rx&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.legend(loc=&#39;best&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    They satisfy the recurrence relation:</span>

<span class="sd">    .. math::</span>
<span class="sd">        U_{2n-1}(x) = 2 T_n(x)U_{n-1}(x)</span>

<span class="sd">    where the :math:`T_n` are the Chebyshev polynomial of the first kind.</span>
<span class="sd">    Let&#39;s verify it for :math:`n = 2`:</span>

<span class="sd">    &gt;&gt;&gt; from scipy.special import chebyt</span>
<span class="sd">    &gt;&gt;&gt; x = np.arange(-1.0, 1.0, 0.01)</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(chebyu(3)(x), 2 * chebyt(2)(x) * chebyu(1)(x))</span>
<span class="sd">    True</span>

<span class="sd">    We can plot the Chebyshev polynomials :math:`U_n` for some values</span>
<span class="sd">    of :math:`n`:</span>

<span class="sd">    &gt;&gt;&gt; x = np.arange(-1.0, 1.0, 0.01)</span>
<span class="sd">    &gt;&gt;&gt; fig, ax = plt.subplots()</span>
<span class="sd">    &gt;&gt;&gt; ax.set_ylim(-1.5, 1.5)</span>
<span class="sd">    &gt;&gt;&gt; ax.set_title(r&#39;Chebyshev polynomials $U_n$&#39;)</span>
<span class="sd">    &gt;&gt;&gt; for n in np.arange(1,5):</span>
<span class="sd">    ...     ax.plot(x, chebyu(n)(x), label=rf&#39;$U_n={n}$&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.legend(loc=&#39;best&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">base</span> <span class="o">=</span> <span class="n">jacobi</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">monic</span><span class="o">=</span><span class="n">monic</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">monic</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">base</span>
    <span class="n">factor</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">pi</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">_gam</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">_gam</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mf">1.5</span><span class="p">)</span>
    <span class="n">base</span><span class="o">.</span><span class="n">_scale</span><span class="p">(</span><span class="n">factor</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">base</span>

<span class="c1"># Chebyshev of the first kind        C_n(x)</span>


<span class="k">def</span> <span class="nf">roots_chebyc</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Gauss-Chebyshev (first kind) quadrature.</span>

<span class="sd">    Compute the sample points and weights for Gauss-Chebyshev</span>
<span class="sd">    quadrature. The sample points are the roots of the nth degree</span>
<span class="sd">    Chebyshev polynomial of the first kind, :math:`C_n(x)`. These</span>
<span class="sd">    sample points and weights correctly integrate polynomials of</span>
<span class="sd">    degree :math:`2n - 1` or less over the interval :math:`[-2, 2]`</span>
<span class="sd">    with weight function :math:`w(x) = 1 / \sqrt{1 - (x/2)^2}`. See</span>
<span class="sd">    22.2.6 in [AS]_ for more details.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : int</span>
<span class="sd">        quadrature order</span>
<span class="sd">    mu : bool, optional</span>
<span class="sd">        If True, return the sum of the weights, optional.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    x : ndarray</span>
<span class="sd">        Sample points</span>
<span class="sd">    w : ndarray</span>
<span class="sd">        Weights</span>
<span class="sd">    mu : float</span>
<span class="sd">        Sum of the weights</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    scipy.integrate.quadrature</span>
<span class="sd">    scipy.integrate.fixed_quad</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [AS] Milton Abramowitz and Irene A. Stegun, eds.</span>
<span class="sd">        Handbook of Mathematical Functions with Formulas,</span>
<span class="sd">        Graphs, and Mathematical Tables. New York: Dover, 1972.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="n">roots_chebyt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">*=</span> <span class="mi">2</span>
    <span class="n">w</span> <span class="o">*=</span> <span class="mi">2</span>
    <span class="n">m</span> <span class="o">*=</span> <span class="mi">2</span>
    <span class="k">if</span> <span class="n">mu</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">m</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">w</span>


<span class="k">def</span> <span class="nf">chebyc</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">monic</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Chebyshev polynomial of the first kind on :math:`[-2, 2]`.</span>

<span class="sd">    Defined as :math:`C_n(x) = 2T_n(x/2)`, where :math:`T_n` is the</span>
<span class="sd">    nth Chebychev polynomial of the first kind.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : int</span>
<span class="sd">        Degree of the polynomial.</span>
<span class="sd">    monic : bool, optional</span>
<span class="sd">        If `True`, scale the leading coefficient to be 1. Default is</span>
<span class="sd">        `False`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    C : orthopoly1d</span>
<span class="sd">        Chebyshev polynomial of the first kind on :math:`[-2, 2]`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    chebyt : Chebyshev polynomial of the first kind.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The polynomials :math:`C_n(x)` are orthogonal over :math:`[-2, 2]`</span>
<span class="sd">    with weight function :math:`1/\sqrt{1 - (x/2)^2}`.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Abramowitz and Stegun, &quot;Handbook of Mathematical Functions&quot;</span>
<span class="sd">           Section 22. National Bureau of Standards, 1972.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;n must be nonnegative.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="n">n</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">roots_chebyc</span><span class="p">(</span><span class="n">n1</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
    <span class="n">hn</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">pi</span> <span class="o">*</span> <span class="p">((</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">kn</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">orthopoly1d</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">hn</span><span class="p">,</span> <span class="n">kn</span><span class="p">,</span>
                    <span class="n">wfunc</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span> <span class="o">/</span> <span class="mf">4.0</span><span class="p">),</span>
                    <span class="n">limits</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">monic</span><span class="o">=</span><span class="n">monic</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">monic</span><span class="p">:</span>
        <span class="n">p</span><span class="o">.</span><span class="n">_scale</span><span class="p">(</span><span class="mf">2.0</span> <span class="o">/</span> <span class="n">p</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
        <span class="n">p</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s1">&#39;_eval_func&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">_ufuncs</span><span class="o">.</span><span class="n">eval_chebyc</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">p</span>

<span class="c1"># Chebyshev of the second kind       S_n(x)</span>


<span class="k">def</span> <span class="nf">roots_chebys</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Gauss-Chebyshev (second kind) quadrature.</span>

<span class="sd">    Compute the sample points and weights for Gauss-Chebyshev</span>
<span class="sd">    quadrature. The sample points are the roots of the nth degree</span>
<span class="sd">    Chebyshev polynomial of the second kind, :math:`S_n(x)`. These</span>
<span class="sd">    sample points and weights correctly integrate polynomials of</span>
<span class="sd">    degree :math:`2n - 1` or less over the interval :math:`[-2, 2]`</span>
<span class="sd">    with weight function :math:`w(x) = \sqrt{1 - (x/2)^2}`. See 22.2.7</span>
<span class="sd">    in [AS]_ for more details.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : int</span>
<span class="sd">        quadrature order</span>
<span class="sd">    mu : bool, optional</span>
<span class="sd">        If True, return the sum of the weights, optional.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    x : ndarray</span>
<span class="sd">        Sample points</span>
<span class="sd">    w : ndarray</span>
<span class="sd">        Weights</span>
<span class="sd">    mu : float</span>
<span class="sd">        Sum of the weights</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    scipy.integrate.quadrature</span>
<span class="sd">    scipy.integrate.fixed_quad</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [AS] Milton Abramowitz and Irene A. Stegun, eds.</span>
<span class="sd">        Handbook of Mathematical Functions with Formulas,</span>
<span class="sd">        Graphs, and Mathematical Tables. New York: Dover, 1972.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="n">roots_chebyu</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">*=</span> <span class="mi">2</span>
    <span class="n">w</span> <span class="o">*=</span> <span class="mi">2</span>
    <span class="n">m</span> <span class="o">*=</span> <span class="mi">2</span>
    <span class="k">if</span> <span class="n">mu</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">m</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">w</span>


<span class="k">def</span> <span class="nf">chebys</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">monic</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Chebyshev polynomial of the second kind on :math:`[-2, 2]`.</span>

<span class="sd">    Defined as :math:`S_n(x) = U_n(x/2)` where :math:`U_n` is the</span>
<span class="sd">    nth Chebychev polynomial of the second kind.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : int</span>
<span class="sd">        Degree of the polynomial.</span>
<span class="sd">    monic : bool, optional</span>
<span class="sd">        If `True`, scale the leading coefficient to be 1. Default is</span>
<span class="sd">        `False`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    S : orthopoly1d</span>
<span class="sd">        Chebyshev polynomial of the second kind on :math:`[-2, 2]`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    chebyu : Chebyshev polynomial of the second kind</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The polynomials :math:`S_n(x)` are orthogonal over :math:`[-2, 2]`</span>
<span class="sd">    with weight function :math:`\sqrt{1 - (x/2)}^2`.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Abramowitz and Stegun, &quot;Handbook of Mathematical Functions&quot;</span>
<span class="sd">           Section 22. National Bureau of Standards, 1972.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;n must be nonnegative.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="n">n</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">roots_chebys</span><span class="p">(</span><span class="n">n1</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
    <span class="n">hn</span> <span class="o">=</span> <span class="n">pi</span>
    <span class="n">kn</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">orthopoly1d</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">hn</span><span class="p">,</span> <span class="n">kn</span><span class="p">,</span>
                    <span class="n">wfunc</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span> <span class="o">/</span> <span class="mf">4.0</span><span class="p">),</span>
                    <span class="n">limits</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">monic</span><span class="o">=</span><span class="n">monic</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">monic</span><span class="p">:</span>
        <span class="n">factor</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">/</span> <span class="n">p</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">p</span><span class="o">.</span><span class="n">_scale</span><span class="p">(</span><span class="n">factor</span><span class="p">)</span>
        <span class="n">p</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s1">&#39;_eval_func&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">_ufuncs</span><span class="o">.</span><span class="n">eval_chebys</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">p</span>

<span class="c1"># Shifted Chebyshev of the first kind     T^*_n(x)</span>


<span class="k">def</span> <span class="nf">roots_sh_chebyt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Gauss-Chebyshev (first kind, shifted) quadrature.</span>

<span class="sd">    Compute the sample points and weights for Gauss-Chebyshev</span>
<span class="sd">    quadrature. The sample points are the roots of the nth degree</span>
<span class="sd">    shifted Chebyshev polynomial of the first kind, :math:`T_n(x)`.</span>
<span class="sd">    These sample points and weights correctly integrate polynomials of</span>
<span class="sd">    degree :math:`2n - 1` or less over the interval :math:`[0, 1]`</span>
<span class="sd">    with weight function :math:`w(x) = 1/\sqrt{x - x^2}`. See 22.2.8</span>
<span class="sd">    in [AS]_ for more details.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : int</span>
<span class="sd">        quadrature order</span>
<span class="sd">    mu : bool, optional</span>
<span class="sd">        If True, return the sum of the weights, optional.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    x : ndarray</span>
<span class="sd">        Sample points</span>
<span class="sd">    w : ndarray</span>
<span class="sd">        Weights</span>
<span class="sd">    mu : float</span>
<span class="sd">        Sum of the weights</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    scipy.integrate.quadrature</span>
<span class="sd">    scipy.integrate.fixed_quad</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [AS] Milton Abramowitz and Irene A. Stegun, eds.</span>
<span class="sd">        Handbook of Mathematical Functions with Formulas,</span>
<span class="sd">        Graphs, and Mathematical Tables. New York: Dover, 1972.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">xw</span> <span class="o">=</span> <span class="n">roots_chebyt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">mu</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">((</span><span class="n">xw</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,)</span> <span class="o">+</span> <span class="n">xw</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>


<span class="k">def</span> <span class="nf">sh_chebyt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">monic</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Shifted Chebyshev polynomial of the first kind.</span>

<span class="sd">    Defined as :math:`T^*_n(x) = T_n(2x - 1)` for :math:`T_n` the nth</span>
<span class="sd">    Chebyshev polynomial of the first kind.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : int</span>
<span class="sd">        Degree of the polynomial.</span>
<span class="sd">    monic : bool, optional</span>
<span class="sd">        If `True`, scale the leading coefficient to be 1. Default is</span>
<span class="sd">        `False`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    T : orthopoly1d</span>
<span class="sd">        Shifted Chebyshev polynomial of the first kind.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The polynomials :math:`T^*_n` are orthogonal over :math:`[0, 1]`</span>
<span class="sd">    with weight function :math:`(x - x^2)^{-1/2}`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">base</span> <span class="o">=</span> <span class="n">sh_jacobi</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">monic</span><span class="o">=</span><span class="n">monic</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">monic</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">base</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">factor</span> <span class="o">=</span> <span class="mi">4</span><span class="o">**</span><span class="n">n</span> <span class="o">/</span> <span class="mf">2.0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">factor</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="n">base</span><span class="o">.</span><span class="n">_scale</span><span class="p">(</span><span class="n">factor</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">base</span>


<span class="c1"># Shifted Chebyshev of the second kind    U^*_n(x)</span>
<span class="k">def</span> <span class="nf">roots_sh_chebyu</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Gauss-Chebyshev (second kind, shifted) quadrature.</span>

<span class="sd">    Computes the sample points and weights for Gauss-Chebyshev</span>
<span class="sd">    quadrature. The sample points are the roots of the nth degree</span>
<span class="sd">    shifted Chebyshev polynomial of the second kind, :math:`U_n(x)`.</span>
<span class="sd">    These sample points and weights correctly integrate polynomials of</span>
<span class="sd">    degree :math:`2n - 1` or less over the interval :math:`[0, 1]`</span>
<span class="sd">    with weight function :math:`w(x) = \sqrt{x - x^2}`. See 22.2.9 in</span>
<span class="sd">    [AS]_ for more details.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : int</span>
<span class="sd">        quadrature order</span>
<span class="sd">    mu : bool, optional</span>
<span class="sd">        If True, return the sum of the weights, optional.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    x : ndarray</span>
<span class="sd">        Sample points</span>
<span class="sd">    w : ndarray</span>
<span class="sd">        Weights</span>
<span class="sd">    mu : float</span>
<span class="sd">        Sum of the weights</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    scipy.integrate.quadrature</span>
<span class="sd">    scipy.integrate.fixed_quad</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [AS] Milton Abramowitz and Irene A. Stegun, eds.</span>
<span class="sd">        Handbook of Mathematical Functions with Formulas,</span>
<span class="sd">        Graphs, and Mathematical Tables. New York: Dover, 1972.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="n">roots_chebyu</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="n">m_us</span> <span class="o">=</span> <span class="n">_ufuncs</span><span class="o">.</span><span class="n">beta</span><span class="p">(</span><span class="mf">1.5</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">)</span>
    <span class="n">w</span> <span class="o">*=</span> <span class="n">m_us</span> <span class="o">/</span> <span class="n">m</span>
    <span class="k">if</span> <span class="n">mu</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">m_us</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">w</span>


<span class="k">def</span> <span class="nf">sh_chebyu</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">monic</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Shifted Chebyshev polynomial of the second kind.</span>

<span class="sd">    Defined as :math:`U^*_n(x) = U_n(2x - 1)` for :math:`U_n` the nth</span>
<span class="sd">    Chebyshev polynomial of the second kind.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : int</span>
<span class="sd">        Degree of the polynomial.</span>
<span class="sd">    monic : bool, optional</span>
<span class="sd">        If `True`, scale the leading coefficient to be 1. Default is</span>
<span class="sd">        `False`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    U : orthopoly1d</span>
<span class="sd">        Shifted Chebyshev polynomial of the second kind.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The polynomials :math:`U^*_n` are orthogonal over :math:`[0, 1]`</span>
<span class="sd">    with weight function :math:`(x - x^2)^{1/2}`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">base</span> <span class="o">=</span> <span class="n">sh_jacobi</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="n">monic</span><span class="o">=</span><span class="n">monic</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">monic</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">base</span>
    <span class="n">factor</span> <span class="o">=</span> <span class="mi">4</span><span class="o">**</span><span class="n">n</span>
    <span class="n">base</span><span class="o">.</span><span class="n">_scale</span><span class="p">(</span><span class="n">factor</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">base</span>

<span class="c1"># Legendre</span>


<span class="k">def</span> <span class="nf">roots_legendre</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Gauss-Legendre quadrature.</span>

<span class="sd">    Compute the sample points and weights for Gauss-Legendre</span>
<span class="sd">    quadrature [GL]_. The sample points are the roots of the nth degree</span>
<span class="sd">    Legendre polynomial :math:`P_n(x)`. These sample points and</span>
<span class="sd">    weights correctly integrate polynomials of degree :math:`2n - 1`</span>
<span class="sd">    or less over the interval :math:`[-1, 1]` with weight function</span>
<span class="sd">    :math:`w(x) = 1`. See 2.2.10 in [AS]_ for more details.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : int</span>
<span class="sd">        quadrature order</span>
<span class="sd">    mu : bool, optional</span>
<span class="sd">        If True, return the sum of the weights, optional.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    x : ndarray</span>
<span class="sd">        Sample points</span>
<span class="sd">    w : ndarray</span>
<span class="sd">        Weights</span>
<span class="sd">    mu : float</span>
<span class="sd">        Sum of the weights</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    scipy.integrate.quadrature</span>
<span class="sd">    scipy.integrate.fixed_quad</span>
<span class="sd">    numpy.polynomial.legendre.leggauss</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [AS] Milton Abramowitz and Irene A. Stegun, eds.</span>
<span class="sd">        Handbook of Mathematical Functions with Formulas,</span>
<span class="sd">        Graphs, and Mathematical Tables. New York: Dover, 1972.</span>
<span class="sd">    .. [GL] Gauss-Legendre quadrature, Wikipedia,</span>
<span class="sd">        https://en.wikipedia.org/wiki/Gauss%E2%80%93Legendre_quadrature</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; from scipy.special import roots_legendre, eval_legendre</span>
<span class="sd">    &gt;&gt;&gt; roots, weights = roots_legendre(9)</span>

<span class="sd">    ``roots`` holds the roots, and ``weights`` holds the weights for</span>
<span class="sd">    Gauss-Legendre quadrature.</span>

<span class="sd">    &gt;&gt;&gt; roots</span>
<span class="sd">    array([-0.96816024, -0.83603111, -0.61337143, -0.32425342,  0.        ,</span>
<span class="sd">            0.32425342,  0.61337143,  0.83603111,  0.96816024])</span>
<span class="sd">    &gt;&gt;&gt; weights</span>
<span class="sd">    array([0.08127439, 0.18064816, 0.2606107 , 0.31234708, 0.33023936,</span>
<span class="sd">           0.31234708, 0.2606107 , 0.18064816, 0.08127439])</span>

<span class="sd">    Verify that we have the roots by evaluating the degree 9 Legendre</span>
<span class="sd">    polynomial at ``roots``.  All the values are approximately zero:</span>

<span class="sd">    &gt;&gt;&gt; eval_legendre(9, roots)</span>
<span class="sd">    array([-8.88178420e-16, -2.22044605e-16,  1.11022302e-16,  1.11022302e-16,</span>
<span class="sd">            0.00000000e+00, -5.55111512e-17, -1.94289029e-16,  1.38777878e-16,</span>
<span class="sd">           -8.32667268e-17])</span>

<span class="sd">    Here we&#39;ll show how the above values can be used to estimate the</span>
<span class="sd">    integral from 1 to 2 of f(t) = t + 1/t with Gauss-Legendre</span>
<span class="sd">    quadrature [GL]_.  First define the function and the integration</span>
<span class="sd">    limits.</span>

<span class="sd">    &gt;&gt;&gt; def f(t):</span>
<span class="sd">    ...    return t + 1/t</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; a = 1</span>
<span class="sd">    &gt;&gt;&gt; b = 2</span>

<span class="sd">    We&#39;ll use ``integral(f(t), t=a, t=b)`` to denote the definite integral</span>
<span class="sd">    of f from t=a to t=b.  The sample points in ``roots`` are from the</span>
<span class="sd">    interval [-1, 1], so we&#39;ll rewrite the integral with the simple change</span>
<span class="sd">    of variable::</span>

<span class="sd">        x = 2/(b - a) * t - (a + b)/(b - a)</span>

<span class="sd">    with inverse::</span>

<span class="sd">        t = (b - a)/2 * x + (a + 2)/2</span>

<span class="sd">    Then::</span>

<span class="sd">        integral(f(t), a, b) =</span>
<span class="sd">            (b - a)/2 * integral(f((b-a)/2*x + (a+b)/2), x=-1, x=1)</span>

<span class="sd">    We can approximate the latter integral with the values returned</span>
<span class="sd">    by `roots_legendre`.</span>

<span class="sd">    Map the roots computed above from [-1, 1] to [a, b].</span>

<span class="sd">    &gt;&gt;&gt; t = (b - a)/2 * roots + (a + b)/2</span>

<span class="sd">    Approximate the integral as the weighted sum of the function values.</span>

<span class="sd">    &gt;&gt;&gt; (b - a)/2 * f(t).dot(weights)</span>
<span class="sd">    2.1931471805599276</span>

<span class="sd">    Compare that to the exact result, which is 3/2 + log(2):</span>

<span class="sd">    &gt;&gt;&gt; 1.5 + np.log(2)</span>
<span class="sd">    2.1931471805599454</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">m</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">n</span> <span class="o">!=</span> <span class="n">m</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;n must be a positive integer.&quot;</span><span class="p">)</span>

    <span class="n">mu0</span> <span class="o">=</span> <span class="mf">2.0</span>
    <span class="k">def</span> <span class="nf">an_func</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
        <span class="k">return</span> <span class="mf">0.0</span> <span class="o">*</span> <span class="n">k</span>
    <span class="k">def</span> <span class="nf">bn_func</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">k</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="n">k</span> <span class="o">*</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">_ufuncs</span><span class="o">.</span><span class="n">eval_legendre</span>
    <span class="k">def</span> <span class="nf">df</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="o">-</span><span class="n">n</span> <span class="o">*</span> <span class="n">x</span> <span class="o">*</span> <span class="n">_ufuncs</span><span class="o">.</span><span class="n">eval_legendre</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
                <span class="o">+</span> <span class="n">n</span> <span class="o">*</span> <span class="n">_ufuncs</span><span class="o">.</span><span class="n">eval_legendre</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">x</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_gen_roots_and_weights</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">mu0</span><span class="p">,</span> <span class="n">an_func</span><span class="p">,</span> <span class="n">bn_func</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">mu</span><span class="p">)</span>


<div class="viewcode-block" id="legendre">
<a class="viewcode-back" href="../../../_autosummary/pipeline.extern.tsys_contamination.legendre.html#pipeline.extern.tsys_contamination.legendre">[docs]</a>
<span class="k">def</span> <span class="nf">legendre</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">monic</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Legendre polynomial.</span>

<span class="sd">    Defined to be the solution of</span>

<span class="sd">    .. math::</span>
<span class="sd">        \frac{d}{dx}\left[(1 - x^2)\frac{d}{dx}P_n(x)\right]</span>
<span class="sd">          + n(n + 1)P_n(x) = 0;</span>

<span class="sd">    :math:`P_n(x)` is a polynomial of degree :math:`n`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : int</span>
<span class="sd">        Degree of the polynomial.</span>
<span class="sd">    monic : bool, optional</span>
<span class="sd">        If `True`, scale the leading coefficient to be 1. Default is</span>
<span class="sd">        `False`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    P : orthopoly1d</span>
<span class="sd">        Legendre polynomial.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The polynomials :math:`P_n` are orthogonal over :math:`[-1, 1]`</span>
<span class="sd">    with weight function 1.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Generate the 3rd-order Legendre polynomial 1/2*(5x^3 + 0x^2 - 3x + 0):</span>

<span class="sd">    &gt;&gt;&gt; from scipy.special import legendre</span>
<span class="sd">    &gt;&gt;&gt; legendre(3)</span>
<span class="sd">    poly1d([ 2.5,  0. , -1.5,  0. ])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;n must be nonnegative.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="n">n</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">roots_legendre</span><span class="p">(</span><span class="n">n1</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
    <span class="n">hn</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">kn</span> <span class="o">=</span> <span class="n">_gam</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">_gam</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="mf">2.0</span><span class="o">**</span><span class="n">n</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">orthopoly1d</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">hn</span><span class="p">,</span> <span class="n">kn</span><span class="p">,</span> <span class="n">wfunc</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">limits</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
                    <span class="n">monic</span><span class="o">=</span><span class="n">monic</span><span class="p">,</span>
                    <span class="n">eval_func</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">_ufuncs</span><span class="o">.</span><span class="n">eval_legendre</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">p</span></div>


<span class="c1"># Shifted Legendre              P^*_n(x)</span>


<span class="k">def</span> <span class="nf">roots_sh_legendre</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Gauss-Legendre (shifted) quadrature.</span>

<span class="sd">    Compute the sample points and weights for Gauss-Legendre</span>
<span class="sd">    quadrature. The sample points are the roots of the nth degree</span>
<span class="sd">    shifted Legendre polynomial :math:`P^*_n(x)`. These sample points</span>
<span class="sd">    and weights correctly integrate polynomials of degree :math:`2n -</span>
<span class="sd">    1` or less over the interval :math:`[0, 1]` with weight function</span>
<span class="sd">    :math:`w(x) = 1.0`. See 2.2.11 in [AS]_ for details.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : int</span>
<span class="sd">        quadrature order</span>
<span class="sd">    mu : bool, optional</span>
<span class="sd">        If True, return the sum of the weights, optional.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    x : ndarray</span>
<span class="sd">        Sample points</span>
<span class="sd">    w : ndarray</span>
<span class="sd">        Weights</span>
<span class="sd">    mu : float</span>
<span class="sd">        Sum of the weights</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    scipy.integrate.quadrature</span>
<span class="sd">    scipy.integrate.fixed_quad</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [AS] Milton Abramowitz and Irene A. Stegun, eds.</span>
<span class="sd">        Handbook of Mathematical Functions with Formulas,</span>
<span class="sd">        Graphs, and Mathematical Tables. New York: Dover, 1972.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">roots_legendre</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="n">w</span> <span class="o">/=</span> <span class="mi">2</span>
    <span class="k">if</span> <span class="n">mu</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="mf">1.0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">w</span>


<span class="k">def</span> <span class="nf">sh_legendre</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">monic</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Shifted Legendre polynomial.</span>

<span class="sd">    Defined as :math:`P^*_n(x) = P_n(2x - 1)` for :math:`P_n` the nth</span>
<span class="sd">    Legendre polynomial.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : int</span>
<span class="sd">        Degree of the polynomial.</span>
<span class="sd">    monic : bool, optional</span>
<span class="sd">        If `True`, scale the leading coefficient to be 1. Default is</span>
<span class="sd">        `False`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    P : orthopoly1d</span>
<span class="sd">        Shifted Legendre polynomial.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The polynomials :math:`P^*_n` are orthogonal over :math:`[0, 1]`</span>
<span class="sd">    with weight function 1.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;n must be nonnegative.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">wfunc</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="mf">0.0</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="mf">1.0</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">orthopoly1d</span><span class="p">([],</span> <span class="p">[],</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">wfunc</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">monic</span><span class="p">,</span>
                           <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">_ufuncs</span><span class="o">.</span><span class="n">eval_sh_legendre</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">roots_sh_legendre</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="n">hn</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">n</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">)</span>
    <span class="n">kn</span> <span class="o">=</span> <span class="n">_gam</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">_gam</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">orthopoly1d</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">hn</span><span class="p">,</span> <span class="n">kn</span><span class="p">,</span> <span class="n">wfunc</span><span class="p">,</span> <span class="n">limits</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">monic</span><span class="o">=</span><span class="n">monic</span><span class="p">,</span>
                    <span class="n">eval_func</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">_ufuncs</span><span class="o">.</span><span class="n">eval_sh_legendre</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">p</span>


<span class="c1"># Make the old root function names an alias for the new ones</span>
<span class="n">_modattrs</span> <span class="o">=</span> <span class="nb">globals</span><span class="p">()</span>
<span class="k">for</span> <span class="n">newfun</span><span class="p">,</span> <span class="n">oldfun</span> <span class="ow">in</span> <span class="n">_rootfuns_map</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
    <span class="n">_modattrs</span><span class="p">[</span><span class="n">oldfun</span><span class="p">]</span> <span class="o">=</span> <span class="n">_modattrs</span><span class="p">[</span><span class="n">newfun</span><span class="p">]</span>
    <span class="n">__all__</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">oldfun</span><span class="p">)</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020–2024, Pipeline Dev. Team, build: 2024.2.0.4+149-gc67ed7416-PIPE-1669-run-dev-pipeline-with-modular-casa6.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>