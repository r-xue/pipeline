

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>pipeline.infrastructure.callibrary &mdash; Pipeline 
 (2024.2.0.4) 2025.1.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../_static/mystnb.8ecb98da25f57f5357bf6f572d296f466b2cfe2517ffebfabe82451661e28f02.css" />
      <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css?v=4ae1632d" />
      <link rel="stylesheet" type="text/css" href="../../../_static/sphinx_astrorefs.css?v=4d4a2fdb" />
      <link rel="stylesheet" type="text/css" href="../../../_static/copybutton.css?v=76b2166b" />
      <link rel="stylesheet" type="text/css" href="../../../_static/custom_theme.css?v=047bd54c" />

  
    <link rel="shortcut icon" href="../../../_static/favicon-16x16.png"/>
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=e72a64b0"></script>
      <script src="../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="../../../_static/clipboard.min.js?v=a7894cd8"></script>
      <script src="../../../_static/copybutton.js?v=0729d509"></script>
      <script type="module" src="https://cdn.jsdelivr.net/npm/mermaid@11.12.1/dist/mermaid.esm.min.mjs"></script>
      <script type="module" src="https://cdn.jsdelivr.net/npm/@mermaid-js/layout-elk@0.1.4/dist/mermaid-layout-elk.esm.min.mjs"></script>
      <script type="module">import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@11.12.1/dist/mermaid.esm.min.mjs";import elkLayouts from "https://cdn.jsdelivr.net/npm/@mermaid-js/layout-elk@0.1.4/dist/mermaid-layout-elk.esm.min.mjs";mermaid.registerLayoutLoaders(elkLayouts);mermaid.initialize({startOnLoad:false});</script>
      <script src="https://cdn.jsdelivr.net/npm/d3@7.9.0/dist/d3.min.js"></script>
      <script type="module">import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@11.12.1/dist/mermaid.esm.min.mjs";

const style = document.createElement('style');
style.textContent = `.mermaid-container {
    position: relative !important;
    display: inline-block;
    width: 100%;
}

.mermaid-fullscreen-btn {
    position: absolute !important;
    width: 28px;
    height: 28px;
    background: rgba(255, 255, 255, 0.95);
    border: 1px solid rgba(0, 0, 0, 0.3);
    border-radius: 4px;
    cursor: pointer;
    z-index: 100;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s;
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
    font-size: 14px;
    line-height: 1;
    padding: 0;
    color: #333;
}

.mermaid-fullscreen-btn:hover {
    opacity: 100% !important;
    background: rgba(255, 255, 255, 1);
    box-shadow: 0 3px 10px rgba(0, 0, 0, 0.3);
    transform: scale(1.1);
}

.mermaid-fullscreen-btn.dark-theme {
    background: rgba(50, 50, 50, 0.95);
    border: 1px solid rgba(255, 255, 255, 0.3);
    color: #e0e0e0;
}

.mermaid-fullscreen-btn.dark-theme:hover {
    background: rgba(60, 60, 60, 1);
    box-shadow: 0 3px 10px rgba(255, 255, 255, 0.2);
}

.mermaid-fullscreen-modal {
    display: none;
    position: fixed !important;
    top: 0 !important;
    left: 0 !important;
    width: 100vw;
    height: 100vh;
    background: rgba(255, 255, 255, 0.98);
    z-index: 9999;
    padding: 20px;
    overflow: auto;
}

.mermaid-fullscreen-modal.dark-theme {
    background: rgba(0, 0, 0, 0.98);
}

.mermaid-fullscreen-modal.active {
    display: flex;
    align-items: center;
    justify-content: center;
}

.mermaid-fullscreen-content {
    position: relative;
    width: 95vw;
    height: 90vh;
    max-width: 95vw;
    max-height: 90vh;
    background: white;
    border-radius: 8px;
    padding: 20px;
    box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
    overflow: auto;
    display: flex;
    align-items: center;
    justify-content: center;
}

.mermaid-fullscreen-content.dark-theme {
    background: #1a1a1a;
    box-shadow: 0 10px 40px rgba(0, 0, 0, 0.8);
}

.mermaid-fullscreen-content .mermaid {
    width: 100%;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
}

.mermaid-fullscreen-content .mermaid svg {
    width: 100%;
    height: auto;
    max-width: 100%;
    max-height: 85vh;
    cursor: grab;
}

.mermaid-fullscreen-close {
    position: fixed !important;
    top: 20px !important;
    right: 20px !important;
    width: 40px;
    height: 40px;
    background: rgba(255, 255, 255, 0.95);
    border: 1px solid rgba(0, 0, 0, 0.2);
    border-radius: 50%;
    cursor: pointer;
    z-index: 10000;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    transition: all 0.2s;
    font-size: 24px;
    line-height: 1;
    color: #333;
}

.mermaid-fullscreen-close:hover {
    background: white;
    box-shadow: 0 6px 16px rgba(0, 0, 0, 0.4);
    transform: scale(1.1);
}

.mermaid-fullscreen-close.dark-theme {
    background: rgba(50, 50, 50, 0.95);
    border: 1px solid rgba(255, 255, 255, 0.2);
    color: #e0e0e0;
}

.mermaid-fullscreen-close.dark-theme:hover {
    background: rgba(60, 60, 60, 1);
    box-shadow: 0 6px 16px rgba(255, 255, 255, 0.2);
}

.mermaid-fullscreen-modal .mermaid-fullscreen-btn {
    display: none !important;
}
`;
document.head.appendChild(style);

// Detect if page has dark background
const isDarkTheme = () => {
    const bgColor = window.getComputedStyle(document.body).backgroundColor;
    const match = bgColor.match(/rgb\((\d+),\s*(\d+),\s*(\d+)/);
    if (match) {
        const r = parseInt(match[1]);
        const g = parseInt(match[2]);
        const b = parseInt(match[3]);
        const brightness = (r * 299 + g * 587 + b * 114) / 1000;
        return brightness < 128;
    }
    return false;
};

const load = async () => {
    await mermaid.run();
    const all_mermaids = document.querySelectorAll(".mermaid");
    const mermaids_to_add_zoom = -1 === -1 ? all_mermaids.length : -1;
    const mermaids_processed = document.querySelectorAll(".mermaid[data-processed='true']");
    if(mermaids_to_add_zoom > 0) {
        var svgs = d3.selectAll(".mermaid svg");
        if(all_mermaids.length !== mermaids_processed.length) {
            setTimeout(load, 200);
            return;
        } else if(svgs.size() !== mermaids_to_add_zoom) {
            setTimeout(load, 200);
            return;
        } else {
            svgs.each(function() {
                var svg = d3.select(this);
                svg.html("<g class='wrapper'>" + svg.html() + "</g>");
                var inner = svg.select("g");
                var zoom = d3.zoom().on("zoom", function(event) {
                    inner.attr("transform", event.transform);
                });
                svg.call(zoom);
            });
        }
    }

    const darkTheme = isDarkTheme();

    const modal = document.createElement('div');
    modal.className = 'mermaid-fullscreen-modal' + (darkTheme ? ' dark-theme' : '');
    modal.setAttribute('role', 'dialog');
    modal.setAttribute('aria-modal', 'true');
    modal.setAttribute('aria-label', 'Fullscreen diagram viewer');
    modal.innerHTML = `
        <button class="mermaid-fullscreen-close${darkTheme ? ' dark-theme' : ''}" aria-label="Close fullscreen">✕</button>
        <div class="mermaid-fullscreen-content${darkTheme ? ' dark-theme' : ''}"></div>
    `;
    document.body.appendChild(modal);

    const modalContent = modal.querySelector('.mermaid-fullscreen-content');
    const closeBtn = modal.querySelector('.mermaid-fullscreen-close');

    let previousScrollOffset = [window.scrollX, window.scrollY];

    const closeModal = () => {
        modal.classList.remove('active');
        modalContent.innerHTML = '';
        document.body.style.overflow = ''
        window.scrollTo({left: previousScrollOffset[0], top: previousScrollOffset[1], behavior: 'instant'});
    };

    closeBtn.addEventListener('click', closeModal);
    modal.addEventListener('click', (e) => {
        if (e.target === modal) closeModal();
    });
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && modal.classList.contains('active')) {
            closeModal();
        }
    });

    const allButtons = [];

    document.querySelectorAll('.mermaid').forEach((mermaidDiv) => {
        if (mermaidDiv.parentNode.classList.contains('mermaid-container') ||
            mermaidDiv.closest('.mermaid-fullscreen-modal')) {
            return;
        }

        const container = document.createElement('div');
        container.className = 'mermaid-container';
        mermaidDiv.parentNode.insertBefore(container, mermaidDiv);
        container.appendChild(mermaidDiv);

        const fullscreenBtn = document.createElement('button');
        fullscreenBtn.className = 'mermaid-fullscreen-btn' + (darkTheme ? ' dark-theme' : '');
        fullscreenBtn.setAttribute('aria-label', 'View diagram in fullscreen');
        fullscreenBtn.textContent = '⛶';
        fullscreenBtn.style.opacity = '50%';

        // Calculate dynamic position based on diagram's margin and padding
        const diagramStyle = window.getComputedStyle(mermaidDiv);
        const marginTop = parseFloat(diagramStyle.marginTop) || 0;
        const marginRight = parseFloat(diagramStyle.marginRight) || 0;
        const paddingTop = parseFloat(diagramStyle.paddingTop) || 0;
        const paddingRight = parseFloat(diagramStyle.paddingRight) || 0;
        fullscreenBtn.style.top = `${marginTop + paddingTop + 4}px`;
        fullscreenBtn.style.right = `${marginRight + paddingRight + 4}px`;

        fullscreenBtn.addEventListener('click', () => {
            previousScrollOffset = [window.scroll, window.scrollY];
            const clone = mermaidDiv.cloneNode(true);
            modalContent.innerHTML = '';
            modalContent.appendChild(clone);

            const svg = clone.querySelector('svg');
            if (svg) {
                svg.removeAttribute('width');
                svg.removeAttribute('height');
                svg.style.width = '100%';
                svg.style.height = 'auto';
                svg.style.maxWidth = '100%';
                svg.style.display = 'block';

                setTimeout(() => {
                    const g = svg.querySelector('g');
                    if (g) {
                        var svgD3 = d3.select(svg);
                        svgD3.html("<g class='wrapper'>" + svgD3.html() + "</g>");
                        var inner = svgD3.select("g");
                        var zoom = d3.zoom().on("zoom", function(event) {
                            inner.attr("transform", event.transform);
                        });
                        svgD3.call(zoom);
                    }
                }, 100);
            }

            modal.classList.add('active');
            document.body.style.overflow = 'hidden';
        });

        container.appendChild(fullscreenBtn);
        allButtons.push(fullscreenBtn);
    });

    // Update theme classes when theme changes
    const updateTheme = () => {
        const dark = isDarkTheme();
        allButtons.forEach(btn => {
            if (dark) {
                btn.classList.add('dark-theme');
            } else {
                btn.classList.remove('dark-theme');
            }
        });
        if (dark) {
            modal.classList.add('dark-theme');
            modalContent.classList.add('dark-theme');
            closeBtn.classList.add('dark-theme');
        } else {
            modal.classList.remove('dark-theme');
            modalContent.classList.remove('dark-theme');
            closeBtn.classList.remove('dark-theme');
        }
    };

    // Watch for theme changes
    const observer = new MutationObserver(updateTheme);
    observer.observe(document.documentElement, {
        attributes: true,
        attributeFilter: ['class', 'style', 'data-theme']
    });
    observer.observe(document.body, {
        attributes: true,
        attributeFilter: ['class', 'style']
    });
};

window.addEventListener("load", load);
</script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: gray" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            Pipeline 
 (2024.2.0.4)
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Basics</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../develdocmd/ways_to_run_the_pipeline.html">Ways to run the Pipeline</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../develdocmd/recipes.html">Pipeline Recipes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../dependencies.html">Dependencies of <code class="docutils literal notranslate"><span class="pre">Pipeline</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../releases.html">Releases</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../timeline.html">Roadmap &amp; Branching Strategy</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../apisummary.html">Full APIs (autosummary)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../apisummary.html#pipeline-tasks-autosummary">Pipeline Tasks (autosummary)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../apisummary.html#pipeline-domain-context-autosummary">Pipeline domain/context (autosummary)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../apisummary.html#pipeline-domain-infrastructure-modules-automodapi">Pipeline domain/infrastructure modules (automodapi)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../apisummary.html#pipeline-h-tasks-modules-autmodapi"><code class="docutils literal notranslate"><span class="pre">pipeline.h*.tasks</span></code> modules (autmodapi)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../apisummary.html#inheritance-diagrams-for-pipeline-task-inputs-results-classes">Inheritance Diagrams for Pipeline <code class="docutils literal notranslate"><span class="pre">Task</span></code>/<code class="docutils literal notranslate"><span class="pre">Inputs</span></code>/<code class="docutils literal notranslate"><span class="pre">Results</span></code> Classes</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Developer Notes</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../develdocmd/ALMA-Imaging-Workflow.html">ALMA interferometry imaging workflow</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../develdocmd/VLA-Imaging-Workflow.html">VLA interferometry imaging workflow</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../develdocmd/VLASS-SE-CONT-Imaging-Workflow.html">VLASS-SE-CONT imaging workflow</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../develdocmd/VLASS-SE-CUBE-Imaging-Workflow.html">VLASS-SE-CUBE imaging workflow</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../develdocmd/selfcal_workflow.html">VLASS Selfcal &amp; Restore workflows</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../develdocmd/comparing_pipeline_executions.html">Comparing pipeline executions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../develdocmd/building_the_pipeline.html">Building the pipeline</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../modular.html">Run the Pipeline in a Conda environment</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../develdocmd/pipeline_tests.html">Pipeline testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../develdocmd/DataType_Testing.html">DataType Testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../develdocmd/QA_scores.html">Pipeline Quality Assurance (QA) Score Class Design</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../develdocmd/DeveloperDocumentation.html">Pipeline developer documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../develdocmd/python3_conversion_notes.html">Python 3 conversion notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../heuristics/field_parameter.html">Field parameter</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../heuristics/FlaggingTasks.html">Pipeline Flagging Tasks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notebooks/context.html">Pipeline Context and Domain Objects</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notebooks/tier0dask.html">“Tier0” Parallelization with Dask/Futures</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: gray" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">Pipeline 
 (2024.2.0.4)</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
          <li class="breadcrumb-item"><a href="../../pipeline.html">pipeline</a></li>
      <li class="breadcrumb-item active">pipeline.infrastructure.callibrary</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for pipeline.infrastructure.callibrary</h1><div class="highlight"><pre>
<span></span><span class="c1"># Do not evaluate type annotations at definition time.</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">__future__</span><span class="w"> </span><span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">collections</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">copy</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">datetime</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">functools</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">itertools</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">operator</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">os</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">uuid</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">weakref</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Generator</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">TYPE_CHECKING</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">cachetools</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">intervaltree</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">casatasks.private.callibrary</span><span class="w"> </span><span class="kn">import</span> <span class="n">applycaltocallib</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">.</span><span class="w"> </span><span class="kn">import</span> <span class="n">casa_tools</span><span class="p">,</span> <span class="n">launcher</span><span class="p">,</span> <span class="n">logging</span><span class="p">,</span> <span class="n">utils</span>
<span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">pipeline.domain</span><span class="w"> </span><span class="kn">import</span> <span class="n">Field</span><span class="p">,</span> <span class="n">MeasurementSet</span><span class="p">,</span> <span class="n">SpectralWindow</span>

<span class="n">LOG</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">get_logger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>

<span class="n">CalToArgs</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;CalToArgs&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;vis&#39;</span><span class="p">,</span> <span class="s1">&#39;spw&#39;</span><span class="p">,</span> <span class="s1">&#39;field&#39;</span><span class="p">,</span> <span class="s1">&#39;intent&#39;</span><span class="p">,</span> <span class="s1">&#39;antenna&#39;</span><span class="p">])</span>

<span class="c1"># struct used to link calapplication to the task and inputs that created it</span>
<span class="n">CalAppOrigin</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;CalAppOrigin&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;task&#39;</span><span class="p">,</span> <span class="s1">&#39;inputs&#39;</span><span class="p">])</span>

<span class="c1"># observations before this date are considered Cycle 0 observations</span>
<span class="n">CYCLE_0_END_DATE</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">(</span><span class="mi">2013</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">21</span><span class="p">)</span>


<div class="viewcode-block" id="CalApplication">
<a class="viewcode-back" href="../../../_automodapi/pipeline.infrastructure.callibrary.CalApplication.html#pipeline.infrastructure.callibrary.CalApplication">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">CalApplication</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    CalApplication maps calibration tables and their application arguments to</span>
<span class="sd">    a target data selection, encapsulated as CalFrom and CalTo objects</span>
<span class="sd">    respectively.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        calto: The CalTo representing the data selection to which the</span>
<span class="sd">            calibration should apply.</span>
<span class="sd">        calfrom: The CalFrom representing the calibration and application</span>
<span class="sd">            parameters.</span>
<span class="sd">        origin: The CalAppOrigin marking how this calibration was created.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">calto</span><span class="p">:</span> <span class="n">CalTo</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="n">CalTo</span><span class="p">],</span> <span class="n">calfrom</span><span class="p">:</span> <span class="n">CalFrom</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="n">CalFrom</span><span class="p">],</span>
                 <span class="n">origin</span><span class="p">:</span> <span class="n">CalAppOrigin</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="n">CalAppOrigin</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize a CalApplication object.</span>

<span class="sd">        Args:</span>
<span class="sd">            calto: CalTo object, or list thereof, representing the data</span>
<span class="sd">                selection(s) to which the calibration should apply.</span>
<span class="sd">            calfrom: CalFrom object, or list thereof, representing the</span>
<span class="sd">                calibration and application parameters.</span>
<span class="sd">            origin: CalOrigin object, or list thereof, marking how this</span>
<span class="sd">                calibration was created.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">calto</span> <span class="o">=</span> <span class="n">calto</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">calfrom</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">calfrom</span> <span class="o">=</span> <span class="p">[</span><span class="n">calfrom</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">calfrom</span> <span class="o">=</span> <span class="n">calfrom</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">origin</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">origin</span> <span class="o">=</span> <span class="p">[</span><span class="n">origin</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">origin</span> <span class="o">=</span> <span class="n">origin</span>

<div class="viewcode-block" id="CalApplication.from_export">
<a class="viewcode-back" href="../../../_automodapi/pipeline.infrastructure.callibrary.CalApplication.html#pipeline.infrastructure.callibrary.CalApplication.from_export">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_export</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">CalApplication</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Unmarshal a CalApplication from a string.</span>

<span class="sd">        Args:</span>
<span class="sd">            s: String representation of a CalApplication as a CASA applycal call.</span>

<span class="sd">        Returns:</span>
<span class="sd">            CalApplication object generated from given string.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;applycal(&#39;</span><span class="p">,</span> <span class="s1">&#39;dict(&#39;</span><span class="p">))</span>
        <span class="n">calto</span> <span class="o">=</span> <span class="n">CalTo</span><span class="p">(</span><span class="n">vis</span><span class="o">=</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;vis&#39;</span><span class="p">],</span> <span class="n">field</span><span class="o">=</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;field&#39;</span><span class="p">],</span> <span class="n">spw</span><span class="o">=</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;spw&#39;</span><span class="p">],</span>
                      <span class="n">antenna</span><span class="o">=</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;antenna&#39;</span><span class="p">],</span> <span class="n">intent</span><span class="o">=</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;intent&#39;</span><span class="p">])</span>

        <span class="c1"># wrap these values in a list if they are single valued,</span>
        <span class="c1"># eg. &#39;m31&#39; -&gt; [&#39;m31&#39;]</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;gainfield&#39;</span><span class="p">,</span> <span class="s1">&#39;gaintable&#39;</span><span class="p">,</span> <span class="s1">&#39;interp&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]]</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;calwt&#39;</span><span class="p">,):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="nb">bool</span><span class="p">):</span>
                <span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]]</span>

        <span class="c1"># do the same for spwmap. A bit more complicated, as a single valued</span>
        <span class="c1"># spwmap is a list of integers, or may not have any values at all.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;spwmap&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">d</span><span class="p">[</span><span class="s1">&#39;spwmap&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;spwmap&#39;</span><span class="p">]]</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="n">d</span><span class="p">[</span><span class="s1">&#39;spwmap&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;spwmap&#39;</span><span class="p">]]</span>

        <span class="n">zipped</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;gaintable&#39;</span><span class="p">],</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;gainfield&#39;</span><span class="p">],</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;interp&#39;</span><span class="p">],</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;spwmap&#39;</span><span class="p">],</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;calwt&#39;</span><span class="p">]))</span>

        <span class="n">calfroms</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">gaintable</span><span class="p">,</span> <span class="n">gainfield</span><span class="p">,</span> <span class="n">interp</span><span class="p">,</span> <span class="n">spwmap</span><span class="p">,</span> <span class="n">calwt</span><span class="p">)</span> <span class="ow">in</span> <span class="n">zipped</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">gaintable</span><span class="p">):</span>
                <span class="k">with</span> <span class="n">casa_tools</span><span class="o">.</span><span class="n">TableReader</span><span class="p">(</span><span class="n">gaintable</span><span class="p">)</span> <span class="k">as</span> <span class="n">caltable</span><span class="p">:</span>
                    <span class="n">viscal</span> <span class="o">=</span> <span class="n">caltable</span><span class="o">.</span><span class="n">getkeyword</span><span class="p">(</span><span class="s1">&#39;VisCal&#39;</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">LOG</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Could not access </span><span class="si">{}</span><span class="s1">. Using heuristics to determine caltable type&#39;</span>
                            <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">gaintable</span><span class="p">)))</span>
                <span class="k">if</span> <span class="s1">&#39;tsys&#39;</span> <span class="ow">in</span> <span class="n">gaintable</span><span class="p">:</span>
                    <span class="n">viscal</span> <span class="o">=</span> <span class="s1">&#39;B TSYS&#39;</span>
                <span class="k">elif</span> <span class="s1">&#39;bcal&#39;</span> <span class="ow">in</span> <span class="n">gaintable</span><span class="p">:</span>
                    <span class="n">viscal</span> <span class="o">=</span> <span class="s1">&#39;B JONES&#39;</span>
                <span class="k">elif</span> <span class="s1">&#39;gpcal&#39;</span> <span class="ow">in</span> <span class="n">gaintable</span><span class="p">:</span>
                    <span class="n">viscal</span> <span class="o">=</span> <span class="s1">&#39;G JONES&#39;</span>
                <span class="k">elif</span> <span class="s1">&#39;gcal&#39;</span> <span class="ow">in</span> <span class="n">gaintable</span><span class="p">:</span>
                    <span class="n">viscal</span> <span class="o">=</span> <span class="s1">&#39;G JONES&#39;</span>
                <span class="k">elif</span> <span class="s1">&#39;gacal&#39;</span> <span class="ow">in</span> <span class="n">gaintable</span><span class="p">:</span>
                    <span class="n">viscal</span> <span class="o">=</span> <span class="s1">&#39;G JONES&#39;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">gaintable</span><span class="p">)</span>

            <span class="n">caltype</span> <span class="o">=</span> <span class="n">CalFrom</span><span class="o">.</span><span class="n">get_caltype_for_viscal</span><span class="p">(</span><span class="n">viscal</span><span class="p">)</span>
            <span class="n">calfrom</span> <span class="o">=</span> <span class="n">CalFrom</span><span class="p">(</span><span class="n">gaintable</span><span class="p">,</span> <span class="n">gainfield</span><span class="o">=</span><span class="n">gainfield</span><span class="p">,</span> <span class="n">interp</span><span class="o">=</span><span class="n">interp</span><span class="p">,</span>
                              <span class="n">spwmap</span><span class="o">=</span><span class="n">spwmap</span><span class="p">,</span> <span class="n">calwt</span><span class="o">=</span><span class="n">calwt</span><span class="p">,</span> <span class="n">caltype</span><span class="o">=</span><span class="n">caltype</span><span class="p">)</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;Marking caltable </span><span class="se">\&#39;</span><span class="si">%s</span><span class="se">\&#39;</span><span class="s1"> as caltype </span><span class="se">\&#39;</span><span class="si">%s</span><span class="se">\&#39;</span><span class="s1">&#39;</span>
                      <span class="s1">&#39;&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">gaintable</span><span class="p">,</span> <span class="n">calfrom</span><span class="o">.</span><span class="n">caltype</span><span class="p">))</span>

            <span class="n">calfroms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">calfrom</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">CalApplication</span><span class="p">(</span><span class="n">calto</span><span class="p">,</span> <span class="n">calfroms</span><span class="p">)</span></div>


<div class="viewcode-block" id="CalApplication.as_applycal">
<a class="viewcode-back" href="../../../_automodapi/pipeline.infrastructure.callibrary.CalApplication.html#pipeline.infrastructure.callibrary.CalApplication.as_applycal">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">as_applycal</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get a representation of this object as a CASA applycal call.</span>

<span class="sd">        Returns:</span>
<span class="sd">            String representation of CalApplication as a CASA applycal call.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;vis&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">vis</span><span class="p">,</span>
            <span class="s1">&#39;field&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">field</span><span class="p">,</span>
            <span class="s1">&#39;intent&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">intent</span><span class="p">,</span>
            <span class="s1">&#39;spw&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">spw</span><span class="p">,</span>
            <span class="s1">&#39;antenna&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">antenna</span><span class="p">,</span>
            <span class="s1">&#39;gaintable&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">gaintable</span><span class="p">,</span>
            <span class="s1">&#39;gainfield&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">gainfield</span><span class="p">,</span>
            <span class="s1">&#39;spwmap&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">spwmap</span><span class="p">,</span>
            <span class="s1">&#39;interp&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">interp</span><span class="p">,</span>
            <span class="s1">&#39;calwt&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">calwt</span>
        <span class="p">}</span>

        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;gaintable&#39;</span><span class="p">,</span> <span class="s1">&#39;gainfield&#39;</span><span class="p">,</span> <span class="s1">&#39;spwmap&#39;</span><span class="p">,</span> <span class="s1">&#39;interp&#39;</span><span class="p">,</span> <span class="s1">&#39;calwt&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">args</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\&#39;</span><span class="si">%s</span><span class="se">\&#39;</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">args</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

        <span class="k">return</span> <span class="p">(</span><span class="s1">&#39;applycal(vis=</span><span class="se">\&#39;</span><span class="si">{vis}</span><span class="se">\&#39;</span><span class="s1">, field=</span><span class="se">\&#39;</span><span class="si">{field}</span><span class="se">\&#39;</span><span class="s1">, &#39;</span>
                <span class="s1">&#39;intent=</span><span class="se">\&#39;</span><span class="si">{intent}</span><span class="se">\&#39;</span><span class="s1">, spw=</span><span class="se">\&#39;</span><span class="si">{spw}</span><span class="se">\&#39;</span><span class="s1">, antenna=</span><span class="se">\&#39;</span><span class="si">{antenna}</span><span class="se">\&#39;</span><span class="s1">, &#39;</span>
                <span class="s1">&#39;gaintable=</span><span class="si">{gaintable}</span><span class="s1">, gainfield=</span><span class="si">{gainfield}</span><span class="s1">, &#39;</span>
                <span class="s1">&#39;spwmap=</span><span class="si">{spwmap}</span><span class="s1">, interp=</span><span class="si">{interp}</span><span class="s1">, calwt=</span><span class="si">{calwt}</span><span class="s1">)&#39;</span>
                <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">**</span><span class="n">args</span><span class="p">))</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">antenna</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The antennas to which the calibrations apply.</span>

<span class="sd">        Returns:</span>
<span class="sd">            String representing the (comma-separated) antennas to which the</span>
<span class="sd">            calibrations apply.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">calto</span><span class="o">.</span><span class="n">antenna</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">calwt</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">bool</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The calwt parameter to be used when applying these calibrations.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Boolean representing what to use for calwt for this calibration.</span>
<span class="sd">            If there are multiple CalFrom objects to apply, this returns a list</span>
<span class="sd">            of booleans, one per CalFrom.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">l</span> <span class="o">=</span> <span class="p">[</span><span class="n">cf</span><span class="o">.</span><span class="n">calwt</span> <span class="k">for</span> <span class="n">cf</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">calfrom</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">l</span>

<div class="viewcode-block" id="CalApplication.exists">
<a class="viewcode-back" href="../../../_automodapi/pipeline.infrastructure.callibrary.CalApplication.html#pipeline.infrastructure.callibrary.CalApplication.exists">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">exists</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Test whether all calibration tables referred to by this application exist.</span>

<span class="sd">        Returns:</span>
<span class="sd">            True if all calibration tables exist in the file system.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">cf</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">calfrom</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">cf</span><span class="o">.</span><span class="n">gaintable</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">field</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The field(s) to which the calibrations apply.</span>

<span class="sd">        Returns:</span>
<span class="sd">            String representing the field(s) (comma-separated) to apply the</span>
<span class="sd">            calibrations to.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">calto</span><span class="o">.</span><span class="n">field</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">gainfield</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The gainfield parameters to be used when applying these calibrations.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Value for the gainfield parameter to be used when applying these</span>
<span class="sd">            calibrations; returns a scalar string if representing 1 calibration,</span>
<span class="sd">            otherwise a list of strings.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">l</span> <span class="o">=</span> <span class="p">[</span><span class="n">cf</span><span class="o">.</span><span class="n">gainfield</span> <span class="k">for</span> <span class="n">cf</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">calfrom</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">l</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">gaintable</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The gaintable parameters to be used when applying these calibrations.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Value for the gaintable parameter to be used when applying these</span>
<span class="sd">            calibrations; returns a scalar string if representing 1 calibration,</span>
<span class="sd">            otherwise a list of strings.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">l</span> <span class="o">=</span> <span class="p">[</span><span class="n">cf</span><span class="o">.</span><span class="n">gaintable</span> <span class="k">for</span> <span class="n">cf</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">calfrom</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">l</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">intent</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The observing intent(s) to which the calibrations apply.</span>

<span class="sd">        Returns:</span>
<span class="sd">            String representing the intent(s) (comma-separated) to apply the</span>
<span class="sd">            calibrations to.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">calto</span><span class="o">.</span><span class="n">intent</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">interp</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The interp parameters to be used when applying these calibrations.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Value for the interp parameter to be used when applying these</span>
<span class="sd">            calibrations; returns a scalar string if representing 1 calibration,</span>
<span class="sd">            otherwise a list of strings.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">l</span> <span class="o">=</span> <span class="p">[</span><span class="n">cf</span><span class="o">.</span><span class="n">interp</span> <span class="k">for</span> <span class="n">cf</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">calfrom</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">l</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">spw</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Spectral window(s) to which the calibrations apply.</span>

<span class="sd">        Returns:</span>
<span class="sd">            String representing the spectral window id(s) (comma-separated) to</span>
<span class="sd">            apply the calibrations to.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">calto</span><span class="o">.</span><span class="n">spw</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">spwmap</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The spwmap parameters to be used when applying these calibrations.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Value for the spwmap parameter to be used when applying these</span>
<span class="sd">            calibrations; returns a scalar string if representing 1 calibration,</span>
<span class="sd">            otherwise a list of strings.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># convert tuples back into lists for the CASA argument</span>
        <span class="n">l</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">cf</span><span class="o">.</span><span class="n">spwmap</span><span class="p">)</span> <span class="k">for</span> <span class="n">cf</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">calfrom</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">l</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">vis</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Name of the measurement set to which the calibrations apply.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The name of the measurement set to which the calibrations apply.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">calto</span><span class="o">.</span><span class="n">vis</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_applycal</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="s1">&#39;CalApplication(</span><span class="si">%s</span><span class="s1">, </span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">calto</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">calfrom</span><span class="p">)</span></div>



<div class="viewcode-block" id="CalTo">
<a class="viewcode-back" href="../../../_automodapi/pipeline.infrastructure.callibrary.CalTo.html#pipeline.infrastructure.callibrary.CalTo">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">CalTo</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    CalTo represents a target data selection to which a calibration can be</span>
<span class="sd">    applied.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;_antenna&#39;</span><span class="p">,</span> <span class="s1">&#39;_intent&#39;</span><span class="p">,</span> <span class="s1">&#39;_field&#39;</span><span class="p">,</span> <span class="s1">&#39;_spw&#39;</span><span class="p">,</span> <span class="s1">&#39;_vis&#39;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Define what to pickle as a class instance.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_antenna</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_intent</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_field</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_spw</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vis</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Define how to unpickle a class instance.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_antenna</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_intent</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_field</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_spw</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vis</span> <span class="o">=</span> <span class="n">state</span>

<div class="viewcode-block" id="CalTo.from_caltoargs">
<a class="viewcode-back" href="../../../_automodapi/pipeline.infrastructure.callibrary.CalTo.html#pipeline.infrastructure.callibrary.CalTo.from_caltoargs">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_caltoargs</span><span class="p">(</span><span class="n">cta</span><span class="p">:</span> <span class="n">CalToArgs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">CalTo</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a CalTo object for given arguments ``cta``.</span>

<span class="sd">        Args:</span>
<span class="sd">            cta: CalToArgs object representing the arguments for the new CalTo object.</span>

<span class="sd">        Returns:</span>
<span class="sd">            CalTo object initialized with given arguments ``cta``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">join</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">((</span><span class="nb">str</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">s</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">CalTo</span><span class="p">(</span><span class="n">vis</span><span class="o">=</span><span class="n">join</span><span class="p">(</span><span class="n">cta</span><span class="o">.</span><span class="n">vis</span><span class="p">),</span> <span class="n">field</span><span class="o">=</span><span class="n">join</span><span class="p">(</span><span class="n">cta</span><span class="o">.</span><span class="n">field</span><span class="p">),</span> <span class="n">spw</span><span class="o">=</span><span class="n">join</span><span class="p">(</span><span class="n">cta</span><span class="o">.</span><span class="n">spw</span><span class="p">),</span> <span class="n">antenna</span><span class="o">=</span><span class="n">join</span><span class="p">(</span><span class="n">cta</span><span class="o">.</span><span class="n">antenna</span><span class="p">),</span>
                     <span class="n">intent</span><span class="o">=</span><span class="n">join</span><span class="p">(</span><span class="n">cta</span><span class="o">.</span><span class="n">intent</span><span class="p">))</span></div>


    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vis</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">field</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">spw</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">antenna</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">intent</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>\
            <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize a CalTo object.</span>

<span class="sd">        Args:</span>
<span class="sd">            vis: Name of the measurement set to which the calibrations apply.</span>
<span class="sd">            field: The field(s) to which the calibrations apply.</span>
<span class="sd">            spw: The spectral window(s) to which the calibrations apply.</span>
<span class="sd">            antenna: The antennas to which the calibrations apply.</span>
<span class="sd">            intent: The observing intent(s) to which the calibrations apply.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vis</span> <span class="o">=</span> <span class="n">vis</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">field</span> <span class="o">=</span> <span class="n">field</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spw</span> <span class="o">=</span> <span class="n">spw</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">antenna</span> <span class="o">=</span> <span class="n">antenna</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">intent</span> <span class="o">=</span> <span class="n">intent</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">antenna</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the antennas to which the calibrations apply.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_antenna</span>

    <span class="nd">@antenna</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">antenna</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the antennas to which the calibrations apply to given value.</span>

<span class="sd">        Args:</span>
<span class="sd">            value: Antenna ID (integer) or a string of comma-separated antenna</span>
<span class="sd">                IDs to which the calibrations apply. If None, this is set to an</span>
<span class="sd">                empty string. Contiguous ID ranges are represented as a CASA</span>
<span class="sd">                range, e.g. 1~5.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_antenna</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">find_ranges</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">field</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the field(s) to which the calibrations apply.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_field</span>

    <span class="nd">@field</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">field</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the field(s) to which the calibrations apply to given value.</span>

<span class="sd">        Args:</span>
<span class="sd">            value: String of comma-separated fields to which the calibrations</span>
<span class="sd">                apply. If None, this is set to an empty string.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_field</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">intent</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the observing intent(s) to which the calibrations apply.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_intent</span>

    <span class="nd">@intent</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">intent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the observing intent(s) to which the calibrations apply to given</span>
<span class="sd">        value.</span>

<span class="sd">        Args:</span>
<span class="sd">            value: String of comma-separated intents to which the calibrations</span>
<span class="sd">                apply. If None, this is set to an empty string.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_intent</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">spw</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the spectral window(s) to which the calibrations apply.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_spw</span>

    <span class="nd">@spw</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">spw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the spectral window(s) to which the calibrations apply.</span>

<span class="sd">        Args:</span>
<span class="sd">            value: Spectral window ID (integer) or a string of comma-separated</span>
<span class="sd">            spectral window IDs to which the calibrations apply. If None, this</span>
<span class="sd">            is set to an empty string. Contiguous ID ranges are represented as a</span>
<span class="sd">            CASA range, e.g. 1~5.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_spw</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">find_ranges</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">vis</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the name of the measurement set to which the calibrations apply.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vis</span>

    <span class="nd">@vis</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">vis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the name of the measurement set to which the calibrations apply.</span>

<span class="sd">        Args:</span>
<span class="sd">            value: Name of the measurement set to which the calibrations apply.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_vis</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="s1">&#39;CalTo(vis=</span><span class="se">\&#39;</span><span class="si">%s</span><span class="se">\&#39;</span><span class="s1">, field=</span><span class="se">\&#39;</span><span class="si">%s</span><span class="se">\&#39;</span><span class="s1">, spw=</span><span class="se">\&#39;</span><span class="si">%s</span><span class="se">\&#39;</span><span class="s1">, antenna=</span><span class="se">\&#39;</span><span class="si">%s</span><span class="se">\&#39;</span><span class="s1">,&#39;</span>
                <span class="s1">&#39;intent=</span><span class="se">\&#39;</span><span class="si">%s</span><span class="se">\&#39;</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vis</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">field</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spw</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">antenna</span><span class="p">,</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">intent</span><span class="p">))</span></div>



<div class="viewcode-block" id="CalFrom">
<a class="viewcode-back" href="../../../_automodapi/pipeline.infrastructure.callibrary.CalFrom.html#pipeline.infrastructure.callibrary.CalFrom">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">CalFrom</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    CalFrom represents a calibration table and the CASA arguments that should</span>
<span class="sd">    be used when applying that calibration table.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        CALTYPES: an enumeration of calibration table types identified by this code.</span>
<span class="sd">        CALTYPE_TO_VISCAL: mapping of calibration type to caltable identifier as</span>
<span class="sd">            store in the table header.</span>
<span class="sd">        VISCAL: mapping of calibration table header information to a description</span>
<span class="sd">            of that table type.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">CALTYPES</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;unknown&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="s1">&#39;gaincal&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
        <span class="s1">&#39;bandpass&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
        <span class="s1">&#39;tsys&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
        <span class="s1">&#39;wvr&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span>
        <span class="s1">&#39;polarization&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
        <span class="s1">&#39;antpos&#39;</span><span class="p">:</span> <span class="mi">6</span><span class="p">,</span>
        <span class="s1">&#39;gc&#39;</span><span class="p">:</span> <span class="mi">7</span><span class="p">,</span>
        <span class="s1">&#39;opac&#39;</span><span class="p">:</span> <span class="mi">8</span><span class="p">,</span>
        <span class="s1">&#39;rq&#39;</span><span class="p">:</span> <span class="mi">9</span><span class="p">,</span>
        <span class="s1">&#39;swpow&#39;</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span>
        <span class="s1">&#39;finalcal&#39;</span><span class="p">:</span> <span class="mi">11</span><span class="p">,</span>
        <span class="s1">&#39;uvcont&#39;</span><span class="p">:</span> <span class="mi">12</span><span class="p">,</span>
        <span class="s1">&#39;amp&#39;</span><span class="p">:</span> <span class="mi">13</span><span class="p">,</span>
        <span class="s1">&#39;ps&#39;</span><span class="p">:</span> <span class="mi">14</span><span class="p">,</span>
        <span class="s1">&#39;otfraster&#39;</span><span class="p">:</span> <span class="mi">15</span><span class="p">,</span>
        <span class="s1">&#39;tecim&#39;</span><span class="p">:</span> <span class="mi">16</span><span class="p">,</span>
        <span class="s1">&#39;kcross&#39;</span><span class="p">:</span> <span class="mi">17</span><span class="p">,</span>
        <span class="s1">&#39;otf&#39;</span><span class="p">:</span> <span class="mi">18</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="n">CALTYPE_TO_VISCAL</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;gaincal&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;G JONES&#39;</span><span class="p">,</span> <span class="s1">&#39;GSPLINE&#39;</span><span class="p">,</span> <span class="s1">&#39;T JONES&#39;</span><span class="p">),</span>
        <span class="s1">&#39;bandpass&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;B JONES&#39;</span><span class="p">,</span> <span class="s1">&#39;BPOLY&#39;</span><span class="p">),</span>
        <span class="s1">&#39;tsys&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;B TSYS&#39;</span><span class="p">,),</span>
        <span class="s1">&#39;antpos&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;KANTPOS JONES&#39;</span><span class="p">,),</span>
        <span class="s1">&#39;uvcont&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;A MUELLER&#39;</span><span class="p">,),</span>
        <span class="c1"># &#39;amp&#39;: (&#39;G JONES&#39;,),</span>
        <span class="s1">&#39;ps&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;SDSKY_PS&#39;</span><span class="p">,),</span>
        <span class="s1">&#39;otfraster&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;SDSKY_RASTER&#39;</span><span class="p">,),</span>
        <span class="s1">&#39;otf&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;SDSKY_OTF&#39;</span><span class="p">,),</span>
    <span class="p">}</span>

    <span class="n">VISCAL</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;P JONES&#39;</span><span class="p">:</span> <span class="s1">&#39;P Jones (parallactic angle phase)&#39;</span><span class="p">,</span>
        <span class="s1">&#39;T JONES&#39;</span><span class="p">:</span> <span class="s1">&#39;T Jones (polarization-independent troposphere)&#39;</span><span class="p">,</span>
        <span class="s1">&#39;TF JONES&#39;</span><span class="p">:</span> <span class="s1">&#39;Tf Jones (frequency-dependent atmospheric complex gain)&#39;</span><span class="p">,</span>
        <span class="s1">&#39;G JONES&#39;</span><span class="p">:</span> <span class="s1">&#39;G Jones (electronic Gain)&#39;</span><span class="p">,</span>
        <span class="s1">&#39;B JONES&#39;</span><span class="p">:</span> <span class="s1">&#39;B Jones (bandpass)&#39;</span><span class="p">,</span>
        <span class="s1">&#39;DGEN JONES&#39;</span><span class="p">:</span> <span class="s1">&#39;Dgen Jones (instrumental polarization)&#39;</span><span class="p">,</span>
        <span class="s1">&#39;DFGEN JONES&#39;</span><span class="p">:</span> <span class="s1">&#39;Dfgen Jones (frequency-dependent instrumental polarization)&#39;</span><span class="p">,</span>
        <span class="s1">&#39;D JONES&#39;</span><span class="p">:</span> <span class="s1">&#39;D Jones (instrumental polarization)&#39;</span><span class="p">,</span>
        <span class="s1">&#39;DF JONES&#39;</span><span class="p">:</span> <span class="s1">&#39;Df Jones (frequency-dependent instrumental polarization)&#39;</span><span class="p">,</span>
        <span class="s1">&#39;J JONES&#39;</span><span class="p">:</span> <span class="s1">&#39;J Jones (generic polarized gain)&#39;</span><span class="p">,</span>
        <span class="s1">&#39;M MUELLER&#39;</span><span class="p">:</span> <span class="s1">&#39;M Mueller (baseline-based)&#39;</span><span class="p">,</span>
        <span class="s1">&#39;MF MUELLER&#39;</span><span class="p">:</span> <span class="s1">&#39;Mf Mueller (closure bandpass)&#39;</span><span class="p">,</span>
        <span class="s1">&#39;TOPAC&#39;</span><span class="p">:</span> <span class="s1">&#39;TOpac (Opacity corrections in amplitude)&#39;</span><span class="p">,</span>
        <span class="s1">&#39;TFOPAC&#39;</span><span class="p">:</span> <span class="s1">&#39;TfOpac (frequency-dependent opacity)&#39;</span><span class="p">,</span>
        <span class="s1">&#39;X MUELLER&#39;</span><span class="p">:</span> <span class="s1">&#39;X Mueller (baseline-based)&#39;</span><span class="p">,</span>
        <span class="s1">&#39;X JONES&#39;</span><span class="p">:</span> <span class="s1">&#39;X Jones (antenna-based)&#39;</span><span class="p">,</span>
        <span class="s1">&#39;XF JONES&#39;</span><span class="p">:</span> <span class="s1">&#39;Xf Jones (antenna-based)&#39;</span><span class="p">,</span>
        <span class="s1">&#39;GLINXPH JONES&#39;</span><span class="p">:</span> <span class="s1">&#39;GlinXph Jones (X-Y phase)&#39;</span><span class="p">,</span>
        <span class="s1">&#39;B TSYS&#39;</span><span class="p">:</span> <span class="s1">&#39;B TSYS (freq-dep Tsys)&#39;</span><span class="p">,</span>
        <span class="s1">&#39;BPOLY&#39;</span><span class="p">:</span> <span class="s1">&#39;B Jones Poly (bandpass)&#39;</span><span class="p">,</span>
        <span class="s1">&#39;GSPLINE&#39;</span><span class="p">:</span> <span class="s1">&#39;G Jones SPLINE (elec. gain)&#39;</span><span class="p">,</span>
        <span class="s1">&#39;KANTPOS JONES&#39;</span><span class="p">:</span> <span class="s1">&#39;KAntPos Jones (antenna position errors)&#39;</span><span class="p">,</span>
        <span class="s1">&#39;A MUELLER&#39;</span><span class="p">:</span> <span class="s1">&#39;A Mueller (baseline-based)&#39;</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="c1"># Hundreds of thousands of CalFroms can be created and stored in a context.</span>
    <span class="c1"># To save memory, CalFrom uses a Flyweight pattern, caching objects in</span>
    <span class="c1"># _CalFromPool and returning a shared immutable instance for CalFroms</span>
    <span class="c1"># constructed with the same arguments.</span>
    <span class="n">_CalFromPool</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">WeakValueDictionary</span><span class="p">()</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_calc_hash</span><span class="p">(</span><span class="n">gaintable</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">gainfield</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">interp</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">spwmap</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">,</span> <span class="n">calwt</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate a hash code unique to the given arguments.</span>

<span class="sd">        Args:</span>
<span class="sd">            gaintable: Filename of calibration table.</span>
<span class="sd">            gainfield: Field(s) to select from calibration table to use.</span>
<span class="sd">            interp: Value to use for interp when applying these calibrations.</span>
<span class="sd">            spwmap: Value to use for spwmap when applying these calibrations.</span>
<span class="sd">            calwt: Value to use for calwt when applying these calibrations.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Integer representing hash code for given arguments.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="mi">17</span>
        <span class="n">result</span> <span class="o">=</span> <span class="mi">37</span> <span class="o">*</span> <span class="n">result</span> <span class="o">+</span> <span class="nb">hash</span><span class="p">(</span><span class="n">gaintable</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="mi">37</span> <span class="o">*</span> <span class="n">result</span> <span class="o">+</span> <span class="nb">hash</span><span class="p">(</span><span class="n">gainfield</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="mi">37</span> <span class="o">*</span> <span class="n">result</span> <span class="o">+</span> <span class="nb">hash</span><span class="p">(</span><span class="n">interp</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="mi">37</span> <span class="o">*</span> <span class="n">result</span> <span class="o">+</span> <span class="nb">hash</span><span class="p">(</span><span class="n">spwmap</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="mi">37</span> <span class="o">*</span> <span class="n">result</span> <span class="o">+</span> <span class="nb">hash</span><span class="p">(</span><span class="n">calwt</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">gaintable</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">gainfield</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">interp</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;linear,linear&#39;</span><span class="p">,</span>
                <span class="n">spwmap</span><span class="p">:</span> <span class="nb">list</span> <span class="o">|</span> <span class="nb">tuple</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">caltype</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;unknown&#39;</span><span class="p">,</span> <span class="n">calwt</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">CalFrom</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a new instance of the CalFrom class.</span>

<span class="sd">        This override is to implement the Flyweight Pattern for the CalFrom</span>
<span class="sd">        class, to save memory given that hundreds of the same CalFrom objects</span>
<span class="sd">        could be created and stored in the context.</span>

<span class="sd">        Upon creating a new instance of CalFrom, the combination of input</span>
<span class="sd">        arguments are first hashed. If this is the first occurence of this hash,</span>
<span class="sd">        then the corresponding CalFrom object is created and a reference to this</span>
<span class="sd">        object is stored in the module-level _CalFromPool, as well as returned.</span>
<span class="sd">        If the hash of the input arguments already exists in the _CalFromPool,</span>
<span class="sd">        then a reference to the corresponding (previously created) CalFrom is</span>
<span class="sd">        returned instead.</span>

<span class="sd">        In this implementation, the entire state of the CalFrom object is</span>
<span class="sd">        immutable, and any required modification to a CalFrom should be achieved</span>
<span class="sd">        through creating a new CalFrom.</span>

<span class="sd">        Args:</span>
<span class="sd">            gaintable: Filename of calibration table.</span>
<span class="sd">            gainfield: Field(s) to select from calibration table to use.</span>
<span class="sd">            interp: Value to use for interp when applying these calibrations.</span>
<span class="sd">            spwmap: Value to use for spwmap when applying these calibrations.</span>
<span class="sd">            caltype: String declaring type of calibration table, e.g. &#39;tsys&#39;.</span>
<span class="sd">            calwt: Value to use for calwt when applying these calibrations.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A new instance of the CalFrom class.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError if gaintable is None, gainfield is not a string,</span>
<span class="sd">            interp is not a string, or spwmap is not a list, tuple, or None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">spwmap</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">spwmap</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="n">gaintable</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;gaintable must be specified. Got None&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">gainfield</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;gainfield must be a string. Got </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">gainfield</span><span class="p">))</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">interp</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;interp must be a string. Got </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">interp</span><span class="p">))</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">spwmap</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">spwmap</span> <span class="o">=</span> <span class="p">[</span><span class="n">spw</span> <span class="k">for</span> <span class="n">spw</span> <span class="ow">in</span> <span class="n">spwmap</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">spwmap</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;spwmap must be a list. Got </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">spwmap</span><span class="p">))</span>
        <span class="c1"># Flyweight instances should be immutable, so convert spwmap to a</span>
        <span class="c1"># tuple. This also makes spwmap hashable for our hash function.</span>
        <span class="n">spwmap</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">o</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">spwmap</span><span class="p">])</span>

        <span class="n">caltype</span> <span class="o">=</span> <span class="n">caltype</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="k">assert</span> <span class="n">caltype</span> <span class="ow">in</span> <span class="n">CalFrom</span><span class="o">.</span><span class="n">CALTYPES</span>

        <span class="n">arg_hash</span> <span class="o">=</span> <span class="n">CalFrom</span><span class="o">.</span><span class="n">_calc_hash</span><span class="p">(</span><span class="n">gaintable</span><span class="p">,</span> <span class="n">gainfield</span><span class="p">,</span> <span class="n">interp</span><span class="p">,</span> <span class="n">spwmap</span><span class="p">,</span>
                                      <span class="n">calwt</span><span class="p">)</span>

        <span class="n">obj</span> <span class="o">=</span> <span class="n">CalFrom</span><span class="o">.</span><span class="n">_CalFromPool</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">arg_hash</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">obj</span><span class="p">:</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;Creating new CalFrom(gaintable=</span><span class="se">\&#39;</span><span class="si">%s</span><span class="se">\&#39;</span><span class="s1">, &#39;</span>
                      <span class="s1">&#39;gainfield=</span><span class="se">\&#39;</span><span class="si">%s</span><span class="se">\&#39;</span><span class="s1">, interp=</span><span class="se">\&#39;</span><span class="si">%s</span><span class="se">\&#39;</span><span class="s1">, spwmap=</span><span class="si">%s</span><span class="s1">, &#39;</span>
                      <span class="s1">&#39;caltype=</span><span class="se">\&#39;</span><span class="si">%s</span><span class="se">\&#39;</span><span class="s1">, calwt=</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span>
                      <span class="p">(</span><span class="n">gaintable</span><span class="p">,</span> <span class="n">gainfield</span><span class="p">,</span> <span class="n">interp</span><span class="p">,</span> <span class="n">spwmap</span><span class="p">,</span> <span class="n">caltype</span><span class="p">,</span> <span class="n">calwt</span><span class="p">))</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="nb">object</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">__gaintable</span> <span class="o">=</span> <span class="n">gaintable</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">__gainfield</span> <span class="o">=</span> <span class="n">gainfield</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">__interp</span> <span class="o">=</span> <span class="n">interp</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">__spwmap</span> <span class="o">=</span> <span class="n">spwmap</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">__caltype</span> <span class="o">=</span> <span class="n">caltype</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">__calwt</span> <span class="o">=</span> <span class="n">calwt</span>

            <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Adding new CalFrom to pool: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">obj</span><span class="p">)</span>
            <span class="n">CalFrom</span><span class="o">.</span><span class="n">_CalFromPool</span><span class="p">[</span><span class="n">arg_hash</span><span class="p">]</span> <span class="o">=</span> <span class="n">obj</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;New pool contents: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="nb">list</span><span class="p">(</span><span class="n">CalFrom</span><span class="o">.</span><span class="n">_CalFromPool</span><span class="o">.</span><span class="n">items</span><span class="p">()))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;Reusing existing CalFrom(gaintable=</span><span class="se">\&#39;</span><span class="si">%s</span><span class="se">\&#39;</span><span class="s1">, &#39;</span>
                      <span class="s1">&#39;gainfield=</span><span class="se">\&#39;</span><span class="si">%s</span><span class="se">\&#39;</span><span class="s1">, interp=</span><span class="se">\&#39;</span><span class="si">%s</span><span class="se">\&#39;</span><span class="s1">, spwmap=</span><span class="se">\&#39;</span><span class="si">%s</span><span class="se">\&#39;</span><span class="s1">, &#39;</span>
                      <span class="s1">&#39;caltype=</span><span class="se">\&#39;</span><span class="si">%s</span><span class="se">\&#39;</span><span class="s1">, calwt=</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span>
                      <span class="p">(</span><span class="n">gaintable</span><span class="p">,</span> <span class="n">gainfield</span><span class="p">,</span> <span class="n">interp</span><span class="p">,</span> <span class="n">spwmap</span><span class="p">,</span> <span class="n">caltype</span><span class="p">,</span> <span class="n">calwt</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">obj</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;__caltype&#39;</span><span class="p">,</span> <span class="s1">&#39;__calwt&#39;</span><span class="p">,</span> <span class="s1">&#39;__gainfield&#39;</span><span class="p">,</span> <span class="s1">&#39;__gaintable&#39;</span><span class="p">,</span>
                 <span class="s1">&#39;__interp&#39;</span><span class="p">,</span> <span class="s1">&#39;__spwmap&#39;</span><span class="p">,</span> <span class="s1">&#39;__weakref__&#39;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">bool</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Define what to pickle as a class instance.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__caltype</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__calwt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__gainfield</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__gaintable</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__interp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__spwmap</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">bool</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Define how to unpickle a class instance.&quot;&quot;&quot;</span>
        <span class="c1"># a misguided attempt to clear stale CalFroms when loading from a</span>
        <span class="c1"># pickle. I don&#39;t think this should be done here.</span>
        <span class="c1">#         # prevent exception with pickle format #1 by calling hash on properties</span>
        <span class="c1">#         # rather than the object</span>
        <span class="c1">#         (_, calwt, gainfield, gaintable, interp, spwmap) = state</span>
        <span class="c1">#         old_hash = CalFrom._calc_hash(gaintable, gainfield, interp, spwmap, calwt)</span>
        <span class="c1">#         if old_hash in CalFrom._CalFromPool:</span>
        <span class="c1">#             del CalFrom._CalFromPool[old_hash]</span>

        <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__caltype</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__calwt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__gainfield</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__gaintable</span><span class="p">,</span>
         <span class="bp">self</span><span class="o">.</span><span class="n">__interp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__spwmap</span><span class="p">)</span> <span class="o">=</span> <span class="n">state</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__getnewargs__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Define the tuple of input arguments to pass to __new__ during unpickling.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gaintable</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gainfield</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">interp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spwmap</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">caltype</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">calwt</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize a CalFrom instance.&quot;&quot;&quot;</span>
        <span class="k">pass</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">caltype</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the type of calibration table.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__caltype</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">calwt</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the value to use for calwt when applying these calibrations.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__calwt</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">gainfield</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return which field(s) in the calibration table to apply.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__gainfield</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">gaintable</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the filename of the calibration table.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__gaintable</span>

<div class="viewcode-block" id="CalFrom.get_caltype_for_viscal">
<a class="viewcode-back" href="../../../_automodapi/pipeline.infrastructure.callibrary.CalFrom.html#pipeline.infrastructure.callibrary.CalFrom.get_caltype_for_viscal">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_caltype_for_viscal</span><span class="p">(</span><span class="n">viscal</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the calibration table type for given VISCAL identifier.</span>

<span class="sd">        VISCAL identifiers are the caltable identifier as stored in the table</span>
<span class="sd">        header.</span>

<span class="sd">        Args:</span>
<span class="sd">            viscal: VISCAL table identifier to convert to calibration table type.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Type of calibration table.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">viscal</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">caltype</span><span class="p">,</span> <span class="n">viscals</span> <span class="ow">in</span> <span class="n">CalFrom</span><span class="o">.</span><span class="n">CALTYPE_TO_VISCAL</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">viscals</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">caltype</span>
        <span class="k">return</span> <span class="s1">&#39;unknown&#39;</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">interp</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Value to use for interp when applying these calibrations.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__interp</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">spwmap</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Value to use for spwmap when applying these calibrations.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__spwmap</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">CalFrom</span><span class="o">.</span><span class="n">_calc_hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gaintable</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gainfield</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">interp</span><span class="p">,</span>
                                  <span class="bp">self</span><span class="o">.</span><span class="n">spwmap</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">calwt</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="s1">&#39;CalFrom(</span><span class="se">\&#39;</span><span class="si">%s</span><span class="se">\&#39;</span><span class="s1">, gainfield=</span><span class="se">\&#39;</span><span class="si">%s</span><span class="se">\&#39;</span><span class="s1">, interp=</span><span class="se">\&#39;</span><span class="si">%s</span><span class="se">\&#39;</span><span class="s1">, spwmap=</span><span class="si">%s</span><span class="s1">, &#39;</span>
                <span class="s1">&#39;caltype=</span><span class="se">\&#39;</span><span class="si">%s</span><span class="se">\&#39;</span><span class="s1">, calwt=</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gaintable</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gainfield</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">interp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spwmap</span><span class="p">,</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">caltype</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">calwt</span><span class="p">))</span></div>



<div class="viewcode-block" id="CalToIdAdapter">
<a class="viewcode-back" href="../../../_automodapi/pipeline.infrastructure.callibrary.CalToIdAdapter.html#pipeline.infrastructure.callibrary.CalToIdAdapter">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">CalToIdAdapter</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    CalToIdAdapter is an adapter class for CalTo that return some of its</span>
<span class="sd">    attributes as lists of IDs/names, instead of as the CASA-style string argument.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">:</span> <span class="n">launcher</span><span class="o">.</span><span class="n">Context</span><span class="p">,</span> <span class="n">calto</span><span class="p">:</span> <span class="n">CalTo</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize a CalToIdAdapter instance.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_context</span> <span class="o">=</span> <span class="n">context</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_calto</span> <span class="o">=</span> <span class="n">calto</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">antenna</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return IDs of antennas to which the calibrations apply as a list of integers.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">id</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ms</span><span class="o">.</span><span class="n">get_antenna</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_calto</span><span class="o">.</span><span class="n">antenna</span><span class="p">)]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">field</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return fields to which the calibrations apply as a list of names or integer IDs.&quot;&quot;&quot;</span>
        <span class="n">fields</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ms</span><span class="o">.</span><span class="n">get_fields</span><span class="p">(</span><span class="n">task_arg</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_calto</span><span class="o">.</span><span class="n">field</span><span class="p">)]</span>
        <span class="c1"># if the field names are unique, we can return field names. Otherwise,</span>
        <span class="c1"># we fall back to field IDs.</span>
        <span class="n">all_field_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ms</span><span class="o">.</span><span class="n">get_fields</span><span class="p">()]</span>
        <span class="c1">### Activate the following line for NRO ###</span>
        <span class="c1">#         return [f.id for f in fields]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">all_field_names</span><span class="p">))</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_field_names</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">f</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">fields</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">f</span><span class="o">.</span><span class="n">id</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">fields</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">intent</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the intents to which the calibrations apply.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calto</span><span class="o">.</span><span class="n">intent</span>

<div class="viewcode-block" id="CalToIdAdapter.get_field_intents">
<a class="viewcode-back" href="../../../_automodapi/pipeline.infrastructure.callibrary.CalToIdAdapter.html#pipeline.infrastructure.callibrary.CalToIdAdapter.get_field_intents">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_field_intents</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">field_id</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">str</span><span class="p">,</span> <span class="n">spw_id</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return set of intents that are common to CalTo, given field(s), and</span>
<span class="sd">        given spectral window(s).&quot;&quot;&quot;</span>
        <span class="n">field</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_field</span><span class="p">(</span><span class="n">field_id</span><span class="p">)</span>
        <span class="n">field_intents</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="n">intents</span>

        <span class="n">spw</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_spw</span><span class="p">(</span><span class="n">spw_id</span><span class="p">)</span>
        <span class="n">spw_intents</span> <span class="o">=</span> <span class="n">spw</span><span class="o">.</span><span class="n">intents</span>

        <span class="n">user_intents</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_calto</span><span class="o">.</span><span class="n">intent</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calto</span><span class="o">.</span><span class="n">intent</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
            <span class="n">user_intents</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="n">intents</span>

        <span class="k">return</span> <span class="n">user_intents</span> <span class="o">&amp;</span> <span class="n">field_intents</span> <span class="o">&amp;</span> <span class="n">spw_intents</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">ms</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">MeasurementSet</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the MeasurementSet object (from context) that the CalTo applies to.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_context</span><span class="o">.</span><span class="n">observing_run</span><span class="o">.</span><span class="n">get_ms</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_calto</span><span class="o">.</span><span class="n">vis</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">spw</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span> <span class="o">|</span> <span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return spectral windows IDs to which the calibrations apply.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">spw</span><span class="o">.</span><span class="n">id</span> <span class="k">for</span> <span class="n">spw</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ms</span><span class="o">.</span><span class="n">get_spectral_windows</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_calto</span><span class="o">.</span><span class="n">spw</span><span class="p">,</span> <span class="n">science_windows_only</span><span class="o">=</span><span class="kc">False</span><span class="p">)]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_field</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">field_id</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Field</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the Field object (from context/MS) for given field ID/name.&quot;&quot;&quot;</span>
        <span class="n">fields</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ms</span><span class="o">.</span><span class="n">get_fields</span><span class="p">(</span><span class="n">task_arg</span><span class="o">=</span><span class="n">field_id</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">fields</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Illegal field ID </span><span class="se">\&#39;</span><span class="si">%s</span><span class="se">\&#39;</span><span class="s1"> for vis </span><span class="se">\&#39;</span><span class="si">%s</span><span class="se">\&#39;</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">field_id</span><span class="p">,</span>
                                                              <span class="bp">self</span><span class="o">.</span><span class="n">_calto</span><span class="o">.</span><span class="n">vis</span><span class="p">)</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fields</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_spw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spw_id</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SpectralWindow</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the SpectralWindow object (from context/MS) for given ID.&quot;&quot;&quot;</span>
        <span class="n">spws</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ms</span><span class="o">.</span><span class="n">get_spectral_windows</span><span class="p">(</span><span class="n">spw_id</span><span class="p">,</span>
                                            <span class="n">science_windows_only</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">spws</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Illegal spw ID </span><span class="se">\&#39;</span><span class="si">%s</span><span class="se">\&#39;</span><span class="s1"> for vis </span><span class="se">\&#39;</span><span class="si">%s</span><span class="se">\&#39;</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">spw_id</span><span class="p">,</span>
                                                            <span class="bp">self</span><span class="o">.</span><span class="n">_calto</span><span class="o">.</span><span class="n">vis</span><span class="p">)</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">spws</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="s1">&#39;CalToIdAdapter(ms=</span><span class="se">\&#39;</span><span class="si">%s</span><span class="se">\&#39;</span><span class="s1">, field=</span><span class="se">\&#39;</span><span class="si">%s</span><span class="se">\&#39;</span><span class="s1">, intent=</span><span class="se">\&#39;</span><span class="si">%s</span><span class="se">\&#39;</span><span class="s1">, &#39;</span>
                <span class="s1">&#39;spw=</span><span class="si">%s</span><span class="s1">, antenna=</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ms</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">field</span><span class="p">,</span>
                                         <span class="bp">self</span><span class="o">.</span><span class="n">intent</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spw</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">antenna</span><span class="p">))</span></div>



<div class="viewcode-block" id="unit">
<a class="viewcode-back" href="../../../_automodapi/pipeline.infrastructure.callibrary.unit.html#pipeline.infrastructure.callibrary.unit">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">unit</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span></div>



<div class="viewcode-block" id="contiguous_sequences">
<a class="viewcode-back" href="../../../_automodapi/pipeline.infrastructure.callibrary.contiguous_sequences.html#pipeline.infrastructure.callibrary.contiguous_sequences">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">contiguous_sequences</span><span class="p">(</span><span class="n">l</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate contiguous sequences of numbers from a list.</span>

<span class="sd">    This function takes a list of integers (or values that can be converted to</span>
<span class="sd">    integers), sorts them, and yields contiguous sequences of these integers.</span>

<span class="sd">    A contiguous sequence is defined as a sequence of numbers where each number</span>
<span class="sd">    is exactly one greater than the previous number.</span>

<span class="sd">    Args:</span>
<span class="sd">        l: A list of integers or values that can be converted to integers.</span>

<span class="sd">    Yields:</span>
<span class="sd">        List containing sequence of continguous integers.</span>

<span class="sd">    Example:</span>
<span class="sd">    &gt;&gt;&gt; list(contiguous_sequences([3, 1, 4, 2, 6, 5, 8]))</span>
<span class="sd">    [[1, 2, 3, 4, 5, 6], [8]]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">s</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">([</span><span class="nb">int</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">l</span><span class="p">])</span>

    <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="k">lambda</span> <span class="n">i_x</span><span class="p">:</span> <span class="n">i_x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">i_x</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
        <span class="n">rng</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">itemgetter</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">g</span><span class="p">))</span>
        <span class="k">yield</span> <span class="n">rng</span></div>



<span class="c1"># intervals are not inclusive of the upper bound, hence the +1 on the right bound</span>
<span class="n">sequence_to_range</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">l</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>


<div class="viewcode-block" id="sequence_to_casa_range">
<a class="viewcode-back" href="../../../_automodapi/pipeline.infrastructure.callibrary.sequence_to_casa_range.html#pipeline.infrastructure.callibrary.sequence_to_casa_range">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">sequence_to_casa_range</span><span class="p">(</span><span class="n">seq</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">as_casa_range</span><span class="p">(</span><span class="n">seq</span><span class="p">):</span>
        <span class="n">size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;&#39;</span>
        <span class="k">elif</span> <span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">seq</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">~</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">seq</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">seq</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">as_casa_range</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span> <span class="k">for</span> <span class="n">seq</span> <span class="ow">in</span> <span class="n">contiguous_sequences</span><span class="p">(</span><span class="n">seq</span><span class="p">))</span></div>



<div class="viewcode-block" id="CalToIntervalAdapter">
<a class="viewcode-back" href="../../../_automodapi/pipeline.infrastructure.callibrary.CalToIntervalAdapter.html#pipeline.infrastructure.callibrary.CalToIntervalAdapter">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">CalToIntervalAdapter</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">calto</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_context</span> <span class="o">=</span> <span class="n">context</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_calto</span> <span class="o">=</span> <span class="n">calto</span>

        <span class="n">ms</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">observing_run</span><span class="o">.</span><span class="n">get_ms</span><span class="p">(</span><span class="n">calto</span><span class="o">.</span><span class="n">vis</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ms</span> <span class="o">=</span> <span class="n">ms</span>

        <span class="n">antenna_ids</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">id</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">ms</span><span class="o">.</span><span class="n">get_antenna</span><span class="p">(</span><span class="n">calto</span><span class="o">.</span><span class="n">antenna</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">antenna</span> <span class="o">=</span> <span class="p">[</span><span class="n">sequence_to_range</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span> <span class="k">for</span> <span class="n">seq</span> <span class="ow">in</span> <span class="n">contiguous_sequences</span><span class="p">(</span><span class="n">antenna_ids</span><span class="p">)]</span>

        <span class="n">field_ids</span> <span class="o">=</span> <span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">id</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">ms</span><span class="o">.</span><span class="n">get_fields</span><span class="p">(</span><span class="n">task_arg</span><span class="o">=</span><span class="n">calto</span><span class="o">.</span><span class="n">field</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">field</span> <span class="o">=</span> <span class="p">[</span><span class="n">sequence_to_range</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span> <span class="k">for</span> <span class="n">seq</span> <span class="ow">in</span> <span class="n">contiguous_sequences</span><span class="p">(</span><span class="n">field_ids</span><span class="p">)]</span>

        <span class="n">spw_ids</span> <span class="o">=</span> <span class="p">(</span><span class="n">spw</span><span class="o">.</span><span class="n">id</span> <span class="k">for</span> <span class="n">spw</span> <span class="ow">in</span> <span class="n">ms</span><span class="o">.</span><span class="n">get_spectral_windows</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_calto</span><span class="o">.</span><span class="n">spw</span><span class="p">,</span> <span class="n">science_windows_only</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spw</span> <span class="o">=</span> <span class="p">[</span><span class="n">sequence_to_range</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span> <span class="k">for</span> <span class="n">seq</span> <span class="ow">in</span> <span class="n">contiguous_sequences</span><span class="p">(</span><span class="n">spw_ids</span><span class="p">)]</span>

        <span class="n">id_to_intent</span> <span class="o">=</span> <span class="n">get_intent_id_map</span><span class="p">(</span><span class="n">ms</span><span class="p">)</span>
        <span class="n">intent_to_id</span> <span class="o">=</span> <span class="p">{</span><span class="n">v</span><span class="p">:</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">id_to_intent</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calto</span><span class="o">.</span><span class="n">intent</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">intent</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">intent_to_id</span><span class="p">))]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">str_intents</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calto</span><span class="o">.</span><span class="n">intent</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)</span>
            <span class="c1"># the conditional check for intent is required as task parameters may</span>
            <span class="c1"># specify an intent that is not in the MS, such as CHECK.</span>
            <span class="n">intent_ids</span> <span class="o">=</span> <span class="p">(</span><span class="n">intent_to_id</span><span class="p">[</span><span class="n">intent</span><span class="p">]</span> <span class="k">for</span> <span class="n">intent</span> <span class="ow">in</span> <span class="n">str_intents</span>
                          <span class="k">if</span> <span class="n">intent</span> <span class="ow">in</span> <span class="n">intent_to_id</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">intent</span> <span class="o">=</span> <span class="p">[</span><span class="n">sequence_to_range</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span> <span class="k">for</span> <span class="n">seq</span> <span class="ow">in</span> <span class="n">contiguous_sequences</span><span class="p">(</span><span class="n">intent_ids</span><span class="p">)]</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="s1">&#39;CalToIntervalAdapter(ms=</span><span class="si">{!r}</span><span class="s1">, field=</span><span class="si">{!r}</span><span class="s1">, intent=</span><span class="si">{!r}</span><span class="s1">, spw=</span><span class="si">{!r}</span><span class="s1">, antenna=</span><span class="si">{!r}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_calto</span><span class="o">.</span><span class="n">vis</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">field</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">intent</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spw</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">antenna</span><span class="p">))</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="s1">&#39;CalToIntervalAdapter(</span><span class="si">{!s}</span><span class="s1">, </span><span class="si">{!s}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_context</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calto</span><span class="p">)</span></div>



<div class="viewcode-block" id="create_data_reducer">
<a class="viewcode-back" href="../../../_automodapi/pipeline.infrastructure.callibrary.create_data_reducer.html#pipeline.infrastructure.callibrary.create_data_reducer">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">create_data_reducer</span><span class="p">(</span><span class="n">join</span><span class="p">:</span> <span class="n">Callable</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Callable</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a function that creates a new TimestampedData object containing the</span>
<span class="sd">    result of executing the given operation on two TimestampedData objects.</span>

<span class="sd">    The use case for this function is actually quite simple: perform an</span>
<span class="sd">    operation on two TimestampedData objects (add, subtract, etc.) and put the</span>
<span class="sd">    result in a new TimestampedData object.</span>

<span class="sd">    The resulting TimestampedData object has a creation time equal to that of</span>
<span class="sd">    the oldest input object.</span>

<span class="sd">    Args:</span>
<span class="sd">        join: The function to call on the two input objects.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Function that creates a TimestampedData object containing result of</span>
<span class="sd">        executing given join operation on two TimestampedData objects, with</span>
<span class="sd">        creation time equal to that of the oldest input object.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">m</span><span class="p">(</span><span class="n">td1</span><span class="p">:</span> <span class="n">TimestampedData</span><span class="p">,</span> <span class="n">td2</span><span class="p">:</span> <span class="n">TimestampedData</span><span class="p">,</span> <span class="n">join</span><span class="p">:</span> <span class="n">Callable</span> <span class="o">=</span> <span class="n">join</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TimestampedData</span><span class="p">:</span>
        <span class="n">oldest</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">td1</span><span class="p">,</span> <span class="n">td2</span><span class="p">)</span>
        <span class="n">newest</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">td1</span><span class="p">,</span> <span class="n">td2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">TimestampedData</span><span class="p">(</span><span class="n">oldest</span><span class="o">.</span><span class="n">time</span><span class="p">,</span> <span class="n">join</span><span class="p">(</span><span class="n">oldest</span><span class="p">,</span> <span class="n">newest</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">m</span></div>



<div class="viewcode-block" id="merge_lists">
<a class="viewcode-back" href="../../../_automodapi/pipeline.infrastructure.callibrary.merge_lists.html#pipeline.infrastructure.callibrary.merge_lists">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">merge_lists</span><span class="p">(</span><span class="n">join_fn</span><span class="o">=</span><span class="n">operator</span><span class="o">.</span><span class="n">add</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a function that merge two lists by calling the input operation</span>
<span class="sd">    on the two input arguments.</span>

<span class="sd">    :param join_fn:</span>
<span class="sd">    :return:</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">m</span><span class="p">(</span><span class="n">oldest</span><span class="p">,</span> <span class="n">newest</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">join_fn</span><span class="p">(</span><span class="n">oldest</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">newest</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">m</span></div>



<div class="viewcode-block" id="merge_intervaltrees">
<a class="viewcode-back" href="../../../_automodapi/pipeline.infrastructure.callibrary.merge_intervaltrees.html#pipeline.infrastructure.callibrary.merge_intervaltrees">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">merge_intervaltrees</span><span class="p">(</span><span class="n">on_intersect</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a function that merges two IntervalTrees, executing a function</span>
<span class="sd">    on the intersecting Interval ranges in the resulting merged IntervalTree.</span>

<span class="sd">    :param on_intersect: the function to call on overlapping Intervals</span>
<span class="sd">    :return: function</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">m</span><span class="p">(</span><span class="n">oldest</span><span class="p">,</span> <span class="n">newest</span><span class="p">):</span>
        <span class="n">union</span> <span class="o">=</span> <span class="n">oldest</span><span class="o">.</span><span class="n">data</span> <span class="o">|</span> <span class="n">newest</span><span class="o">.</span><span class="n">data</span>
        <span class="n">union</span><span class="o">.</span><span class="n">split_overlaps</span><span class="p">()</span>
        <span class="n">union</span><span class="o">.</span><span class="n">merge_equals</span><span class="p">(</span><span class="n">data_reducer</span><span class="o">=</span><span class="n">on_intersect</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">union</span>

    <span class="k">return</span> <span class="n">m</span></div>



<div class="viewcode-block" id="ranges">
<a class="viewcode-back" href="../../../_automodapi/pipeline.infrastructure.callibrary.ranges.html#pipeline.infrastructure.callibrary.ranges">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">ranges</span><span class="p">(</span><span class="n">lst</span><span class="p">):</span>
    <span class="n">pos</span> <span class="o">=</span> <span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">lst</span><span class="p">))</span>
    <span class="n">t</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">els</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">pos</span><span class="p">):</span>
        <span class="n">l</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">els</span><span class="p">))</span>
        <span class="n">el</span> <span class="o">=</span> <span class="n">lst</span><span class="p">[</span><span class="n">t</span><span class="p">]</span>
        <span class="n">t</span> <span class="o">+=</span> <span class="n">l</span>
        <span class="k">yield</span> <span class="p">(</span><span class="n">el</span><span class="p">,</span> <span class="n">el</span> <span class="o">+</span> <span class="n">l</span><span class="p">)</span></div>



<div class="viewcode-block" id="safe_join">
<a class="viewcode-back" href="../../../_automodapi/pipeline.infrastructure.callibrary.safe_join.html#pipeline.infrastructure.callibrary.safe_join">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">safe_join</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="n">separator</span><span class="o">=</span><span class="s1">&#39;,&#39;</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">separator</span><span class="o">.</span><span class="n">join</span><span class="p">((</span><span class="nb">str</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">vals</span><span class="p">))</span></div>



<div class="viewcode-block" id="merge_contiguous_intervals">
<a class="viewcode-back" href="../../../_automodapi/pipeline.infrastructure.callibrary.merge_contiguous_intervals.html#pipeline.infrastructure.callibrary.merge_contiguous_intervals">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">merge_contiguous_intervals</span><span class="p">(</span><span class="n">tree</span><span class="p">:</span> <span class="n">intervaltree</span><span class="o">.</span><span class="n">IntervalTree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">intervaltree</span><span class="o">.</span><span class="n">IntervalTree</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Merge contiguous Intervals with the same value into one Interval.</span>

<span class="sd">    Args:</span>
<span class="sd">        tree: An IntervalTree.</span>

<span class="sd">    Returns:</span>
<span class="sd">        A new IntervalTree with merged Intervals.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">merged_tree</span> <span class="o">=</span> <span class="n">intervaltree</span><span class="o">.</span><span class="n">IntervalTree</span><span class="p">()</span>

    <span class="c1"># sort the tree by the list values. This is a prerequisite of using the</span>
    <span class="c1"># itertools.groupby function</span>
    <span class="n">data</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">tsd_accessor</span><span class="p">)</span>

    <span class="c1"># create groups of Intervals that have the same list values. These are the</span>
    <span class="c1"># Intervals we can merge.</span>
    <span class="k">for</span> <span class="n">l</span><span class="p">,</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">tsd_accessor</span><span class="p">):</span>
        <span class="c1"># create a tree for these Intervals with the same list values</span>
        <span class="n">candidate_tree</span> <span class="o">=</span> <span class="n">intervaltree</span><span class="o">.</span><span class="n">IntervalTree</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
        <span class="c1"># expand the Interval ranges to a list of integers (e.g. 1,3,6,7,8),</span>
        <span class="c1"># then find the contiguous ranges</span>
        <span class="n">sequence</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">begin</span><span class="p">,</span> <span class="n">i</span><span class="o">.</span><span class="n">end</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">candidate_tree</span><span class="p">)]))</span>
        <span class="k">for</span> <span class="n">begin</span><span class="p">,</span> <span class="n">end</span> <span class="ow">in</span> <span class="n">ranges</span><span class="p">(</span><span class="n">sequence</span><span class="p">):</span>
            <span class="n">vals</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">candidate_tree</span><span class="p">[</span><span class="n">begin</span><span class="p">:</span><span class="n">end</span><span class="p">],</span> <span class="n">key</span><span class="o">=</span><span class="n">tsd_accessor</span><span class="p">)</span>
            <span class="c1"># create a new Interval for the contiguous range but using an</span>
            <span class="c1"># existing value, thus reusing the timestamp</span>
            <span class="n">merged_tree</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">intervaltree</span><span class="o">.</span><span class="n">Interval</span><span class="p">(</span><span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">vals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">merged_tree</span></div>



<span class="c1"># function to access the value of a TimestampedData inside an Interval</span>
<span class="n">tsd_accessor</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">attrgetter</span><span class="p">(</span><span class="s1">&#39;data.data&#39;</span><span class="p">)</span>


<div class="viewcode-block" id="defrag_interval_tree">
<a class="viewcode-back" href="../../../_automodapi/pipeline.infrastructure.callibrary.defrag_interval_tree.html#pipeline.infrastructure.callibrary.defrag_interval_tree">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">defrag_interval_tree</span><span class="p">(</span><span class="n">tree</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Condense an IntervalTree by consolidating fragmented entries with the same</span>
<span class="sd">    value into contiguous Intervals.</span>

<span class="sd">    :param tree:</span>
<span class="sd">    :return:</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># if the intervals in this tree do not contain IntervalTrees, we&#39;re at the final</span>
    <span class="c1"># branch - the branch with the list of CalApplications. The intervals in this</span>
    <span class="c1"># branch can be merged</span>
    <span class="n">leaf_values</span> <span class="o">=</span> <span class="p">[</span><span class="n">tsd_accessor</span><span class="p">(</span><span class="n">interval</span><span class="p">)</span> <span class="k">for</span> <span class="n">interval</span> <span class="ow">in</span> <span class="n">tree</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">((</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">intervaltree</span><span class="o">.</span><span class="n">IntervalTree</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">leaf_values</span><span class="p">)):</span>
        <span class="k">return</span> <span class="n">merge_contiguous_intervals</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>

    <span class="c1"># otherwise call recursively</span>
    <span class="n">merged_tree</span> <span class="o">=</span> <span class="n">intervaltree</span><span class="o">.</span><span class="n">IntervalTree</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">interval</span> <span class="ow">in</span> <span class="n">tree</span><span class="p">:</span>
        <span class="n">new_leaf</span> <span class="o">=</span> <span class="n">intervaltree</span><span class="o">.</span><span class="n">Interval</span><span class="p">(</span><span class="n">interval</span><span class="o">.</span><span class="n">begin</span><span class="p">,</span>
                                         <span class="n">interval</span><span class="o">.</span><span class="n">end</span><span class="p">,</span>
                                         <span class="n">defrag_interval_tree</span><span class="p">(</span><span class="n">tsd_accessor</span><span class="p">(</span><span class="n">interval</span><span class="p">)))</span>
        <span class="n">merged_tree</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">new_leaf</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">merged_tree</span></div>



<span class="c1"># this chain of functions defines how to add overlapping Intervals when adding</span>
<span class="c1"># IntervalTrees</span>
<span class="n">intent_add</span><span class="p">:</span> <span class="n">Callable</span> <span class="o">=</span> <span class="n">create_data_reducer</span><span class="p">(</span><span class="n">join</span><span class="o">=</span><span class="n">merge_lists</span><span class="p">(</span><span class="n">join_fn</span><span class="o">=</span><span class="n">operator</span><span class="o">.</span><span class="n">add</span><span class="p">))</span>
<span class="n">field_add</span><span class="p">:</span> <span class="n">Callable</span> <span class="o">=</span> <span class="n">create_data_reducer</span><span class="p">(</span><span class="n">join</span><span class="o">=</span><span class="n">merge_intervaltrees</span><span class="p">(</span><span class="n">intent_add</span><span class="p">))</span>
<span class="n">spw_add</span><span class="p">:</span> <span class="n">Callable</span> <span class="o">=</span> <span class="n">create_data_reducer</span><span class="p">(</span><span class="n">join</span><span class="o">=</span><span class="n">merge_intervaltrees</span><span class="p">(</span><span class="n">field_add</span><span class="p">))</span>
<span class="n">ant_add</span><span class="p">:</span> <span class="n">Callable</span> <span class="o">=</span> <span class="n">create_data_reducer</span><span class="p">(</span><span class="n">join</span><span class="o">=</span><span class="n">merge_intervaltrees</span><span class="p">(</span><span class="n">spw_add</span><span class="p">))</span>

<span class="c1"># this chain of functions defines how to subtract overlapping Intervals when</span>
<span class="c1"># subtracting IntervalTrees</span>
<span class="n">intent_sub</span><span class="p">:</span> <span class="n">Callable</span> <span class="o">=</span> <span class="n">create_data_reducer</span><span class="p">(</span><span class="n">join</span><span class="o">=</span><span class="n">merge_lists</span><span class="p">(</span><span class="n">join_fn</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="p">[</span><span class="n">item</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">x</span> <span class="k">if</span> <span class="n">item</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">y</span><span class="p">]))</span>
<span class="n">field_sub</span><span class="p">:</span> <span class="n">Callable</span> <span class="o">=</span> <span class="n">create_data_reducer</span><span class="p">(</span><span class="n">join</span><span class="o">=</span><span class="n">merge_intervaltrees</span><span class="p">(</span><span class="n">intent_sub</span><span class="p">))</span>
<span class="n">spw_sub</span><span class="p">:</span> <span class="n">Callable</span> <span class="o">=</span> <span class="n">create_data_reducer</span><span class="p">(</span><span class="n">join</span><span class="o">=</span><span class="n">merge_intervaltrees</span><span class="p">(</span><span class="n">field_sub</span><span class="p">))</span>
<span class="n">ant_sub</span><span class="p">:</span> <span class="n">Callable</span> <span class="o">=</span> <span class="n">create_data_reducer</span><span class="p">(</span><span class="n">join</span><span class="o">=</span><span class="n">merge_intervaltrees</span><span class="p">(</span><span class="n">spw_sub</span><span class="p">))</span>


<div class="viewcode-block" id="interval_to_set">
<a class="viewcode-back" href="../../../_automodapi/pipeline.infrastructure.callibrary.interval_to_set.html#pipeline.infrastructure.callibrary.interval_to_set">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">interval_to_set</span><span class="p">(</span><span class="n">interval</span><span class="p">:</span> <span class="n">intervaltree</span><span class="o">.</span><span class="n">Interval</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">set</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get all the indices covered by an Interval.</span>

<span class="sd">    Args:</span>
<span class="sd">        interval: Interval to retrieve indices for.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Set of indices covered by given Interval.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">interval</span><span class="o">.</span><span class="n">begin</span><span class="p">,</span> <span class="n">interval</span><span class="o">.</span><span class="n">end</span><span class="p">))</span></div>



<div class="viewcode-block" id="get_id_to_intent_fn">
<a class="viewcode-back" href="../../../_automodapi/pipeline.infrastructure.callibrary.get_id_to_intent_fn.html#pipeline.infrastructure.callibrary.get_id_to_intent_fn">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_id_to_intent_fn</span><span class="p">(</span><span class="n">id_to_intent</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">Callable</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a function that can convert intent IDs to a string intent.</span>

<span class="sd">    Takes a dict of dicts, first key mapping measurement set name and second</span>
<span class="sd">    key mapping numeric intent ID to string intent for that MS, e.g.</span>

<span class="sd">    {&#39;a.ms&#39;: {0: &#39;PHASE&#39;, 1: &#39;BANDPASS&#39;}</span>

<span class="sd">    Args:</span>
<span class="sd">        id_to_intent: Dictionary mapping vis to a dictionary of intent ID: string intent.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Function that converts given intent IDs for given MS to set of intents.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">f</span><span class="p">(</span><span class="n">vis</span><span class="p">,</span> <span class="n">intent_ids</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">vis</span> <span class="ow">in</span> <span class="n">id_to_intent</span>

        <span class="n">mapping</span> <span class="o">=</span> <span class="n">id_to_intent</span><span class="p">[</span><span class="n">vis</span><span class="p">]</span>

        <span class="c1"># if the intent range spans all intents for this measurement set,</span>
        <span class="c1"># transform it back to &#39;&#39; to indicate all intents</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">((</span><span class="n">i</span> <span class="ow">in</span> <span class="n">intent_ids</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">mapping</span><span class="p">)):</span>
            <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">set</span><span class="p">((</span><span class="n">mapping</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">intent_ids</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">f</span></div>



<div class="viewcode-block" id="get_id_to_field_fn">
<a class="viewcode-back" href="../../../_automodapi/pipeline.infrastructure.callibrary.get_id_to_field_fn.html#pipeline.infrastructure.callibrary.get_id_to_field_fn">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_id_to_field_fn</span><span class="p">(</span><span class="n">ms_to_id_to_field</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a function that can convert field IDs to a field name.</span>

<span class="sd">    Takes a dict of dicts, first key mapping measurement set name and second</span>
<span class="sd">    key mapping numeric field ID to field name, eg.</span>

<span class="sd">    {&#39;a.ms&#39;: {0: &#39;field 1&#39;, 1: &#39;field 2&#39;}</span>

<span class="sd">    :param ms_to_id_to_field: dict of vis : field ID : field name</span>
<span class="sd">    :return: set of field names (or field IDs if names are not unique)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">id_to_identifier</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">ms_name</span><span class="p">,</span> <span class="n">id_to_field</span> <span class="ow">in</span> <span class="n">ms_to_id_to_field</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">counter</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">Counter</span><span class="p">()</span>
        <span class="n">counter</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">id_to_field</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>

        <span class="c1"># construct an id:name mapping using the ID for non-unique field names</span>
        <span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="n">field_id</span><span class="p">:</span> <span class="n">field_name</span> <span class="k">if</span> <span class="n">counter</span><span class="p">[</span><span class="n">field_name</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">field_id</span>
             <span class="k">for</span> <span class="n">field_id</span><span class="p">,</span> <span class="n">field_name</span> <span class="ow">in</span> <span class="n">id_to_field</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="n">id_to_identifier</span><span class="p">[</span><span class="n">ms_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">f</span><span class="p">(</span><span class="n">vis</span><span class="p">,</span> <span class="n">field_ids</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">vis</span> <span class="ow">in</span> <span class="n">id_to_identifier</span>

        <span class="n">field_id_to_field_name</span> <span class="o">=</span> <span class="n">id_to_identifier</span><span class="p">[</span><span class="n">vis</span><span class="p">]</span>

        <span class="c1"># if the field range spans all fields for this measurement set,</span>
        <span class="c1"># transform it back to &#39;&#39; to indicate all fields</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">i</span> <span class="ow">in</span> <span class="n">field_ids</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">field_id_to_field_name</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="n">field_id_to_field_name</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">field_ids</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">f</span></div>



<div class="viewcode-block" id="expand_interval">
<a class="viewcode-back" href="../../../_automodapi/pipeline.infrastructure.callibrary.expand_interval.html#pipeline.infrastructure.callibrary.expand_interval">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">expand_interval</span><span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="n">calto_args</span><span class="p">,</span> <span class="n">calto_fn</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert an Interval into the equivalent list of (CalTo, [CalFrom..])</span>
<span class="sd">    2-tuples.</span>

<span class="sd">    This function is the partner function to expand_intervaltree. See the</span>
<span class="sd">    documention for expand_intervaltree for more details on the argument</span>
<span class="sd">    format for this function.</span>

<span class="sd">    :param interval: the Interval to convert</span>
<span class="sd">    :param calto_args: the list of (argument name, conversion function) 2-tuples</span>
<span class="sd">     for the remaining dimensions</span>
<span class="sd">    :param calto_fn: the partial CalToArgs application</span>
<span class="sd">    :return:  a list of (CalTo, [CalFrom..]) tuples</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">tsd_accessor</span><span class="p">(</span><span class="n">interval</span><span class="p">)</span>
    <span class="n">numeric_ids</span> <span class="o">=</span> <span class="n">interval_to_set</span><span class="p">(</span><span class="n">interval</span><span class="p">)</span>

    <span class="n">arg_name</span><span class="p">,</span> <span class="n">conversion_fn</span> <span class="o">=</span> <span class="n">calto_args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">processed</span> <span class="o">=</span> <span class="n">conversion_fn</span><span class="p">(</span><span class="n">numeric_ids</span><span class="p">)</span>
    <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="n">arg_name</span><span class="p">:</span> <span class="n">processed</span><span class="p">}</span>

    <span class="n">calto_fn</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">calto_fn</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">intervaltree</span><span class="o">.</span><span class="n">IntervalTree</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">expand_intervaltree</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">calto_args</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">calto_fn</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># the return type is an iterable of 2-tuples</span>
        <span class="k">return</span> <span class="p">((</span><span class="n">calto_fn</span><span class="p">(),</span> <span class="n">data</span><span class="p">),)</span></div>



<div class="viewcode-block" id="expand_intervaltree">
<a class="viewcode-back" href="../../../_automodapi/pipeline.infrastructure.callibrary.expand_intervaltree.html#pipeline.infrastructure.callibrary.expand_intervaltree">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">expand_intervaltree</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">convert_fns</span><span class="p">,</span> <span class="n">calto_fn</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert an IntervalTree into the equivalent list of (CalTo, [CalFrom..])</span>
<span class="sd">    2-tuples.</span>

<span class="sd">    The second argument for this function is a list of 2-tuples of (CalToArgs</span>
<span class="sd">    constructor argument for this dimension, value conversion function for</span>
<span class="sd">    this dimension). The conversion function takes in a set of integer indexes</span>
<span class="sd">    and converts it to a suitable (probably more human-readable value) for that</span>
<span class="sd">    dimension, e.g. a conversion from field ID to field name. So, for a</span>
<span class="sd">    dimension that supplies the &#39;antenna&#39; argument to CalToArgs and should</span>
<span class="sd">    prefix &#39;DV&#39; to each antenna index, the tuple for that dimension could be</span>
<span class="sd">    (&#39;antenna&#39;, lambda id: {&#39;DV%s&#39; % i for i in field_ids}).</span>

<span class="sd">    The third argument is the partially-applied CalToArgs constructor. A</span>
<span class="sd">    CalToArgs needs a number of arguments (vis, field, spw, etc.), each of</span>
<span class="sd">    which corresponds to a dimension of the IntervalTree and which must be</span>
<span class="sd">    supplied at CalToArgs creation time. To achieve this while iterating</span>
<span class="sd">    through the dimensions (when the constructor arguments are not fully</span>
<span class="sd">    known), object creation is delayed by performing just a partial</span>
<span class="sd">    application, adding the keyword for the current dimension to the partial</span>
<span class="sd">    application. At the final leaf node, when all constructor arguments have</span>
<span class="sd">    been partially applied, we can call the partial function and get the</span>
<span class="sd">    CalToArgs.</span>

<span class="sd">    :param tree: the IntervalTree to convert</span>
<span class="sd">    :param convert_fns: the list of (argument name, conversion function) 2-tuples</span>
<span class="sd">     for the remaining dimensions</span>
<span class="sd">    :param calto_fn: the partial CalToArgs application</span>
<span class="sd">    :return: a list of (CalTo, [CalFrom..]) tuples</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">x</span>
            <span class="k">for</span> <span class="n">interval</span> <span class="ow">in</span> <span class="n">tree</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">expand_interval</span><span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="n">convert_fns</span><span class="p">,</span> <span class="n">calto_fn</span><span class="p">))</span></div>



<div class="viewcode-block" id="expand_calstate_to_calapps">
<a class="viewcode-back" href="../../../_automodapi/pipeline.infrastructure.callibrary.expand_calstate_to_calapps.html#pipeline.infrastructure.callibrary.expand_calstate_to_calapps">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">expand_calstate_to_calapps</span><span class="p">(</span><span class="n">calstate</span><span class="p">:</span> <span class="n">IntervalCalState</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="n">CalTo</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="n">CalFrom</span><span class="p">]]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert an IntervalCalState into a list of (CalTo, [CalFrom..]) tuples.</span>

<span class="sd">    Args:</span>
<span class="sd">        calstate: The IntervalCalState to convert.</span>

<span class="sd">    Returns:</span>
<span class="sd">        A list of 2-tuples, first element a Calto, second element a list</span>
<span class="sd">        of CalFroms.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># get functions to map from integer IDs to field and intent for this MS</span>
    <span class="n">id_to_field_fn</span> <span class="o">=</span> <span class="n">get_id_to_field_fn</span><span class="p">(</span><span class="n">calstate</span><span class="o">.</span><span class="n">id_to_field</span><span class="p">)</span>
    <span class="n">id_to_intent_fn</span> <span class="o">=</span> <span class="n">get_id_to_intent_fn</span><span class="p">(</span><span class="n">calstate</span><span class="o">.</span><span class="n">id_to_intent</span><span class="p">)</span>

    <span class="n">calapps</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="n">CalTo</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="n">CalFrom</span><span class="p">]]]</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">vis</span> <span class="ow">in</span> <span class="n">calstate</span><span class="p">:</span>
        <span class="c1"># Set the vis argument for the CalToArgs constructor through partial</span>
        <span class="c1"># application. The subsequent calls will set the other arguments for</span>
        <span class="c1"># CalToArgs (field, intent, spw, etc.)</span>
        <span class="n">caltoarg_fn</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">CalToArgs</span><span class="p">,</span> <span class="n">vis</span><span class="o">=</span><span class="p">{</span><span class="n">vis</span><span class="p">})</span>

        <span class="c1"># partially apply vis so that callees can call id-to-X functions</span>
        <span class="c1"># directly rather than having to push the vis arg through the layers</span>
        <span class="n">intent_fn</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">id_to_intent_fn</span><span class="p">,</span> <span class="n">vis</span><span class="p">)</span>
        <span class="n">field_fn</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">id_to_field_fn</span><span class="p">,</span> <span class="n">vis</span><span class="p">)</span>

        <span class="c1"># maps dimension order to the CalToArgs argument and value processing</span>
        <span class="c1"># function for that dimension. We have to process values at this point</span>
        <span class="c1"># while vis is still atomic, as once it&#39;s a set for the CalTo (as it</span>
        <span class="c1"># justly needs to be to handle sessions) we can&#39;t determine vis to</span>
        <span class="c1"># perform the mapping.</span>
        <span class="n">caltoarg_dimension</span> <span class="o">=</span> <span class="p">((</span><span class="s1">&#39;antenna&#39;</span><span class="p">,</span> <span class="n">unit</span><span class="p">),</span>
                              <span class="p">(</span><span class="s1">&#39;spw&#39;</span><span class="p">,</span> <span class="n">unit</span><span class="p">),</span>
                              <span class="p">(</span><span class="s1">&#39;field&#39;</span><span class="p">,</span> <span class="n">field_fn</span><span class="p">),</span>
                              <span class="p">(</span><span class="s1">&#39;intent&#39;</span><span class="p">,</span> <span class="n">intent_fn</span><span class="p">))</span>

        <span class="n">vis_tree</span> <span class="o">=</span> <span class="n">calstate</span><span class="p">[</span><span class="n">vis</span><span class="p">]</span>
        <span class="n">vis_calapps</span> <span class="o">=</span> <span class="n">expand_intervaltree</span><span class="p">(</span><span class="n">vis_tree</span><span class="p">,</span> <span class="n">caltoarg_dimension</span><span class="p">,</span> <span class="n">caltoarg_fn</span><span class="p">)</span>
        <span class="n">calapps</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">vis_calapps</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">calapps</span></div>



<div class="viewcode-block" id="consolidate_calibrations">
<a class="viewcode-back" href="../../../_automodapi/pipeline.infrastructure.callibrary.consolidate_calibrations.html#pipeline.infrastructure.callibrary.consolidate_calibrations">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">consolidate_calibrations</span><span class="p">(</span><span class="n">all_my_calapps</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Consolidate a list of (CalTo, [CalFrom..]) 2-tuples into a smaller set of</span>
<span class="sd">    equivalent applications by consolidating their data selection arguments.</span>

<span class="sd">    This function works by merging the data selections of CalTo objects that</span>
<span class="sd">    have the same calibration application, as determined by the values and</span>
<span class="sd">    data selection present in the CalFroms.</span>

<span class="sd">    :param calapps: an iterable of (CalTo, [CalFrom..]) 2-tuples</span>
<span class="sd">    :return: a list of (CalTo, [CalFrom..]) tuples</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># When faced with a large number of EBs, trying to merge calibrations</span>
    <span class="c1"># across all MSes results in a huge number of iterations - most of them</span>
    <span class="c1"># pointless as the caltables only apply to one MS. So, partition the</span>
    <span class="c1"># calapps, grouping them by MS, and merge within these partitions and not</span>
    <span class="c1"># across them.</span>
    <span class="n">vis_to_calapps</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">calto</span><span class="p">,</span> <span class="n">calfroms</span> <span class="ow">in</span> <span class="n">all_my_calapps</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">calto</span><span class="o">.</span><span class="n">vis</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Cannot handle calibrations that apply to multiple MSes&#39;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="n">vis</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">calto</span><span class="o">.</span><span class="n">vis</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">vis_to_calapps</span><span class="p">[</span><span class="n">vis</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">calto</span><span class="p">,</span> <span class="n">calfroms</span><span class="p">))</span>

    <span class="n">all_accepted</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">vis</span><span class="p">,</span> <span class="n">calapps_for_vis</span> <span class="ow">in</span> <span class="n">vis_to_calapps</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Consolidating calibrations for </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">vis</span><span class="p">)))</span>

        <span class="c1"># dict mapping an object hash to the object itself:</span>
        <span class="c1">#     hash([CalFrom, ...]): [CalFrom, ...]</span>
        <span class="n">hash_to_calfroms</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># dict mapping from object hash to corresponding list of CalToArgs</span>
        <span class="n">hash_to_calto_args</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

        <span class="c1"># create our maps of hashes, which we need to test for overlapping data</span>
        <span class="c1"># selections</span>
        <span class="k">for</span> <span class="n">calto_args</span><span class="p">,</span> <span class="n">calfroms</span> <span class="ow">in</span> <span class="n">calapps_for_vis</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">calfroms</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># create a tuple, as lists are not hashable</span>
            <span class="n">hashable_calfroms</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">hash</span><span class="p">(</span><span class="n">cf</span><span class="p">)</span> <span class="k">for</span> <span class="n">cf</span> <span class="ow">in</span> <span class="n">calfroms</span><span class="p">)</span>
            <span class="n">hash_to_calto_args</span><span class="p">[</span><span class="n">hashable_calfroms</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">calto_args</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">hashable_calfroms</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">hash_to_calfroms</span><span class="p">:</span>
                <span class="n">hash_to_calfroms</span><span class="p">[</span><span class="n">hashable_calfroms</span><span class="p">]</span> <span class="o">=</span> <span class="n">calfroms</span>

        <span class="c1"># dict that maps holds accepted data selections and their CalFroms</span>
        <span class="n">accepted</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">hashable_calfroms</span><span class="p">,</span> <span class="n">calto_args</span> <span class="ow">in</span> <span class="n">hash_to_calto_args</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># assemble the other data selections (the other CalToArgs) which we</span>
            <span class="c1"># will use to search for conflicting data selections</span>
            <span class="n">other_data_selections</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="p">[</span><span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">hash_to_calto_args</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="o">!=</span> <span class="n">hashable_calfroms</span><span class="p">]:</span>
                <span class="n">other_data_selections</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">to_merge</span> <span class="ow">in</span> <span class="n">calto_args</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">hashable_calfroms</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">accepted</span><span class="p">:</span>
                    <span class="c1"># first time round for this calibration application, therefore it can always be added</span>
                    <span class="c1"># as there will be nothing to merge</span>
                    <span class="n">accepted</span><span class="p">[</span><span class="n">hashable_calfroms</span><span class="p">]</span> <span class="o">=</span> <span class="p">[(</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">to_merge</span><span class="p">),</span> <span class="n">hash_to_calfroms</span><span class="p">[</span><span class="n">hashable_calfroms</span><span class="p">])]</span>
                    <span class="k">continue</span>

                <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="p">(</span><span class="n">existing_calto</span><span class="p">,</span> <span class="n">calfroms</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">accepted</span><span class="p">[</span><span class="n">hashable_calfroms</span><span class="p">]):</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">calfroms</span><span class="p">:</span>
                        <span class="k">continue</span>

                    <span class="n">proposed_calto</span> <span class="o">=</span> <span class="n">CalToArgs</span><span class="p">(</span><span class="o">*</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">existing_calto</span><span class="p">))</span>

                    <span class="k">for</span> <span class="n">proposed_values</span><span class="p">,</span> <span class="n">to_merge_values</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">proposed_calto</span><span class="p">,</span> <span class="n">to_merge</span><span class="p">):</span>
                        <span class="n">proposed_values</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">to_merge_values</span><span class="p">)</span>

                    <span class="c1"># if the merged data selection does not conflict with any of</span>
                    <span class="c1"># the explicitly registered data selections that require a</span>
                    <span class="c1"># different calibration application, then it is safe to add</span>
                    <span class="c1"># the merged data selection and discard the unmerged data</span>
                    <span class="c1"># selection</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">((</span><span class="n">data_selection_contains</span><span class="p">(</span><span class="n">proposed_calto</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="k">for</span> <span class="n">other</span> <span class="ow">in</span> <span class="n">other_data_selections</span><span class="p">)):</span>
                        <span class="k">if</span> <span class="n">LOG</span><span class="o">.</span><span class="n">isEnabledFor</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">TRACE</span><span class="p">):</span>
                            <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;No conflicting data selection detected&#39;</span><span class="p">)</span>
                            <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;Accepting merged data selection: </span><span class="si">{!s}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">proposed_calto</span><span class="p">))</span>
                            <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;Discarding unmerged data selection: </span><span class="si">{!s}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">to_merge</span><span class="p">))</span>
                        <span class="n">accepted</span><span class="p">[</span><span class="n">hashable_calfroms</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">proposed_calto</span><span class="p">,</span> <span class="n">hash_to_calfroms</span><span class="p">[</span><span class="n">hashable_calfroms</span><span class="p">])</span>
                        <span class="k">break</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># we get here if all of the proposed merged data selections</span>
                    <span class="c1"># conflict with the data selection in hand. In this case, it</span>
                    <span class="c1"># should be added as it stands, completely unaltered.</span>
                    <span class="k">if</span> <span class="n">LOG</span><span class="o">.</span><span class="n">isEnabledFor</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">TRACE</span><span class="p">):</span>
                        <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;Merged data selection conflicts with other registrations&#39;</span><span class="p">)</span>
                        <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;Abandoning proposed data selection: </span><span class="si">{!s}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">proposed_calto</span><span class="p">))</span>
                        <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;Appending new unmerged data selection: </span><span class="si">{!s}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">to_merge</span><span class="p">))</span>
                    <span class="n">unmergeable</span> <span class="o">=</span> <span class="p">(</span><span class="n">to_merge</span><span class="p">,</span> <span class="n">hash_to_calfroms</span><span class="p">[</span><span class="n">hashable_calfroms</span><span class="p">])</span>
                    <span class="n">accepted</span><span class="p">[</span><span class="n">hashable_calfroms</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">unmergeable</span><span class="p">)</span>

            <span class="n">all_accepted</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">accepted</span><span class="p">)</span>

    <span class="c1"># dict values are lists, which we need to flatten into a single list</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">all_accepted</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
        <span class="n">result</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span></div>



<div class="viewcode-block" id="data_selection_contains">
<a class="viewcode-back" href="../../../_automodapi/pipeline.infrastructure.callibrary.data_selection_contains.html#pipeline.infrastructure.callibrary.data_selection_contains">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">data_selection_contains</span><span class="p">(</span><span class="n">proposed</span><span class="p">:</span> <span class="n">CalToArgs</span><span class="p">,</span> <span class="n">calto_args</span><span class="p">:</span> <span class="n">CalToArgs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return True if one data selection is contained within another.</span>

<span class="sd">    Args:</span>
<span class="sd">        proposed: Data selection 1 as CalToArgs tuple.</span>
<span class="sd">        calto_args: Data selection 2 as CalToArgs tuple.</span>

<span class="sd">    Returns:</span>
<span class="sd">        True if data selection 2 is contained within data selection 1.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">all</span><span class="p">([</span><span class="ow">not</span> <span class="n">proposed</span><span class="o">.</span><span class="n">vis</span><span class="o">.</span><span class="n">isdisjoint</span><span class="p">(</span><span class="n">calto_args</span><span class="o">.</span><span class="n">vis</span><span class="p">),</span>
                <span class="ow">not</span> <span class="n">proposed</span><span class="o">.</span><span class="n">antenna</span><span class="o">.</span><span class="n">isdisjoint</span><span class="p">(</span><span class="n">calto_args</span><span class="o">.</span><span class="n">antenna</span><span class="p">),</span>
                <span class="ow">not</span> <span class="n">proposed</span><span class="o">.</span><span class="n">field</span><span class="o">.</span><span class="n">isdisjoint</span><span class="p">(</span><span class="n">calto_args</span><span class="o">.</span><span class="n">field</span><span class="p">),</span>
                <span class="ow">not</span> <span class="n">proposed</span><span class="o">.</span><span class="n">spw</span><span class="o">.</span><span class="n">isdisjoint</span><span class="p">(</span><span class="n">calto_args</span><span class="o">.</span><span class="n">spw</span><span class="p">),</span>
                <span class="ow">not</span> <span class="n">proposed</span><span class="o">.</span><span class="n">intent</span><span class="o">.</span><span class="n">isdisjoint</span><span class="p">(</span><span class="n">calto_args</span><span class="o">.</span><span class="n">intent</span><span class="p">)])</span></div>



<div class="viewcode-block" id="expand_calstate">
<a class="viewcode-back" href="../../../_automodapi/pipeline.infrastructure.callibrary.expand_calstate.html#pipeline.infrastructure.callibrary.expand_calstate">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">expand_calstate</span><span class="p">(</span><span class="n">calstate</span><span class="p">:</span> <span class="n">IntervalCalState</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="n">CalToArgs</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="n">CalFrom</span><span class="p">]]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert an IntervalCalState into the equivalent consolidated list of</span>
<span class="sd">    (CalToArgs, [CalFrom..]) 2-tuples.</span>

<span class="sd">    This function is the top-level entry point for converting a calibration</span>
<span class="sd">    state to 2-tuples. It consolidates data selections and converts numeric</span>
<span class="sd">    data selection IDs to friendly equivalents through downstream processing,</span>

<span class="sd">    Args:</span>
<span class="sd">        calstate: The IntervalCalState to convert.</span>

<span class="sd">    Returns:</span>
<span class="sd">        A list of (CalToArgs, [CalFrom..]) tuples.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># step 1: convert to [(CalTo, [CalFrom..]), ..]</span>
    <span class="n">unmerged</span> <span class="o">=</span> <span class="n">expand_calstate_to_calapps</span><span class="p">(</span><span class="n">calstate</span><span class="p">)</span>

    <span class="c1"># step 2: consolidate entries with identical calibrations</span>
    <span class="n">consolidated</span> <span class="o">=</span> <span class="n">consolidate_calibrations</span><span class="p">(</span><span class="n">unmerged</span><span class="p">)</span>

    <span class="c1"># step 3: take the list of (CalToArgs, [CalFrom]) tuples, taking any</span>
    <span class="c1"># CalToArgs whose vis property targets multiple MSes and dividing them</span>
    <span class="c1"># into n entries each targeting a single MS. This keeps the export data</span>
    <span class="c1"># format more readable as each entry targets a single measurement set.</span>
    <span class="n">per_ms</span> <span class="o">=</span> <span class="p">[(</span><span class="n">CalToArgs</span><span class="p">({</span><span class="n">vis</span><span class="p">},</span> <span class="o">*</span><span class="n">cta</span><span class="p">[</span><span class="mi">1</span><span class="p">:]),</span> <span class="n">calfroms</span><span class="p">)</span>
              <span class="k">for</span> <span class="n">cta</span><span class="p">,</span> <span class="n">calfroms</span> <span class="ow">in</span> <span class="n">consolidated</span> <span class="k">for</span> <span class="n">vis</span> <span class="ow">in</span> <span class="n">cta</span><span class="o">.</span><span class="n">vis</span><span class="p">]</span>

    <span class="c1"># step 4: convert integer ranges in data selection to friendlier CASA range</span>
    <span class="c1"># syntax, e.g.  [1,2,3,4,6,8] =&gt; [&#39;1~4&#39;,&#39;6&#39;,&#39;8&#39;]</span>
    <span class="n">casa_format</span> <span class="o">=</span> <span class="p">[(</span><span class="n">CalToArgs</span><span class="p">(</span><span class="n">vis</span><span class="o">=</span><span class="n">calto_args</span><span class="o">.</span><span class="n">vis</span><span class="p">,</span>
                              <span class="n">antenna</span><span class="o">=</span><span class="n">sequence_to_casa_range</span><span class="p">(</span><span class="n">calto_args</span><span class="o">.</span><span class="n">antenna</span><span class="p">),</span>
                              <span class="n">spw</span><span class="o">=</span><span class="n">sequence_to_casa_range</span><span class="p">(</span><span class="n">calto_args</span><span class="o">.</span><span class="n">spw</span><span class="p">),</span>
                              <span class="n">field</span><span class="o">=</span><span class="n">calto_args</span><span class="o">.</span><span class="n">field</span><span class="p">,</span>
                              <span class="n">intent</span><span class="o">=</span><span class="n">calto_args</span><span class="o">.</span><span class="n">intent</span><span class="p">),</span> <span class="n">calfroms</span><span class="p">)</span>
                   <span class="k">for</span> <span class="n">calto_args</span><span class="p">,</span> <span class="n">calfroms</span> <span class="ow">in</span> <span class="n">per_ms</span><span class="p">]</span>

    <span class="c1"># step 5: convert each iterable argument to a comma-separated string</span>
    <span class="k">return</span> <span class="p">[(</span><span class="n">CalToArgs</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">safe_join</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">calto_args</span><span class="p">]),</span> <span class="n">calfroms</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">calto_args</span><span class="p">,</span> <span class="n">calfroms</span> <span class="ow">in</span> <span class="n">casa_format</span><span class="p">]</span></div>



<div class="viewcode-block" id="get_min_max">
<a class="viewcode-back" href="../../../_automodapi/pipeline.infrastructure.callibrary.get_min_max.html#pipeline.infrastructure.callibrary.get_min_max">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_min_max</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">keyfunc</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">keyfunc</span><span class="p">:</span>
        <span class="n">l</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">keyfunc</span><span class="p">,</span> <span class="n">l</span><span class="p">))</span>
    <span class="c1"># this function is used to specify Interval ranges, which are not</span>
    <span class="c1"># inclusive of the upper bound - hence the +1.</span>
    <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">l</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span></div>



<div class="viewcode-block" id="create_interval_tree">
<a class="viewcode-back" href="../../../_automodapi/pipeline.infrastructure.callibrary.create_interval_tree.html#pipeline.infrastructure.callibrary.create_interval_tree">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">create_interval_tree</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create an IntervalTree containing a set of Intervals.</span>

<span class="sd">    The input argument used to create the Intervals is an iterable of</span>
<span class="sd">    3-tuples, each 3-tuple defined as:</span>

<span class="sd">    (interval start, interval end, function giving value for that interval).</span>

<span class="sd">    :param a: the iterable of argument tuples</span>
<span class="sd">    :return: IntervalTree</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">intervals</span> <span class="o">=</span> <span class="p">(</span><span class="n">intervaltree</span><span class="o">.</span><span class="n">Interval</span><span class="p">(</span><span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">data_fn</span><span class="p">())</span>
                 <span class="k">for</span> <span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">data_fn</span> <span class="ow">in</span> <span class="n">a</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">intervaltree</span><span class="o">.</span><span class="n">IntervalTree</span><span class="p">(</span><span class="n">intervals</span><span class="p">)</span></div>



<div class="viewcode-block" id="create_interval_tree_nd">
<a class="viewcode-back" href="../../../_automodapi/pipeline.infrastructure.callibrary.create_interval_tree_nd.html#pipeline.infrastructure.callibrary.create_interval_tree_nd">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">create_interval_tree_nd</span><span class="p">(</span><span class="n">intervals</span><span class="p">,</span> <span class="n">value_fn</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a multidimensional IntervalTree. Each Interval within the</span>
<span class="sd">    IntervalTree points to the next dimension, with the final Interval</span>
<span class="sd">    containing the value given by calling value_fn.</span>

<span class="sd">    :param intervals: a list of Interval lists, with range of the final</span>
<span class="sd">    (deepest) first, ending with the range of the root dimension</span>
<span class="sd">    :param value_fn: function that returns value for the final dimension</span>
<span class="sd">    :return: an IntervalTree</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># wrapper to create TimestampedData objects with a fixed timestamp of now</span>
    <span class="n">tsd_now</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">TimestampedData</span><span class="p">,</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">())</span>

    <span class="c1"># Intervals have to point to the next dimension, so we must create the</span>
    <span class="c1"># dimensions in reverse order, starting with the deepest dimension.</span>
    <span class="n">final_tree</span> <span class="o">=</span> <span class="n">create_interval_tree</span><span class="p">([(</span><span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="k">lambda</span><span class="p">:</span> <span class="n">tsd_now</span><span class="p">(</span><span class="n">value_fn</span><span class="p">()))</span>
                                       <span class="k">for</span> <span class="n">begin</span><span class="p">,</span> <span class="n">end</span> <span class="ow">in</span> <span class="n">intervals</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
    <span class="n">root</span> <span class="o">=</span> <span class="n">final_tree</span>

    <span class="c1"># the parent dimensions just link to their child dimensions, similar to a</span>
    <span class="c1"># linked list</span>
    <span class="k">for</span> <span class="n">current_dim_intervals</span> <span class="ow">in</span> <span class="n">intervals</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
        <span class="n">dim_args</span> <span class="o">=</span> <span class="p">[(</span><span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="k">lambda</span><span class="p">:</span> <span class="n">tsd_now</span><span class="p">(</span><span class="n">root</span><span class="p">))</span>
                    <span class="k">for</span> <span class="n">begin</span><span class="p">,</span> <span class="n">end</span> <span class="ow">in</span> <span class="n">current_dim_intervals</span><span class="p">]</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">create_interval_tree</span><span class="p">(</span><span class="n">dim_args</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">root</span></div>



<div class="viewcode-block" id="create_interval_tree_for_ms">
<a class="viewcode-back" href="../../../_automodapi/pipeline.infrastructure.callibrary.create_interval_tree_for_ms.html#pipeline.infrastructure.callibrary.create_interval_tree_for_ms">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">create_interval_tree_for_ms</span><span class="p">(</span><span class="n">ms</span><span class="p">:</span> <span class="n">MeasurementSet</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">intervaltree</span><span class="o">.</span><span class="n">IntervalTree</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a new IntervalTree fitted to the dimensions of a measurement set.</span>

<span class="sd">    This function creates a new IntervalTree with the size of the antenna,</span>
<span class="sd">    spw, field and intent dimensions fitted to envelop of the input measurement</span>
<span class="sd">    set.</span>

<span class="sd">    Args:</span>
<span class="sd">        ms: MeasurementSet to create new IntervalTree for.</span>

<span class="sd">    Returns:</span>
<span class="sd">        An IntervalTree fitted to the dimensions of given measurement set.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">id_getter</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">attrgetter</span><span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
    <span class="n">tree_intervals</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">ms</span><span class="o">.</span><span class="n">intents</span><span class="p">))],</span>
        <span class="p">[</span><span class="n">get_min_max</span><span class="p">(</span><span class="n">ms</span><span class="o">.</span><span class="n">fields</span><span class="p">,</span> <span class="n">keyfunc</span><span class="o">=</span><span class="n">id_getter</span><span class="p">)],</span>
        <span class="p">[</span><span class="n">get_min_max</span><span class="p">(</span><span class="n">ms</span><span class="o">.</span><span class="n">spectral_windows</span><span class="p">,</span> <span class="n">keyfunc</span><span class="o">=</span><span class="n">id_getter</span><span class="p">)],</span>
        <span class="p">[</span><span class="n">get_min_max</span><span class="p">(</span><span class="n">ms</span><span class="o">.</span><span class="n">antennas</span><span class="p">,</span> <span class="n">keyfunc</span><span class="o">=</span><span class="n">id_getter</span><span class="p">)]</span>
    <span class="p">]</span>

    <span class="k">return</span> <span class="n">create_interval_tree_nd</span><span class="p">(</span><span class="n">tree_intervals</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span></div>



<div class="viewcode-block" id="trim">
<a class="viewcode-back" href="../../../_automodapi/pipeline.infrastructure.callibrary.trim.html#pipeline.infrastructure.callibrary.trim">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">trim</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">ranges</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return an IntervalTree trimmed to the specified ranges.</span>

<span class="sd">    Ranges are specified as tuples of (begin, end).</span>

<span class="sd">    :param tree: the IntervalTree to trim</span>
<span class="sd">    :param ranges: a list of range tuples</span>
<span class="sd">    :return: the trimmed IntervalTree</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">insertions</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">begin</span><span class="p">,</span> <span class="n">end</span> <span class="ow">in</span> <span class="n">ranges</span><span class="p">:</span>
        <span class="c1"># locate Intervals overlapping the range, not just those completely</span>
        <span class="c1"># contained within the range</span>
        <span class="n">overlapping</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">overlap</span><span class="p">(</span><span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>

        <span class="c1"># truncate the Intervals to the range boundaries</span>
        <span class="n">truncated</span> <span class="o">=</span> <span class="p">{</span><span class="n">intervaltree</span><span class="o">.</span><span class="n">Interval</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">iv</span><span class="o">.</span><span class="n">begin</span><span class="p">,</span> <span class="n">begin</span><span class="p">),</span>
                                           <span class="nb">min</span><span class="p">(</span><span class="n">iv</span><span class="o">.</span><span class="n">end</span><span class="p">,</span> <span class="n">end</span><span class="p">),</span>
                                           <span class="n">iv</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
                     <span class="k">for</span> <span class="n">iv</span> <span class="ow">in</span> <span class="n">overlapping</span><span class="p">}</span>
        <span class="n">insertions</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">truncated</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">intervaltree</span><span class="o">.</span><span class="n">IntervalTree</span><span class="p">(</span><span class="n">insertions</span><span class="p">)</span></div>



<div class="viewcode-block" id="trim_nd">
<a class="viewcode-back" href="../../../_automodapi/pipeline.infrastructure.callibrary.trim_nd.html#pipeline.infrastructure.callibrary.trim_nd">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">trim_nd</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">selection</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return an IntervalTree with each dimension trimmed to the specified</span>
<span class="sd">    set of ranges.</span>

<span class="sd">    The data selection for each dimension is specified as a sequence of</span>
<span class="sd">    (begin, end) tuples; the data selection for the tree as a whole is a</span>
<span class="sd">    sequence of these dimension sequences. For example, the data selection</span>

<span class="sd">        [ [(1, 3)], [(0, 5), (7, 8)] ]</span>

<span class="sd">    would select 1-3 from the first dimension and 0-5, and 7 from the</span>
<span class="sd">    second dimension.</span>

<span class="sd">    :param tree: the IntervalTree to trim</span>
<span class="sd">    :param selection: the sequence of data selections for each dimension</span>
<span class="sd">    :return:</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># print(&#39;tree={}\nselection={}&#39;.format(tree, selection))</span>
    <span class="n">root</span> <span class="o">=</span> <span class="n">trim</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">selection</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">selection</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># TimestampedData objects are immutable namedtuples, so to change the</span>
        <span class="c1"># data they point to we must replace the whole Interval. These</span>
        <span class="c1"># replacement Intervals are identical to those they replace except for</span>
        <span class="c1"># the TimestampedData.data property, which is trimmed to the next set</span>
        <span class="c1"># of dimensions</span>
        <span class="n">replacements</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">intervaltree</span><span class="o">.</span><span class="n">Interval</span><span class="p">(</span><span class="n">iv</span><span class="o">.</span><span class="n">begin</span><span class="p">,</span>
                                  <span class="n">iv</span><span class="o">.</span><span class="n">end</span><span class="p">,</span>
                                  <span class="n">TimestampedData</span><span class="p">(</span><span class="n">iv</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">time</span><span class="p">,</span>
                                                  <span class="n">trim_nd</span><span class="p">(</span><span class="n">tsd_accessor</span><span class="p">(</span><span class="n">iv</span><span class="p">),</span> <span class="n">selection</span><span class="p">[</span><span class="mi">1</span><span class="p">:])))</span>
            <span class="k">for</span> <span class="n">iv</span> <span class="ow">in</span> <span class="n">root</span>
        <span class="p">}</span>
        <span class="c1"># now remove the untrimmed Intervals and replace them with our trimmed</span>
        <span class="c1"># versions</span>
        <span class="n">root</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="n">root</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">replacements</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">root</span></div>



<div class="viewcode-block" id="get_intent_id_map">
<a class="viewcode-back" href="../../../_automodapi/pipeline.infrastructure.callibrary.get_intent_id_map.html#pipeline.infrastructure.callibrary.get_intent_id_map">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_intent_id_map</span><span class="p">(</span><span class="n">ms</span><span class="p">:</span> <span class="n">MeasurementSet</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the mapping of intent ID to string intent for a measurement set.</span>

<span class="sd">    Args:</span>
<span class="sd">        ms: The measurement set to analyse.</span>

<span class="sd">    Returns:</span>
<span class="sd">        A dict of intent ID: intent.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># intents are sorted to ensure consistent ordering</span>
    <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">ms</span><span class="o">.</span><span class="n">intents</span><span class="p">)))</span></div>



<div class="viewcode-block" id="IntervalCalState">
<a class="viewcode-back" href="../../../_automodapi/pipeline.infrastructure.callibrary.IntervalCalState.html#pipeline.infrastructure.callibrary.IntervalCalState">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">IntervalCalState</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    IntervalCalState is a data structure used to map calibrations for all data</span>
<span class="sd">    registered with the pipeline.</span>

<span class="sd">    It is implemented as a multi-dimensional array indexed by data selection</span>
<span class="sd">    parameters (ms, spw, field, intent, antenna), with the end value being a</span>
<span class="sd">    list of CalFroms, representing the calibrations to be applied to that data</span>
<span class="sd">    selection.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize an IntervalCalState object.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">id_to_intent</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">id_to_field</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">{}</span>

<div class="viewcode-block" id="IntervalCalState.from_calapplication">
<a class="viewcode-back" href="../../../_automodapi/pipeline.infrastructure.callibrary.IntervalCalState.html#pipeline.infrastructure.callibrary.IntervalCalState.from_calapplication">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_calapplication</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">calto</span><span class="p">,</span> <span class="n">calfroms</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">calfroms</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">calfroms</span> <span class="o">=</span> <span class="p">[</span><span class="n">calfroms</span><span class="p">]</span>

        <span class="n">adapted</span> <span class="o">=</span> <span class="n">CalToIntervalAdapter</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">calto</span><span class="p">)</span>

        <span class="n">selection_intervals</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">adapted</span><span class="o">.</span><span class="n">intent</span><span class="p">,</span>
            <span class="n">adapted</span><span class="o">.</span><span class="n">field</span><span class="p">,</span>
            <span class="n">adapted</span><span class="o">.</span><span class="n">spw</span><span class="p">,</span>
            <span class="n">adapted</span><span class="o">.</span><span class="n">antenna</span>
        <span class="p">]</span>
        <span class="n">selection</span> <span class="o">=</span> <span class="n">create_interval_tree_nd</span><span class="p">(</span><span class="n">selection_intervals</span><span class="p">,</span> <span class="k">lambda</span><span class="p">:</span> <span class="n">calfroms</span><span class="p">)</span>

        <span class="n">calstate</span> <span class="o">=</span> <span class="n">IntervalCalState</span><span class="o">.</span><span class="n">create_from_context</span><span class="p">(</span><span class="n">context</span><span class="p">)</span>
        <span class="n">ms</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">observing_run</span><span class="o">.</span><span class="n">get_ms</span><span class="p">(</span><span class="n">calto</span><span class="o">.</span><span class="n">vis</span><span class="p">)</span>
        <span class="n">calstate</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">ms</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">selection</span>

        <span class="n">calstate</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">ms</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">trim_to_valid_data_selection</span><span class="p">(</span><span class="n">calstate</span><span class="p">,</span> <span class="n">ms</span><span class="o">.</span><span class="n">name</span><span class="p">)[</span><span class="n">ms</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">calstate</span></div>


<div class="viewcode-block" id="IntervalCalState.create_from_context">
<a class="viewcode-back" href="../../../_automodapi/pipeline.infrastructure.callibrary.IntervalCalState.html#pipeline.infrastructure.callibrary.IntervalCalState.create_from_context">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">create_from_context</span><span class="p">(</span><span class="n">context</span><span class="p">:</span> <span class="n">launcher</span><span class="o">.</span><span class="n">Context</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">IntervalCalState</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a new IntervalCalState based on given Pipeline context.</span>

<span class="sd">        This method initialises a new IntervalCalState instance and then updates</span>
<span class="sd">        its key attributes by generating &quot;ID to intent&quot; and &quot;ID to field&quot;</span>
<span class="sd">        mapping dictionaries, generating interval trees with correct dimensions,</span>
<span class="sd">        and computing the shape, for all measurement sets that are registered in</span>
<span class="sd">        the given context.</span>

<span class="sd">        Args:</span>
<span class="sd">            context: The Pipeline context.</span>

<span class="sd">        Returns:</span>
<span class="sd">            IntervalCalState based on given Pipeline context.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">LOG</span><span class="o">.</span><span class="n">isEnabledFor</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">TRACE</span><span class="p">):</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;Creating new CalLibrary from context&#39;</span><span class="p">)</span>

        <span class="c1"># holds a mapping of numeric intent ID to string intent for each ms.</span>
        <span class="n">id_to_intent</span> <span class="o">=</span> <span class="p">{</span><span class="n">ms</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="n">get_intent_id_map</span><span class="p">(</span><span class="n">ms</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">ms</span> <span class="ow">in</span> <span class="n">context</span><span class="o">.</span><span class="n">observing_run</span><span class="o">.</span><span class="n">measurement_sets</span><span class="p">}</span>

        <span class="c1"># holds a mapping of numeric ID to field name for each ms.</span>
        <span class="n">id_to_field</span> <span class="o">=</span> <span class="p">{</span><span class="n">ms</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="p">{</span><span class="n">field</span><span class="o">.</span><span class="n">id</span><span class="p">:</span> <span class="n">field</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">ms</span><span class="o">.</span><span class="n">fields</span><span class="p">}</span>
                       <span class="k">for</span> <span class="n">ms</span> <span class="ow">in</span> <span class="n">context</span><span class="o">.</span><span class="n">observing_run</span><span class="o">.</span><span class="n">measurement_sets</span><span class="p">}</span>

        <span class="n">calstate</span> <span class="o">=</span> <span class="n">IntervalCalState</span><span class="p">()</span>
        <span class="n">calstate</span><span class="o">.</span><span class="n">id_to_intent</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">id_to_intent</span><span class="p">)</span>
        <span class="n">calstate</span><span class="o">.</span><span class="n">id_to_field</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">id_to_field</span><span class="p">)</span>

        <span class="n">interval_trees</span> <span class="o">=</span> <span class="p">{</span><span class="n">ms</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="n">create_interval_tree_for_ms</span><span class="p">(</span><span class="n">ms</span><span class="p">)</span>
                          <span class="k">for</span> <span class="n">ms</span> <span class="ow">in</span> <span class="n">context</span><span class="o">.</span><span class="n">observing_run</span><span class="o">.</span><span class="n">measurement_sets</span><span class="p">}</span>
        <span class="n">calstate</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">interval_trees</span><span class="p">)</span>

        <span class="c1"># the shape is never modified and hence can be shared between calstates</span>
        <span class="k">for</span> <span class="n">ms</span> <span class="ow">in</span> <span class="n">context</span><span class="o">.</span><span class="n">observing_run</span><span class="o">.</span><span class="n">measurement_sets</span><span class="p">:</span>
            <span class="n">calstate</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">ms</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_calstate_shape</span><span class="p">(</span><span class="n">ms</span><span class="p">)</span>

        <span class="n">calstate</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">trim_to_valid_data_selection</span><span class="p">(</span><span class="n">calstate</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">calstate</span></div>


<div class="viewcode-block" id="IntervalCalState.clear">
<a class="viewcode-back" href="../../../_automodapi/pipeline.infrastructure.callibrary.IntervalCalState.html#pipeline.infrastructure.callibrary.IntervalCalState.clear">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">clear</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">calstate</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">calstate</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span></div>

        <span class="c1"># do NOT clear the id mapping dicts as without access to the context</span>
        <span class="c1"># we have no way to repopulate them.</span>
        <span class="c1"># self.id_to_intent.clear()</span>
        <span class="c1"># self.id_to_field.clear()</span>

<div class="viewcode-block" id="IntervalCalState.trimmed">
<a class="viewcode-back" href="../../../_automodapi/pipeline.infrastructure.callibrary.IntervalCalState.html#pipeline.infrastructure.callibrary.IntervalCalState.trimmed">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">trimmed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">calto</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a copy of this IntervalCalState trimmed to the specified CalTo data selection.</span>
<span class="sd">        :param calto:</span>
<span class="sd">        :param selection_intervals:</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># wrap the text-only CalTo in a CalToIntervalAdapter, which will parse</span>
        <span class="c1"># the CalTo properties and give us the appropriate subtable IDs to</span>
        <span class="c1"># iterate over</span>
        <span class="n">adapted</span> <span class="o">=</span> <span class="n">CalToIntervalAdapter</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">calto</span><span class="p">)</span>

        <span class="c1"># get the data selection as numeric IDs</span>
        <span class="n">selection_intervals</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">adapted</span><span class="o">.</span><span class="n">antenna</span><span class="p">,</span>
            <span class="n">adapted</span><span class="o">.</span><span class="n">spw</span><span class="p">,</span>
            <span class="n">adapted</span><span class="o">.</span><span class="n">field</span><span class="p">,</span>
            <span class="n">adapted</span><span class="o">.</span><span class="n">intent</span>
        <span class="p">]</span>

        <span class="c1"># get a copy of this calstate trimmed to the CalTo data selection</span>
        <span class="n">vis</span> <span class="o">=</span> <span class="n">adapted</span><span class="o">.</span><span class="n">ms</span><span class="o">.</span><span class="n">name</span>

        <span class="c1"># if the data has not been registered with the CalLibrary, create a</span>
        <span class="c1"># new and empty calibration application and register it, thereby</span>
        <span class="c1"># creating all the IntervalTrees necessary for the MS.</span>
        <span class="k">if</span> <span class="n">vis</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">:</span>
            <span class="n">ms</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">observing_run</span><span class="o">.</span><span class="n">get_ms</span><span class="p">(</span><span class="n">vis</span><span class="p">)</span>
            <span class="n">calto</span> <span class="o">=</span> <span class="n">CalTo</span><span class="p">(</span><span class="n">vis</span><span class="o">=</span><span class="n">ms</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="n">to_add</span> <span class="o">=</span> <span class="n">IntervalCalState</span><span class="o">.</span><span class="n">from_calapplication</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">calto</span><span class="p">,</span> <span class="p">[])</span>
            <span class="bp">self</span><span class="o">.</span><span class="fm">__iadd__</span><span class="p">(</span><span class="n">to_add</span><span class="p">)</span>

        <span class="n">copied</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">vis</span><span class="p">])</span>
        <span class="n">trimmed</span> <span class="o">=</span> <span class="n">trim_nd</span><span class="p">(</span><span class="n">copied</span><span class="p">,</span> <span class="n">selection_intervals</span><span class="p">)</span>

        <span class="n">calstate</span> <span class="o">=</span> <span class="n">IntervalCalState</span><span class="p">()</span>
        <span class="n">calstate</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">vis</span><span class="p">]</span> <span class="o">=</span> <span class="n">trimmed</span>
        <span class="n">calstate</span><span class="o">.</span><span class="n">id_to_intent</span><span class="p">[</span><span class="n">vis</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">id_to_intent</span><span class="p">[</span><span class="n">vis</span><span class="p">]</span>
        <span class="n">calstate</span><span class="o">.</span><span class="n">id_to_field</span><span class="p">[</span><span class="n">vis</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">id_to_field</span><span class="p">[</span><span class="n">vis</span><span class="p">]</span>
        <span class="n">calstate</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span>

        <span class="k">return</span> <span class="n">calstate</span></div>


<div class="viewcode-block" id="IntervalCalState.get_caltable">
<a class="viewcode-back" href="../../../_automodapi/pipeline.infrastructure.callibrary.IntervalCalState.html#pipeline.infrastructure.callibrary.IntervalCalState.get_caltable">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_caltable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">caltypes</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the names of all caltables registered with this CalState.</span>

<span class="sd">        If an optional caltypes argument is given, only caltables of the</span>
<span class="sd">        requested type will be returned.</span>

<span class="sd">        :param caltypes: Caltypes should be one or/a list of table</span>
<span class="sd">        types known in CalFrom.CALTYPES.</span>

<span class="sd">        :rtype: set of strings</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">caltypes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">caltypes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">CalFrom</span><span class="o">.</span><span class="n">CALTYPES</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">caltypes</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">caltypes</span> <span class="o">=</span> <span class="p">(</span><span class="n">caltypes</span><span class="p">,)</span>

        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">caltypes</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">CalFrom</span><span class="o">.</span><span class="n">CALTYPES</span>

        <span class="k">return</span> <span class="p">{</span><span class="n">calfrom</span><span class="o">.</span><span class="n">gaintable</span> <span class="k">for</span> <span class="n">calfroms</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">merged</span><span class="p">()</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">calfrom</span> <span class="ow">in</span> <span class="n">calfroms</span>
                <span class="k">if</span> <span class="n">calfrom</span><span class="o">.</span><span class="n">caltype</span> <span class="ow">in</span> <span class="n">caltypes</span><span class="p">}</span></div>


<div class="viewcode-block" id="IntervalCalState.merged">
<a class="viewcode-back" href="../../../_automodapi/pipeline.infrastructure.callibrary.IntervalCalState.html#pipeline.infrastructure.callibrary.IntervalCalState.merged">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">merged</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hide_empty</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">calapps</span> <span class="o">=</span> <span class="n">expand_calstate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">hide_empty</span><span class="p">:</span>
            <span class="n">calapps</span> <span class="o">=</span> <span class="p">[</span><span class="n">ca</span> <span class="k">for</span> <span class="n">ca</span> <span class="ow">in</span> <span class="n">calapps</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ca</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>

        <span class="c1"># TODO dict is unnecessary. refactor all usages of this class to use</span>
        <span class="c1"># the tuple</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">calapps</span><span class="p">)</span></div>


<div class="viewcode-block" id="IntervalCalState.export_to_casa_callibrary">
<a class="viewcode-back" href="../../../_automodapi/pipeline.infrastructure.callibrary.IntervalCalState.html#pipeline.infrastructure.callibrary.IntervalCalState.export_to_casa_callibrary">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">export_to_casa_callibrary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ms</span><span class="p">,</span> <span class="n">callibfile</span><span class="p">):</span>
        <span class="n">calapps</span> <span class="o">=</span> <span class="p">(</span><span class="n">CalApplication</span><span class="p">(</span><span class="n">calto</span><span class="p">,</span> <span class="n">calfroms</span><span class="p">)</span>
                   <span class="k">for</span> <span class="n">calto</span><span class="p">,</span> <span class="n">calfroms</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">merged</span><span class="p">(</span><span class="n">hide_empty</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
        <span class="n">append</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">calapp</span> <span class="ow">in</span> <span class="n">calapps</span><span class="p">:</span>
            <span class="n">casa_intents</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">to_CASA_intent</span><span class="p">(</span><span class="n">ms</span><span class="p">,</span> <span class="n">calapp</span><span class="o">.</span><span class="n">intent</span><span class="p">)</span>
            <span class="n">applycaltocallib</span><span class="p">(</span><span class="n">callibfile</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="n">append</span><span class="p">,</span> <span class="n">field</span><span class="o">=</span><span class="n">calapp</span><span class="o">.</span><span class="n">field</span><span class="p">,</span> <span class="n">intent</span><span class="o">=</span><span class="n">casa_intents</span><span class="p">,</span> <span class="n">spw</span><span class="o">=</span><span class="n">calapp</span><span class="o">.</span><span class="n">spw</span><span class="p">,</span>
                             <span class="n">gaintable</span><span class="o">=</span><span class="n">calapp</span><span class="o">.</span><span class="n">gaintable</span><span class="p">,</span> <span class="n">gainfield</span><span class="o">=</span><span class="n">calapp</span><span class="o">.</span><span class="n">gainfield</span><span class="p">,</span> <span class="n">interp</span><span class="o">=</span><span class="n">calapp</span><span class="o">.</span><span class="n">interp</span><span class="p">,</span>
                             <span class="n">spwmap</span><span class="o">=</span><span class="n">calapp</span><span class="o">.</span><span class="n">spwmap</span><span class="p">,</span> <span class="n">calwt</span><span class="o">=</span><span class="n">calapp</span><span class="o">.</span><span class="n">calwt</span><span class="p">)</span>
            <span class="n">append</span> <span class="o">=</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="IntervalCalState.as_applycal">
<a class="viewcode-back" href="../../../_automodapi/pipeline.infrastructure.callibrary.IntervalCalState.html#pipeline.infrastructure.callibrary.IntervalCalState.as_applycal">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">as_applycal</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the CalState as a string representation of the corresponding applycal commands.&quot;&quot;&quot;</span>
        <span class="n">calapps</span> <span class="o">=</span> <span class="p">(</span><span class="n">CalApplication</span><span class="p">(</span><span class="n">calto</span><span class="p">,</span> <span class="n">calfroms</span><span class="p">)</span>
                   <span class="k">for</span> <span class="n">calto</span><span class="p">,</span> <span class="n">calfroms</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">merged</span><span class="p">(</span><span class="n">hide_empty</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>

        <span class="k">return</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">calapps</span><span class="p">])</span></div>


    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_applycal</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_combine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">IntervalCalState</span><span class="p">,</span> <span class="n">combine_fn</span><span class="p">:</span> <span class="n">Callable</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">IntervalCalState</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the union of this object combined with another IntervalCalState,</span>
<span class="sd">        applying a function to any Intervals that overlap.</span>

<span class="sd">        Args:</span>
<span class="sd">            other: The other IntervalCalState.</span>
<span class="sd">            combine_fn: The combining function to apply to overlapping intervals.</span>

<span class="sd">        Returns:</span>
<span class="sd">            New IntervalCalState object representing union of this</span>
<span class="sd">            IntervalCalState and given ``other`` IntervalCalState.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">calstate</span> <span class="o">=</span> <span class="n">IntervalCalState</span><span class="p">()</span>

        <span class="c1"># ensure that the other calstate is not considered equal to this</span>
        <span class="c1"># calstate, even if they the values they hold are identical. This step</span>
        <span class="c1"># is required so that all entries are added to in the union</span>
        <span class="c1"># (my_root | other_root) operation, and ensures that arithmetic like</span>
        <span class="c1"># &#39;calstate_x - calstate_x = 0&#39; holds true.</span>
        <span class="n">marker</span> <span class="o">=</span> <span class="n">uuid</span><span class="o">.</span><span class="n">uuid4</span><span class="p">()</span>
        <span class="n">other_marked</span> <span class="o">=</span> <span class="n">set_calstate_marker</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">marker</span><span class="p">)</span>

        <span class="c1"># copy the ID mapping and shape data across.</span>
        <span class="n">calstate</span><span class="o">.</span><span class="n">id_to_intent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">id_to_intent</span>
        <span class="n">calstate</span><span class="o">.</span><span class="n">id_to_field</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">id_to_field</span>
        <span class="n">calstate</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span>

        <span class="k">for</span> <span class="n">vis</span><span class="p">,</span> <span class="n">my_root</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">LOG</span><span class="o">.</span><span class="n">isEnabledFor</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">TRACE</span><span class="p">):</span>
                <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;Combining callibrary entries for </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">vis</span><span class="p">)))</span>
            <span class="c1"># adopt IntervalTrees present in just this object</span>
            <span class="k">if</span> <span class="n">vis</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">other_marked</span><span class="o">.</span><span class="n">data</span><span class="p">:</span>
                <span class="c1"># TODO think: does this need to be a deep copy?</span>
                <span class="n">calstate</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">vis</span><span class="p">]</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">vis</span><span class="p">])</span>
                <span class="k">continue</span>

            <span class="c1"># get the union of IntervalTrees for MSes present in both objects</span>
            <span class="n">other_root</span> <span class="o">=</span> <span class="n">other_marked</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">vis</span><span class="p">]</span>
            <span class="n">union</span> <span class="o">=</span> <span class="n">my_root</span> <span class="o">|</span> <span class="n">other_root</span>
            <span class="n">union</span><span class="o">.</span><span class="n">split_overlaps</span><span class="p">()</span>
            <span class="n">union</span><span class="o">.</span><span class="n">merge_equals</span><span class="p">(</span><span class="n">data_reducer</span><span class="o">=</span><span class="n">combine_fn</span><span class="p">)</span>

            <span class="n">calstate</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">vis</span><span class="p">]</span> <span class="o">=</span> <span class="n">union</span>

        <span class="n">calstate</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">trim_to_valid_data_selection</span><span class="p">(</span><span class="n">calstate</span><span class="p">)</span>

        <span class="c1"># Unmark the result calstate, thus eliminating any residual uuids</span>
        <span class="n">unmarked</span> <span class="o">=</span> <span class="n">set_calstate_marker</span><span class="p">(</span><span class="n">calstate</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">unmarked</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">IntervalCalState</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">IntervalCalState</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Defines how to add this IntervalCalState to given ``other`` IntervalCalState.&quot;&quot;&quot;</span>
        <span class="c1"># Create new IntervalCalState by combining this IntervalCalState with</span>
        <span class="c1"># given &quot;other&quot; IntervalCalState, while applying the &quot;antenna addition&quot;</span>
        <span class="c1"># function chain to overlapping intervals.</span>
        <span class="n">calstate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_combine</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ant_add</span><span class="p">)</span>

        <span class="c1"># also adopt IntervalTrees only present in the other object</span>
        <span class="k">for</span> <span class="n">vis</span><span class="p">,</span> <span class="n">other_root</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">vis</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">:</span>
                <span class="n">calstate</span><span class="p">[</span><span class="n">vis</span><span class="p">]</span> <span class="o">=</span> <span class="n">other_root</span>
                <span class="n">calstate</span><span class="o">.</span><span class="n">id_to_intent</span><span class="p">[</span><span class="n">vis</span><span class="p">]</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">id_to_intent</span><span class="p">[</span><span class="n">vis</span><span class="p">]</span>
                <span class="n">calstate</span><span class="o">.</span><span class="n">id_to_field</span><span class="p">[</span><span class="n">vis</span><span class="p">]</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">id_to_field</span><span class="p">[</span><span class="n">vis</span><span class="p">]</span>
                <span class="n">calstate</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">vis</span><span class="p">]</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">vis</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">calstate</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__iadd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="n">sum_state</span> <span class="o">=</span> <span class="bp">self</span> <span class="o">+</span> <span class="n">other</span>

        <span class="c1"># adopt all properties from the added states</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">sum_state</span><span class="o">.</span><span class="n">data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">id_to_field</span> <span class="o">=</span> <span class="n">sum_state</span><span class="o">.</span><span class="n">id_to_field</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">id_to_intent</span> <span class="o">=</span> <span class="n">sum_state</span><span class="o">.</span><span class="n">id_to_intent</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">sum_state</span><span class="o">.</span><span class="n">shape</span>

        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_combine</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ant_sub</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span></div>



<div class="viewcode-block" id="fix_cycle0_data_selection">
<a class="viewcode-back" href="../../../_automodapi/pipeline.infrastructure.callibrary.fix_cycle0_data_selection.html#pipeline.infrastructure.callibrary.fix_cycle0_data_selection">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">fix_cycle0_data_selection</span><span class="p">(</span><span class="n">context</span><span class="p">:</span> <span class="n">launcher</span><span class="o">.</span><span class="n">Context</span><span class="p">,</span> <span class="n">calstate</span><span class="p">:</span> <span class="n">IntervalCalState</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">IntervalCalState</span><span class="p">:</span>
    <span class="c1"># shortcut to minimise processing for data from Cycle 1 onwards.</span>
    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">utils</span><span class="o">.</span><span class="n">get_epoch_as_datetime</span><span class="p">(</span><span class="n">ms</span><span class="o">.</span><span class="n">start_time</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">CYCLE_0_END_DATE</span>
           <span class="k">for</span> <span class="n">ms</span> <span class="ow">in</span> <span class="n">context</span><span class="o">.</span><span class="n">observing_run</span><span class="o">.</span><span class="n">measurement_sets</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">calstate</span>

    <span class="n">final_calstate</span> <span class="o">=</span> <span class="n">IntervalCalState</span><span class="o">.</span><span class="n">create_from_context</span><span class="p">(</span><span class="n">context</span><span class="p">)</span>

    <span class="c1"># We can&#39;t trust Cycle 0 data intents. If this is Cycle 0 data we need</span>
    <span class="c1"># to resolve the intents to fields and add them to the CalTo data</span>
    <span class="c1"># selection to ensure that the correct data is selected.</span>
    <span class="k">for</span> <span class="n">calto</span><span class="p">,</span> <span class="n">calfroms</span> <span class="ow">in</span> <span class="n">calstate</span><span class="o">.</span><span class="n">merged</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">vis</span> <span class="o">=</span> <span class="n">calto</span><span class="o">.</span><span class="n">vis</span>
        <span class="n">ms</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">observing_run</span><span class="o">.</span><span class="n">get_ms</span><span class="p">(</span><span class="n">vis</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">utils</span><span class="o">.</span><span class="n">get_epoch_as_datetime</span><span class="p">(</span><span class="n">ms</span><span class="o">.</span><span class="n">start_time</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">CYCLE_0_END_DATE</span><span class="p">:</span>
            <span class="n">final_calstate</span> <span class="o">+=</span> <span class="n">IntervalCalState</span><span class="o">.</span><span class="n">from_calapplication</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">calto</span><span class="p">,</span> <span class="n">calfroms</span><span class="p">)</span>
            <span class="k">continue</span>

        <span class="k">if</span> <span class="n">calto</span><span class="o">.</span><span class="n">intent</span> <span class="o">!=</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
            <span class="n">fields_with_intent</span> <span class="o">=</span> <span class="n">ms</span><span class="o">.</span><span class="n">get_fields</span><span class="p">(</span><span class="n">task_arg</span><span class="o">=</span><span class="n">calto</span><span class="o">.</span><span class="n">field</span><span class="p">,</span> <span class="n">intent</span><span class="o">=</span><span class="n">calto</span><span class="o">.</span><span class="n">intent</span><span class="p">)</span>
            <span class="n">field_names</span> <span class="o">=</span> <span class="p">{</span><span class="n">f</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">fields_with_intent</span><span class="p">}</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">field_names</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">fields_with_intent</span><span class="p">):</span>
                <span class="n">new_field_arg</span> <span class="o">=</span> <span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">field_names</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_field_arg</span> <span class="o">=</span> <span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">field</span><span class="o">.</span><span class="n">id</span><span class="p">)</span> <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">fields_with_intent</span><span class="p">])</span>

            <span class="k">if</span> <span class="n">new_field_arg</span> <span class="o">!=</span> <span class="n">calto</span><span class="o">.</span><span class="n">field</span><span class="p">:</span>
                <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Rewriting data selection to work around mislabeled Cycle 0 data intents. &#39;</span>
                         <span class="s1">&#39;Old field selection: </span><span class="si">%r</span><span class="s1">; new field selection: </span><span class="si">%r</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">calto</span><span class="o">.</span><span class="n">field</span><span class="p">,</span> <span class="n">new_field_arg</span><span class="p">)</span>
                <span class="n">calto</span> <span class="o">=</span> <span class="n">CalTo</span><span class="p">(</span><span class="n">vis</span><span class="o">=</span><span class="n">calto</span><span class="o">.</span><span class="n">vis</span><span class="p">,</span> <span class="n">field</span><span class="o">=</span><span class="n">new_field_arg</span><span class="p">,</span> <span class="n">spw</span><span class="o">=</span><span class="n">calto</span><span class="o">.</span><span class="n">spw</span><span class="p">,</span> <span class="n">antenna</span><span class="o">=</span><span class="n">calto</span><span class="o">.</span><span class="n">antenna</span><span class="p">,</span>
                              <span class="n">intent</span><span class="o">=</span><span class="n">calto</span><span class="o">.</span><span class="n">intent</span><span class="p">)</span>

        <span class="n">to_add</span> <span class="o">=</span> <span class="n">IntervalCalState</span><span class="o">.</span><span class="n">from_calapplication</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">calto</span><span class="p">,</span> <span class="n">calfroms</span><span class="p">)</span>
        <span class="n">final_calstate</span> <span class="o">+=</span> <span class="n">to_add</span>

    <span class="k">return</span> <span class="n">final_calstate</span></div>



<div class="viewcode-block" id="IntervalCalLibrary">
<a class="viewcode-back" href="../../../_automodapi/pipeline.infrastructure.callibrary.IntervalCalLibrary.html#pipeline.infrastructure.callibrary.IntervalCalLibrary">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">IntervalCalLibrary</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    IntervalCalLibrary is the root object for the pipeline calibration state.</span>

<span class="sd">    This implementation of the CalLibrary is based on the interval tree data</span>
<span class="sd">    structure.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">:</span> <span class="n">launcher</span><span class="o">.</span><span class="n">Context</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize an IntervalCalLibrary instance.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_context</span> <span class="o">=</span> <span class="n">context</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_active</span> <span class="o">=</span> <span class="n">IntervalCalState</span><span class="o">.</span><span class="n">create_from_context</span><span class="p">(</span><span class="n">context</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_applied</span> <span class="o">=</span> <span class="n">IntervalCalState</span><span class="o">.</span><span class="n">create_from_context</span><span class="p">(</span><span class="n">context</span><span class="p">)</span>

<div class="viewcode-block" id="IntervalCalLibrary.clear">
<a class="viewcode-back" href="../../../_automodapi/pipeline.infrastructure.callibrary.IntervalCalLibrary.html#pipeline.infrastructure.callibrary.IntervalCalLibrary.clear">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">clear</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Clear all active and applied calibrations.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_active</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_applied</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_calc_filename</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return output filename for this IntervalCalLibrary.</span>

<span class="sd">        If given filename is not None or an empty string, then given filename is</span>
<span class="sd">        returned. Otherwise, a new filename is defined based on the context</span>
<span class="sd">        name.</span>

<span class="sd">        Args:</span>
<span class="sd">            filename: Proposed output filename (optional).</span>

<span class="sd">        Returns:</span>
<span class="sd">            Output filename to use.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">filename</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">filename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_context</span><span class="o">.</span><span class="n">output_dir</span><span class="p">,</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">_context</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;.calstate&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">filename</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_export</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">calstate</span><span class="p">:</span> <span class="n">IntervalCalState</span><span class="p">,</span> <span class="n">filename</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Export input calibration state to a file.</span>

<span class="sd">        Args:</span>
<span class="sd">            calstate: Calibration state to export to a file.</span>
<span class="sd">            filename: Name for saved calibration state file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calc_filename</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>

        <span class="n">calapps</span> <span class="o">=</span> <span class="p">[</span><span class="n">CalApplication</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">calstate</span><span class="o">.</span><span class="n">merged</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">()]</span>

        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">export_file</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ca</span> <span class="ow">in</span> <span class="n">calapps</span><span class="p">:</span>
                <span class="n">export_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">ca</span><span class="o">.</span><span class="n">as_applycal</span><span class="p">())</span>
                <span class="n">export_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="IntervalCalLibrary.add">
<a class="viewcode-back" href="../../../_automodapi/pipeline.infrastructure.callibrary.IntervalCalLibrary.html#pipeline.infrastructure.callibrary.IntervalCalLibrary.add">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">calto</span><span class="p">,</span> <span class="n">calfroms</span><span class="p">):</span>
        <span class="n">to_add</span> <span class="o">=</span> <span class="n">IntervalCalState</span><span class="o">.</span><span class="n">from_calapplication</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_context</span><span class="p">,</span> <span class="n">calto</span><span class="p">,</span> <span class="n">calfroms</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_active</span> <span class="o">+=</span> <span class="n">to_add</span>

        <span class="k">if</span> <span class="n">LOG</span><span class="o">.</span><span class="n">isEnabledFor</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">TRACE</span><span class="p">):</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;Calstate after _add:</span><span class="se">\n</span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_active</span><span class="o">.</span><span class="n">as_applycal</span><span class="p">())</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">active</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">IntervalCalState</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        CalState holding CalApplications to be (pre-)applied to the MS.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_active</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">applied</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">IntervalCalState</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        CalState holding CalApplications that have been applied to the MS via</span>
<span class="sd">        the pipeline applycal task.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_applied</span>

<div class="viewcode-block" id="IntervalCalLibrary.export">
<a class="viewcode-back" href="../../../_automodapi/pipeline.infrastructure.callibrary.IntervalCalLibrary.html#pipeline.infrastructure.callibrary.IntervalCalLibrary.export">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">export</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Export the pre-apply calibration state to disk.</span>

<span class="sd">        The pre-apply calibrations held in the &#39;active&#39; CalState will be</span>
<span class="sd">        written to disk as a set of equivalent applycal calls.</span>

<span class="sd">        Args:</span>
<span class="sd">            filename: Name for saved calibration state file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calc_filename</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Exporting current calibration state to </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_export</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_active</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span></div>


<div class="viewcode-block" id="IntervalCalLibrary.export_applied">
<a class="viewcode-back" href="../../../_automodapi/pipeline.infrastructure.callibrary.IntervalCalLibrary.html#pipeline.infrastructure.callibrary.IntervalCalLibrary.export_applied">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">export_applied</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Export the applied calibration state to disk.</span>

<span class="sd">        The calibrations held in the &#39;applied&#39; CalState will be written to</span>
<span class="sd">        disk as a set of equivalent applycal calls.</span>

<span class="sd">        Args:</span>
<span class="sd">            filename: Name for saved calibration state file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calc_filename</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Exporting applied calibration state to </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_export</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_applied</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span></div>


<div class="viewcode-block" id="IntervalCalLibrary.get_calstate">
<a class="viewcode-back" href="../../../_automodapi/pipeline.infrastructure.callibrary.IntervalCalLibrary.html#pipeline.infrastructure.callibrary.IntervalCalLibrary.get_calstate">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_calstate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">calto</span><span class="p">,</span> <span class="n">ignore</span><span class="p">:</span> <span class="nb">list</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">IntervalCalState</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the active calibration state for a target data selection.</span>

<span class="sd">        Args:</span>
<span class="sd">            calto: The data selection to retrieve active calibration state for.</span>
<span class="sd">            ignore: CalFrom properties to ignore.</span>

<span class="sd">        Returns:</span>
<span class="sd">            New IntervalCalState object representing active calibration state</span>
<span class="sd">            for a target data selection.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ignore</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ignore</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">trimmed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">active</span><span class="o">.</span><span class="n">trimmed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_context</span><span class="p">,</span> <span class="n">calto</span><span class="p">)</span>

        <span class="c1"># TODO replace with something like defrag_tree implementation</span>
        <span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="n">trimmed</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">antenna_interval</span> <span class="ow">in</span> <span class="n">tree</span><span class="p">:</span>
                <span class="n">spw_tree</span> <span class="o">=</span> <span class="n">tsd_accessor</span><span class="p">(</span><span class="n">antenna_interval</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">spw_interval</span> <span class="ow">in</span> <span class="n">spw_tree</span><span class="p">:</span>
                    <span class="n">field_tree</span> <span class="o">=</span> <span class="n">tsd_accessor</span><span class="p">(</span><span class="n">spw_interval</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">field_interval</span> <span class="ow">in</span> <span class="n">field_tree</span><span class="p">:</span>
                        <span class="n">intent_tree</span> <span class="o">=</span> <span class="n">tsd_accessor</span><span class="p">(</span><span class="n">field_interval</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">intent_interval</span> <span class="ow">in</span> <span class="n">intent_tree</span><span class="p">:</span>
                            <span class="n">old_vals</span> <span class="o">=</span> <span class="n">tsd_accessor</span><span class="p">(</span><span class="n">intent_interval</span><span class="p">)</span>
                            <span class="n">old_vals</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_copy_calfrom</span><span class="p">(</span><span class="n">cf</span><span class="p">,</span> <span class="n">ignore</span><span class="p">)</span>
                                           <span class="k">for</span> <span class="n">cf</span> <span class="ow">in</span> <span class="n">old_vals</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">trimmed</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_copy_calfrom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">to_copy</span><span class="p">,</span> <span class="n">ignore</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">ignore</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ignore</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">calfrom_properties</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;caltype&#39;</span><span class="p">,</span> <span class="s1">&#39;calwt&#39;</span><span class="p">,</span> <span class="s1">&#39;gainfield&#39;</span><span class="p">,</span> <span class="s1">&#39;gaintable&#39;</span><span class="p">,</span>
                              <span class="s1">&#39;interp&#39;</span><span class="p">,</span> <span class="s1">&#39;spwmap&#39;</span><span class="p">]</span>

        <span class="n">copied</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">to_copy</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">calfrom_properties</span>
                  <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ignore</span><span class="p">}</span>

        <span class="k">return</span> <span class="n">CalFrom</span><span class="p">(</span><span class="o">**</span><span class="n">copied</span><span class="p">)</span>

<div class="viewcode-block" id="IntervalCalLibrary.import_state">
<a class="viewcode-back" href="../../../_automodapi/pipeline.infrastructure.callibrary.IntervalCalLibrary.html#pipeline.infrastructure.callibrary.IntervalCalLibrary.import_state">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">import_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calc_filename</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>

        <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Importing calibration state from </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">filename</span><span class="p">)</span>
        <span class="n">calapps</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">import_file</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="p">[</span><span class="n">l</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">import_file</span> <span class="k">if</span> <span class="n">l</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;applycal(&#39;</span><span class="p">)]:</span>
                <span class="n">calapp</span> <span class="o">=</span> <span class="n">CalApplication</span><span class="o">.</span><span class="n">from_export</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
                <span class="n">calapps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">calapp</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">append</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">calstate</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_active</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">calstate</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">calapp</span> <span class="ow">in</span> <span class="n">calapps</span><span class="p">:</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Adding </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">calapp</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">calapp</span><span class="o">.</span><span class="n">calto</span><span class="p">,</span> <span class="n">calapp</span><span class="o">.</span><span class="n">calfrom</span><span class="p">)</span>

        <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Calibration state after import:</span><span class="se">\n</span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">active</span><span class="o">.</span><span class="n">as_applycal</span><span class="p">())</span></div>


<div class="viewcode-block" id="IntervalCalLibrary.mark_as_applied">
<a class="viewcode-back" href="../../../_automodapi/pipeline.infrastructure.callibrary.IntervalCalLibrary.html#pipeline.infrastructure.callibrary.IntervalCalLibrary.mark_as_applied">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">mark_as_applied</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">calto</span><span class="p">,</span> <span class="n">calfrom</span><span class="p">):</span>
        <span class="n">application</span> <span class="o">=</span> <span class="n">IntervalCalState</span><span class="o">.</span><span class="n">from_calapplication</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_context</span><span class="p">,</span> <span class="n">calto</span><span class="p">,</span> <span class="n">calfrom</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_active</span> <span class="o">-=</span> <span class="n">application</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_applied</span> <span class="o">+=</span> <span class="n">application</span>

        <span class="k">if</span> <span class="n">LOG</span><span class="o">.</span><span class="n">isEnabledFor</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">):</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;New calibration state:</span><span class="se">\n</span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">active</span><span class="o">.</span><span class="n">as_applycal</span><span class="p">())</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Applied calibration state:</span><span class="se">\n</span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">applied</span><span class="o">.</span><span class="n">as_applycal</span><span class="p">())</span></div>


<div class="viewcode-block" id="IntervalCalLibrary.unregister_calibrations">
<a class="viewcode-back" href="../../../_automodapi/pipeline.infrastructure.callibrary.IntervalCalLibrary.html#pipeline.infrastructure.callibrary.IntervalCalLibrary.unregister_calibrations">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">unregister_calibrations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">predicate_fn</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">CalToArgs</span><span class="p">,</span> <span class="n">CalFrom</span><span class="p">],</span> <span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Delete active calibrations that match the input predicate function.</span>

<span class="sd">        Context</span>
<span class="sd">        =======</span>

<span class="sd">        Previously, calibration had to be removed by calling private callibrary</span>
<span class="sd">        functions, e.g.,</span>

<span class="sd">            calto = callibrary.CalTo(self.inputs.vis)</span>
<span class="sd">            calfrom = callibrary.CalFrom(gaintable=ktypecaltable, interp=&#39;&#39;, calwt=False)</span>
<span class="sd">            context.callibrary._remove(calto, calfrom, context.callibrary._active)</span>

<span class="sd">        This function makes calibration removal a first-class public function</span>
<span class="sd">        of the callibrary, and requires less knowledge of the calibration to remove.</span>

<span class="sd">        Example usage</span>
<span class="sd">        =============</span>

<span class="sd">        The predicate function passed in by the caller defines which</span>
<span class="sd">        calibrations should be unregistered. For example, Tsys caltable</span>
<span class="sd">        removal can be achieved with the code below.</span>

<span class="sd">            def match_tsys(calto, calfrom):</span>
<span class="sd">                return calfrom.type == &#39;tsys&#39;</span>
<span class="sd">            callibrary.unregister_calibrations(match_tsys)</span>

<span class="sd">        The pipeline inserts the task name into the caltable filename,</span>
<span class="sd">        which can be used to unregister caltables generated by that task. For</span>
<span class="sd">        example,</span>

<span class="sd">            def match_task_caltable(calto, calfrom):</span>
<span class="sd">                return &#39;hifa_bandpass&#39; in calfrom.gaintable</span>
<span class="sd">            context.callibrary.unregister_calibrations(match_task_caltable)</span>

<span class="sd">        If you wanted to match calwt, interp, vis, etc. then that could be</span>
<span class="sd">        done in the matcher function too, but if it&#39;s not necessary to</span>
<span class="sd">        identify the caltable then it doesn&#39;t need to be tested in the</span>
<span class="sd">        predicate function.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">to_remove</span> <span class="o">=</span> <span class="n">get_matching_calstate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_context</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">active</span><span class="p">,</span> <span class="n">predicate_fn</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_active</span> <span class="o">-=</span> <span class="n">to_remove</span></div>
</div>



<span class="c1"># Set the pipeline calibration state and library to the Interval Tree based</span>
<span class="c1"># implementation.</span>
<span class="n">CalState</span> <span class="o">=</span> <span class="n">IntervalCalState</span>
<span class="n">CalLibrary</span> <span class="o">=</span> <span class="n">IntervalCalLibrary</span>

<span class="c1"># Note: the current Interval Tree based implementation of the callibrary</span>
<span class="c1"># was introduced in March 2016 (commit 71b6e5bd67d240e2e27fe1a973715cf3aec4b0ab)</span>
<span class="c1"># and has been in use since the Cycle 4 Pipeline release, October 2016,</span>
<span class="c1"># (CASA 4.7.0 + Pipeline-Cycle4-R2-B, r38377).</span>
<span class="c1">#</span>
<span class="c1"># The original Pipeline callibrary was a dictionary-based implementation of the</span>
<span class="c1"># calibration state (DictCalState) and corresponding library (DictCalLibrary),</span>
<span class="c1"># that supported the same interface as the interval-tree based implementation.</span>
<span class="c1"># The dictionary-based implementation has been unused since the Cycle 4 Pipeline</span>
<span class="c1"># release in 2016, and was removed in December 2024 (as part of infrastructure</span>
<span class="c1"># work done in PIPE-2160) in commit: 81b674d10b9aa4b6ed9df8550af18ec86e2f26ce</span>


<div class="viewcode-block" id="TimestampedData">
<a class="viewcode-back" href="../../../_automodapi/pipeline.infrastructure.callibrary.TimestampedData.html#pipeline.infrastructure.callibrary.TimestampedData">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">TimestampedData</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;TimestampedDataBase&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="s1">&#39;marker&#39;</span><span class="p">])):</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">()</span>  <span class="c1"># Saves memory, avoiding the need to create __dict__ for each interval</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">TimestampedData</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">marker</span><span class="p">)</span>

<div class="viewcode-block" id="TimestampedData.cmp">
<a class="viewcode-back" href="../../../_automodapi/pipeline.infrastructure.callibrary.TimestampedData.html#pipeline.infrastructure.callibrary.TimestampedData.cmp">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">cmp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Tells whether other sorts before, after or equal to this</span>
<span class="sd">        Interval.</span>

<span class="sd">        Sorting is by time then by data fields.</span>

<span class="sd">        If data fields are not both sortable types, data fields are</span>
<span class="sd">        compared alphabetically by type name.</span>
<span class="sd">        :param other: Interval</span>
<span class="sd">        :return: -1, 0, 1</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">time</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="n">time</span> <span class="k">else</span> <span class="mi">1</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">data</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">0</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="n">data</span> <span class="k">else</span> <span class="mi">1</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span>
            <span class="n">o</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span>
            <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="n">o</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">0</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="n">s</span> <span class="o">&lt;</span> <span class="n">o</span> <span class="k">else</span> <span class="mi">1</span></div>


    <span class="k">def</span><span class="w"> </span><span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Less than operator. Parrots __cmp__()</span>
<span class="sd">        :param other: Interval or point</span>
<span class="sd">        :return: True or False</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cmp</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__gt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Greater than operator. Parrots __cmp__()</span>
<span class="sd">        :param other: Interval or point</span>
<span class="sd">        :return: True or False</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cmp</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return executable string representation of this Interval.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">marker</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;TSD(</span><span class="si">{0}</span><span class="s1">, </span><span class="si">{1}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">,</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">))</span>
        <span class="k">return</span> <span class="s1">&#39;TSD(</span><span class="si">{0}</span><span class="s1">, </span><span class="si">{1}</span><span class="s1">, </span><span class="si">{2}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">,</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">marker</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return string representation of this Interval.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s1">&#39;TSD(</span><span class="si">{0}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">))</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">TimestampedData</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Whether the begins equal, the ends equal, and the data fields</span>
<span class="sd">        equal. Compare range_matches().</span>

<span class="sd">        Args:</span>
<span class="sd">            other: TimestampedData to test equality for.</span>

<span class="sd">        Returns:</span>
<span class="sd">            True or False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">TimestampedData</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">time</span> <span class="ow">and</span> \
               <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">data</span> <span class="ow">and</span> \
               <span class="bp">self</span><span class="o">.</span><span class="n">marker</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">marker</span></div>



<div class="viewcode-block" id="trim_to_valid_data_selection">
<a class="viewcode-back" href="../../../_automodapi/pipeline.infrastructure.callibrary.trim_to_valid_data_selection.html#pipeline.infrastructure.callibrary.trim_to_valid_data_selection">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">trim_to_valid_data_selection</span><span class="p">(</span><span class="n">calstate</span><span class="p">:</span> <span class="n">IntervalCalState</span><span class="p">,</span> <span class="n">vis</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> \
        <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">intervaltree</span><span class="o">.</span><span class="n">IntervalTree</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Trim an IntervalCalState to the shape of valid (present) data selections.</span>

<span class="sd">    This is achieved by trimming Intervals for each dimension (antenna, spw,</span>
<span class="sd">    field, intent) to exclude ranges for which no data is present.</span>

<span class="sd">    See CAS-9415: CalLibrary needs a way to filter out calibration</span>
<span class="sd">    applications for missing data selections</span>

<span class="sd">    Args:</span>
<span class="sd">        calstate: The calstate to shape.</span>
<span class="sd">        vis: Name of the calstate to shape. If not defined, shape all.</span>

<span class="sd">    Returns:</span>
<span class="sd">        A dictionary mapping name of MS to its trimmed IntervalTree.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">vis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">vislist</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">calstate</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">vislist</span> <span class="o">=</span> <span class="p">[</span><span class="n">vis</span><span class="p">]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">vis</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="n">vis</span>

    <span class="n">results</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">vis</span> <span class="ow">in</span> <span class="n">vislist</span><span class="p">:</span>
        <span class="n">antenna_tree</span> <span class="o">=</span> <span class="n">calstate</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">vis</span><span class="p">]</span>

        <span class="n">new_root</span> <span class="o">=</span> <span class="n">intervaltree</span><span class="o">.</span><span class="n">IntervalTree</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">antenna_tuple</span> <span class="ow">in</span> <span class="n">calstate</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">vis</span><span class="p">]:</span>
            <span class="k">for</span> <span class="n">antenna_ranges</span><span class="p">,</span> <span class="n">spw_tuple</span> <span class="ow">in</span> <span class="n">antenna_tuple</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">spw_ranges</span><span class="p">,</span> <span class="n">field_tuple</span> <span class="ow">in</span> <span class="n">spw_tuple</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">field_ranges</span><span class="p">,</span> <span class="n">intent_ranges</span> <span class="ow">in</span> <span class="n">field_tuple</span><span class="p">:</span>
                        <span class="n">tree_intervals</span> <span class="o">=</span> <span class="p">(</span><span class="n">antenna_ranges</span><span class="p">,</span> <span class="n">spw_ranges</span><span class="p">,</span> <span class="n">field_ranges</span><span class="p">,</span> <span class="n">intent_ranges</span><span class="p">)</span>
                        <span class="c1"># print(&#39;Shaping to {!r}&#39;.format(tree_intervals))</span>
                        <span class="n">new_root</span> <span class="o">|=</span> <span class="n">trim_nd</span><span class="p">(</span><span class="n">antenna_tree</span><span class="p">,</span> <span class="n">tree_intervals</span><span class="p">)</span>

        <span class="n">results</span><span class="p">[</span><span class="n">vis</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_root</span>

    <span class="k">return</span> <span class="n">results</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">_merge_intervals</span><span class="p">(</span><span class="n">unmerged</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Merge adjacent Intervals (represented by the keys within the input dict)</span>
<span class="sd">    that have identical values and output an IntervalTree-friendly tuple of</span>
<span class="sd">    constructor arguments.</span>

<span class="sd">    For example, a dict containing</span>

<span class="sd">        {1: A, 2: B, 3:A, 4:A}</span>

<span class="sd">    would be converted to</span>

<span class="sd">        ((((1, 2), (3, 5)), &#39;A&#39;), (((2, 3),), &#39;B&#39;))</span>

<span class="sd">    Args:</span>
<span class="sd">        unmerged: A dict mapping IDs to values.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tuple of constructor arguments ready for create_interval_tree_nd.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">reversed</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">set</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">unmerged</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="nb">reversed</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">((</span><span class="nb">tuple</span><span class="p">(</span><span class="n">sequence_to_range</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span> <span class="k">for</span> <span class="n">seq</span> <span class="ow">in</span> <span class="n">contiguous_sequences</span><span class="p">(</span><span class="n">v</span><span class="p">)),</span> <span class="n">k</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="o">.</span><span class="n">items</span><span class="p">()))</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_print_dimensions</span><span class="p">(</span><span class="n">calstate</span><span class="p">:</span> <span class="n">IntervalCalState</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Debugging function used to print the dimensions of an IntervalCalState.</span>

<span class="sd">    Args:</span>
<span class="sd">        calstate: The calstate to inspect.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">vis</span><span class="p">,</span> <span class="n">antenna_tree</span> <span class="ow">in</span> <span class="n">calstate</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">antenna_interval</span> <span class="ow">in</span> <span class="n">antenna_tree</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">antenna_ranges</span> <span class="o">=</span> <span class="p">(</span><span class="n">antenna_interval</span><span class="o">.</span><span class="n">begin</span><span class="p">,</span> <span class="n">antenna_interval</span><span class="o">.</span><span class="n">end</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">spw_interval</span> <span class="ow">in</span> <span class="n">antenna_interval</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">data</span><span class="p">:</span>
                <span class="n">spw_ranges</span> <span class="o">=</span> <span class="p">(</span><span class="n">spw_interval</span><span class="o">.</span><span class="n">begin</span><span class="p">,</span> <span class="n">spw_interval</span><span class="o">.</span><span class="n">end</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">field_interval</span> <span class="ow">in</span> <span class="n">spw_interval</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">data</span><span class="p">:</span>
                    <span class="n">field_ranges</span> <span class="o">=</span> <span class="p">(</span><span class="n">field_interval</span><span class="o">.</span><span class="n">begin</span><span class="p">,</span> <span class="n">field_interval</span><span class="o">.</span><span class="n">end</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">intent_interval</span> <span class="ow">in</span> <span class="n">field_interval</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">data</span><span class="p">:</span>
                        <span class="n">intent_ranges</span> <span class="o">=</span> <span class="p">(</span><span class="n">intent_interval</span><span class="o">.</span><span class="n">begin</span><span class="p">,</span> <span class="n">intent_interval</span><span class="o">.</span><span class="n">end</span><span class="p">)</span>
                        <span class="n">tree_intervals</span> <span class="o">=</span> <span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">vis</span><span class="p">),</span> <span class="n">antenna_ranges</span><span class="p">,</span> <span class="n">spw_ranges</span><span class="p">,</span> <span class="n">field_ranges</span><span class="p">,</span> <span class="n">intent_ranges</span><span class="p">)</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{!r}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tree_intervals</span><span class="p">))</span>


<div class="viewcode-block" id="get_calto_from_inputs">
<a class="viewcode-back" href="../../../_automodapi/pipeline.infrastructure.callibrary.get_calto_from_inputs.html#pipeline.infrastructure.callibrary.get_calto_from_inputs">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_calto_from_inputs</span><span class="p">(</span><span class="n">inputs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get a CalTo data selection object based on the state of an Inputs object</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">CalTo</span><span class="p">(</span><span class="n">vis</span><span class="o">=</span><span class="n">inputs</span><span class="o">.</span><span class="n">vis</span><span class="p">,</span> <span class="n">field</span><span class="o">=</span><span class="n">inputs</span><span class="o">.</span><span class="n">field</span><span class="p">,</span> <span class="n">spw</span><span class="o">=</span><span class="n">inputs</span><span class="o">.</span><span class="n">spw</span><span class="p">,</span> <span class="n">intent</span><span class="o">=</span><span class="n">inputs</span><span class="o">.</span><span class="n">intent</span><span class="p">,</span> <span class="n">antenna</span><span class="o">=</span><span class="n">inputs</span><span class="o">.</span><span class="n">antenna</span><span class="p">)</span></div>



<div class="viewcode-block" id="set_calstate_marker">
<a class="viewcode-back" href="../../../_automodapi/pipeline.infrastructure.callibrary.set_calstate_marker.html#pipeline.infrastructure.callibrary.set_calstate_marker">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">set_calstate_marker</span><span class="p">(</span><span class="n">calstate</span><span class="p">,</span> <span class="n">marker</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a copy of a calstate, modified so that TimeStampedData objects in</span>
<span class="sd">    the final leaf node are annotated with the given marker object.</span>

<span class="sd">    Technical details:</span>

<span class="sd">    CalFroms are flyweight objects, so two identical CalFroms have the same</span>
<span class="sd">    hash. Identical hashes stop the IntervalTree union function from working</span>
<span class="sd">    as expected: IntervalTrees are based on sets, and as such adding two</span>
<span class="sd">    lists of CalFrom with identical hashes results in just one CalFrom list in</span>
<span class="sd">    the final IntervalTree, when we actually *wanted* the duplicate to be</span>
<span class="sd">    added.</span>

<span class="sd">    This function is used to ensure that CalState arithmetic works as</span>
<span class="sd">    expected. By changing the TimeStampedData marker and thus making the</span>
<span class="sd">    hashes different, &#39;identical&#39; calibrations can indeed be duplicated in the</span>
<span class="sd">    IntervalTree union operation, and subsequently operated on in a</span>
<span class="sd">    merge_equals step.</span>

<span class="sd">    Args:</span>
<span class="sd">        calstate: The calstate to modify.</span>
<span class="sd">        marker: The object to annotate calstates with.</span>

<span class="sd">    Returns:</span>
<span class="sd">        New IntervalCalState representing the annotated calibration state.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">calstate_copy</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">calstate</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">vis</span><span class="p">,</span> <span class="n">antenna_tree</span> <span class="ow">in</span> <span class="n">calstate_copy</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">antenna_interval</span> <span class="ow">in</span> <span class="n">antenna_tree</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">spw_interval</span> <span class="ow">in</span> <span class="n">antenna_interval</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">data</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">field_interval</span> <span class="ow">in</span> <span class="n">spw_interval</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">data</span><span class="p">:</span>

                    <span class="n">to_remove</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">field_interval</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">data</span><span class="p">]</span>
                    <span class="n">to_add</span> <span class="o">=</span> <span class="p">[]</span>

                    <span class="n">intent_intervaltree</span> <span class="o">=</span> <span class="n">field_interval</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">data</span>
                    <span class="k">for</span> <span class="n">intent_interval</span> <span class="ow">in</span> <span class="n">intent_intervaltree</span><span class="p">:</span>
                        <span class="n">old_tsd</span> <span class="o">=</span> <span class="n">intent_interval</span><span class="o">.</span><span class="n">data</span>
                        <span class="n">new_tsd</span> <span class="o">=</span> <span class="n">TimestampedData</span><span class="p">(</span><span class="n">time</span><span class="o">=</span><span class="n">old_tsd</span><span class="o">.</span><span class="n">time</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">old_tsd</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="n">marker</span><span class="p">)</span>
                        <span class="n">to_add</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">intervaltree</span><span class="o">.</span><span class="n">Interval</span><span class="p">(</span><span class="n">intent_interval</span><span class="o">.</span><span class="n">begin</span><span class="p">,</span> <span class="n">intent_interval</span><span class="o">.</span><span class="n">end</span><span class="p">,</span> <span class="n">new_tsd</span><span class="p">))</span>

                    <span class="k">for</span> <span class="n">interval</span> <span class="ow">in</span> <span class="n">to_remove</span><span class="p">:</span>
                        <span class="n">intent_intervaltree</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">interval</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">interval</span> <span class="ow">in</span> <span class="n">to_add</span><span class="p">:</span>
                        <span class="n">intent_intervaltree</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">interval</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">calstate_copy</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">_copy_calfrom</span><span class="p">(</span><span class="n">calfrom</span><span class="p">:</span> <span class="n">CalFrom</span><span class="p">,</span> <span class="o">**</span><span class="n">overrides</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">CalFrom</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Copy a CalFrom, overwriting any CalFrom properties with the specified</span>
<span class="sd">    override values.</span>

<span class="sd">    For instance, to create a copy of a CalFrom with calwt set to True:</span>

<span class="sd">    modified = _copy_calfrom(calfrom, calwt=True)</span>

<span class="sd">    Args:</span>
<span class="sd">        calapp: CalFrom to copy.</span>
<span class="sd">        overrides: Keyword/value pairs of CalFrom properties to override.</span>

<span class="sd">    Returns:</span>
<span class="sd">        CalFrom instance with keywords overridden as per given arguments.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">new_kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">gaintable</span><span class="o">=</span><span class="n">calfrom</span><span class="o">.</span><span class="n">gaintable</span><span class="p">,</span> <span class="n">gainfield</span><span class="o">=</span><span class="n">calfrom</span><span class="o">.</span><span class="n">gainfield</span><span class="p">,</span> <span class="n">interp</span><span class="o">=</span><span class="n">calfrom</span><span class="o">.</span><span class="n">interp</span><span class="p">,</span>
                      <span class="n">spwmap</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">calfrom</span><span class="o">.</span><span class="n">spwmap</span><span class="p">),</span> <span class="n">caltype</span><span class="o">=</span><span class="n">calfrom</span><span class="o">.</span><span class="n">caltype</span><span class="p">,</span> <span class="n">calwt</span><span class="o">=</span><span class="n">calfrom</span><span class="o">.</span><span class="n">calwt</span><span class="p">)</span>
    <span class="n">new_kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">overrides</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">CalFrom</span><span class="p">(</span><span class="o">**</span><span class="n">new_kwargs</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_copy_calto</span><span class="p">(</span><span class="n">calto</span><span class="p">:</span> <span class="n">CalTo</span><span class="p">,</span> <span class="o">**</span><span class="n">overrides</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">CalTo</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Copy a CalTo, overwriting any CalFrom properties with the specified</span>
<span class="sd">    override values.</span>

<span class="sd">    For instance, to create a copy of a CalTo with spw set to 9:</span>

<span class="sd">    modified = _copy_calto(calto, spw=9)</span>

<span class="sd">    Args:</span>
<span class="sd">        calapp: CalTo to copy.</span>
<span class="sd">        overrides: Keyword/value pairs of CalTo properties to override</span>

<span class="sd">    Returns:</span>
<span class="sd">        CalTo instance with keywords overridden as per given arguments.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">new_kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">vis</span><span class="o">=</span><span class="n">calto</span><span class="o">.</span><span class="n">vis</span><span class="p">,</span> <span class="n">field</span><span class="o">=</span><span class="n">calto</span><span class="o">.</span><span class="n">field</span><span class="p">,</span> <span class="n">spw</span><span class="o">=</span><span class="n">calto</span><span class="o">.</span><span class="n">spw</span><span class="p">,</span> <span class="n">antenna</span><span class="o">=</span><span class="n">calto</span><span class="o">.</span><span class="n">antenna</span><span class="p">,</span> <span class="n">intent</span><span class="o">=</span><span class="n">calto</span><span class="o">.</span><span class="n">intent</span><span class="p">)</span>
    <span class="n">new_kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">overrides</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">CalTo</span><span class="p">(</span><span class="o">**</span><span class="n">new_kwargs</span><span class="p">)</span>


<div class="viewcode-block" id="copy_calapplication">
<a class="viewcode-back" href="../../../_automodapi/pipeline.infrastructure.callibrary.copy_calapplication.html#pipeline.infrastructure.callibrary.copy_calapplication">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">copy_calapplication</span><span class="p">(</span><span class="n">calapp</span><span class="p">:</span> <span class="n">CalApplication</span><span class="p">,</span> <span class="n">origin</span><span class="p">:</span> <span class="n">CalAppOrigin</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">overrides</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">CalApplication</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Copy a CalApplication, overwriting any CalTo or CalFrom values with the</span>
<span class="sd">    given override values.</span>

<span class="sd">    For instance, to create a copy of a CalApplication with the CalFrom.calwt</span>
<span class="sd">    set to True and the CalTo.spw set to 9:</span>

<span class="sd">    modified = copy_calapplication(calapp, calwt=True, spw=9)</span>

<span class="sd">    Args:</span>
<span class="sd">        calapp: The CalApplication to copy.</span>
<span class="sd">        origin: Origin to set, or None to copy the origin from calapp.</span>
<span class="sd">        overrides: Keyword/value pairs of CalTo/CalFrom attributes to override.</span>

<span class="sd">    Returns:</span>
<span class="sd">        New CalApplication instance with origin and keywords overridden as per</span>
<span class="sd">        given arguments.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">origin</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">origin</span> <span class="o">=</span> <span class="n">calapp</span><span class="o">.</span><span class="n">origin</span>

    <span class="n">calto_kw</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;vis&#39;</span><span class="p">,</span> <span class="s1">&#39;field&#39;</span><span class="p">,</span> <span class="s1">&#39;spw&#39;</span><span class="p">,</span> <span class="s1">&#39;antenna&#39;</span><span class="p">,</span> <span class="s1">&#39;intent&#39;</span><span class="p">]</span>
    <span class="n">calto_overrides</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">overrides</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">calto_kw</span><span class="p">}</span>
    <span class="n">calto</span> <span class="o">=</span> <span class="n">_copy_calto</span><span class="p">(</span><span class="n">calapp</span><span class="o">.</span><span class="n">calto</span><span class="p">,</span> <span class="o">**</span><span class="n">calto_overrides</span><span class="p">)</span>

    <span class="n">calfrom_kw</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;gaintable&#39;</span><span class="p">,</span> <span class="s1">&#39;gainfield&#39;</span><span class="p">,</span> <span class="s1">&#39;interp&#39;</span><span class="p">,</span> <span class="s1">&#39;spwmap&#39;</span><span class="p">,</span> <span class="s1">&#39;caltype&#39;</span><span class="p">,</span> <span class="s1">&#39;calwt&#39;</span><span class="p">]</span>
    <span class="n">calfrom_overrides</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">overrides</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">calfrom_kw</span><span class="p">}</span>
    <span class="n">calfrom</span> <span class="o">=</span> <span class="p">[</span><span class="n">_copy_calfrom</span><span class="p">(</span><span class="n">calfrom</span><span class="p">,</span> <span class="o">**</span><span class="n">calfrom_overrides</span><span class="p">)</span> <span class="k">for</span> <span class="n">calfrom</span> <span class="ow">in</span> <span class="n">calapp</span><span class="o">.</span><span class="n">calfrom</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">CalApplication</span><span class="p">(</span><span class="n">calto</span><span class="p">,</span> <span class="n">calfrom</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="n">origin</span><span class="p">)</span></div>



<div class="viewcode-block" id="get_calstate_shape">
<a class="viewcode-back" href="../../../_automodapi/pipeline.infrastructure.callibrary.get_calstate_shape.html#pipeline.infrastructure.callibrary.get_calstate_shape">[docs]</a>
<span class="nd">@cachetools</span><span class="o">.</span><span class="n">cached</span><span class="p">(</span><span class="n">cachetools</span><span class="o">.</span><span class="n">LRUCache</span><span class="p">(</span><span class="mi">50</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="n">operator</span><span class="o">.</span><span class="n">attrgetter</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">))</span>
<span class="k">def</span><span class="w"> </span><span class="nf">get_calstate_shape</span><span class="p">(</span><span class="n">ms</span><span class="p">:</span> <span class="n">MeasurementSet</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get an IntervalTree shaped to the dimensions of the given measurement set.</span>

<span class="sd">    This function calculates the size of each metadata dimension (spw; intent;</span>
<span class="sd">    field; antenna), creating and returning an IntervalTree shaped to match.</span>
<span class="sd">    The output of this function is used to trim a calibration applied globally</span>
<span class="sd">    in one or more dimensions to a valid data selection.</span>

<span class="sd">    Output from this function is cached as it can take several seconds to</span>
<span class="sd">    calculate the result, which is done repeatedly when importing a calstate</span>
<span class="sd">    containing many entries.</span>

<span class="sd">    Note: this assumes that shape of an MS never changes, which should be</span>
<span class="sd">    true; the number of spws, fields, ants, etc. never changes.</span>

<span class="sd">    Args:</span>
<span class="sd">        ms: The MeasurementSet to analyse.</span>

<span class="sd">    Returns:</span>
<span class="sd">        IntervalTree shaped to match valid data dimensions.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Calculating callibrary shape for </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ms</span><span class="o">.</span><span class="n">basename</span><span class="p">))</span>

    <span class="c1"># holds a mapping of numeric intent ID to string intent</span>
    <span class="n">id_to_intent</span> <span class="o">=</span> <span class="n">get_intent_id_map</span><span class="p">(</span><span class="n">ms</span><span class="p">)</span>
    <span class="c1"># create map of observing intent to intent ID by inverting existing map</span>
    <span class="n">intent_to_id</span> <span class="o">=</span> <span class="p">{</span><span class="n">v</span><span class="p">:</span> <span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">id_to_intent</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

    <span class="c1"># create interval tree. root branch is antenna</span>
    <span class="n">antenna_tree</span> <span class="o">=</span> <span class="n">create_interval_tree_for_ms</span><span class="p">(</span><span class="n">ms</span><span class="p">)</span>

    <span class="n">spw_shape</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">spw</span> <span class="ow">in</span> <span class="n">ms</span><span class="o">.</span><span class="n">spectral_windows</span><span class="p">:</span>
        <span class="n">intents_for_field</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">ms</span><span class="o">.</span><span class="n">fields</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">spw</span> <span class="ow">in</span> <span class="n">field</span><span class="o">.</span><span class="n">valid_spws</span><span class="p">:</span>
                <span class="c1"># construct the list of observed intent IDs for this field</span>
                <span class="c1">#</span>
                <span class="c1"># we can&#39;t rely on field.intents as this property</span>
                <span class="c1"># aggregates all intents across all spws, which may</span>
                <span class="c1"># differ across spws when there are multiple tunings</span>
                <span class="c1">#</span>
                <span class="c1"># DON&#39;T DO THIS!</span>
                <span class="c1"># observed_intent_ids = (intent_to_id[i] for i in field.intents)</span>
                <span class="n">scans_for_field_and_spw</span> <span class="o">=</span> <span class="n">ms</span><span class="o">.</span><span class="n">get_scans</span><span class="p">(</span><span class="n">spw</span><span class="o">=</span><span class="n">spw</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">field</span><span class="o">=</span><span class="n">field</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
                <span class="n">observed_intent_ids</span> <span class="o">=</span> <span class="p">[</span><span class="n">intent_to_id</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                                       <span class="k">for</span> <span class="n">scan</span> <span class="ow">in</span> <span class="n">scans_for_field_and_spw</span>
                                       <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">scan</span><span class="o">.</span><span class="n">intents</span><span class="p">]</span>

                <span class="c1"># SD scans can have subscans, where each subscan observes a</span>
                <span class="c1"># different field with different intent, e.g., TARGET alternating</span>
                <span class="c1"># with REFERENCE. Non-SD data should have a single target per</span>
                <span class="c1"># scan, so the following code should be a no-op.</span>
                <span class="n">subscan_fields</span> <span class="o">=</span> <span class="p">{</span><span class="n">scan_field</span> <span class="k">for</span> <span class="n">scan</span> <span class="ow">in</span> <span class="n">scans_for_field_and_spw</span> <span class="k">for</span> <span class="n">scan_field</span> <span class="ow">in</span> <span class="n">scan</span><span class="o">.</span><span class="n">fields</span><span class="p">}</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">subscan_fields</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="c1"># unfortunately, we have to fall back to the field.intents</span>
                    <span class="c1"># method. Expect this to break for multituning SD EBs.</span>
                    <span class="n">observed_intent_ids</span> <span class="o">=</span> <span class="p">(</span><span class="n">intent_to_id</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">field</span><span class="o">.</span><span class="n">intents</span><span class="p">)</span>

                <span class="c1"># convert the intent IDs to an IntervalTree-friendly range</span>
                <span class="c1"># and record it against the field ID</span>
                <span class="n">intents_for_field</span><span class="p">[</span><span class="n">field</span><span class="o">.</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
                    <span class="n">sequence_to_range</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span> <span class="k">for</span> <span class="n">seq</span> <span class="ow">in</span> <span class="n">contiguous_sequences</span><span class="p">(</span><span class="n">observed_intent_ids</span><span class="p">)</span>
                <span class="p">)</span>
        <span class="c1"># merge adjacent field intervals that have identical values</span>
        <span class="n">spw_shape</span><span class="p">[</span><span class="n">spw</span><span class="o">.</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">_merge_intervals</span><span class="p">(</span><span class="n">intents_for_field</span><span class="p">)</span>
    <span class="c1"># merge adjacent spw intervals that have identical values</span>
    <span class="n">spw_shape</span> <span class="o">=</span> <span class="n">_merge_intervals</span><span class="p">(</span><span class="n">spw_shape</span><span class="p">)</span>

    <span class="c1"># assume that spws are observed by all antennas. Note the trailing comma to make it a tuple!</span>
    <span class="c1"># the inner tuple is needed to convert the generator comprehension to objects</span>
    <span class="n">antenna_shape</span> <span class="o">=</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">((((</span><span class="n">interval</span><span class="o">.</span><span class="n">begin</span><span class="p">,</span> <span class="n">interval</span><span class="o">.</span><span class="n">end</span><span class="p">),),</span> <span class="n">spw_shape</span><span class="p">)</span> <span class="k">for</span> <span class="n">interval</span> <span class="ow">in</span> <span class="n">antenna_tree</span><span class="p">),)</span>

    <span class="k">return</span> <span class="n">antenna_shape</span></div>



<div class="viewcode-block" id="get_matching_calstate">
<a class="viewcode-back" href="../../../_automodapi/pipeline.infrastructure.callibrary.get_matching_calstate.html#pipeline.infrastructure.callibrary.get_matching_calstate">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_matching_calstate</span><span class="p">(</span><span class="n">context</span><span class="p">:</span> <span class="n">launcher</span><span class="o">.</span><span class="n">Context</span><span class="p">,</span> <span class="n">calstate</span><span class="p">:</span> <span class="n">IntervalCalState</span><span class="p">,</span>
                          <span class="n">predicate_fn</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">CalToArgs</span><span class="p">,</span> <span class="n">CalFrom</span><span class="p">],</span> <span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">IntervalCalState</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return an IntervalCalState contain calibrations in the input </span>
<span class="sd">    IntervalCalState that match the predicate function.</span>

<span class="sd">    The use case for this function is to identify calibrations matching a</span>
<span class="sd">    pattern so that those calibrations can be deleted or modified. For</span>
<span class="sd">    instance, matching registered bandpass caltables so they can be removed</span>
<span class="sd">    from the active CalState.</span>

<span class="sd">    Args:</span>
<span class="sd">        context: Pipeline context (required to create IntervalCalState).</span>
<span class="sd">        calstate: Calibration state to inspect.</span>
<span class="sd">        predicate_fn: Matching function that returns True when the selection</span>
<span class="sd">            is to be added to the output IntervalCalState.</span>

<span class="sd">    Returns:</span>
<span class="sd">        IntervalCalState containing the calibrations from the input</span>
<span class="sd">        IntervalCalState that match the given predicate function.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">expanded</span> <span class="o">=</span> <span class="n">expand_calstate_to_calapps</span><span class="p">(</span><span class="n">calstate</span><span class="p">)</span>

    <span class="n">matching</span> <span class="o">=</span> <span class="p">[</span><span class="n">IntervalCalState</span><span class="o">.</span><span class="n">from_calapplication</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">CalTo</span><span class="o">.</span><span class="n">from_caltoargs</span><span class="p">(</span><span class="n">caltoargs</span><span class="p">),</span> <span class="n">calfrom</span><span class="p">)</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">caltoargs</span><span class="p">,</span> <span class="n">calfroms</span><span class="p">)</span> <span class="ow">in</span> <span class="n">expanded</span>
                <span class="k">for</span> <span class="n">calfrom</span> <span class="ow">in</span> <span class="n">calfroms</span>
                <span class="k">if</span> <span class="n">predicate_fn</span><span class="p">(</span><span class="n">caltoargs</span><span class="p">,</span> <span class="n">calfrom</span><span class="p">)]</span>

    <span class="n">consolidated</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">add</span><span class="p">,</span> <span class="n">matching</span><span class="p">,</span> <span class="n">IntervalCalState</span><span class="o">.</span><span class="n">create_from_context</span><span class="p">(</span><span class="n">context</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">consolidated</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020–2025, Pipeline Dev. Team, build: 2024.2.0.4+PIPE-2361-1-2130-g356079c234-update-docs-build-and-packaging-setup.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>