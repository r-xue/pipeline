The data type information is stored in two places in the MS domain objects.
Originally, we just had a mapping of column (data or corrected) to data
type for all sources and spws. This dictionary is MeasurementSet::data\_column
with keys being a data type from the DataType enum and values being the column
name.

Later we saw the need for the per source/spw information. This is stored in
MeasurementSet::data\_types\_per\_source\_and\_spw. Its keys are tuples of source
name and real spw ID. The values are lists of data types that exist for the
given selection in this MS (at most two because there are just the data
and corrected columns).

These dictionaries are accessed via the MeasurementSet::set\_data\_column and
MeasurementSet::get\_data\_column methods. The importdata tasks use
set\_data\_column to set a data type for the column. This also sets *all*
source/spw entries in data\_types\_per\_source\_and\_spw if no special source/spw
selection is given (which is the case for the importdata tasks).

The self calibration task is using "set\_data\_column" always with a source/spw
selection. In that case MeasurementSet::data\_column is set, but
MeasurementSet::data\_types\_per\_source\_and\_spw just gets an entry for the
particular selection.

To arrive at a setup that might be generated by hif\_selfcal one needs to mimic
some "set\_data\_column" calls.

For PIPE-1474, for example, two MSes were used that were mentioned in PIPE-1209
which are not too large and also exercise the virtual spws. From a normal PL
run one can take

uid\_\_\_A002\_Xed4607\_Xfbf7\_targets.ms

and

uid\_\_\_A002\_Xed4607\_Xfd64\_targets.ms

and manually copy the DATA column to CORRECTED just to have some data in both
columns. The first MS has science spw IDs 13, 15, 17, 19, the second MS has
5, 7, 9, 11.

Now one can import these MSes in a new PL session and modify the lookup tables
manually:

from pipeline.domain import DataType
ctx=h\_init()
hifa\_importdata(['uid\_\_\_A002\_Xed4607\_Xfbf7\_targets.ms',
                  'uid\_\_\_A002\_Xed4607\_Xfd64\_targets.ms'],
                  datacolumns={'data': 'regcal\_contline\_science'})
# First MS
ctx.observing\_run.measurement\_sets[0].set\_data\_column(DataType.SELFCAL\_CONTLINE\_SCIENCE, 'CORRECTED\_DATA', 'HL\_Tau', '17')
ctx.observing\_run.measurement\_sets[0].set\_data\_column(DataType.SELFCAL\_CONTLINE\_SCIENCE, 'CORRECTED\_DATA', 'HL\_Tau', '19')
# Second MS
ctx.observing\_run.measurement\_sets[1].set\_data\_column(DataType.SELFCAL\_CONTLINE\_SCIENCE, 'CORRECTED\_DATA', 'HL\_Tau', '7')
ctx.observing\_run.measurement\_sets[1].set\_data\_column(DataType.SELFCAL\_CONTLINE\_SCIENCE, 'CORRECTED\_DATA', 'HL\_Tau', '9')
ctx.observing\_run.measurement\_sets[1].set\_data\_column(DataType.SELFCAL\_CONTLINE\_SCIENCE, 'CORRECTED\_DATA', 'HL\_Tau', '11')
h\_save('c1')

This would set up just regular calibration data for virtual spw 13, one MS
with selfcal in virtual spw 15 (real spw ID 7 in MS2) and two MSes with selfcal
in virtual spw IDs 17 and 19.

Now one has a setup to test various combinations of data types per
source/spw incl. virtual spw lookups. One would keep resuming the saved
context, run some commands and save to a new file (h\_save('c2'), etc.).

For hif\_makeimlist and hif\_editimlist the query involves a list of MSes,
so there is another method to deliver that information. It is
ObservingRun::get\_measurement\_sets\_of\_type. It takes a list of data types in
the order of possible fallbacks. For example, for specmode mfs the list is

[DataType.SELFCAL\_CONTLINE\_SCIENCE, DataType.REGCAL\_CONTLINE\_SCIENCE, DataType.REGCAL\_CONTLINE\_ALL, DataType.RAW]

for science targets and

[DataType.REGCAL\_CONTLINE\_ALL, DataType.RAW]

for calibrators. This means for science targets that selfcal is preferred over
regcal and if the split into the \_targets MSes has not yet been done, the regcal
from the original MSes is used and so on. The method delivers a list MSes where
to find the data. Optionally, one can again specify a source and spw.
