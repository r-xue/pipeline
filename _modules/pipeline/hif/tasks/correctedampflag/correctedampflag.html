

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>pipeline.hif.tasks.correctedampflag.correctedampflag &mdash; Pipeline unknown documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../../../_static/graphviz.css?v=4ae1632d" />
      <link rel="stylesheet" type="text/css" href="../../../../../_static/custom_theme.css?v=678032d9" />

  
      <script src="../../../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../../../_static/documentation_options.js?v=3f1b9271"></script>
      <script src="../../../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../../index.html" class="icon icon-home">
            Pipeline
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Pipeline Tasks</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../pipeline_tasks/pipeline_tasks.html">Pipeline Heuristics Tasks</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Pipeline Task (sphinx-autosummary)</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../_autosummary/pipeline.h.cli.html">pipeline.h.cli</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../_autosummary/pipeline.hif.cli.html">pipeline.hif.cli</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../_autosummary/pipeline.hifa.cli.html">pipeline.hifa.cli</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../_autosummary/pipeline.hifv.cli.html">pipeline.hifv.cli</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../_autosummary/pipeline.hsd.cli.html">pipeline.hsd.cli</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../_autosummary/pipeline.hsdn.cli.html">pipeline.hsdn.cli</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../_autosummary/pipeline.domain.html">pipeline.domain</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../_autosummary/pipeline.infrastructure.launcher.html">pipeline.infrastructure.launcher</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../_autosummary/pipeline.domain.html">pipeline.domain</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../_autosummary/pipeline.infrastructure.launcher.html">pipeline.infrastructure.launcher</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Pipeline Heuristics</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../heuristics/field_parameter.html">Field parameter</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../heuristics/FlaggingTasks.html">Pipeline Flagging Tasks</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Releases etc.</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../releases.html">Past Releases</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../modular.html">Run the Pipeline in a Conda environment</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../dependencies.html">Dependencies of <code class="docutils literal notranslate"><span class="pre">Pipeline</span></code></a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Pipeline Basics</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../basics.html"><code class="docutils literal notranslate"><span class="pre">pipeline.domain</span></code> module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../basics.html#module-pipeline.infrastructure.launcher"><code class="docutils literal notranslate"><span class="pre">pipeline.infrastructure.launcher</span></code> module</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Task Classes</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../task_classes.html"><code class="docutils literal notranslate"><span class="pre">pipeline.hifa.tasks</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../task_classes.html#module-pipeline.hif.tasks"><code class="docutils literal notranslate"><span class="pre">pipeline.hif.tasks</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../task_classes.html#module-pipeline.hif"><code class="docutils literal notranslate"><span class="pre">pipeline.hif</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../task_classes.html#pipeline-inheritance-diagrams">Pipeline Inheritance Diagrams</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Developer Notes</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../develdocmd/ways_to_run_the_pipeline.html">Ways to run the Pipeline</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../develdocmd/comparing_pipeline_executions.html">Comparing pipeline executions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../develdocmd/building_the_pipeline.html">Building the pipeline</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../develdocmd/ALMA-Imaging-Workflow.html">ALMA interferometry imaging workflow</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../develdocmd/VLA-Imaging-Workflow.html">VLA interferometry imaging workflow</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../develdocmd/VLASS-SE-CONT-Imaging-Workflow.html">VLASS-SE-CONT imaging workflow</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../develdocmd/VLASS-SE-CUBE-Imaging-Workflow.html">VLASS-SE-CUBE imaging workflow</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../develdocmd/selfcal_workflow.html">VLASS Selfcal &amp; Restore workflows</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../develdocmd/pipeline_tests.html">Pipeline testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../develdocmd/DataType_Testing.html">DataType Testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../develdocmd/QA_scores.html">Pipeline Quality Assurance (QA) Score Class Design</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../develdocmd/DeveloperDocumentation.html">Pipeline developer documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../develdocmd/python3_conversion_notes.html">Python 3 conversion notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../develdocmd/recipes.html">Pipeline Recipes</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Examples Notes (from Jupyter Notebooks)</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../examples/test1.html">test</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Example Notes (from .rst)</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../examples/test2.html">Example 1</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../../index.html">Pipeline</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../../../index.html">Module code</a></li>
          <li class="breadcrumb-item"><a href="../../../../pipeline.html">pipeline</a></li>
      <li class="breadcrumb-item active">pipeline.hif.tasks.correctedampflag.correctedampflag</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for pipeline.hif.tasks.correctedampflag.correctedampflag</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">from</span> <span class="nn">statistics</span> <span class="kn">import</span> <span class="n">mode</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Tuple</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">numpy.typing</span> <span class="kn">import</span> <span class="n">NDArray</span>

<span class="kn">import</span> <span class="nn">pipeline.infrastructure</span> <span class="k">as</span> <span class="nn">infrastructure</span>
<span class="kn">import</span> <span class="nn">pipeline.infrastructure.basetask</span> <span class="k">as</span> <span class="nn">basetask</span>
<span class="kn">import</span> <span class="nn">pipeline.infrastructure.utils</span> <span class="k">as</span> <span class="nn">utils</span>
<span class="kn">import</span> <span class="nn">pipeline.infrastructure.vdp</span> <span class="k">as</span> <span class="nn">vdp</span>
<span class="kn">from</span> <span class="nn">pipeline.domain</span> <span class="kn">import</span> <span class="n">DataType</span>
<span class="kn">from</span> <span class="nn">pipeline.domain.measurementset</span> <span class="kn">import</span> <span class="n">MeasurementSet</span>
<span class="kn">from</span> <span class="nn">pipeline.h.tasks.common</span> <span class="kn">import</span> <span class="n">commonhelpermethods</span><span class="p">,</span> <span class="n">mstools</span>
<span class="kn">from</span> <span class="nn">pipeline.h.tasks.common.arrayflaggerbase</span> <span class="kn">import</span> <span class="n">FlagCmd</span>
<span class="kn">from</span> <span class="nn">pipeline.h.tasks.flagging.flagdatasetter</span> <span class="kn">import</span> <span class="n">FlagdataSetter</span>
<span class="kn">from</span> <span class="nn">pipeline.infrastructure</span> <span class="kn">import</span> <span class="n">task_registry</span>
<span class="kn">from</span> <span class="nn">.resultobjects</span> <span class="kn">import</span> <span class="n">CorrectedampflagResults</span>

<span class="n">LOG</span> <span class="o">=</span> <span class="n">infrastructure</span><span class="o">.</span><span class="n">get_logger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_consolidate_flags</span><span class="p">(</span><span class="n">flags</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">FlagCmd</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">FlagCmd</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function to consolidate a list of FlagCmd objects (&quot;flags&quot;).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Consolidate by polarisation.</span>
    <span class="n">flags</span> <span class="o">=</span> <span class="n">_consolidate_flags_with_same_pol</span><span class="p">(</span><span class="n">flags</span><span class="p">)</span>

    <span class="c1"># Consolidate by timestamps.</span>
    <span class="n">flags</span> <span class="o">=</span> <span class="n">_consolidate_flags_by_timestamps</span><span class="p">(</span><span class="n">flags</span><span class="p">)</span>

    <span class="c1"># Consolidate by antennas.</span>
    <span class="n">flags</span> <span class="o">=</span> <span class="n">_consolidate_flags_by_antennas</span><span class="p">(</span><span class="n">flags</span><span class="p">)</span>

    <span class="c1"># Consolidate duplicate flags.</span>
    <span class="n">flags</span> <span class="o">=</span> <span class="n">_consolidate_duplicate_flags</span><span class="p">(</span><span class="n">flags</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">flags</span>


<span class="k">def</span> <span class="nf">_consolidate_flags_with_same_pol</span><span class="p">(</span><span class="n">flags</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">FlagCmd</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">FlagCmd</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function to consolidate a list of FlagCmd objects (&quot;flags&quot;) by removing</span>
<span class="sd">    flags that differ only in polarisation.</span>

<span class="sd">    This function belongs to correctedampflag, by making assumptions on which</span>
<span class="sd">    properties of the FlagCmd it needs to compare.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Get flag commands.</span>
    <span class="n">flagcmds</span> <span class="o">=</span> <span class="p">[</span><span class="n">flag</span><span class="o">.</span><span class="n">flagcmd</span> <span class="k">for</span> <span class="n">flag</span> <span class="ow">in</span> <span class="n">flags</span><span class="p">]</span>

    <span class="c1"># If all flag commands are unique, then there is nothing to</span>
    <span class="c1"># consolidate.</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">flagcmds</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">flagcmds</span><span class="p">)):</span>
        <span class="n">cflags</span> <span class="o">=</span> <span class="n">flags</span>

    <span class="c1"># If duplicate flag commands exist, go through each one, verify that</span>
    <span class="c1"># the duplication is just due to difference in polarisation, and for</span>
    <span class="c1"># those where this is true, replace them with a single flag.</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Identify the flags that have non-unique flagging commands:</span>
        <span class="n">uval</span><span class="p">,</span> <span class="n">uind</span><span class="p">,</span> <span class="n">ucnt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">flagcmds</span><span class="p">,</span> <span class="n">return_inverse</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Build new list of flags.</span>
        <span class="n">cflags</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">cnt</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ucnt</span><span class="p">):</span>
            <span class="c1"># For flags that appear twice...</span>
            <span class="k">if</span> <span class="n">cnt</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="c1"># Identify which flags these were.</span>
                <span class="n">flag1</span><span class="p">,</span> <span class="n">flag2</span> <span class="o">=</span> <span class="p">[</span><span class="n">flags</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">uind</span><span class="p">)</span>
                                <span class="k">if</span> <span class="n">val</span> <span class="o">==</span> <span class="n">ind</span><span class="p">]</span>
                <span class="c1"># Check that the flag commands differ only in polarisation</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">flag1</span><span class="o">.</span><span class="n">filename</span> <span class="o">==</span> <span class="n">flag2</span><span class="o">.</span><span class="n">filename</span> <span class="ow">and</span>
                        <span class="n">flag1</span><span class="o">.</span><span class="n">spw</span> <span class="o">==</span> <span class="n">flag2</span><span class="o">.</span><span class="n">spw</span> <span class="ow">and</span>
                        <span class="n">flag1</span><span class="o">.</span><span class="n">antenna</span> <span class="o">==</span> <span class="n">flag2</span><span class="o">.</span><span class="n">antenna</span> <span class="ow">and</span>
                        <span class="n">flag1</span><span class="o">.</span><span class="n">intent</span> <span class="o">==</span> <span class="n">flag2</span><span class="o">.</span><span class="n">intent</span> <span class="ow">and</span>
                        <span class="n">flag1</span><span class="o">.</span><span class="n">time</span> <span class="o">==</span> <span class="n">flag2</span><span class="o">.</span><span class="n">time</span> <span class="ow">and</span>
                        <span class="n">flag1</span><span class="o">.</span><span class="n">field</span> <span class="o">==</span> <span class="n">flag2</span><span class="o">.</span><span class="n">field</span> <span class="ow">and</span>
                        <span class="n">flag1</span><span class="o">.</span><span class="n">reason</span> <span class="o">==</span> <span class="n">flag2</span><span class="o">.</span><span class="n">reason</span> <span class="ow">and</span>
                        <span class="n">flag1</span><span class="o">.</span><span class="n">pol</span> <span class="o">!=</span> <span class="n">flag2</span><span class="o">.</span><span class="n">pol</span><span class="p">):</span>

                    <span class="c1"># Copy across just first flag, but set its polarisation</span>
                    <span class="c1"># to empty.</span>
                    <span class="n">flag1</span><span class="o">.</span><span class="n">pol</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
                    <span class="n">cflags</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">flag1</span><span class="p">)</span>
                    <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Consolidated 2 duplicate flags that &#39;</span>
                              <span class="s1">&#39;differed only in polarisation.&#39;</span><span class="p">)</span>
                <span class="c1"># If they differed in a non-anticipated manner, copy across</span>
                <span class="c1"># both.</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">cflags</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">flag1</span><span class="p">,</span> <span class="n">flag2</span><span class="p">])</span>
                    <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Unable to consolidate 2 flags with same flag &#39;</span>
                              <span class="s1">&#39;command, appear to differ in unanticipated &#39;</span>
                              <span class="s1">&#39;manner.&#39;</span><span class="p">)</span>

            <span class="c1"># If flags do not appear twice, they either appear once</span>
            <span class="c1"># (commonly expected) or more than twice (never expected).</span>
            <span class="c1"># Either way, don&#39;t attempt any consolidation for these cases</span>
            <span class="c1"># and just copy them to the output array.</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cflags</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">flags</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                               <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">uind</span><span class="p">)</span>
                               <span class="k">if</span> <span class="n">val</span> <span class="o">==</span> <span class="n">ind</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">cnt</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="c1"># If the flag appeared more than twice, something must</span>
                    <span class="c1"># have gone wrong, insofar that flags differed by a</span>
                    <span class="c1"># metric that is not the polarisation but that was not</span>
                    <span class="c1"># included in flagging command. This should not happen,</span>
                    <span class="c1"># but log it as a &quot;trace&quot; message for potential</span>
                    <span class="c1"># debugging.</span>
                    <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Unable to consolidate 3+ flags with same flag &#39;</span>
                              <span class="s1">&#39;command, unanticipated case.&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">cflags</span>


<span class="k">def</span> <span class="nf">_consolidate_flags_by_timestamps</span><span class="p">(</span><span class="n">flags</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">FlagCmd</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">FlagCmd</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function to consolidate a list of FlagCmd objects (&quot;flags&quot;) by removing</span>
<span class="sd">    flags with timestamps if for the same (spw, field, intent), the antenna</span>
<span class="sd">    and/or baseline is covered by a flagging command without timestamp</span>
<span class="sd">    (covering same baseline, or an antenna from baseline, or all antennas).</span>

<span class="sd">    This function belongs to correctedampflag, by making assumptions on which</span>
<span class="sd">    properties of the FlagCmd it needs to compare.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Identify list of properties of flag commands without timestamps.</span>
    <span class="n">flags_without_timestamps</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">flag</span> <span class="ow">in</span> <span class="n">flags</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">flag</span><span class="o">.</span><span class="n">time</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">flags_without_timestamps</span><span class="p">[(</span><span class="n">flag</span><span class="o">.</span><span class="n">filename</span><span class="p">,</span> <span class="n">flag</span><span class="o">.</span><span class="n">spw</span><span class="p">,</span> <span class="n">flag</span><span class="o">.</span><span class="n">intent</span><span class="p">,</span> <span class="n">flag</span><span class="o">.</span><span class="n">field</span><span class="p">)]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">flag</span><span class="o">.</span><span class="n">antenna</span><span class="p">)</span>

    <span class="c1"># If flag commands without timestamp exist, go through every flag</span>
    <span class="c1"># command and remove the ones that are cover the same</span>
    <span class="c1"># (filename, intent, field, spw, antenna), ignoring differences in</span>
    <span class="c1"># reason and polarisation.</span>
    <span class="k">if</span> <span class="n">flags_without_timestamps</span><span class="p">:</span>

        <span class="c1"># Build new list of flags, and preserve skipped flag commands to</span>
        <span class="c1"># report.</span>
        <span class="n">cflags</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">skipped_flagcmds</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Go through list of flags.</span>
        <span class="k">for</span> <span class="n">flag</span> <span class="ow">in</span> <span class="n">flags</span><span class="p">:</span>

            <span class="c1"># If the current flag matches in properties with one of the</span>
            <span class="c1"># flagging commands without timestamps:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">flag</span><span class="o">.</span><span class="n">filename</span><span class="p">,</span> <span class="n">flag</span><span class="o">.</span><span class="n">spw</span><span class="p">,</span> <span class="n">flag</span><span class="o">.</span><span class="n">intent</span><span class="p">,</span> <span class="n">flag</span><span class="o">.</span><span class="n">field</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">flags_without_timestamps</span><span class="p">:</span>

                <span class="c1"># If flag for current file, spw, intent, and field is</span>
                <span class="c1"># time-stamp specific, check if any of matching</span>
                <span class="c1"># no-timestamp flags cover an antenna that also appears in</span>
                <span class="c1"># the current flag command (same antenna, same baseline,</span>
                <span class="c1"># and/or an antenna in current baseline).</span>
                <span class="k">if</span> <span class="n">flag</span><span class="o">.</span><span class="n">time</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># Skip if antenna or baseline is covered by no-timestamp flags.</span>
                    <span class="k">if</span> <span class="n">flag</span><span class="o">.</span><span class="n">antenna</span> <span class="ow">in</span> <span class="n">flags_without_timestamps</span><span class="p">[</span><span class="n">idx</span><span class="p">]:</span>
                        <span class="n">skipped_flagcmds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">flag</span><span class="o">.</span><span class="n">flagcmd</span><span class="p">)</span>
                    <span class="c1"># Skip if any ant in baseline is covered by no-timestamp flags.</span>
                    <span class="k">elif</span> <span class="nb">any</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">ant</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">flag</span><span class="o">.</span><span class="n">antenna</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;&amp;&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">ant</span> <span class="ow">in</span> <span class="n">flags_without_timestamps</span><span class="p">[</span><span class="n">idx</span><span class="p">]):</span>
                        <span class="n">skipped_flagcmds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">flag</span><span class="o">.</span><span class="n">flagcmd</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">cflags</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">flag</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">cflags</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">flag</span><span class="p">)</span>

            <span class="c1"># If the current flag does not match with any of the flagging</span>
            <span class="c1"># commands without timestamps, then preserve it.</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cflags</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">flag</span><span class="p">)</span>

        <span class="c1"># Log a summary of consolidated flag commands:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">skipped_flagcmds</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;The following </span><span class="si">{}</span><span class="s1"> time-specific flag commands were &#39;</span>
                      <span class="s1">&#39;consolidated into one or more flag commands &#39;</span>
                      <span class="s1">&#39;without a timestamp:</span><span class="se">\n</span><span class="s1">&#39;</span>
                      <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">skipped_flagcmds</span><span class="p">),</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">skipped_flagcmds</span><span class="p">)))</span>

    <span class="c1"># If no flag commands with timestamp exist, then there is nothing to</span>
    <span class="c1"># consolidate =&gt; return flags unmodified.</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">cflags</span> <span class="o">=</span> <span class="n">flags</span>

    <span class="k">return</span> <span class="n">cflags</span>


<span class="k">def</span> <span class="nf">_consolidate_flags_by_antennas</span><span class="p">(</span><span class="n">flags</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">FlagCmd</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">FlagCmd</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function to consolidate a list of FlagCmd objects (&quot;flags&quot;)</span>
<span class="sd">    by antennas.</span>

<span class="sd">    This function belongs to correctedampflag, by making assumptions on which</span>
<span class="sd">    properties of the FlagCmd it needs to compare.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Consolidate flags matching a non-antenna specific flag.</span>
    <span class="n">flags</span> <span class="o">=</span> <span class="n">_consolidate_flags_non_antenna_specific</span><span class="p">(</span><span class="n">flags</span><span class="p">)</span>

    <span class="c1"># Consolidate flags with baselines matching a flag for one of</span>
    <span class="c1"># the baseline ants.</span>
    <span class="n">flags</span> <span class="o">=</span> <span class="n">_consolidate_flags_for_ant_in_baselines</span><span class="p">(</span><span class="n">flags</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">flags</span>


<span class="k">def</span> <span class="nf">_consolidate_flags_non_antenna_specific</span><span class="p">(</span><span class="n">flags</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">FlagCmd</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">FlagCmd</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function to consolidate a list of FlagCmd objects (&quot;flags&quot;) by removing</span>
<span class="sd">    flags with antennas/baselines if the same (timestamp, spw, field,</span>
<span class="sd">    intent) is covered by a flagging command without antennas (i.e. all</span>
<span class="sd">    antennas).</span>

<span class="sd">    This function belongs to correctedampflag, by making assumptions on which</span>
<span class="sd">    properties of the FlagCmd it needs to compare.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Identify list of properties of flag commands without antenna.</span>
    <span class="n">flags_without_ant</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">flag</span> <span class="ow">in</span> <span class="n">flags</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">flag</span><span class="o">.</span><span class="n">antenna</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">flags_without_ant</span><span class="p">[(</span><span class="n">flag</span><span class="o">.</span><span class="n">filename</span><span class="p">,</span> <span class="n">flag</span><span class="o">.</span><span class="n">spw</span><span class="p">,</span> <span class="n">flag</span><span class="o">.</span><span class="n">intent</span><span class="p">,</span> <span class="n">flag</span><span class="o">.</span><span class="n">field</span><span class="p">)]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">flag</span><span class="o">.</span><span class="n">time</span><span class="p">)</span>

    <span class="c1"># If flag commands without antenna exist, go through every flag</span>
    <span class="c1"># command and remove the ones that are cover the same</span>
    <span class="c1"># (filename, intent, field, spw, timestamp), ignoring differences in</span>
    <span class="c1"># reason and polarisation.</span>
    <span class="k">if</span> <span class="n">flags_without_ant</span><span class="p">:</span>

        <span class="c1"># Build new list of flags, and preserve skipped flag commands to</span>
        <span class="c1"># report.</span>
        <span class="n">cflags</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">skipped_flagcmds</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Go through list of flags.</span>
        <span class="k">for</span> <span class="n">flag</span> <span class="ow">in</span> <span class="n">flags</span><span class="p">:</span>

            <span class="c1"># If the current flag matches in properties with one of the</span>
            <span class="c1"># flagging commands without antennas:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">flag</span><span class="o">.</span><span class="n">filename</span><span class="p">,</span> <span class="n">flag</span><span class="o">.</span><span class="n">spw</span><span class="p">,</span> <span class="n">flag</span><span class="o">.</span><span class="n">intent</span><span class="p">,</span> <span class="n">flag</span><span class="o">.</span><span class="n">field</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">flags_without_ant</span><span class="p">:</span>

                <span class="c1"># If the current flag is antenna-specific but its timestamp</span>
                <span class="c1"># is covered by one of the no-antenna flags, then skip this</span>
                <span class="c1"># flag; otherwise preserve it.</span>
                <span class="k">if</span> <span class="n">flag</span><span class="o">.</span><span class="n">antenna</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">flag</span><span class="o">.</span><span class="n">time</span> <span class="ow">in</span> <span class="n">flags_without_ant</span><span class="p">[</span><span class="n">idx</span><span class="p">]:</span>
                    <span class="n">skipped_flagcmds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">flag</span><span class="o">.</span><span class="n">flagcmd</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">cflags</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">flag</span><span class="p">)</span>

                <span class="c1"># If the current flag does not match with any of the flagging</span>
                <span class="c1"># commands without antennas, then preserve it.</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cflags</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">flag</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">skipped_flagcmds</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;The following </span><span class="si">{}</span><span class="s1"> antenna-specific flag commands were &#39;</span>
                      <span class="s1">&#39;consolidated into one or more flag commands &#39;</span>
                      <span class="s1">&#39;without an antenna:</span><span class="se">\n</span><span class="s1">&#39;</span>
                      <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">skipped_flagcmds</span><span class="p">),</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">skipped_flagcmds</span><span class="p">)))</span>

    <span class="c1"># If no flag commands with timestamp exist, then there is nothing to</span>
    <span class="c1"># consolidate =&gt; return flags unmodified.</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">cflags</span> <span class="o">=</span> <span class="n">flags</span>

    <span class="k">return</span> <span class="n">cflags</span>


<span class="k">def</span> <span class="nf">_consolidate_flags_for_ant_in_baselines</span><span class="p">(</span><span class="n">flags</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">FlagCmd</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">FlagCmd</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Function to consolidate a list of FlagCmd objects (&quot;flags&quot;) by removing</span>
<span class="sd">    flags with baselines if the same (timestamp, spw, field, intent) is</span>
<span class="sd">    covered by a flagging command for one of the antennas in the baseline.</span>

<span class="sd">    This function belongs to correctedampflag, by making assumptions on which</span>
<span class="sd">    properties of the FlagCmd it needs to compare.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Identify list of properties of flag commands with a single antenna.</span>
    <span class="n">flags_for_single_ant</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">flag</span> <span class="ow">in</span> <span class="n">flags</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">flag</span><span class="o">.</span><span class="n">antenna</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="s1">&#39;&amp;&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">flag</span><span class="o">.</span><span class="n">antenna</span><span class="p">):</span>
            <span class="n">flags_for_single_ant</span><span class="p">[(</span><span class="n">flag</span><span class="o">.</span><span class="n">filename</span><span class="p">,</span> <span class="n">flag</span><span class="o">.</span><span class="n">spw</span><span class="p">,</span> <span class="n">flag</span><span class="o">.</span><span class="n">intent</span><span class="p">,</span> <span class="n">flag</span><span class="o">.</span><span class="n">field</span><span class="p">,</span> <span class="n">flag</span><span class="o">.</span><span class="n">time</span><span class="p">)]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="nb">str</span><span class="p">(</span><span class="n">flag</span><span class="o">.</span><span class="n">antenna</span><span class="p">))</span>

    <span class="c1"># If flag commands for a single antenna exist, go through every flag</span>
    <span class="c1"># command and remove the ones that are cover the same</span>
    <span class="c1"># (filename, intent, field, spw, timestamp) for which their baseline</span>
    <span class="c1"># includes an antenna covered by a single antenna (ignoring differences in</span>
    <span class="c1"># reason and polarisation).</span>
    <span class="k">if</span> <span class="n">flags_for_single_ant</span><span class="p">:</span>

        <span class="c1"># Build new list of flags, and preserve skipped flag commands to</span>
        <span class="c1"># report.</span>
        <span class="n">cflags</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">skipped_flagcmds</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Go through list of flags.</span>
        <span class="k">for</span> <span class="n">flag</span> <span class="ow">in</span> <span class="n">flags</span><span class="p">:</span>

            <span class="c1"># If the current flag matches in properties with one of the</span>
            <span class="c1"># flagging commands without antennas:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">flag</span><span class="o">.</span><span class="n">filename</span><span class="p">,</span> <span class="n">flag</span><span class="o">.</span><span class="n">spw</span><span class="p">,</span> <span class="n">flag</span><span class="o">.</span><span class="n">intent</span><span class="p">,</span> <span class="n">flag</span><span class="o">.</span><span class="n">field</span><span class="p">,</span> <span class="n">flag</span><span class="o">.</span><span class="n">time</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="ow">in</span> <span class="n">flags_for_single_ant</span> <span class="ow">and</span>
                    <span class="nb">str</span><span class="p">(</span><span class="n">flag</span><span class="o">.</span><span class="n">antenna</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">flags_for_single_ant</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="ow">and</span>
                    <span class="nb">any</span><span class="p">(</span><span class="n">ant</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">flag</span><span class="o">.</span><span class="n">antenna</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;&amp;&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">ant</span> <span class="ow">in</span> <span class="n">flags_for_single_ant</span><span class="p">[</span><span class="n">idx</span><span class="p">])):</span>
                <span class="n">skipped_flagcmds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">flag</span><span class="o">.</span><span class="n">flagcmd</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cflags</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">flag</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">skipped_flagcmds</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;The following </span><span class="si">{}</span><span class="s1"> baseline-specific flag commands were &#39;</span>
                      <span class="s1">&#39;consolidated into one or more flag commands &#39;</span>
                      <span class="s1">&#39;covering one of its antennas:</span><span class="se">\n</span><span class="s1">&#39;</span>
                      <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">skipped_flagcmds</span><span class="p">),</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">skipped_flagcmds</span><span class="p">)))</span>

    <span class="c1"># If no flag commands with timestamp exist, then there is nothing to</span>
    <span class="c1"># consolidate =&gt; return flags unmodified.</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">cflags</span> <span class="o">=</span> <span class="n">flags</span>

    <span class="k">return</span> <span class="n">cflags</span>


<span class="k">def</span> <span class="nf">_consolidate_duplicate_flags</span><span class="p">(</span><span class="n">flags</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">FlagCmd</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">FlagCmd</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function to consolidate a list of FlagCmd objects (&quot;flags&quot;) by removing</span>
<span class="sd">    duplicate flags that result in the same flagging command.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Build new list of flags, and preserve skipped flag commands to</span>
    <span class="c1"># report.</span>
    <span class="n">cflags</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">keep_flagcmds</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">skipped_flagcmds</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">flag</span> <span class="ow">in</span> <span class="n">flags</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">flag</span><span class="o">.</span><span class="n">flagcmd</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">keep_flagcmds</span><span class="p">:</span>
            <span class="n">cflags</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">flag</span><span class="p">)</span>
            <span class="n">keep_flagcmds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">flag</span><span class="o">.</span><span class="n">flagcmd</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">skipped_flagcmds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">flag</span><span class="o">.</span><span class="n">flagcmd</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">skipped_flagcmds</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;The following </span><span class="si">{}</span><span class="s1"> flag commands were consolidated as duplicates.&#39;</span>
                  <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">:</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">skipped_flagcmds</span><span class="p">),</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">skipped_flagcmds</span><span class="p">)))</span>

    <span class="k">return</span> <span class="n">cflags</span>


<span class="k">def</span> <span class="nf">_propagate_phase_flags</span><span class="p">(</span><span class="n">flags</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">FlagCmd</span><span class="p">],</span> <span class="n">ms</span><span class="p">:</span> <span class="n">MeasurementSet</span><span class="p">,</span> <span class="n">antenna_id_to_name</span><span class="p">:</span> <span class="n">Dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">FlagCmd</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function to take a list of FlagCmd objects (&quot;flags&quot;) and propagate</span>
<span class="sd">    flags with reason = &#39;bad baseline&#39; and intent = PHASE to intents</span>
<span class="sd">    TARGET and CHECK.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Intents to propagate to.</span>
    <span class="n">intents_propto</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;TARGET&quot;</span><span class="p">,</span> <span class="s2">&quot;CHECK&quot;</span><span class="p">]</span>

    <span class="c1"># Check for presence of intents in current MS, and if valid intent,</span>
    <span class="c1"># retrieve corresponding fields from MS.</span>
    <span class="n">valid_intents</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">valid_intents_fields</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">intent</span> <span class="ow">in</span> <span class="n">intents_propto</span><span class="p">:</span>
        <span class="n">casa_intent</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">to_CASA_intent</span><span class="p">(</span><span class="n">ms</span><span class="p">,</span> <span class="n">intent</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">casa_intent</span><span class="p">:</span>
            <span class="n">valid_intents</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">casa_intent</span><span class="p">)</span>
            <span class="n">fields</span> <span class="o">=</span> <span class="p">{</span><span class="n">field</span><span class="o">.</span><span class="n">name</span>
                      <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">ms</span><span class="o">.</span><span class="n">get_fields</span><span class="p">(</span><span class="n">intent</span><span class="o">=</span><span class="n">intent</span><span class="p">)}</span>
            <span class="n">valid_intents_fields</span><span class="p">[</span><span class="n">casa_intent</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">fields</span><span class="p">)</span>

    <span class="c1"># Proceed if there are valid intents to propagate to.</span>
    <span class="n">propagated_flags</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">nr_propagated_flags</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">valid_intents</span><span class="p">:</span>

        <span class="c1"># Go through each flag, looking for &#39;bad baseline&#39; reason and</span>
        <span class="c1"># &quot;PHASE&quot; intent...</span>
        <span class="k">for</span> <span class="n">flag</span> <span class="ow">in</span> <span class="n">flags</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">flag</span><span class="o">.</span><span class="n">reason</span> <span class="o">==</span> <span class="s1">&#39;bad baseline&#39;</span>
                    <span class="ow">and</span> <span class="n">flag</span><span class="o">.</span><span class="n">intent</span> <span class="o">==</span> <span class="n">utils</span><span class="o">.</span><span class="n">to_CASA_intent</span><span class="p">(</span><span class="n">ms</span><span class="p">,</span> <span class="s2">&quot;PHASE&quot;</span><span class="p">)):</span>

                <span class="n">nr_propagated_flags</span> <span class="o">+=</span> <span class="mi">1</span>

                <span class="c1"># If a match was found, propagate to each of the valid</span>
                <span class="c1"># intents.</span>
                <span class="k">for</span> <span class="n">intent</span> <span class="ow">in</span> <span class="n">valid_intents</span><span class="p">:</span>
                    <span class="n">propagated_flags</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="n">FlagCmd</span><span class="p">(</span>
                            <span class="n">filename</span><span class="o">=</span><span class="n">flag</span><span class="o">.</span><span class="n">filename</span><span class="p">,</span>
                            <span class="n">spw</span><span class="o">=</span><span class="n">flag</span><span class="o">.</span><span class="n">spw</span><span class="p">,</span>
                            <span class="n">antenna</span><span class="o">=</span><span class="n">flag</span><span class="o">.</span><span class="n">antenna</span><span class="p">,</span>
                            <span class="n">intent</span><span class="o">=</span><span class="n">intent</span><span class="p">,</span>
                            <span class="n">pol</span><span class="o">=</span><span class="n">flag</span><span class="o">.</span><span class="n">pol</span><span class="p">,</span>
                            <span class="n">field</span><span class="o">=</span><span class="n">valid_intents_fields</span><span class="p">[</span><span class="n">intent</span><span class="p">],</span>
                            <span class="n">reason</span><span class="o">=</span><span class="s1">&#39;bad baseline propagated from PHASE&#39;</span><span class="p">,</span>
                            <span class="n">antenna_id_to_name</span><span class="o">=</span><span class="n">antenna_id_to_name</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">propagated_flags</span><span class="p">:</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Propagated </span><span class="si">{}</span><span class="s1"> flagging command(s) with reason &#39;</span>
                 <span class="s1">&#39;</span><span class="se">\&quot;</span><span class="s1">bad baseline</span><span class="se">\&quot;</span><span class="s1"> from PHASE intent to TARGET &#39;</span>
                 <span class="s1">&#39;and CHECK intent (where present).&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nr_propagated_flags</span><span class="p">))</span>
        <span class="n">flags</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">propagated_flags</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">flags</span>


<div class="viewcode-block" id="CorrectedampflagInputs">
<a class="viewcode-back" href="../../../../../_apidoc/pipeline.hif.tasks.correctedampflag.html#pipeline.hif.tasks.CorrectedampflagInputs">[docs]</a>
<span class="k">class</span> <span class="nc">CorrectedampflagInputs</span><span class="p">(</span><span class="n">vdp</span><span class="o">.</span><span class="n">StandardInputs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    CorrectedampflagInputs defines the inputs for the Correctedampflag pipeline task.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Search order of input vis</span>
    <span class="n">processing_data_type</span> <span class="o">=</span> <span class="p">[</span><span class="n">DataType</span><span class="o">.</span><span class="n">REGCAL_CONTLINE_ALL</span><span class="p">,</span> <span class="n">DataType</span><span class="o">.</span><span class="n">RAW</span><span class="p">]</span>
    <span class="c1"># Lower sigma threshold for identifying outliers as a result of &quot;bad</span>
    <span class="c1"># baselines&quot; and/or &quot;bad antennas&quot; within baselines (across all</span>
    <span class="c1"># timestamps); equivalent to:</span>
    <span class="c1"># catchNegativeOutliers[&#39;scalardiff&#39;]</span>
    <span class="n">antblnegsig</span> <span class="o">=</span> <span class="n">vdp</span><span class="o">.</span><span class="n">VisDependentProperty</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="mf">3.4</span><span class="p">)</span>

    <span class="c1"># Upper sigma threshold for identifying outliers as a result of &quot;bad</span>
    <span class="c1"># baselines&quot; and/or &quot;bad antennas&quot; within baselines (across all</span>
    <span class="c1"># timestamps); equivalent to:</span>
    <span class="c1"># flag_nsigma[&#39;scalardiff&#39;]</span>
    <span class="n">antblpossig</span> <span class="o">=</span> <span class="n">vdp</span><span class="o">.</span><span class="n">VisDependentProperty</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="mf">3.2</span><span class="p">)</span>

    <span class="c1"># Lower sigma threshold for identifying outliers as a result of bad</span>
    <span class="c1"># antennas within individual timestamps; equivalent to:</span>
    <span class="c1"># relaxationSigma</span>
    <span class="n">antnegsig</span> <span class="o">=</span> <span class="n">vdp</span><span class="o">.</span><span class="n">VisDependentProperty</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="mf">4.0</span><span class="p">)</span>

    <span class="c1"># Upper sigma threshold for identifying outliers as a result of bad</span>
    <span class="c1"># antennas within individual timestamps; equivalent to:</span>
    <span class="c1"># positiveSigmaAntennaBased</span>
    <span class="n">antpossig</span> <span class="o">=</span> <span class="n">vdp</span><span class="o">.</span><span class="n">VisDependentProperty</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="mf">4.6</span><span class="p">)</span>

    <span class="nd">@vdp</span><span class="o">.</span><span class="n">VisDependentProperty</span>
    <span class="k">def</span> <span class="nf">field</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># By default, return the fields corresponding to the input</span>
        <span class="c1"># intents.</span>
        <span class="n">fieldids</span> <span class="o">=</span> <span class="p">[</span><span class="n">field</span><span class="o">.</span><span class="n">name</span>
                    <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ms</span><span class="o">.</span><span class="n">get_fields</span><span class="p">(</span><span class="n">intent</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">intent</span><span class="p">)]</span>
        <span class="k">return</span> <span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">fieldids</span><span class="p">)</span>

    <span class="n">intent</span> <span class="o">=</span> <span class="n">vdp</span><span class="o">.</span><span class="n">VisDependentProperty</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="s1">&#39;BANDPASS&#39;</span><span class="p">)</span>

    <span class="n">niter</span> <span class="o">=</span> <span class="n">vdp</span><span class="o">.</span><span class="n">VisDependentProperty</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

    <span class="c1"># Relaxed value to set the threshold scaling factor to under certain</span>
    <span class="c1"># conditions; equivalent to:</span>
    <span class="c1"># relaxationFactor</span>
    <span class="n">relaxed_factor</span> <span class="o">=</span> <span class="n">vdp</span><span class="o">.</span><span class="n">VisDependentProperty</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="mf">2.0</span><span class="p">)</span>

    <span class="nd">@vdp</span><span class="o">.</span><span class="n">VisDependentProperty</span>
    <span class="k">def</span> <span class="nf">spw</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">science_spws</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ms</span><span class="o">.</span><span class="n">get_spectral_windows</span><span class="p">(</span>
            <span class="n">science_windows_only</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">spw</span><span class="o">.</span><span class="n">id</span><span class="p">)</span> <span class="k">for</span> <span class="n">spw</span> <span class="ow">in</span> <span class="n">science_spws</span><span class="p">])</span>

    <span class="c1"># Threshold for maximum fraction of timestamps that are allowed</span>
    <span class="c1"># to contain outliers; equivalent to:</span>
    <span class="c1"># checkForAntennaBasedBadIntegrations</span>
    <span class="n">tmantint</span> <span class="o">=</span> <span class="n">vdp</span><span class="o">.</span><span class="n">VisDependentProperty</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="mf">0.063</span><span class="p">)</span>

    <span class="c1"># Initial threshold for maximum fraction of &quot;bad baselines&quot; over &quot;all</span>
    <span class="c1"># baselines&quot; that an antenna may be a part of; equivalent to:</span>
    <span class="c1"># tooManyBaselinesFraction</span>
    <span class="n">tmbl</span> <span class="o">=</span> <span class="n">vdp</span><span class="o">.</span><span class="n">VisDependentProperty</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="mf">0.175</span><span class="p">)</span>

    <span class="c1"># Initial threshold for maximum fraction of &quot;outlier timestamps&quot; over</span>
    <span class="c1"># &quot;total timestamps&quot; that a baseline may be a part of; equivalent to:</span>
    <span class="c1"># tooManyIntegrationsFraction</span>
    <span class="n">tmint</span> <span class="o">=</span> <span class="n">vdp</span><span class="o">.</span><span class="n">VisDependentProperty</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="mf">0.085</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">output_dir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">intent</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">field</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">spw</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">antnegsig</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">antpossig</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tmantint</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tmint</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tmbl</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">antblnegsig</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">antblpossig</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">relaxed_factor</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">niter</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">CorrectedampflagInputs</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

        <span class="c1"># pipeline inputs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">context</span> <span class="o">=</span> <span class="n">context</span>
        <span class="c1"># vis must be set first, as other properties may depend on it</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vis</span> <span class="o">=</span> <span class="n">vis</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_dir</span> <span class="o">=</span> <span class="n">output_dir</span>

        <span class="c1"># data selection arguments</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">field</span> <span class="o">=</span> <span class="n">field</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">intent</span> <span class="o">=</span> <span class="n">intent</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spw</span> <span class="o">=</span> <span class="n">spw</span>

        <span class="c1"># flagging parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">antnegsig</span> <span class="o">=</span> <span class="n">antnegsig</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">antpossig</span> <span class="o">=</span> <span class="n">antpossig</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tmantint</span> <span class="o">=</span> <span class="n">tmantint</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tmint</span> <span class="o">=</span> <span class="n">tmint</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tmbl</span> <span class="o">=</span> <span class="n">tmbl</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">antblnegsig</span> <span class="o">=</span> <span class="n">antblnegsig</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">antblpossig</span> <span class="o">=</span> <span class="n">antblpossig</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">relaxed_factor</span> <span class="o">=</span> <span class="n">relaxed_factor</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">niter</span> <span class="o">=</span> <span class="n">niter</span></div>



<div class="viewcode-block" id="Correctedampflag">
<a class="viewcode-back" href="../../../../../_automodapi/pipeline.hif.tasks.Correctedampflag.html#pipeline.hif.tasks.Correctedampflag">[docs]</a>
<span class="nd">@task_registry</span><span class="o">.</span><span class="n">set_equivalent_casa_task</span><span class="p">(</span><span class="s1">&#39;hif_correctedampflag&#39;</span><span class="p">)</span>
<span class="nd">@task_registry</span><span class="o">.</span><span class="n">set_casa_commands_comment</span><span class="p">(</span>
    <span class="s1">&#39;This task identifies, for one or more specified calibrator source intents, baselines and antennas with a &#39;</span>
    <span class="s1">&#39;significant fraction of outlier integrations, by statistically examining the scalar difference of the corrected &#39;</span>
    <span class="s1">&#39;amplitudes minus model amplitudes.&#39;</span>
<span class="p">)</span>
<span class="k">class</span> <span class="nc">Correctedampflag</span><span class="p">(</span><span class="n">basetask</span><span class="o">.</span><span class="n">StandardTaskTemplate</span><span class="p">):</span>
    <span class="n">Inputs</span> <span class="o">=</span> <span class="n">CorrectedampflagInputs</span>

<div class="viewcode-block" id="Correctedampflag.prepare">
<a class="viewcode-back" href="../../../../../_automodapi/pipeline.hif.tasks.Correctedampflag.html#pipeline.hif.tasks.Correctedampflag.prepare">[docs]</a>
    <span class="k">def</span> <span class="nf">prepare</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">inputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span>

        <span class="c1"># Initialize results.</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">CorrectedampflagResults</span><span class="p">()</span>

        <span class="c1"># Store the vis in the result</span>
        <span class="n">result</span><span class="o">.</span><span class="n">vis</span> <span class="o">=</span> <span class="n">inputs</span><span class="o">.</span><span class="n">vis</span>

        <span class="c1"># Get the MS object.</span>
        <span class="n">ms</span> <span class="o">=</span> <span class="n">inputs</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">observing_run</span><span class="o">.</span><span class="n">get_ms</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">inputs</span><span class="o">.</span><span class="n">vis</span><span class="p">)</span>

        <span class="c1"># Get translation dictionary for antenna id to name.</span>
        <span class="n">antenna_id_to_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_ant_id_to_name_dict</span><span class="p">(</span><span class="n">ms</span><span class="p">)</span>

        <span class="c1"># Initialize list of all newly found flags, and before/after flagging</span>
        <span class="c1"># summaries.</span>
        <span class="n">allflags</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">stats_before</span><span class="p">,</span> <span class="n">stats_after</span> <span class="o">=</span> <span class="p">{},</span> <span class="p">{}</span>

        <span class="c1"># Start iterative flagging.</span>
        <span class="n">counter</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">while</span> <span class="n">counter</span> <span class="o">&lt;=</span> <span class="n">inputs</span><span class="o">.</span><span class="n">niter</span><span class="p">:</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Evaluating flagging heuristics for </span><span class="si">{}</span><span class="s2">, iteration </span><span class="si">{}</span><span class="s2">&quot;</span>
                     <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">inputs</span><span class="o">.</span><span class="n">vis</span><span class="p">),</span> <span class="n">counter</span><span class="p">))</span>

            <span class="c1"># Identify new flags.</span>
            <span class="n">newflags</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_run_flagging_iteration</span><span class="p">(</span><span class="n">ms</span><span class="p">,</span> <span class="n">antenna_id_to_name</span><span class="p">)</span>

            <span class="c1"># Run step that will propagate flags under certain conditions.</span>
            <span class="c1"># PIPE-1630: run this within iterative flagging loop to ensure that</span>
            <span class="c1"># propagated flags show up in the &quot;after&quot; flagging summary.</span>
            <span class="n">newflags</span> <span class="o">=</span> <span class="n">_propagate_phase_flags</span><span class="p">(</span><span class="n">newflags</span><span class="p">,</span> <span class="n">ms</span><span class="p">,</span> <span class="n">antenna_id_to_name</span><span class="p">)</span>

            <span class="c1"># Add flags to overall list.</span>
            <span class="n">allflags</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">newflags</span><span class="p">)</span>

            <span class="c1"># Apply intermediate flags; on first iteration, always include &quot;before&quot; summary.</span>
            <span class="k">if</span> <span class="n">counter</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># If new flags are found, but there will be another iteration,</span>
                <span class="c1"># then skip &quot;after&quot; summary; otherwise include the &quot;after&quot; summary.</span>
                <span class="k">if</span> <span class="n">newflags</span> <span class="ow">and</span> <span class="n">counter</span> <span class="o">&lt;</span> <span class="n">inputs</span><span class="o">.</span><span class="n">niter</span><span class="p">:</span>
                    <span class="n">stats_before</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_flags</span><span class="p">(</span><span class="n">newflags</span><span class="p">,</span> <span class="n">sum_before</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">stats_before</span><span class="p">,</span> <span class="n">stats_after</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_flags</span><span class="p">(</span><span class="n">newflags</span><span class="p">,</span> <span class="n">sum_before</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">sum_after</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="c1"># On subsequent iterations, if new flags are found, but there are</span>
            <span class="c1"># more iterations, then skip summaries.</span>
            <span class="k">elif</span> <span class="n">newflags</span> <span class="ow">and</span> <span class="n">counter</span> <span class="o">&lt;</span> <span class="n">inputs</span><span class="o">.</span><span class="n">niter</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_apply_flags</span><span class="p">(</span><span class="n">newflags</span><span class="p">)</span>

            <span class="c1"># On subsequent iterations, if no new flags are found, or this is</span>
            <span class="c1"># the final iteration, then include the &quot;after&quot; summary.</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">_</span><span class="p">,</span> <span class="n">stats_after</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_flags</span><span class="p">(</span><span class="n">newflags</span><span class="p">,</span> <span class="n">sum_after</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">newflags</span><span class="p">:</span>
                <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Evaluation of flagging heuristics for </span><span class="si">{}</span><span class="s2">, iteration </span><span class="si">{}</span><span class="s2"> resulted 0 new flagging commands.&quot;</span>
                         <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">inputs</span><span class="o">.</span><span class="n">vis</span><span class="p">),</span> <span class="n">counter</span><span class="p">))</span>
                <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Evaluation of flagging heuristics for </span><span class="si">{}</span><span class="s2">, iteration </span><span class="si">{}</span><span class="s2"> resulted in </span><span class="si">{}</span><span class="s2"> new&quot;</span>
                         <span class="s2">&quot; flagging commands.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">inputs</span><span class="o">.</span><span class="n">vis</span><span class="p">),</span> <span class="n">counter</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">newflags</span><span class="p">)))</span>

            <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># After iterative evaluation of heuristics, if any flags were found:</span>
        <span class="k">if</span> <span class="n">allflags</span><span class="p">:</span>
            <span class="c1"># Consolidate final list of all flagging commands.</span>
            <span class="n">allflags</span> <span class="o">=</span> <span class="n">_consolidate_flags</span><span class="p">(</span><span class="n">allflags</span><span class="p">)</span>

            <span class="c1"># Report final number of new flags (CAS-7336: show as info message instead of warning).</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Evaluation of flagging heuristics for </span><span class="si">{}</span><span class="s2"> raised total of </span><span class="si">{}</span><span class="s2"> flagging command(s)&quot;</span>
                     <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">inputs</span><span class="o">.</span><span class="n">vis</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">allflags</span><span class="p">)))</span>

        <span class="c1"># Store final list of flags in result.</span>
        <span class="n">result</span><span class="o">.</span><span class="n">addflags</span><span class="p">(</span><span class="n">allflags</span><span class="p">)</span>

        <span class="c1"># Attach flagging summaries to result</span>
        <span class="n">result</span><span class="o">.</span><span class="n">summaries</span> <span class="o">=</span> <span class="p">[</span><span class="n">stats_before</span><span class="p">,</span> <span class="n">stats_after</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="Correctedampflag.analyse">
<a class="viewcode-back" href="../../../../../_automodapi/pipeline.hif.tasks.Correctedampflag.html#pipeline.hif.tasks.Correctedampflag.analyse">[docs]</a>
    <span class="k">def</span> <span class="nf">analyse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">result</span></div>


    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_get_ant_id_to_name_dict</span><span class="p">(</span><span class="n">ms</span><span class="p">:</span> <span class="n">MeasurementSet</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return dictionary with antenna ID mapped to antenna name.</span>
<span class="sd">        If no unique antenna name can be assigned to each antenna ID,</span>
<span class="sd">        then return empty dictionary.</span>

<span class="sd">        :param ms: MeasurementSet</span>
<span class="sd">        :return: dictionary</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Create an antenna id-to-name translation dictionary.</span>
        <span class="n">antenna_id_to_name</span> <span class="o">=</span> <span class="p">{</span><span class="n">ant</span><span class="o">.</span><span class="n">id</span><span class="p">:</span> <span class="n">ant</span><span class="o">.</span><span class="n">name</span>
                              <span class="k">for</span> <span class="n">ant</span> <span class="ow">in</span> <span class="n">ms</span><span class="o">.</span><span class="n">antennas</span>
                              <span class="k">if</span> <span class="n">ant</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">strip</span><span class="p">()}</span>

        <span class="c1"># Check that each antenna ID is represented by a unique non-empty</span>
        <span class="c1"># name, by testing that the unique set of antenna names is same</span>
        <span class="c1"># length as list of IDs. If not, then set the translation</span>
        <span class="c1"># dictionary to an empty dictionary (to revert back to flagging by ID.)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">antenna_id_to_name</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ms</span><span class="o">.</span><span class="n">antennas</span><span class="p">):</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;No unique name available for each antenna ID:&#39;</span>
                     <span class="s1">&#39; flagging by antenna ID instead of by name.&#39;</span><span class="p">)</span>
            <span class="n">antenna_id_to_name</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">return</span> <span class="n">antenna_id_to_name</span>

    <span class="k">def</span> <span class="nf">_run_flagging_iteration</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ms</span><span class="p">:</span> <span class="n">MeasurementSet</span><span class="p">,</span> <span class="n">antenna_id_to_name</span><span class="p">:</span> <span class="n">Dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">FlagCmd</span><span class="p">]:</span>
        <span class="n">inputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span>

        <span class="c1"># Get the spws to use.</span>
        <span class="n">spwids</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">inputs</span><span class="o">.</span><span class="n">spw</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)))</span>

        <span class="c1"># Initialize list of newly found flags.</span>
        <span class="n">newflags</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Evaluate flagging heuristics separately for each intent.</span>
        <span class="k">for</span> <span class="n">intent</span> <span class="ow">in</span> <span class="n">inputs</span><span class="o">.</span><span class="n">intent</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">):</span>

            <span class="c1"># For current intent, identify which fields from inputs are valid.</span>
            <span class="k">if</span> <span class="n">intent</span> <span class="o">==</span> <span class="s1">&#39;TARGET&#39;</span><span class="p">:</span>
                <span class="c1"># Use field IDs to loop over individual mosaic pointings for</span>
                <span class="c1"># science targets (PIPE-337).</span>
                <span class="n">valid_fields</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">field</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
                                <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">ms</span><span class="o">.</span><span class="n">get_fields</span><span class="p">(</span><span class="n">intent</span><span class="o">=</span><span class="n">intent</span><span class="p">)</span>
                                <span class="k">if</span> <span class="n">field</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">utils</span><span class="o">.</span><span class="n">safe_split</span><span class="p">(</span><span class="n">inputs</span><span class="o">.</span><span class="n">field</span><span class="p">))]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Use field names for calibrators.</span>
                <span class="n">valid_fields</span> <span class="o">=</span> <span class="p">[</span><span class="n">field</span><span class="o">.</span><span class="n">name</span>
                                <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">ms</span><span class="o">.</span><span class="n">get_fields</span><span class="p">(</span><span class="n">intent</span><span class="o">=</span><span class="n">intent</span><span class="p">)</span>
                                <span class="k">if</span> <span class="n">field</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">utils</span><span class="o">.</span><span class="n">safe_split</span><span class="p">(</span><span class="n">inputs</span><span class="o">.</span><span class="n">field</span><span class="p">))]</span>

            <span class="c1"># If no valid fields were found, raise warning, and continue to</span>
            <span class="c1"># next intent. The following intents are optional and do not require</span>
            <span class="c1"># a warning: CHECK (PIPE-281), POLANGLE, POLLEAKAGE (PIPE-607),</span>
            <span class="c1"># DIFFGAINREF, DIFFGAINSRC (PIPE-2082, PIPE-2145).</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">valid_fields</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">intent</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;CHECK&#39;</span><span class="p">,</span> <span class="s1">&#39;DIFFGAINREF&#39;</span><span class="p">,</span> <span class="s1">&#39;DIFFGAINSRC&#39;</span><span class="p">,</span> <span class="s1">&#39;POLANGLE&#39;</span><span class="p">,</span> <span class="s1">&#39;POLLEAKAGE&#39;</span><span class="p">]:</span>
                    <span class="n">LOG</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Invalid data selection for given intent(s) and field(s): fields </span><span class="si">{}</span><span class="s2"> do not include&quot;</span>
                                <span class="s2">&quot; intent </span><span class="se">\&#39;</span><span class="si">{}</span><span class="se">\&#39;</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">utils</span><span class="o">.</span><span class="n">commafy</span><span class="p">(</span><span class="n">utils</span><span class="o">.</span><span class="n">safe_split</span><span class="p">(</span><span class="n">inputs</span><span class="o">.</span><span class="n">field</span><span class="p">)),</span> <span class="n">intent</span><span class="p">))</span>
                <span class="k">continue</span>

            <span class="c1"># Evaluate heuristic for each valid field.</span>
            <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">valid_fields</span><span class="p">:</span>

                <span class="c1"># Evaluate flagging heuristics separately for each spw.</span>
                <span class="k">for</span> <span class="n">spwid</span> <span class="ow">in</span> <span class="n">spwids</span><span class="p">:</span>

                    <span class="n">flags_for_intent_field_spw</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_evaluate_heuristic</span><span class="p">(</span>
                        <span class="n">ms</span><span class="p">,</span> <span class="n">intent</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">spwid</span><span class="p">,</span> <span class="n">antenna_id_to_name</span><span class="p">)</span>
                    <span class="n">newflags</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">flags_for_intent_field_spw</span><span class="p">)</span>

        <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Flagging commands from current iteration, before consolidation:</span><span class="se">\n</span><span class="si">{}</span><span class="s2">&quot;</span>
                  <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">flag</span><span class="o">.</span><span class="n">flagcmd</span> <span class="k">for</span> <span class="n">flag</span> <span class="ow">in</span> <span class="n">newflags</span><span class="p">])))</span>

        <span class="c1"># Consolidate flagging commands from current iteration to minimize</span>
        <span class="c1"># request for flagdata.</span>
        <span class="n">newflags</span> <span class="o">=</span> <span class="n">_consolidate_flags</span><span class="p">(</span><span class="n">newflags</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">newflags</span>

    <span class="k">def</span> <span class="nf">_evaluate_heuristic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ms</span><span class="p">:</span> <span class="n">MeasurementSet</span><span class="p">,</span> <span class="n">intent</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">field</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">spwid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                            <span class="n">antenna_id_to_name</span><span class="p">:</span> <span class="n">Dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">FlagCmd</span><span class="p">]:</span>
        <span class="c1"># Initialize flags.</span>
        <span class="n">allflags</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Determine which baseline sets to evaluate separately.</span>
        <span class="n">baseline_sets</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_identify_baseline_sets</span><span class="p">(</span><span class="n">ms</span><span class="p">)</span>

        <span class="c1"># If no baseline sets were received, then evaluate heuristics for</span>
        <span class="c1"># all baselines at once.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">baseline_sets</span><span class="p">:</span>
            <span class="n">allflags</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_evaluate_heuristic_for_baseline_set</span><span class="p">(</span>
                <span class="n">ms</span><span class="p">,</span> <span class="n">intent</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">spwid</span><span class="p">,</span> <span class="n">antenna_id_to_name</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Evaluate heuristic for each set of baselines.</span>
            <span class="k">for</span> <span class="n">baseline_set</span> <span class="ow">in</span> <span class="n">baseline_sets</span><span class="p">:</span>
                <span class="n">newflags</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_evaluate_heuristic_for_baseline_set</span><span class="p">(</span>
                    <span class="n">ms</span><span class="p">,</span> <span class="n">intent</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">spwid</span><span class="p">,</span> <span class="n">antenna_id_to_name</span><span class="p">,</span> <span class="n">baseline_set</span><span class="p">)</span>
                <span class="n">allflags</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">newflags</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">allflags</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_identify_baseline_sets</span><span class="p">(</span><span class="n">ms</span><span class="p">:</span> <span class="n">MeasurementSet</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]:</span>
        <span class="c1"># Determine unique antenna diameters.</span>
        <span class="n">uniq_diams</span> <span class="o">=</span> <span class="p">{</span><span class="n">ant</span><span class="o">.</span><span class="n">diameter</span> <span class="k">for</span> <span class="n">ant</span> <span class="ow">in</span> <span class="n">ms</span><span class="o">.</span><span class="n">antennas</span><span class="p">}</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">uniq_diams</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># If dataset contains only antennas with the same antenna diameter,</span>
            <span class="c1"># then heuristics should be evaluated for all baselines together.</span>
            <span class="n">baseline_sets</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># If the dataset contains antennas of different diameters, then</span>
            <span class="c1"># check that these are ALMA with the expected diameters.</span>
            <span class="k">if</span> <span class="n">ms</span><span class="o">.</span><span class="n">antenna_array</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;ALMA&#39;</span> <span class="ow">and</span> <span class="n">uniq_diams</span> <span class="o">==</span> <span class="p">{</span><span class="mf">7.0</span><span class="p">,</span> <span class="mf">12.0</span><span class="p">}:</span>

                <span class="c1"># For 12m antennas, identify number of &quot;PM*&quot; and &quot;D*&quot; antennas.</span>
                <span class="n">ant_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">ant</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">ant</span> <span class="ow">in</span> <span class="n">ms</span><span class="o">.</span><span class="n">antennas</span><span class="p">]</span>
                <span class="n">n_pm</span> <span class="o">=</span> <span class="nb">len</span><span class="p">([</span><span class="n">name</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">ant_names</span> <span class="k">if</span> <span class="s2">&quot;PM&quot;</span> <span class="ow">in</span> <span class="n">name</span><span class="p">])</span>
                <span class="n">n_d</span> <span class="o">=</span> <span class="nb">len</span><span class="p">([</span><span class="n">name</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">ant_names</span> <span class="k">if</span> <span class="s2">&quot;D&quot;</span> <span class="ow">in</span> <span class="n">name</span><span class="p">])</span>

                <span class="c1"># Always add the mixed-array 7m-12m as a baseline set.</span>
                <span class="n">bl_str</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">if</span> <span class="n">n_pm</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">bl_str</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;CM*&amp;PM*&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">n_d</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">bl_str</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;CM*&amp;D*&quot;</span><span class="p">)</span>
                <span class="n">baseline_sets</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;7m-12m&#39;</span><span class="p">,</span> <span class="s1">&#39;;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">bl_str</span><span class="p">))]</span>

                <span class="c1"># If more than one 7m antenna is present, add these as a</span>
                <span class="c1"># separate baseline set.</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">([</span><span class="n">ant</span> <span class="k">for</span> <span class="n">ant</span> <span class="ow">in</span> <span class="n">ms</span><span class="o">.</span><span class="n">antennas</span> <span class="k">if</span> <span class="n">ant</span><span class="o">.</span><span class="n">diameter</span> <span class="o">==</span> <span class="mf">7.0</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">baseline_sets</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">&#39;7m-7m&#39;</span><span class="p">,</span> <span class="s2">&quot;CM*&amp;CM*&quot;</span><span class="p">))</span>

                <span class="c1"># If more than one 12m antenna is present, add these as a</span>
                <span class="c1"># separate baseline set.</span>
                <span class="k">if</span> <span class="n">n_pm</span> <span class="o">+</span> <span class="n">n_d</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">bl_str</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">if</span> <span class="n">n_pm</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">bl_str</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;PM*&amp;PM*&quot;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">n_d</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">bl_str</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;D*&amp;D*&quot;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">n_pm</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">n_d</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">bl_str</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;PM*&amp;D*&quot;</span><span class="p">)</span>
                    <span class="n">baseline_sets</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">&#39;12m-12m&#39;</span><span class="p">,</span> <span class="s1">&#39;;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">bl_str</span><span class="p">)))</span>
            <span class="c1"># If the mixed-array dataset is not recognized as ALMA diameters,</span>
            <span class="c1"># then continue with evaluating all baselines at once.</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">baseline_sets</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">LOG</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Found mixed-array with multiple antenna diameters, but unanticipated non-ALMA diameters&quot;</span>
                            <span class="s2">&quot; (do not know how to select data). Continuing with heuristic evaluation for all baselines&quot;</span>
                            <span class="s2">&quot; at once.&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">baseline_sets</span>

    <span class="k">def</span> <span class="nf">_uvbinFactor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">uvmin</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">totalpts</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="c1"># Determine the uvrange bin width for searching for outliers in TARGET data.</span>
        <span class="c1"># ACA snapshot mosaics can have small number of visibility points per field that would </span>
        <span class="c1"># not support the option with finer bins at short baselines (18 bins from 7m-36m).  </span>
        <span class="c1"># So, we must use the fixed sqrt(2) bin width in this case, which will lead to only 5 bins.</span>
        <span class="c1"># Where to set the threshold?</span>
        <span class="c1"># Example: 11 antenna array (one 30sec scan/6sec integrations)*11*10/2 = 275 points</span>
        <span class="c1"># Example: 12 antenna array (one 30sec scan/6sec integrations)*12*11/2 = 330 points</span>
        <span class="c1"># Example: 16 antenna array (one 30sec scan/6sec integrations)*12*11/2 = 600 points</span>
        <span class="c1"># Compared to 12m array:</span>
        <span class="c1"># Example: 43 antenna array: 5integrations * 43*42/2 = 4515</span>
        <span class="c1"># Example: 27 antenna array: 5integrations * 27*26/2 = 1755</span>
        <span class="c1"># We set threshold to 1000 points, so that we need at least 2 scans per field</span>
        <span class="c1"># with a 16-antenna array, or 4 scans per field of an 11-antenna array.</span>
        <span class="k">if</span> <span class="n">totalpts</span> <span class="o">&gt;</span> <span class="mi">1000</span><span class="p">:</span>
            <span class="c1"># use faster increments at longer baselines</span>
            <span class="k">if</span> <span class="n">uvmin</span> <span class="o">&lt;</span> <span class="mi">40</span><span class="p">:</span>
                <span class="n">factor</span> <span class="o">=</span> <span class="mf">1.1</span>
            <span class="k">elif</span> <span class="n">uvmin</span> <span class="o">&lt;</span> <span class="mi">90</span><span class="p">:</span>
                <span class="n">factor</span> <span class="o">=</span> <span class="mf">1.2</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">factor</span> <span class="o">=</span> <span class="mf">1.26</span>
        <span class="k">elif</span> <span class="n">totalpts</span> <span class="o">&gt;</span> <span class="mi">500</span><span class="p">:</span>
            <span class="n">factor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Using uvbinFactor=</span><span class="si">%.2f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">factor</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">factor</span> <span class="o">=</span> <span class="mf">1.6</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Using uvbinFactor=</span><span class="si">%.2f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">factor</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">factor</span>
        
    <span class="k">def</span> <span class="nf">_evaluate_heuristic_for_baseline_set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ms</span><span class="p">:</span> <span class="n">MeasurementSet</span><span class="p">,</span> <span class="n">intent</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">field</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">spwid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                                             <span class="n">antenna_id_to_name</span><span class="p">:</span> <span class="n">Dict</span><span class="p">,</span>
                                             <span class="n">baseline_set</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">FlagCmd</span><span class="p">]:</span>

        <span class="n">inputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span>

        <span class="c1"># Set &quot;default&quot; scale factor by which the thresholds</span>
        <span class="c1"># tmint and tmbl should be scaled.</span>
        <span class="n">thresh_scale_factor</span> <span class="o">=</span> <span class="mf">1.0</span>

        <span class="c1"># Set threshold for maximum fraction of outlier baseline scans that</span>
        <span class="c1"># a single antenna can be involved in.</span>
        <span class="n">max_frac_outlier_scans</span> <span class="o">=</span> <span class="mf">0.5</span>

        <span class="c1"># Set threshold for maximum fraction of antennas that can be</span>
        <span class="c1"># &quot;affected&quot;, by being involved in the most, or close to the most,</span>
        <span class="c1"># number of outlier baseline scans.</span>
        <span class="n">ants_in_outlier_baseline_scans_thresh</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="mf">3.0</span>

        <span class="c1"># Set threshold for maximum fraction of antennas that can be either</span>
        <span class="c1"># &quot;affected&quot; or &quot;partially affected&quot;, where the latter are antennas</span>
        <span class="c1"># that are not &quot;affected&quot; but still involved in at least one outlier</span>
        <span class="c1"># baseline scan.</span>
        <span class="n">ants_in_outlier_baseline_scans_partial_thresh</span> <span class="o">=</span> <span class="mf">0.5</span>

        <span class="c1"># Set threshold for minimum number of &quot;bad baselines&quot; than an antenna</span>
        <span class="c1"># may be a part of without getting flagged.</span>
        <span class="n">tmbl_minbadnr</span> <span class="o">=</span> <span class="mf">4.0</span>

        <span class="c1"># Set sigma threshold for identifying very high outliers.</span>
        <span class="n">antveryhighsig</span> <span class="o">=</span> <span class="mf">10.0</span>

        <span class="c1"># Set sigma thresholds for identifying ultra low/high outliers.</span>
        <span class="n">antultrahighsig</span> <span class="o">=</span> <span class="mf">12.0</span>
        <span class="n">antultralowsig</span> <span class="o">=</span> <span class="mf">13.0</span>

        <span class="c1"># Set sigma outlier threshold for purpose of evaluating</span>
        <span class="c1"># whether to relax the threshold scaling factor.</span>
        <span class="n">relaxsig</span> <span class="o">=</span> <span class="mf">6.5</span>

        <span class="c1"># Get number of scans in MS for this intent.</span>
        <span class="n">nscans</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ms</span><span class="o">.</span><span class="n">get_scans</span><span class="p">(</span><span class="n">scan_intent</span><span class="o">=</span><span class="n">intent</span><span class="p">,</span> <span class="n">spw</span><span class="o">=</span><span class="n">spwid</span><span class="p">))</span>

        <span class="c1"># Get number of antennas.</span>
        <span class="n">nants</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ms</span><span class="o">.</span><span class="n">antennas</span><span class="p">)</span>

        <span class="c1"># If there are multiple scans for this intent, then scale up the</span>
        <span class="c1"># threshold for timestamps with outliers.</span>
        <span class="k">if</span> <span class="n">nscans</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">tmantint</span> <span class="o">=</span> <span class="n">inputs</span><span class="o">.</span><span class="n">tmantint</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">nscans</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tmantint</span> <span class="o">=</span> <span class="n">inputs</span><span class="o">.</span><span class="n">tmantint</span>

        <span class="c1"># Initialize flags.</span>
        <span class="n">newflags</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Read in data from MS. If no valid data could be read, return early with no flags.</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">mstools</span><span class="o">.</span><span class="n">read_channel_averaged_data_from_ms</span><span class="p">(</span><span class="n">ms</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">spwid</span><span class="p">,</span> <span class="n">intent</span><span class="p">,</span>
            <span class="p">[</span><span class="s1">&#39;corrected_data&#39;</span><span class="p">,</span> <span class="s1">&#39;model_data&#39;</span><span class="p">,</span> <span class="s1">&#39;antenna1&#39;</span><span class="p">,</span> <span class="s1">&#39;antenna2&#39;</span><span class="p">,</span> <span class="s1">&#39;flag&#39;</span><span class="p">,</span> <span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="s1">&#39;uvdist&#39;</span><span class="p">],</span> <span class="n">baseline_set</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">data</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">newflags</span>

        <span class="c1"># Remove the channel dimension (should be of length 1 as we asked</span>
        <span class="c1"># for average across all channels).</span>
        <span class="n">corrdata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;corrected_data&#39;</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">modeldata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;model_data&#39;</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">flag_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;flag&#39;</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">uvdist_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;uvdist&#39;</span><span class="p">])</span>

        <span class="c1"># Compute &quot;scalar difference&quot; between corrected data and model data.</span>
        <span class="n">cmetric_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">corrdata</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">modeldata</span><span class="p">)</span>

        <span class="c1"># Select non-autocorrelations.</span>
        <span class="n">id_nonac</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;antenna1&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;antenna2&#39;</span><span class="p">])</span>
        <span class="n">time</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">][</span><span class="n">id_nonac</span><span class="p">]</span>
        <span class="n">ant1</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;antenna1&#39;</span><span class="p">][</span><span class="n">id_nonac</span><span class="p">]</span>
        <span class="n">ant2</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;antenna2&#39;</span><span class="p">][</span><span class="n">id_nonac</span><span class="p">]</span>

        <span class="c1"># Get number of correlations for this spw.</span>
        <span class="n">corr_type</span> <span class="o">=</span> <span class="n">commonhelpermethods</span><span class="o">.</span><span class="n">get_corr_products</span><span class="p">(</span><span class="n">ms</span><span class="p">,</span> <span class="n">spwid</span><span class="p">)</span>
        <span class="n">ncorrs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">corr_type</span><span class="p">)</span>

        <span class="c1"># CAS-12011: For multi-scan observations, analyze the mean of the</span>
        <span class="c1"># metric for XX and YY, and for XY and YX (if ncorrs = 4). Combine the</span>
        <span class="c1"># flagging state of the individual correlations by only marking the</span>
        <span class="c1"># mean metric as flagged where both individual contributing</span>
        <span class="c1"># correlations are marked as flagged (by floor-dividing by 2).</span>
        <span class="k">if</span> <span class="n">nscans</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">cmetric_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cmetric_all</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">flag_all</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ncorrs</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">cmetric_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">cmetric_mask</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">flag_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">flag_all</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
                <span class="n">ncorrs</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">ncorrs</span> <span class="o">==</span> <span class="mi">4</span> <span class="ow">and</span> <span class="nb">set</span><span class="p">(</span><span class="n">corr_type</span><span class="p">)</span> <span class="o">==</span> <span class="p">{</span><span class="s1">&#39;XX&#39;</span><span class="p">,</span> <span class="s1">&#39;XY&#39;</span><span class="p">,</span> <span class="s1">&#39;YX&#39;</span><span class="p">,</span> <span class="s1">&#39;YY&#39;</span><span class="p">}:</span>
                <span class="c1"># Create mean of XX and YY polarization, and combine flags.</span>
                <span class="n">col_sel</span> <span class="o">=</span> <span class="p">[</span><span class="n">corr_type</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;XX&#39;</span><span class="p">),</span> <span class="n">corr_type</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;YY&#39;</span><span class="p">)]</span>
                <span class="n">cmetric_copol</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">cmetric_mask</span><span class="p">[</span><span class="n">col_sel</span><span class="p">,</span> <span class="p">:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">flag_copol</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">flag_all</span><span class="p">[</span><span class="n">col_sel</span><span class="p">,</span> <span class="p">:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
                <span class="c1"># Create mean of XY and YX polarization, and combine flags.</span>
                <span class="n">col_sel</span> <span class="o">=</span> <span class="p">[</span><span class="n">corr_type</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;XY&#39;</span><span class="p">),</span> <span class="n">corr_type</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;YX&#39;</span><span class="p">)]</span>
                <span class="n">cmetric_crosspol</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">cmetric_mask</span><span class="p">[</span><span class="n">col_sel</span><span class="p">,</span> <span class="p">:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">flag_crosspol</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">flag_all</span><span class="p">[</span><span class="n">col_sel</span><span class="p">,</span> <span class="p">:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
                <span class="c1"># Create new scalar difference array with the mean data, and</span>
                <span class="c1"># corresponding flagging array.</span>
                <span class="n">cmetric_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">cmetric_copol</span><span class="p">,</span> <span class="n">cmetric_crosspol</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">flag_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">flag_copol</span><span class="p">,</span> <span class="n">flag_crosspol</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">ncorrs</span> <span class="o">=</span> <span class="mi">2</span>

        <span class="c1"># Evaluate flagging heuristics separately for each polarisation.</span>
        <span class="k">for</span> <span class="n">icorr</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ncorrs</span><span class="p">):</span>

            <span class="c1"># Select non-autocorrelations from corrected and model data.</span>
            <span class="n">cmetric</span> <span class="o">=</span> <span class="n">cmetric_all</span><span class="p">[</span><span class="n">icorr</span><span class="p">][</span><span class="n">id_nonac</span><span class="p">]</span>
            <span class="n">flag</span> <span class="o">=</span> <span class="n">flag_all</span><span class="p">[</span><span class="n">icorr</span><span class="p">][</span><span class="n">id_nonac</span><span class="p">]</span>

            <span class="c1"># Compute the threshold for maximum number of timestamps that are allowed</span>
            <span class="c1"># to contain outliers, based on maximum fractional threshold and</span>
            <span class="c1"># number of unique timestamps, while setting to a minimum of 1.</span>
            <span class="n">n_time_with_highsig_thresh_min</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">n_time_with_highsig_thresh_frac</span> <span class="o">=</span> <span class="n">tmantint</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">time</span><span class="p">))</span>
            <span class="n">n_time_with_highsig_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="n">n_time_with_highsig_thresh_min</span><span class="p">,</span> <span class="n">n_time_with_highsig_thresh_frac</span><span class="p">])</span>

            <span class="c1"># Select for non-flagged data and non-NaN data.</span>
            <span class="n">id_nonbad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">flag</span><span class="p">),</span>
                <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">cmetric</span><span class="p">)))</span>
            <span class="n">cmetric_sel</span> <span class="o">=</span> <span class="n">cmetric</span><span class="p">[</span><span class="n">id_nonbad</span><span class="p">]</span>
            <span class="n">time_sel</span> <span class="o">=</span> <span class="n">time</span><span class="p">[</span><span class="n">id_nonbad</span><span class="p">]</span>
            <span class="n">ant1_sel</span> <span class="o">=</span> <span class="n">ant1</span><span class="p">[</span><span class="n">id_nonbad</span><span class="p">]</span>
            <span class="n">ant2_sel</span> <span class="o">=</span> <span class="n">ant2</span><span class="p">[</span><span class="n">id_nonbad</span><span class="p">]</span>

            <span class="c1"># Compute the median. Assuming the distribution is normal,</span>
            <span class="c1"># compute a robust estimate of the standard deviation as</span>
            <span class="c1"># 1.4826 x the median absolute deviation from the median.</span>
            <span class="n">med</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">cmetric_sel</span><span class="p">)</span>
            <span class="n">mad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">cmetric_sel</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">cmetric_sel</span><span class="p">)))</span> <span class="o">*</span> <span class="mf">1.4826</span>
            <span class="c1">#</span>
            <span class="c1"># Evaluate whether the threshold scaling factor should be</span>
            <span class="c1"># set to the relaxed value.</span>
            <span class="c1">#</span>

            <span class="c1"># Based on the &quot;relaxation&quot; sigma outlier threshold, identify</span>
            <span class="c1"># outliers. If an antenna-based bad integrations fraction was</span>
            <span class="c1"># provided, then identify both negative and positive outliers,</span>
            <span class="c1"># otherwise just identify negative outliers.</span>
            <span class="k">if</span> <span class="n">tmantint</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">id_relaxsig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span>
                        <span class="n">cmetric_sel</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">med</span> <span class="o">-</span> <span class="n">mad</span> <span class="o">*</span> <span class="n">relaxsig</span><span class="p">),</span>
                        <span class="n">cmetric_sel</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">med</span> <span class="o">+</span> <span class="n">mad</span> <span class="o">*</span> <span class="n">relaxsig</span><span class="p">)))[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">id_relaxsig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                    <span class="n">cmetric_sel</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">med</span> <span class="o">-</span> <span class="n">mad</span> <span class="o">*</span> <span class="n">inputs</span><span class="o">.</span><span class="n">relaxsig</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># If any outliers were found...</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">id_relaxsig</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># Relax threshold scale factor if not testing for positive</span>
                <span class="c1"># outliers.</span>
                <span class="k">if</span> <span class="n">tmantint</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">thresh_scale_factor</span> <span class="o">=</span> <span class="n">inputs</span><span class="o">.</span><span class="n">relaxed_factor</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># First check if a few antennas (up to 10%) explain most of</span>
                    <span class="c1"># the outlier timestamps (&gt;90%), before determining the</span>
                    <span class="c1"># maximum threshold of outlier timestamps.</span>
                    <span class="n">n_time_max_scale_factor</span> <span class="o">=</span> <span class="mi">1</span>

                    <span class="c1"># Track which antennas appear most frequently among outlier</span>
                    <span class="c1"># timestamps.</span>
                    <span class="n">frequent_ants</span> <span class="o">=</span> <span class="p">[]</span>

                    <span class="c1"># Select antennas for outlier timestamps.</span>
                    <span class="n">ant1_remaining</span> <span class="o">=</span> <span class="n">ant1_sel</span><span class="p">[</span><span class="n">id_relaxsig</span><span class="p">]</span>
                    <span class="n">ant2_remaining</span> <span class="o">=</span> <span class="n">ant2_sel</span><span class="p">[</span><span class="n">id_relaxsig</span><span class="p">]</span>

                    <span class="c1"># Iterate for up to 10% of the nr. of antennas.</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="n">nants</span> <span class="o">//</span> <span class="mi">10</span><span class="p">])):</span>
                        <span class="c1"># Add antenna that appears most frequently.</span>
                        <span class="n">frequent_ant</span> <span class="o">=</span> <span class="n">mode</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">ant1_remaining</span><span class="p">,</span> <span class="n">ant2_remaining</span><span class="p">]))</span>
                        <span class="n">frequent_ants</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">antenna_id_to_name</span><span class="p">[</span><span class="n">frequent_ant</span><span class="p">])</span>

                        <span class="c1"># Identify which antennas remain excluding the newly</span>
                        <span class="c1"># found most frequent antenna.</span>
                        <span class="n">ant1_to_keep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ant1_remaining</span> <span class="o">!=</span> <span class="n">frequent_ant</span><span class="p">)</span>
                        <span class="n">ant2_to_keep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ant2_remaining</span> <span class="o">!=</span> <span class="n">frequent_ant</span><span class="p">)</span>
                        <span class="n">ants_to_keep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">ant1_to_keep</span><span class="p">,</span> <span class="n">ant2_to_keep</span><span class="p">)</span>

                        <span class="c1"># Compute what fraction of outliers the most frequent</span>
                        <span class="c1"># antennas account for.</span>
                        <span class="n">percentage</span> <span class="o">=</span> <span class="mi">100</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ants_to_keep</span><span class="p">))</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">id_relaxsig</span><span class="p">))</span>
                        <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ms</span><span class="o">.</span><span class="n">basename</span><span class="si">}</span><span class="s2">, corr </span><span class="si">{</span><span class="n">icorr</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2"> antenna(s)&quot;</span>
                                 <span class="sa">f</span><span class="s2">&quot; (</span><span class="si">{</span><span class="n">utils</span><span class="o">.</span><span class="n">commafy</span><span class="p">(</span><span class="n">frequent_ants</span><span class="p">,</span><span class="w"> </span><span class="n">quotes</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="si">}</span><span class="s2">) account for </span><span class="si">{</span><span class="n">percentage</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2"> percent&quot;</span>
                                 <span class="sa">f</span><span class="s2">&quot; of relaxsig outliers (PIPE-1000).&quot;</span><span class="p">)</span>

                        <span class="c1"># If the remaining outliers are less than 10%, then</span>
                        <span class="c1"># set a new scaling factor based on nr. of antennas</span>
                        <span class="c1"># that cause the most outliers, and break out of this</span>
                        <span class="c1"># for loop.</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ants_to_keep</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">id_relaxsig</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.1</span><span class="p">:</span>
                            <span class="n">n_time_max_scale_factor</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">-</span> <span class="n">i</span>
                            <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ms</span><span class="o">.</span><span class="n">basename</span><span class="si">}</span><span class="s2">, corr </span><span class="si">{</span><span class="n">icorr</span><span class="si">}</span><span class="s2">: setting scaling factor for maximum threshold for&quot;</span>
                                     <span class="sa">f</span><span class="s2">&quot; outlier timestamps to: </span><span class="si">{</span><span class="n">n_time_max_scale_factor</span><span class="si">}</span><span class="s2"> (PIPE-1000).&quot;</span><span class="p">)</span>
                            <span class="k">break</span>

                        <span class="c1"># If still iterating, re-select the remaining antennas</span>
                        <span class="c1"># for outlier timestamps.</span>
                        <span class="n">ant1_remaining</span> <span class="o">=</span> <span class="n">ant1_remaining</span><span class="p">[</span><span class="n">ants_to_keep</span><span class="p">]</span>
                        <span class="n">ant2_remaining</span> <span class="o">=</span> <span class="n">ant2_remaining</span><span class="p">[</span><span class="n">ants_to_keep</span><span class="p">]</span>

                    <span class="c1"># Identify number of unique outlier timestamps.</span>
                    <span class="n">time_sel_relaxsig</span> <span class="o">=</span> <span class="n">time_sel</span><span class="p">[</span><span class="n">id_relaxsig</span><span class="p">]</span>
                    <span class="n">time_sel_relaxsig_uniq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">time_sel_relaxsig</span><span class="p">)</span>

                    <span class="c1"># Set maximum threshold for outlier timestamps.</span>
                    <span class="c1"># Currently set equal to the threshold for high sigma</span>
                    <span class="c1"># outlier timestamps used in flagging heuristic, scaled by</span>
                    <span class="c1"># the scaling factor based on whether a small fraction of</span>
                    <span class="c1"># antennas are responsible for most outliers.</span>
                    <span class="n">n_time_with_relaxsig_max</span> <span class="o">=</span> <span class="n">n_time_with_highsig_max</span> <span class="o">*</span> <span class="n">n_time_max_scale_factor</span>

                    <span class="c1"># If the number of unique outlier timestamps exceeds the</span>
                    <span class="c1"># threshold, then relax the threshold scale factor.</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">time_sel_relaxsig_uniq</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">n_time_with_relaxsig_max</span><span class="p">:</span>
                        <span class="n">thresh_scale_factor</span> <span class="o">=</span> <span class="n">inputs</span><span class="o">.</span><span class="n">relaxed_factor</span>

            <span class="c1">#</span>
            <span class="c1"># Start with evaluation of flagging heuristics.</span>
            <span class="c1">#</span>

            <span class="c1">#</span>
            <span class="c1"># The following part considers timestamps separately, evaluating a</span>
            <span class="c1"># series of antenna-based heuristics to flag one or more antennas</span>
            <span class="c1"># within a timestamp or to flag an entire timestamp if necessary.</span>
            <span class="c1">#</span>
            <span class="c1"># If outliers are identified, but not flagged by the antenna-based</span>
            <span class="c1"># heuristics, then any existing ultra high outlier</span>
            <span class="c1"># baseline-timestamp combination will be flagged.</span>
            <span class="c1">#</span>

            <span class="c1"># Based on the input antenna based negative and positive sigma</span>
            <span class="c1"># outlier thresholds, identify outliers. If an antenna-based</span>
            <span class="c1"># bad integrations fraction was provided, then identify both</span>
            <span class="c1"># negative and positive outliers, otherwise just identify</span>
            <span class="c1"># negative outliers.</span>
            <span class="k">if</span> <span class="n">tmantint</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">id_highsig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span>
                        <span class="n">cmetric_sel</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">med</span> <span class="o">-</span> <span class="n">mad</span> <span class="o">*</span> <span class="n">inputs</span><span class="o">.</span><span class="n">antnegsig</span><span class="p">),</span>
                        <span class="n">cmetric_sel</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">med</span> <span class="o">+</span> <span class="n">mad</span> <span class="o">*</span> <span class="n">inputs</span><span class="o">.</span><span class="n">antpossig</span><span class="p">)))[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">id_highsig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                    <span class="n">cmetric_sel</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">med</span> <span class="o">-</span> <span class="n">mad</span> <span class="o">*</span> <span class="n">inputs</span><span class="o">.</span><span class="n">antnegsig</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># Based on the &quot;very high&quot; sigma outlier threshold, identify</span>
            <span class="c1"># both negative and positive outliers.</span>
            <span class="n">id_veryhighsig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span>
                    <span class="n">cmetric_sel</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">med</span> <span class="o">-</span> <span class="n">mad</span> <span class="o">*</span> <span class="n">antveryhighsig</span><span class="p">),</span>
                    <span class="n">cmetric_sel</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">med</span> <span class="o">+</span> <span class="n">mad</span> <span class="o">*</span> <span class="n">antveryhighsig</span><span class="p">)))[</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># Based on the &quot;ultra low/high&quot; sigma outlier thresholds, identify</span>
            <span class="c1"># both negative and positive outliers.</span>
            <span class="k">if</span> <span class="n">intent</span> <span class="o">==</span> <span class="s1">&#39;TARGET&#39;</span><span class="p">:</span>
                <span class="c1"># Identify UV bins.</span>
                <span class="n">uvdist</span> <span class="o">=</span> <span class="n">uvdist_all</span><span class="p">[</span><span class="n">id_nonac</span><span class="p">]</span>
                <span class="n">uvdist_sel</span> <span class="o">=</span> <span class="n">uvdist</span><span class="p">[</span><span class="n">id_nonbad</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">uvdist_sel</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">0</span><span class="p">,):</span>
                    <span class="k">continue</span>  <span class="c1"># go on to the next polarization</span>
                <span class="n">uvmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">uvdist_sel</span><span class="p">)</span>
                <span class="n">uvmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">uvdist_sel</span><span class="p">)</span>
                <span class="n">uvbins</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">uv1</span> <span class="o">=</span> <span class="n">uvmin</span>
                <span class="k">while</span> <span class="n">uv1</span> <span class="o">&lt;</span> <span class="n">uvmax</span><span class="p">:</span>
                    <span class="n">uv0</span> <span class="o">=</span> <span class="n">uv1</span>
                    <span class="n">uv1</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_uvbinFactor</span><span class="p">(</span><span class="n">uv0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">uvdist_sel</span><span class="p">))</span>
                    <span class="n">uvbins</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">uv0</span><span class="p">,</span> <span class="n">uv1</span><span class="p">])</span>
                <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">: Defined </span><span class="si">%d</span><span class="s1"> uvbins for field </span><span class="si">%s</span><span class="s1"> spw </span><span class="si">%d</span><span class="s1">: </span><span class="si">%s</span><span class="s1">&#39;</span>
                         <span class="s1">&#39;&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">ms</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">uvbins</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">field</span><span class="p">),</span> <span class="n">spwid</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">uvbins</span><span class="p">)))</span>

                <span class="c1"># Build another set of uvbins, shifted by 1/2 bin from the original set</span>
                <span class="c1"># Any visibilities in the first half of the original bin will be ignored by</span>
                <span class="c1"># the second set of bins, while the final bin will be half the width of the </span>
                <span class="c1"># original final bin.</span>
                <span class="n">uvbins2</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">uv1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">uvbins</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">while</span> <span class="n">uv1</span> <span class="o">&lt;</span> <span class="n">uvbins</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="n">uv0</span> <span class="o">=</span> <span class="n">uv1</span>
                    <span class="n">i</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">uvbins2</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">uvbins</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                        <span class="n">uv1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">uvbins</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">uvbins</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">uv1</span> <span class="o">=</span> <span class="n">uvbins</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">uvbins2</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">uv0</span><span class="p">,</span> <span class="n">uv1</span><span class="p">])</span>
                <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">: Defined </span><span class="si">%d</span><span class="s1"> offset uvbins for field </span><span class="si">%s</span><span class="s1"> spw </span><span class="si">%d</span><span class="s1">: </span><span class="si">%s</span><span class="s1">&#39;</span>
                         <span class="s1">&#39;&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">ms</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">uvbins</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">field</span><span class="p">),</span> <span class="n">spwid</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">uvbins2</span><span class="p">)))</span>
                <span class="n">uvbinsets</span> <span class="o">=</span> <span class="p">[</span><span class="n">uvbins</span><span class="p">,</span> <span class="n">uvbins2</span><span class="p">]</span>

                <span class="n">id_ultrahighsig_dict</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="p">[],</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[]}</span>

                <span class="c1"># Define minimum points for an accurate median/MAD. Note: a</span>
                <span class="c1"># single integration of a 7-antenna array would produce only 6</span>
                <span class="c1"># points per field.</span>
                <span class="n">minimumPoints</span> <span class="o">=</span> <span class="mi">22</span>
                <span class="c1"># Establish count to set the initial uvstart.</span>
                <span class="n">npts</span> <span class="o">=</span> <span class="n">minimumPoints</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="c1"># Iterate through set of UV bins.</span>
                <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">uvbins</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">uvbinsets</span><span class="p">):</span>
                    <span class="n">previousLength</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># only used for LOG message</span>
                    <span class="n">prior_uvstart</span> <span class="o">=</span> <span class="n">uvbins</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">uvbin</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">uvbins</span><span class="p">):</span>
                        <span class="c1"># Advance uvstart, but only if prior bin contained enough points to be evaluated.</span>
                        <span class="c1"># (This avoids leaving a small number of orphaned points unevaluated.)</span>
                        <span class="k">if</span> <span class="n">npts</span> <span class="o">&gt;=</span> <span class="n">minimumPoints</span><span class="p">:</span> 
                            <span class="n">uvstart</span> <span class="o">=</span> <span class="n">uvbin</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="n">id_uvbin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                            <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
                                <span class="n">uvdist_sel</span> <span class="o">&gt;=</span> <span class="n">uvstart</span><span class="p">,</span>
                                <span class="n">uvdist_sel</span> <span class="o">&lt;</span> <span class="n">uvbin</span><span class="p">[</span><span class="mi">1</span><span class="p">]))[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="n">npts</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">id_uvbin</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">npts</span> <span class="o">&lt;</span> <span class="n">minimumPoints</span> <span class="ow">and</span> <span class="n">u</span><span class="o">+</span><span class="mi">1</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">uvbins</span><span class="p">)</span> <span class="ow">and</span> <span class="n">u</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Final bin (</span><span class="si">%d</span><span class="s1">) has too few points (</span><span class="si">%d</span><span class="s1">), including them into prior successful bin&#39;</span>
                                     <span class="s1">&#39; with uvstart=</span><span class="si">%f</span><span class="s1">.&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">npts</span><span class="p">,</span> <span class="n">prior_uvstart</span><span class="p">))</span>
                            <span class="n">id_uvbin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                                <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
                                    <span class="n">uvdist_sel</span> <span class="o">&gt;=</span> <span class="n">prior_uvstart</span><span class="p">,</span>
                                    <span class="n">uvdist_sel</span> <span class="o">&lt;</span> <span class="n">uvbin</span><span class="p">[</span><span class="mi">1</span><span class="p">]))[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="n">npts</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">id_uvbin</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">npts</span> <span class="o">&lt;</span> <span class="n">minimumPoints</span><span class="p">:</span> 
                            <span class="c1"># If the logic is correct above, we should never arrive here while in the final bin, </span>
                            <span class="c1"># and thus we will never leave any data uninspected.</span>
                            <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;uvbin</span><span class="si">%d</span><span class="s1">) has too few points (</span><span class="si">%d</span><span class="s1">), including them into next bin.&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">npts</span><span class="p">))</span>
                            <span class="k">continue</span>

                        <span class="c1"># It is now safe to set prior_uvstart because this is a &quot;successful&quot; bin.</span>
                        <span class="n">prior_uvstart</span> <span class="o">=</span> <span class="n">uvstart</span>
                        <span class="n">maxInThisBin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">cmetric_sel</span><span class="p">[</span><span class="n">id_uvbin</span><span class="p">])</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">uvdist_sel</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1000</span><span class="p">:</span>
                            <span class="n">Q1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">cmetric_sel</span><span class="p">[</span><span class="n">id_uvbin</span><span class="p">],</span> <span class="mi">25</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s1">&#39;midpoint&#39;</span><span class="p">)</span>
                            <span class="n">Q3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">cmetric_sel</span><span class="p">[</span><span class="n">id_uvbin</span><span class="p">],</span> <span class="mi">75</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s1">&#39;midpoint&#39;</span><span class="p">)</span>
                            <span class="k">if</span> <span class="n">npts</span> <span class="o">&gt;=</span> <span class="mi">20</span><span class="p">:</span>
                                <span class="n">D1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">cmetric_sel</span><span class="p">[</span><span class="n">id_uvbin</span><span class="p">],</span> <span class="mi">10</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s1">&#39;midpoint&#39;</span><span class="p">)</span>
                                <span class="n">D9</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">cmetric_sel</span><span class="p">[</span><span class="n">id_uvbin</span><span class="p">],</span> <span class="mi">90</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s1">&#39;midpoint&#39;</span><span class="p">)</span>
                                <span class="n">IQR</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">Q3</span><span class="o">-</span><span class="n">Q1</span><span class="p">)</span>
                                <span class="n">IDR</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">D9</span><span class="o">-</span><span class="n">D1</span><span class="p">)</span><span class="o">/</span><span class="mf">1.9004</span>
                                <span class="n">mad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="n">IQR</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([</span><span class="mi">2</span><span class="o">*</span><span class="n">IQR</span><span class="p">,</span> <span class="n">IDR</span><span class="p">])])</span>
                                <span class="k">if</span> <span class="n">IQR</span> <span class="o">&gt;</span> <span class="n">IDR</span><span class="p">:</span>
                                    <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;uvbin</span><span class="si">%d</span><span class="s1">) using interquartile range </span><span class="si">%f</span><span class="s1">&gt;</span><span class="si">%f</span><span class="s1"> (npts=</span><span class="si">%d</span><span class="s1">, max=</span><span class="si">%f</span><span class="s1">)&#39;</span>
                                             <span class="s1">&#39;&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">IQR</span><span class="p">,</span> <span class="n">IDR</span><span class="p">,</span> <span class="n">npts</span><span class="p">,</span> <span class="n">maxInThisBin</span><span class="p">))</span>
                                <span class="k">else</span><span class="p">:</span>
                                    <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;uvbin</span><span class="si">%d</span><span class="s1">) using scaled interdecile range </span><span class="si">%f</span><span class="s1">&gt;</span><span class="si">%f</span><span class="s1"> (npts=</span><span class="si">%d</span><span class="s1">, max=</span><span class="si">%f</span><span class="s1">)&#39;</span>
                                             <span class="s1">&#39;&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">IDR</span><span class="p">,</span> <span class="n">IQR</span><span class="p">,</span> <span class="n">npts</span><span class="p">,</span> <span class="n">maxInThisBin</span><span class="p">))</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;uvbin</span><span class="si">%d</span><span class="s1">) using IQR npts=</span><span class="si">%d</span><span class="s1">&lt;20, max=</span><span class="si">%f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">npts</span><span class="p">,</span> <span class="n">maxInThisBin</span><span class="p">))</span>
                                <span class="c1"># use half the interquartile spread instead of MAD</span>
                                <span class="n">mad</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">Q3</span><span class="o">-</span><span class="n">Q1</span><span class="p">)</span>
                            <span class="c1"># use midpoint of interquartile spread (the &quot;midhinge&quot;) instead of median</span>
                            <span class="n">med</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">Q1</span><span class="p">,</span> <span class="n">Q3</span><span class="p">])</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;uvbin</span><span class="si">%d</span><span class="s1">) using median &amp; MAD (npts=</span><span class="si">%d</span><span class="s1">, max=</span><span class="si">%f</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">npts</span><span class="p">,</span> <span class="n">maxInThisBin</span><span class="p">))</span>
                            <span class="n">med</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">cmetric_sel</span><span class="p">[</span><span class="n">id_uvbin</span><span class="p">])</span>
                            <span class="n">bufferFactor</span> <span class="o">=</span> <span class="mi">2</span>
                            <span class="n">mad</span> <span class="o">=</span> <span class="n">bufferFactor</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">cmetric_sel</span><span class="p">[</span><span class="n">id_uvbin</span><span class="p">]</span> <span class="o">-</span> <span class="n">med</span><span class="p">))</span> <span class="o">*</span> <span class="mf">1.4826</span>
                            <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;uv</span><span class="si">%d</span><span class="s1">bin</span><span class="si">%d</span><span class="s1">) using median=</span><span class="si">%f</span><span class="s1"> &amp; </span><span class="si">%.2f</span><span class="s1">*MAD=</span><span class="si">%f</span><span class="s1"> (npts=</span><span class="si">%d</span><span class="s1">, maxInThisBin=</span><span class="si">%f</span><span class="s1">)&#39;</span>
                                     <span class="s1">&#39;&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">med</span><span class="p">,</span> <span class="n">bufferFactor</span><span class="p">,</span> <span class="n">mad</span><span class="p">,</span> <span class="n">npts</span><span class="p">,</span> <span class="n">maxInThisBin</span><span class="p">))</span>
                        <span class="k">if</span> <span class="n">tmantint</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">id_ultrahighsig_dict</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="n">id_uvbin</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                                <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span>
                                    <span class="n">cmetric_sel</span><span class="p">[</span><span class="n">id_uvbin</span><span class="p">]</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">med</span> <span class="o">-</span> <span class="n">mad</span> <span class="o">*</span> <span class="n">antultralowsig</span><span class="p">),</span>
                                    <span class="n">cmetric_sel</span><span class="p">[</span><span class="n">id_uvbin</span><span class="p">]</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">med</span> <span class="o">+</span> <span class="n">mad</span> <span class="o">*</span> <span class="n">antultrahighsig</span><span class="p">)))[</span><span class="mi">0</span><span class="p">]])</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">id_ultrahighsig_dict</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="n">id_uvbin</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                                <span class="n">cmetric_sel</span><span class="p">[</span><span class="n">id_uvbin</span><span class="p">]</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">med</span> <span class="o">-</span> <span class="n">mad</span> <span class="o">*</span> <span class="n">antultrahighsig</span><span class="p">))[</span><span class="mi">0</span><span class="p">]])</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">id_ultrahighsig_dict</span><span class="p">[</span><span class="n">v</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">previousLength</span><span class="p">:</span>
                            <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;spw </span><span class="si">%d</span><span class="s1">: Found </span><span class="si">%d</span><span class="s1"> outliers out of </span><span class="si">%d</span><span class="s1"> points in uvbin </span><span class="si">%d</span><span class="s1">&#39;</span>
                                     <span class="s1">&#39;&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">spwid</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">id_ultrahighsig_dict</span><span class="p">[</span><span class="n">v</span><span class="p">])</span><span class="o">-</span><span class="n">previousLength</span><span class="p">,</span> <span class="n">npts</span><span class="p">,</span> <span class="n">u</span><span class="p">))</span>
                        <span class="n">previousLength</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">id_ultrahighsig_dict</span><span class="p">[</span><span class="n">v</span><span class="p">])</span>
                    <span class="c1"># end loop over this uvbin set</span>
                <span class="c1"># end loop over uvbinsets</span>
                <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;spw </span><span class="si">%d</span><span class="s1">: found </span><span class="si">%d</span><span class="s1"> outliers in uvbinset0 and </span><span class="si">%d</span><span class="s1"> in uvbinset1&#39;</span>
                         <span class="s1">&#39;&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">spwid</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">id_ultrahighsig_dict</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">len</span><span class="p">(</span><span class="n">id_ultrahighsig_dict</span><span class="p">[</span><span class="mi">1</span><span class="p">])))</span>

                <span class="n">id_uvbin_firsthalf_firstbin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
                        <span class="n">uvdist_sel</span> <span class="o">&gt;=</span> <span class="n">uvbinsets</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>  <span class="c1"># start of first bin of first group</span>
                        <span class="n">uvdist_sel</span> <span class="o">&lt;</span> <span class="n">uvbinsets</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]))[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># start of first bin of second group</span>
                <span class="n">id_ultrahighsig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">id_ultrahighsig_dict</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">id_ultrahighsig_dict</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">firsthalf_firstbin_flags</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">id_ultrahighsig_dict</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">id_uvbin_firsthalf_firstbin</span><span class="p">)</span>
                <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;spw </span><span class="si">%d</span><span class="s1">: </span><span class="si">%d</span><span class="s1"> outliers are in common and will be flagged, along with </span><span class="si">%d</span><span class="s1"> outliers from the first&#39;</span>
                         <span class="s1">&#39; half of the first bin&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">spwid</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">id_ultrahighsig</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">firsthalf_firstbin_flags</span><span class="p">)))</span>
                <span class="n">id_ultrahighsig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">union1d</span><span class="p">(</span><span class="n">id_ultrahighsig</span><span class="p">,</span> <span class="n">firsthalf_firstbin_flags</span><span class="p">)</span>
                <span class="n">id_ultrahighsig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">id_ultrahighsig</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">id_ultrahighsig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span>
                        <span class="n">cmetric_sel</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">med</span> <span class="o">-</span> <span class="n">mad</span> <span class="o">*</span> <span class="n">antultralowsig</span><span class="p">),</span>
                        <span class="n">cmetric_sel</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">med</span> <span class="o">+</span> <span class="n">mad</span> <span class="o">*</span> <span class="n">antultrahighsig</span><span class="p">)))[</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># If outliers were found and checking for positive outliers...</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">id_highsig</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">tmantint</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># Check whether the outliers were concentrated in only one or a small</span>
                <span class="c1"># fraction (set by bad_int_frac) of timestamps.</span>

                <span class="c1"># Identify timestamps with outliers</span>
                <span class="n">time_sel_highsig</span> <span class="o">=</span> <span class="n">time_sel</span><span class="p">[</span><span class="n">id_highsig</span><span class="p">]</span>
                <span class="n">time_sel_highsig_uniq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">time_sel_highsig</span><span class="p">)</span>

                <span class="c1"># Identify timestamps with very high outliers.</span>
                <span class="n">time_sel_veryhighsig</span> <span class="o">=</span> <span class="n">time_sel</span><span class="p">[</span><span class="n">id_veryhighsig</span><span class="p">]</span>
                <span class="n">time_sel_veryhighsig_uniq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">time_sel_veryhighsig</span><span class="p">)</span>

                <span class="c1"># Set maximum threshold for &quot;very high&quot; outlier timestamps.</span>
                <span class="c1"># Currently set equal to the threshold for high sigma</span>
                <span class="c1"># outlier timestamps used in flagging heuristic.</span>
                <span class="n">n_time_with_veryhighsig_max</span> <span class="o">=</span> <span class="n">n_time_with_highsig_max</span>

                <span class="c1"># The antenna based heuristics shall be done for calibrators</span>
                <span class="c1"># only (PIPE-337).</span>
                <span class="k">if</span> <span class="n">intent</span> <span class="o">!=</span> <span class="s1">&#39;TARGET&#39;</span><span class="p">:</span>
                    <span class="c1"># If all outliers were concentrated within a small number of</span>
                    <span class="c1"># timestamps set by a threshold, then evaluate the antenna</span>
                    <span class="c1"># based heuristics for those timestamps.</span>
                    <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">time_sel_highsig_uniq</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">n_time_with_highsig_max</span><span class="p">:</span>
                        <span class="n">new_antbased_flags</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_evaluate_antbased_heuristics</span><span class="p">(</span>
                            <span class="n">ms</span><span class="p">,</span> <span class="n">spwid</span><span class="p">,</span> <span class="n">intent</span><span class="p">,</span> <span class="n">icorr</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span>
                            <span class="n">ants_in_outlier_baseline_scans_thresh</span><span class="p">,</span>
                            <span class="n">ants_in_outlier_baseline_scans_partial_thresh</span><span class="p">,</span>
                            <span class="n">max_frac_outlier_scans</span><span class="p">,</span>
                            <span class="n">antenna_id_to_name</span><span class="p">,</span> <span class="n">ant1_sel</span><span class="p">,</span> <span class="n">ant2_sel</span><span class="p">,</span> <span class="n">nants</span><span class="p">,</span>
                            <span class="n">id_highsig</span><span class="p">,</span> <span class="n">time_sel_highsig</span><span class="p">,</span> <span class="n">time_sel_highsig_uniq</span><span class="p">)</span>
                        <span class="n">newflags</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">new_antbased_flags</span><span class="p">)</span>
                    <span class="c1"># If all very high outliers were concentrated within a small</span>
                    <span class="c1"># number of timestamps set by a threshold, then evaluate the</span>
                    <span class="c1"># antenna based heuristics for those timestamps.</span>
                    <span class="k">elif</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">time_sel_veryhighsig_uniq</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">n_time_with_veryhighsig_max</span><span class="p">:</span>
                        <span class="n">new_antbased_flags</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_evaluate_antbased_heuristics</span><span class="p">(</span>
                            <span class="n">ms</span><span class="p">,</span> <span class="n">spwid</span><span class="p">,</span> <span class="n">intent</span><span class="p">,</span> <span class="n">icorr</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span>
                            <span class="n">ants_in_outlier_baseline_scans_thresh</span><span class="p">,</span>
                            <span class="n">ants_in_outlier_baseline_scans_partial_thresh</span><span class="p">,</span>
                            <span class="n">max_frac_outlier_scans</span><span class="p">,</span>
                            <span class="n">antenna_id_to_name</span><span class="p">,</span> <span class="n">ant1_sel</span><span class="p">,</span> <span class="n">ant2_sel</span><span class="p">,</span> <span class="n">nants</span><span class="p">,</span>
                            <span class="n">id_veryhighsig</span><span class="p">,</span> <span class="n">time_sel_veryhighsig</span><span class="p">,</span> <span class="n">time_sel_veryhighsig_uniq</span><span class="p">)</span>
                        <span class="n">newflags</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">new_antbased_flags</span><span class="p">)</span>

            <span class="c1"># Flag any ultra high outliers for corresponding baseline/timestamp.</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">id_ultrahighsig</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">bad_timestamps</span> <span class="o">=</span> <span class="n">time_sel</span><span class="p">[</span><span class="n">id_ultrahighsig</span><span class="p">]</span>
                <span class="n">bad_bls</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">ant1_sel</span><span class="p">[</span><span class="n">id_ultrahighsig</span><span class="p">],</span> <span class="n">ant2_sel</span><span class="p">[</span><span class="n">id_ultrahighsig</span><span class="p">]))</span>
                <span class="n">newflags</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_create_flags_for_ultrahigh_baselines_timestamps</span><span class="p">(</span>
                        <span class="n">ms</span><span class="p">,</span> <span class="n">spwid</span><span class="p">,</span> <span class="n">intent</span><span class="p">,</span> <span class="n">icorr</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">bad_timestamps</span><span class="p">,</span> <span class="n">bad_bls</span><span class="p">,</span> <span class="n">antenna_id_to_name</span><span class="p">))</span>

            <span class="c1">#</span>
            <span class="c1"># The following part considers all timestamps at once, and</span>
            <span class="c1"># identifies &quot;bad baselines&quot; as the baselines that contain outliers</span>
            <span class="c1"># in a number of timestamps that exceeds the maximum threshold (set</span>
            <span class="c1"># by scale factor). For each of these &quot;bad&quot; baselines, it then:</span>
            <span class="c1">#</span>
            <span class="c1">#  a.) identifies &quot;bad antennas&quot; as those antennas that are</span>
            <span class="c1">#  part of a number of &quot;bad baselines&quot; that exceeds a</span>
            <span class="c1">#  maximum threshold. Each of these &quot;bad antennas&quot; are</span>
            <span class="c1">#  entirely flagged for all timestamps.</span>
            <span class="c1">#</span>
            <span class="c1">#  b.) identifies remaining &quot;bad baselines&quot; as those that</span>
            <span class="c1">#  do not contain one of the &quot;bad antennas&quot;, but that do</span>
            <span class="c1">#  contain outliers in a number of timestamps that exceeds</span>
            <span class="c1">#  the maximum threshold set by the relaxed scale factor.</span>
            <span class="c1">#  Each of these baselines are flagged for all timestamps.</span>
            <span class="c1">#</span>
            <span class="c1"># This heuristic shall be done for calibrators only (PIPE-337).</span>
            <span class="k">if</span> <span class="n">intent</span> <span class="o">!=</span> <span class="s1">&#39;TARGET&#39;</span><span class="p">:</span>
                <span class="c1"># If requested, identify both positive and negative</span>
                <span class="c1"># outliers, otherwise just identify positive outliers; also</span>
                <span class="c1"># select for non-flagged and non-NaN data.</span>
                <span class="k">if</span> <span class="n">inputs</span><span class="o">.</span><span class="n">antblnegsig</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">id_flagsig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">flag</span><span class="p">),</span>
                                <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">cmetric</span><span class="p">),</span>
                                <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span>
                                    <span class="n">cmetric</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">med</span> <span class="o">-</span> <span class="n">mad</span> <span class="o">*</span> <span class="n">inputs</span><span class="o">.</span><span class="n">antblnegsig</span><span class="p">),</span>
                                    <span class="n">cmetric</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">med</span> <span class="o">+</span> <span class="n">mad</span> <span class="o">*</span> <span class="n">inputs</span><span class="o">.</span><span class="n">antblpossig</span><span class="p">))),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">id_flagsig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">flag</span><span class="p">),</span>
                                <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">cmetric</span><span class="p">),</span>
                                <span class="n">cmetric</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">med</span> <span class="o">+</span> <span class="n">mad</span> <span class="o">*</span> <span class="n">inputs</span><span class="o">.</span><span class="n">antblpossig</span><span class="p">)),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>

                <span class="c1"># Proceed if outliers were found...</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">id_flagsig</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># Identify baselines involved in each baseline/timestamp</span>
                    <span class="c1"># outlier; this list may contain multiples of the same</span>
                    <span class="c1"># baseline when it was an outlier in more than one</span>
                    <span class="c1"># timestamp.</span>
                    <span class="n">outlier_ant1</span> <span class="o">=</span> <span class="n">ant1</span><span class="p">[</span><span class="n">id_flagsig</span><span class="p">]</span>
                    <span class="n">outlier_ant2</span> <span class="o">=</span> <span class="n">ant2</span><span class="p">[</span><span class="n">id_flagsig</span><span class="p">]</span>
                    <span class="n">outlier_bl</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">outlier_ant1</span><span class="p">,</span> <span class="n">outlier_ant2</span><span class="p">))</span>

                    <span class="c1"># Compute for each baseline how many outlier timestamps</span>
                    <span class="c1"># it is a part of. This creates a dictionary with</span>
                    <span class="c1"># baselines as keys, and number of outlier timestamps</span>
                    <span class="c1"># as values.</span>
                    <span class="n">outlier_bl_counts</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">Counter</span><span class="p">(</span><span class="n">outlier_bl</span><span class="p">)</span>

                    <span class="c1"># Compute for each baseline how many timestamps</span>
                    <span class="c1"># it is a part of. This creates a dictionary with</span>
                    <span class="c1"># baselines as keys, and number of timestamps</span>
                    <span class="c1"># as values.</span>
                    <span class="n">baselines</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">ant1</span><span class="p">,</span> <span class="n">ant2</span><span class="p">))</span>
                    <span class="n">bl_counts</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">Counter</span><span class="p">(</span><span class="n">baselines</span><span class="p">)</span>

                    <span class="c1"># Compute final threshold for maximum fraction of &quot;outlier</span>
                    <span class="c1"># timestamps&quot; over &quot;total timestamps&quot; that a baseline can</span>
                    <span class="c1"># be a part of. Scale up the threshold for multi-scan</span>
                    <span class="c1"># observations.</span>
                    <span class="n">tmint_scaled</span> <span class="o">=</span> <span class="n">inputs</span><span class="o">.</span><span class="n">tmint</span> <span class="o">*</span> <span class="n">thresh_scale_factor</span>
                    <span class="k">if</span> <span class="n">nscans</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">icorr</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">tmint_scaled</span> <span class="o">=</span> <span class="n">tmint_scaled</span> <span class="o">*</span> <span class="mi">2</span><span class="o">**</span><span class="mf">0.5</span>
                        <span class="k">else</span><span class="p">:</span> <span class="c1"># increase the threshold for cross-polar visibilities, which can show an offset in scans taken near transit</span>
                            <span class="n">tmint_scaled</span> <span class="o">=</span> <span class="n">tmint_scaled</span> <span class="o">*</span> <span class="mi">3</span>

                    <span class="c1"># Identify &quot;bad baselines&quot; as those baselines whose number</span>
                    <span class="c1"># of timestamps with outliers exceeds the threshold.</span>
                    <span class="n">bad_bls</span> <span class="o">=</span> <span class="p">[</span><span class="n">bl</span> <span class="k">for</span> <span class="n">bl</span><span class="p">,</span> <span class="n">count</span> <span class="ow">in</span> <span class="n">outlier_bl_counts</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                               <span class="k">if</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="n">bl_counts</span><span class="p">[</span><span class="n">bl</span><span class="p">]</span> <span class="o">*</span> <span class="n">tmint_scaled</span><span class="p">])]</span>

                    <span class="c1"># Compute for each antenna how many &quot;bad baselines&quot; it is</span>
                    <span class="c1"># a part of.</span>
                    <span class="n">ant_in_bad_bl_count</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">bad_bls</span><span class="p">,</span> <span class="p">()),</span>
                                                      <span class="n">minlength</span><span class="o">=</span><span class="n">nants</span><span class="p">)</span>

                    <span class="c1"># Compute final threshold for maximum number of &quot;bad</span>
                    <span class="c1"># baselines&quot; that an antenna may be a part of:</span>
                    <span class="c1"># this is based on the scaled fractional threshold</span>
                    <span class="c1"># times the number of baselines that the antenna is</span>
                    <span class="c1"># part of, with a minimum number threshold set by</span>
                    <span class="c1"># &quot;tmbl_minbadnr&quot;.</span>
                    <span class="n">tmbl_nr_thresh</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span>
                        <span class="n">tmbl_minbadnr</span><span class="p">,</span>
                        <span class="n">inputs</span><span class="o">.</span><span class="n">tmbl</span> <span class="o">*</span> <span class="n">thresh_scale_factor</span> <span class="o">*</span> <span class="p">(</span><span class="n">nants</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>

                    <span class="c1"># Identify &quot;bad antennas&quot; as those antennas involved in a number of</span>
                    <span class="c1"># &quot;bad baselines&quot; that exceeds the threshold.</span>
                    <span class="n">bad_ants</span> <span class="o">=</span> <span class="p">[</span><span class="n">ant</span> <span class="k">for</span> <span class="n">ant</span><span class="p">,</span> <span class="n">count</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ant_in_bad_bl_count</span><span class="p">)</span>
                                <span class="k">if</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="n">tmbl_nr_thresh</span><span class="p">]</span>

                    <span class="c1"># Create flagging command for each identified bad antenna.</span>
                    <span class="k">for</span> <span class="n">bad_ant</span> <span class="ow">in</span> <span class="n">bad_ants</span><span class="p">:</span>
                        <span class="n">newflags</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                            <span class="n">FlagCmd</span><span class="p">(</span>
                                <span class="n">filename</span><span class="o">=</span><span class="n">ms</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                                <span class="n">spw</span><span class="o">=</span><span class="n">spwid</span><span class="p">,</span>
                                <span class="n">antenna</span><span class="o">=</span><span class="n">bad_ant</span><span class="p">,</span>
                                <span class="n">intent</span><span class="o">=</span><span class="n">utils</span><span class="o">.</span><span class="n">to_CASA_intent</span><span class="p">(</span><span class="n">ms</span><span class="p">,</span> <span class="n">intent</span><span class="p">),</span>
                                <span class="n">pol</span><span class="o">=</span><span class="n">icorr</span><span class="p">,</span>
                                <span class="n">field</span><span class="o">=</span><span class="n">field</span><span class="p">,</span>
                                <span class="n">reason</span><span class="o">=</span><span class="s1">&#39;bad antenna&#39;</span><span class="p">,</span>
                                <span class="n">antenna_id_to_name</span><span class="o">=</span><span class="n">antenna_id_to_name</span><span class="p">))</span>

                    <span class="c1"># Compute final outlier timestamps per baseline threshold,</span>
                    <span class="c1"># forcibly always using the relaxed threshold scale factor,</span>
                    <span class="c1"># and setting the minimum fraction to 1, such that a</span>
                    <span class="c1"># baseline with 100% outlier timestamps will get flagged</span>
                    <span class="c1"># (even if dynamic threshold exceeded beyond 1.0).</span>
                    <span class="n">tmint_relaxed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span>
                        <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span>
                         <span class="n">inputs</span><span class="o">.</span><span class="n">tmint</span> <span class="o">*</span> <span class="n">inputs</span><span class="o">.</span><span class="n">relaxed_factor</span><span class="p">])</span>

                    <span class="c1"># Compute fraction of outlier timestamps for each bad baseline.</span>
                    <span class="n">bad_bls_timestamp_fraction</span> <span class="o">=</span> <span class="p">{</span>
                        <span class="n">bl</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">outlier_bl_counts</span><span class="p">[</span><span class="n">bl</span><span class="p">])</span> <span class="o">/</span> <span class="n">bl_counts</span><span class="p">[</span><span class="n">bl</span><span class="p">]</span>
                        <span class="k">for</span> <span class="n">bl</span> <span class="ow">in</span> <span class="n">bad_bls</span><span class="p">}</span>

                    <span class="c1"># For each bad baseline, check if it was already covered by</span>
                    <span class="c1"># one of the bad antennas, and otherwise flag it explicitly</span>
                    <span class="c1"># if the fraction of outlier timestamps for this baseline</span>
                    <span class="c1"># equals-or-exceeds the threshold.</span>
                    <span class="k">for</span> <span class="n">bl</span> <span class="ow">in</span> <span class="n">bad_bls</span><span class="p">:</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">bl</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">bad_ants</span>
                                <span class="ow">and</span> <span class="n">bl</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">bad_ants</span>
                                <span class="ow">and</span> <span class="n">bad_bls_timestamp_fraction</span><span class="p">[</span><span class="n">bl</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">tmint_relaxed</span><span class="p">):</span>
                            <span class="n">newflags</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                <span class="n">FlagCmd</span><span class="p">(</span>
                                    <span class="n">filename</span><span class="o">=</span><span class="n">ms</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                                    <span class="n">spw</span><span class="o">=</span><span class="n">spwid</span><span class="p">,</span>
                                    <span class="n">antenna</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">&amp;</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">bl</span><span class="p">,</span>
                                    <span class="n">intent</span><span class="o">=</span><span class="n">utils</span><span class="o">.</span><span class="n">to_CASA_intent</span><span class="p">(</span><span class="n">ms</span><span class="p">,</span> <span class="n">intent</span><span class="p">),</span>
                                    <span class="n">pol</span><span class="o">=</span><span class="n">icorr</span><span class="p">,</span>
                                    <span class="n">field</span><span class="o">=</span><span class="n">field</span><span class="p">,</span>
                                    <span class="n">reason</span><span class="o">=</span><span class="s1">&#39;bad baseline&#39;</span><span class="p">,</span>
                                    <span class="n">antenna_id_to_name</span><span class="o">=</span><span class="n">antenna_id_to_name</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">newflags</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_create_flags_for_ultrahigh_baselines_timestamps</span><span class="p">(</span><span class="n">ms</span><span class="p">:</span> <span class="n">MeasurementSet</span><span class="p">,</span> <span class="n">spwid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">intent</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">icorr</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                                                         <span class="n">field</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">timestamps</span><span class="p">:</span> <span class="n">List</span><span class="p">,</span> <span class="n">baselines</span><span class="p">:</span> <span class="n">List</span><span class="p">,</span>
                                                         <span class="n">antenna_id_to_name</span><span class="p">:</span> <span class="n">Dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">FlagCmd</span><span class="p">]:</span>
        <span class="n">newflags</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">baselines</span><span class="p">)):</span>
            <span class="n">newflags</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">FlagCmd</span><span class="p">(</span>
                    <span class="n">filename</span><span class="o">=</span><span class="n">ms</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                    <span class="n">spw</span><span class="o">=</span><span class="n">spwid</span><span class="p">,</span>
                    <span class="n">antenna</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">&amp;</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">baselines</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span>
                    <span class="n">intent</span><span class="o">=</span><span class="n">utils</span><span class="o">.</span><span class="n">to_CASA_intent</span><span class="p">(</span><span class="n">ms</span><span class="p">,</span> <span class="n">intent</span><span class="p">),</span>
                    <span class="n">pol</span><span class="o">=</span><span class="n">icorr</span><span class="p">,</span>
                    <span class="n">time</span><span class="o">=</span><span class="n">timestamps</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span>
                    <span class="n">field</span><span class="o">=</span><span class="n">field</span><span class="p">,</span>
                    <span class="n">reason</span><span class="o">=</span><span class="s1">&#39;ultrahigh baseline timestamp&#39;</span><span class="p">,</span>
                    <span class="n">antenna_id_to_name</span><span class="o">=</span><span class="n">antenna_id_to_name</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">newflags</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_evaluate_antbased_heuristics</span><span class="p">(</span><span class="n">ms</span><span class="p">:</span> <span class="n">MeasurementSet</span><span class="p">,</span> <span class="n">spwid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">intent</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">icorr</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">field</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                                      <span class="n">ants_in_outlier_baseline_scans_thresh</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
                                      <span class="n">ants_in_outlier_baseline_scans_partial_thresh</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
                                      <span class="n">max_frac_outlier_scans</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">antenna_id_to_name</span><span class="p">:</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">ant1_sel</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">,</span>
                                      <span class="n">ant2_sel</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">,</span> <span class="n">nants</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">id_highsig</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">,</span> <span class="n">time_sel_highsig</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">,</span>
                                      <span class="n">time_sel_highsig_uniq</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">FlagCmd</span><span class="p">]:</span>

        <span class="c1"># Initialize flags.</span>
        <span class="n">newflags</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># For each of the few bad timestamps...</span>
        <span class="k">for</span> <span class="n">timestamp</span> <span class="ow">in</span> <span class="n">time_sel_highsig_uniq</span><span class="p">:</span>

            <span class="c1"># Identify baseline scans within this timestamp.</span>
            <span class="n">id_outlier_scans_in_timestamp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                <span class="n">time_sel_highsig</span> <span class="o">==</span> <span class="n">timestamp</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">n_outlier_scans_in_timestamp</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">id_outlier_scans_in_timestamp</span><span class="p">)</span>

            <span class="c1"># Get a list of antennas involved in outlier scans</span>
            <span class="c1"># matching the timestamp.</span>
            <span class="n">ants_in_olscans_in_tstamp</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                <span class="p">[</span><span class="n">ant1_sel</span><span class="p">[</span><span class="n">id_highsig</span><span class="p">][</span><span class="n">id_outlier_scans_in_timestamp</span><span class="p">],</span>
                 <span class="n">ant2_sel</span><span class="p">[</span><span class="n">id_highsig</span><span class="p">][</span><span class="n">id_outlier_scans_in_timestamp</span><span class="p">]]))</span>

            <span class="c1"># Identify number of outlier scans within current</span>
            <span class="c1"># timestamp that each antenna is involved in.</span>
            <span class="n">antcnts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">ants_in_olscans_in_tstamp</span><span class="p">,</span> <span class="n">minlength</span><span class="o">=</span><span class="n">nants</span><span class="p">)</span>

            <span class="c1"># Identify the ants involved in the largest number</span>
            <span class="c1"># of outliers as well as 1 count less (while ignoring</span>
            <span class="c1"># ants involved in 0 outliers).</span>
            <span class="n">id_affected_ants</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">antcnts</span> <span class="o">&gt;=</span> <span class="nb">max</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="n">antcnts</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]))[</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># Identify the ants that are at least partially affected,</span>
            <span class="c1"># by being involved in at least one outlier, but excluding</span>
            <span class="c1"># antennas already identified as &quot;affected&quot;.</span>
            <span class="n">id_partly_affected_ants</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">antcnts</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span>
                <span class="n">id_affected_ants</span><span class="p">)</span>

            <span class="c1"># If the number of affected antennas is a significant fraction of</span>
            <span class="c1"># all antennas, then flag the entire timestamp.</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">id_affected_ants</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">ants_in_outlier_baseline_scans_thresh</span> <span class="o">*</span> <span class="n">nants</span><span class="p">:</span>
                <span class="c1"># Create a flagging command for all antennas</span>
                <span class="c1"># in this timestamp (for given spw, intent, pol).</span>
                <span class="n">newflags</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">FlagCmd</span><span class="p">(</span>
                        <span class="n">filename</span><span class="o">=</span><span class="n">ms</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                        <span class="n">spw</span><span class="o">=</span><span class="n">spwid</span><span class="p">,</span>
                        <span class="n">intent</span><span class="o">=</span><span class="n">utils</span><span class="o">.</span><span class="n">to_CASA_intent</span><span class="p">(</span><span class="n">ms</span><span class="p">,</span> <span class="n">intent</span><span class="p">),</span>
                        <span class="n">pol</span><span class="o">=</span><span class="n">icorr</span><span class="p">,</span>
                        <span class="n">time</span><span class="o">=</span><span class="n">timestamp</span><span class="p">,</span>
                        <span class="n">field</span><span class="o">=</span><span class="n">field</span><span class="p">,</span>
                        <span class="n">reason</span><span class="o">=</span><span class="s1">&#39;bad timestamp&#39;</span><span class="p">))</span>
            <span class="c1"># Evaluate a slightly more restrictive threshold, this time</span>
            <span class="c1"># on the total number of affected and partly affected antennas,</span>
            <span class="c1"># while still requiring half the original threshold.</span>
            <span class="k">elif</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">id_affected_ants</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">ants_in_outlier_baseline_scans_thresh</span> <span class="o">*</span> <span class="n">nants</span>
                    <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">id_affected_ants</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">id_partly_affected_ants</span><span class="p">)</span> <span class="o">&gt;</span>
                    <span class="n">ants_in_outlier_baseline_scans_partial_thresh</span> <span class="o">*</span> <span class="n">nants</span><span class="p">):</span>

                <span class="c1"># Create a flagging command for all antennas</span>
                <span class="c1"># in this timestamp (for given spw, intent, pol).</span>
                <span class="n">newflags</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">FlagCmd</span><span class="p">(</span>
                        <span class="n">filename</span><span class="o">=</span><span class="n">ms</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                        <span class="n">spw</span><span class="o">=</span><span class="n">spwid</span><span class="p">,</span>
                        <span class="n">intent</span><span class="o">=</span><span class="n">utils</span><span class="o">.</span><span class="n">to_CASA_intent</span><span class="p">(</span><span class="n">ms</span><span class="p">,</span> <span class="n">intent</span><span class="p">),</span>
                        <span class="n">pol</span><span class="o">=</span><span class="n">icorr</span><span class="p">,</span>
                        <span class="n">time</span><span class="o">=</span><span class="n">timestamp</span><span class="p">,</span>
                        <span class="n">field</span><span class="o">=</span><span class="n">field</span><span class="p">,</span>
                        <span class="n">reason</span><span class="o">=</span><span class="s1">&#39;bad timestamp&#39;</span><span class="p">))</span>
            <span class="c1"># If there was no significant fraction of affected antennas,</span>
            <span class="c1"># then proceed to check if the antenna(s) with the highest number</span>
            <span class="c1"># of outlier scans (within this timestamp) equals-or-exceeds the</span>
            <span class="c1"># threshold and flag the corresponding antenna(s).</span>
            <span class="k">elif</span> <span class="p">(</span><span class="n">antcnts</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="n">max_frac_outlier_scans</span> <span class="o">*</span> <span class="n">n_outlier_scans_in_timestamp</span>
                    <span class="ow">and</span> <span class="n">n_outlier_scans_in_timestamp</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">):</span>

                <span class="c1"># Identify which antennas matched the highest counts,</span>
                <span class="c1"># and create a flagging command for each.</span>
                <span class="n">id_ants_highest_cnts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">antcnts</span> <span class="o">==</span> <span class="n">antcnts</span><span class="o">.</span><span class="n">max</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">ant</span> <span class="ow">in</span> <span class="n">id_ants_highest_cnts</span><span class="p">:</span>
                    <span class="c1"># Create a flagging command for this antenna</span>
                    <span class="n">newflags</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="n">FlagCmd</span><span class="p">(</span>
                            <span class="n">filename</span><span class="o">=</span><span class="n">ms</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                            <span class="n">spw</span><span class="o">=</span><span class="n">spwid</span><span class="p">,</span>
                            <span class="n">antenna</span><span class="o">=</span><span class="n">ant</span><span class="p">,</span>
                            <span class="n">intent</span><span class="o">=</span><span class="n">utils</span><span class="o">.</span><span class="n">to_CASA_intent</span><span class="p">(</span><span class="n">ms</span><span class="p">,</span> <span class="n">intent</span><span class="p">),</span>
                            <span class="n">pol</span><span class="o">=</span><span class="n">icorr</span><span class="p">,</span>
                            <span class="n">time</span><span class="o">=</span><span class="n">timestamp</span><span class="p">,</span>
                            <span class="n">field</span><span class="o">=</span><span class="n">field</span><span class="p">,</span>
                            <span class="n">reason</span><span class="o">=</span><span class="s1">&#39;bad antenna timestamp&#39;</span><span class="p">,</span>
                            <span class="n">antenna_id_to_name</span><span class="o">=</span><span class="n">antenna_id_to_name</span><span class="p">))</span>
            <span class="c1"># Heuristic for catching cross-CAI-dependent issues:</span>
            <span class="c1"># If there are affected antennas, and total number of affected</span>
            <span class="c1"># and partially affected antennas exceeds the larger of 6 or</span>
            <span class="c1"># 20% of the antennas, then flag the timestamp. The minimum</span>
            <span class="c1"># threshold of 6 is there to prevent over-application on ACA 7m</span>
            <span class="c1"># datasets.</span>
            <span class="k">elif</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">id_affected_ants</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">id_partly_affected_ants</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="mi">6</span><span class="p">,</span> <span class="mf">0.2</span> <span class="o">*</span> <span class="n">nants</span><span class="p">])</span>
                    <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">id_affected_ants</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>

                <span class="c1"># Create flags only for the &quot;affected&quot; antennas for this timestamp</span>
                <span class="c1"># because CAI-dependent issues do not affect all antennas.</span>
                <span class="k">for</span> <span class="n">ant</span> <span class="ow">in</span> <span class="n">id_affected_ants</span><span class="p">:</span>
                    <span class="c1"># Create a flagging command for this antenna.</span>
                    <span class="n">newflags</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="n">FlagCmd</span><span class="p">(</span>
                            <span class="n">filename</span><span class="o">=</span><span class="n">ms</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                            <span class="n">spw</span><span class="o">=</span><span class="n">spwid</span><span class="p">,</span>
                            <span class="n">antenna</span><span class="o">=</span><span class="n">ant</span><span class="p">,</span>
                            <span class="n">intent</span><span class="o">=</span><span class="n">utils</span><span class="o">.</span><span class="n">to_CASA_intent</span><span class="p">(</span><span class="n">ms</span><span class="p">,</span> <span class="n">intent</span><span class="p">),</span>
                            <span class="n">pol</span><span class="o">=</span><span class="n">icorr</span><span class="p">,</span>
                            <span class="n">time</span><span class="o">=</span><span class="n">timestamp</span><span class="p">,</span>
                            <span class="n">field</span><span class="o">=</span><span class="n">field</span><span class="p">,</span>
                            <span class="n">reason</span><span class="o">=</span><span class="s1">&#39;bad CAI-dependent data&#39;</span><span class="p">,</span>
                            <span class="n">antenna_id_to_name</span><span class="o">=</span><span class="n">antenna_id_to_name</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">newflags</span>

    <span class="k">def</span> <span class="nf">_apply_flags</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flags</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">FlagCmd</span><span class="p">],</span> <span class="n">sum_before</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">sum_after</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> \
            <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Dict</span><span class="p">,</span> <span class="n">Dict</span><span class="p">]:</span>

        <span class="n">inputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span>

        <span class="c1"># Initialize flagging summaries.</span>
        <span class="n">stats_before</span><span class="p">,</span> <span class="n">stats_after</span> <span class="o">=</span> <span class="p">{},</span> <span class="p">{}</span>

        <span class="c1"># Initialize list of flagdata commands.</span>
        <span class="n">allflagcmds</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># If requested, add the &quot;before&quot; summary.</span>
        <span class="k">if</span> <span class="n">sum_before</span><span class="p">:</span>
            <span class="n">allflagcmds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;mode=&#39;summary&#39; name=&#39;before&#39;&quot;</span><span class="p">)</span>

        <span class="c1"># If new flags were found, apply these as part of the flagdata call,</span>
        <span class="c1"># and add an &quot;after&quot; summary if requested.</span>
        <span class="k">if</span> <span class="n">flags</span><span class="p">:</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Applying newly found flags.&#39;</span><span class="p">)</span>
            <span class="n">allflagcmds</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">flags</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">sum_after</span><span class="p">:</span>
                <span class="n">allflagcmds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;mode=&#39;summary&#39; name=&#39;after&#39;&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># If an &quot;after&quot; summary is requested, but no &quot;before&quot; summary,</span>
            <span class="c1"># then run &quot;after&quot; summary explicitly.</span>
            <span class="k">if</span> <span class="n">sum_after</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">sum_before</span><span class="p">:</span>
                <span class="n">allflagcmds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;mode=&#39;summary&#39; name=&#39;after&#39;&quot;</span><span class="p">)</span>

        <span class="c1"># Run flagdata to create summaries and set flags.</span>
        <span class="n">fsinputs</span> <span class="o">=</span> <span class="n">FlagdataSetter</span><span class="o">.</span><span class="n">Inputs</span><span class="p">(</span>
            <span class="n">context</span><span class="o">=</span><span class="n">inputs</span><span class="o">.</span><span class="n">context</span><span class="p">,</span> <span class="n">vis</span><span class="o">=</span><span class="n">inputs</span><span class="o">.</span><span class="n">vis</span><span class="p">,</span> <span class="n">table</span><span class="o">=</span><span class="n">inputs</span><span class="o">.</span><span class="n">vis</span><span class="p">,</span>
            <span class="n">inpfile</span><span class="o">=</span><span class="p">[])</span>
        <span class="n">fstask</span> <span class="o">=</span> <span class="n">FlagdataSetter</span><span class="p">(</span><span class="n">fsinputs</span><span class="p">)</span>
        <span class="n">fstask</span><span class="o">.</span><span class="n">flags_to_set</span><span class="p">(</span><span class="n">allflagcmds</span><span class="p">)</span>
        <span class="n">fsresult</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_executor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">fstask</span><span class="p">)</span>

        <span class="c1"># Extract &quot;before&quot; and/or &quot;after&quot; summary</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">([</span><span class="s1">&#39;report&#39;</span> <span class="ow">in</span> <span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">fsresult</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">]]):</span>
            <span class="c1"># Go through dictionary of reports...</span>
            <span class="k">for</span> <span class="n">report</span> <span class="ow">in</span> <span class="n">fsresult</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">fsresult</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">report</span><span class="p">][</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;before&#39;</span><span class="p">:</span>
                    <span class="n">stats_before</span> <span class="o">=</span> <span class="n">fsresult</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">report</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">fsresult</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">report</span><span class="p">][</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;after&#39;</span><span class="p">:</span>
                    <span class="n">stats_after</span> <span class="o">=</span> <span class="n">fsresult</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">report</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Go through single report.</span>
            <span class="k">if</span> <span class="n">fsresult</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;before&#39;</span><span class="p">:</span>
                <span class="n">stats_before</span> <span class="o">=</span> <span class="n">fsresult</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">fsresult</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;after&#39;</span><span class="p">:</span>
                <span class="n">stats_after</span> <span class="o">=</span> <span class="n">fsresult</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># If no new flags were supplied, and both a &quot;before&quot; and &quot;after&quot;</span>
        <span class="c1"># summary was requested, then create a copy of the &quot;before&quot; summary.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">flags</span> <span class="ow">and</span> <span class="n">sum_before</span> <span class="ow">and</span> <span class="n">sum_after</span><span class="p">:</span>
            <span class="n">stats_after</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">stats_before</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">stats_before</span><span class="p">,</span> <span class="n">stats_after</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020–2024, Pipeline Dev. Team.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>