

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>pipeline.infrastructure.vdp &mdash; Pipeline unknown documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css?v=4ae1632d" />
      <link rel="stylesheet" type="text/css" href="../../../_static/custom_theme.css?v=678032d9" />

  
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=3f1b9271"></script>
      <script src="../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            Pipeline
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Pipeline Tasks</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../pipeline_tasks/pipeline_tasks.html">Pipeline Heuristics Tasks</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Pipeline Task (sphinx-autosummary)</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../_autosummary/pipeline.h.cli.html">pipeline.h.cli</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../_autosummary/pipeline.hif.cli.html">pipeline.hif.cli</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../_autosummary/pipeline.hifa.cli.html">pipeline.hifa.cli</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../_autosummary/pipeline.hifv.cli.html">pipeline.hifv.cli</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../_autosummary/pipeline.hsd.cli.html">pipeline.hsd.cli</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../_autosummary/pipeline.hsdn.cli.html">pipeline.hsdn.cli</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../_autosummary/pipeline.domain.html">pipeline.domain</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../_autosummary/pipeline.infrastructure.launcher.html">pipeline.infrastructure.launcher</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../_autosummary/pipeline.domain.html">pipeline.domain</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../_autosummary/pipeline.infrastructure.launcher.html">pipeline.infrastructure.launcher</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Pipeline Heuristics</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../heuristics/field_parameter.html">Field parameter</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../heuristics/FlaggingTasks.html">Pipeline Flagging Tasks</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Releases etc.</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../releases.html">Pipeline Releases</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../modular.html">Run the Pipeline in a Conda environment</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../dependencies.html">Dependencies of <cite>Pipeline</cite></a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Pipeline Basics</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../basics.html">pipeline.domain</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../basics.html#module-pipeline.infrastructure.launcher">pipeline.infrastructure.launcher</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Task Classes</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../task_classes.html">pipeline</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../task_classes.html#module-pipeline.hif.tasks">pipeline-l2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../task_classes.html#module-pipeline.hif">pipeline-l3</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../task_classes.html#pipeline-diagram">pipeline-diagram</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Developer Notes</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../develdocmd/ways_to_run_the_pipeline.html">Ways to run the Pipeline</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../develdocmd/comparing_pipeline_executions.html">Comparing pipeline executions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../develdocmd/building_the_pipeline.html">Building the pipeline</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../develdocmd/ALMA-Imaging-Workflow.html">ALMA interferometry imaging workflow</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../develdocmd/VLA-Imaging-Workflow.html">VLA interferometry imaging workflow</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../develdocmd/VLASS-SE-CONT-Imaging-Workflow.html">VLASS-SE-CONT imaging workflow</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../develdocmd/VLASS-SE-CUBE-Imaging-Workflow.html">VLASS-SE-CUBE imaging workflow</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../develdocmd/selfcal_workflow.html">VLASS Selfcal &amp; Restore workflows</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../develdocmd/pipeline_tests.html">Pipeline testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../develdocmd/DataType_Testing.html">DataType Testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../develdocmd/QA_scores.html">Pipeline Quality Assurance (QA) Score Class Design</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../develdocmd/DeveloperDocumentation.html">Pipeline developer documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../develdocmd/python3_conversion_notes.html">Python 3 conversion notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../develdocmd/releases.html">Pipeline Releases</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../develdocmd/recipes.html">Pipeline Recipes</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Examples Notes (from Jupyter Notebooks)</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/test1.html">test</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Example Notes (from .rst)</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/test2.html">Example 1</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">Pipeline</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
          <li class="breadcrumb-item"><a href="../../pipeline.html">pipeline</a></li>
          <li class="breadcrumb-item"><a href="../infrastructure.html">pipeline.infrastructure</a></li>
      <li class="breadcrumb-item active">pipeline.infrastructure.vdp</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for pipeline.infrastructure.vdp</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">vdp is a pipeline framework module that contains classes to make writing task</span>
<span class="sd">Inputs easier.</span>

<span class="sd">- InputsContainer lets task implementations operate within the scope of a</span>
<span class="sd">  single measurement set, even if the pipeline run contains multiple data</span>
<span class="sd">  sets.</span>

<span class="sd">- VisDependentProperty is a reworking of pipeline properties to reduce the</span>
<span class="sd">  amount of boilerplate code required to implement an Inputs class.</span>

<span class="sd">Implementation details:</span>

<span class="sd">    See the documentation on the classes, particularly VisDependentProperty,</span>
<span class="sd">    for detailed information on how the framework operates.</span>

<span class="sd">Examples:</span>

<span class="sd">    There are three common scenarios that use VisDependentProperty. The</span>
<span class="sd">    following examples show each scenario for an Inputs property belonging to</span>
<span class="sd">    an Inputs class that extends vdp.StandardInputs.</span>

<span class="sd">    1. To provide a default value that can be overridden on a per-MS basis. Use</span>
<span class="sd">       the optional &#39;default&#39; argument to VisDependentProperty, eg:</span>

<span class="sd">        myarg = VisDependentProperty(default=&#39;some value&#39;)</span>

<span class="sd">    2. For more sophisticated default values, e.g., a default value that is a</span>
<span class="sd">       function of other data or properties, use the @VisDependentProperty</span>
<span class="sd">       decorator. A class property decorated with @VisDependentProperty should</span>
<span class="sd">       return the default value for that property. The function will execute</span>
<span class="sd">       in the scope of a single measurement set, i.e., at the time it is</span>
<span class="sd">       called, vis is set to exactly one value. The function will be called to</span>
<span class="sd">       provide a default value for any measurement set that does not have a</span>
<span class="sd">       user override value.</span>

<span class="sd">        @VisDependentProperty</span>
<span class="sd">        def myarg():</span>
<span class="sd">            # do some processing then return the calculated value</span>
<span class="sd">            return &#39;I am a custom property for measurement set %s&#39; % self.vis</span>

<span class="sd">    3. Convert or validate user input before accept it as an Inputs argument.</span>
<span class="sd">       Use the @VisDependentProperty.convert decorator, possibly alongside the</span>
<span class="sd">       getter decorator as above.</span>

<span class="sd">        @VisDependentProperty</span>
<span class="sd">        def myarg():</span>
<span class="sd">            # this will return 100 - but only if the user has not supplied</span>
<span class="sd">            # an override value!</span>
<span class="sd">            return 100</span>

<span class="sd">        @VisDependentProperty.convert</span>
<span class="sd">        def myarg(user_input):</span>
<span class="sd">            # convert then return the user input which is provided as an</span>
<span class="sd">            # argument to the convert decorator. The converted value will be</span>
<span class="sd">            # returned for all subsequent &#39;gets&#39;.</span>
<span class="sd">            return int(user_input)</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">inspect</span>
<span class="kn">import</span> <span class="nn">numbers</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">pprint</span>
<span class="kn">from</span> <span class="nn">inspect</span> <span class="kn">import</span> <span class="n">signature</span>

<span class="kn">from</span> <span class="nn">pipeline.domain</span> <span class="kn">import</span> <span class="n">DataType</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">api</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">argmapper</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">launcher</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">logging</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">task_registry</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">utils</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;VisDependentProperty&#39;</span><span class="p">,</span>
           <span class="s1">&#39;InputsContainer&#39;</span><span class="p">,</span>
           <span class="s1">&#39;StandardInputs&#39;</span><span class="p">,</span>
           <span class="s1">&#39;ModeInputs&#39;</span><span class="p">]</span>

<span class="n">LOG</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">get_logger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">SingletonType</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    SingletonType is a metaclass that ensures that only a single instance of</span>
<span class="sd">    a class exists. Creating additional instances returns the existing</span>
<span class="sd">    instance.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">__instance</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">__instance</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">SingletonType</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span><span class="o">.</span><span class="fm">__call__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">__instance</span>


<span class="k">class</span> <span class="nc">NullMarker</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    NullMarker is a class that represents the null &quot;parameter not-set&quot; case.</span>
<span class="sd">    It exists to distinguish between a user-provided null value, such as None</span>
<span class="sd">    or &#39;&#39;, and an argument that is null because it has not been set.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">null_input</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Values equal to those in null_input will be considered equal to null.</span>

<span class="sd">        :param null_input: user inputs considered equivalent to a NullMarker.</span>
<span class="sd">        :type null_input: iterable</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">null_input</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">null_input</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">convert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Process the argument, converting user input considered equivalent to</span>
<span class="sd">        null to a NullMarker object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">NullMarker</span><span class="p">)</span> <span class="ow">or</span> <span class="n">val</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">null_input</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">return</span> <span class="n">val</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">NullMarker</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">NullMarker</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;NullMarker(</span><span class="si">{!s}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">null_input</span><span class="p">))</span>


<span class="c1"># shared instance, as very few inputs require custom null equivalents</span>
<span class="n">_NULL</span> <span class="o">=</span> <span class="n">NullMarker</span><span class="p">(</span><span class="n">null_input</span><span class="o">=</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">])</span>


<span class="k">class</span> <span class="nc">NoDefaultMarker</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="n">metaclass</span><span class="o">=</span><span class="n">SingletonType</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    NoDefaultMarker is a class that represents the null &quot;parameter not-set&quot; case</span>
<span class="sd">    for default values. It exists to distinguish between a user-provided</span>
<span class="sd">    default value of None, and when a default has not been set.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">NoDefaultMarker</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">NoDefaultMarker</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">PipelineInputsMeta</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Sets the name of a VisDependentProperty at class definition time.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="n">mcls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">attrs</span><span class="p">):</span>
        <span class="bp">cls</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">PipelineInputsMeta</span><span class="p">,</span> <span class="n">mcls</span><span class="p">)</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="n">mcls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">attrs</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">attr</span><span class="p">,</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">attrs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">VisDependentProperty</span><span class="p">):</span>
                <span class="n">obj</span><span class="o">.</span><span class="n">__set_name__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span>


<div class="viewcode-block" id="VisDependentProperty">
<a class="viewcode-back" href="../../../_apidoc/pipeline.infrastructure.html#pipeline.hifa.tasks.polcal.polcal.VisDependentProperty">[docs]</a>
<span class="k">class</span> <span class="nc">VisDependentProperty</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    VisDependentProperty is a Python data descriptor that standardises the</span>
<span class="sd">    behaviour of pipeline Inputs properties and lets them create default values</span>
<span class="sd">    more easily.</span>

<span class="sd">    On reading a VisDependentProperty (ie. using the dot prefix: inputs.solint),</span>
<span class="sd">    one of two things happens:</span>

<span class="sd">    1. If a NullMarker is found - signifying that no user input has been</span>
<span class="sd">       provided - and a &#39;getter&#39; function has been defined, the getter function</span>
<span class="sd">       will be called to provide a default value for that measurement set.</span>

<span class="sd">    2. If a user has overridden the value (eg. inputs.solint = 123), that</span>
<span class="sd">       value will be retrieved.</span>

<span class="sd">    3. The value, either the default from step 1 or user-provided from step 2,</span>
<span class="sd">       is run through the optional postprocess function, which gives a final</span>
<span class="sd">       opportunity to change the value depending on the state/value of other</span>
<span class="sd">       properties.</span>

<span class="sd">    A VisDependentProperty can be made read-only by specifying &#39;readonly=True&#39;</span>
<span class="sd">    when creating the instance.</span>

<span class="sd">    A VisDependentProperty can be hidden from the containing Inputs string</span>
<span class="sd">    representation by setting &#39;hidden=True&#39; when creating the instance. This</span>
<span class="sd">    will hide the property from the web log and CLI getInputs calls.</span>

<span class="sd">    Each VisDependentProperty has a set of values it considers equivalent to</span>
<span class="sd">    null. When the user sets the VDP value to one of these null values, the</span>
<span class="sd">    VDP machinery converts this to a private NullObject marker that signifies</span>
<span class="sd">    the property is now unset, resulting in the default value being returned</span>
<span class="sd">    next time the property is read. Developers can specify which values should</span>
<span class="sd">    be converted to NullObject by specifying null_input at creation time, e.g.,</span>

<span class="sd">    solint = @VisDependentProperty(default=5, null_input=[None, &#39;&#39;, &#39;RESET&#39;, -1])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO check whether this can be replaced with NULL</span>
    <span class="n">NO_DEFAULT</span> <span class="o">=</span> <span class="n">NoDefaultMarker</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">backing_store_name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The name of the attribute holding the value for this property.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>

<div class="viewcode-block" id="VisDependentProperty.convert">
<a class="viewcode-back" href="../../../_apidoc/pipeline.infrastructure.html#pipeline.hifa.tasks.polcal.polcal.VisDependentProperty.convert">[docs]</a>
    <span class="k">def</span> <span class="nf">convert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fconvert</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the function used to clean and/or convert user-supplied argument</span>
<span class="sd">        values before they are associated with the instance property.</span>

<span class="sd">        The provided function should accept one unnamed argument, which when</span>
<span class="sd">        passed will be the user input *for this measurement set*. That is,</span>
<span class="sd">        after potentially being divided up into per-measurement values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="bp">self</span><span class="o">.</span><span class="n">fdefault</span><span class="p">,</span> <span class="n">fconvert</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fpostprocess</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">default</span><span class="p">,</span> <span class="n">hidden</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">hidden</span><span class="p">,</span>
                          <span class="n">null_input</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">null_input</span><span class="p">)</span></div>


<div class="viewcode-block" id="VisDependentProperty.default">
<a class="viewcode-back" href="../../../_apidoc/pipeline.infrastructure.html#pipeline.hifa.tasks.polcal.polcal.VisDependentProperty.default">[docs]</a>
    <span class="k">def</span> <span class="nf">default</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fdefault</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the function used to get the attribute value when the user has not</span>
<span class="sd">        supplied an override value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="n">fdefault</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fconvert</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fpostprocess</span><span class="p">,</span> <span class="n">hidden</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">hidden</span><span class="p">,</span> <span class="n">null_input</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">null_input</span><span class="p">)</span></div>


<div class="viewcode-block" id="VisDependentProperty.fget">
<a class="viewcode-back" href="../../../_apidoc/pipeline.infrastructure.html#pipeline.hifa.tasks.polcal.polcal.VisDependentProperty.fget">[docs]</a>
    <span class="k">def</span> <span class="nf">fget</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">owner</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets the underlying property value from an instance of the class</span>
<span class="sd">        owning this property</span>

<span class="sd">        :param owner:</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">owner</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">backing_store_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">null</span><span class="p">)</span></div>


<div class="viewcode-block" id="VisDependentProperty.fset">
<a class="viewcode-back" href="../../../_apidoc/pipeline.infrastructure.html#pipeline.hifa.tasks.polcal.polcal.VisDependentProperty.fset">[docs]</a>
    <span class="k">def</span> <span class="nf">fset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">owner</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the property value on the instance owning this property.</span>

<span class="sd">        :param owner:</span>
<span class="sd">        :param value:</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="n">owner</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">backing_store_name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span></div>


<div class="viewcode-block" id="VisDependentProperty.postprocess">
<a class="viewcode-back" href="../../../_apidoc/pipeline.infrastructure.html#pipeline.hifa.tasks.polcal.polcal.VisDependentProperty.postprocess">[docs]</a>
    <span class="k">def</span> <span class="nf">postprocess</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fpostprocess</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the function used to process the value that is about to be</span>
<span class="sd">        returned. This allows the value to be modified or perhaps a different</span>
<span class="sd">        value based on another property to be returned.</span>

<span class="sd">        :param owner:</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="bp">self</span><span class="o">.</span><span class="n">fdefault</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fconvert</span><span class="p">,</span> <span class="n">fpostprocess</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">default</span><span class="p">,</span> <span class="n">hidden</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">hidden</span><span class="p">,</span>
                          <span class="n">null_input</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">null_input</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fdefault</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fconvert</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fpostprocess</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="n">NO_DEFAULT</span><span class="p">,</span> <span class="n">readonly</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">hidden</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">null_input</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fdefault</span> <span class="o">=</span> <span class="n">fdefault</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fconvert</span> <span class="o">=</span> <span class="n">fconvert</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fpostprocess</span> <span class="o">=</span> <span class="n">fpostprocess</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">default</span> <span class="o">=</span> <span class="n">default</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">readonly</span> <span class="o">=</span> <span class="n">readonly</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hidden</span> <span class="o">=</span> <span class="n">hidden</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">null_input</span> <span class="o">=</span> <span class="n">null_input</span>

        <span class="c1"># use shared NullMarker instance where possible. There are lots of</span>
        <span class="c1"># Inputs properties, and only a handful require something custom.</span>
        <span class="k">if</span> <span class="n">null_input</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">null</span> <span class="o">=</span> <span class="n">_NULL</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">null</span> <span class="o">=</span> <span class="n">NullMarker</span><span class="p">(</span><span class="n">null_input</span><span class="o">=</span><span class="n">null_input</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fdefault</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># __call__ is executed when a function definition is called with</span>
        <span class="c1"># arguments</span>
        <span class="c1"># LOG.info(&#39;In __call__ for %s&#39; % fget.func_name)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fdefault</span> <span class="o">=</span> <span class="n">fdefault</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="fm">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">owner</span><span class="p">):</span>
        <span class="c1"># Return the VisDependentProperty itself when called directly</span>
        <span class="k">if</span> <span class="n">instance</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="n">instance_val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fget</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">instance_val</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">null</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fdefault</span><span class="p">:</span>
                <span class="n">instance_val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fdefault</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">default</span> <span class="o">!=</span> <span class="n">VisDependentProperty</span><span class="o">.</span><span class="n">NO_DEFAULT</span><span class="p">:</span>
                <span class="n">instance_val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">default</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Cannot get property with no default and no user value&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fpostprocess</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fpostprocess</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">instance_val</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">instance_val</span>

    <span class="k">def</span> <span class="fm">__set__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">readonly</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;can</span><span class="se">\&#39;</span><span class="s1">t set read-only attribute: </span><span class="si">{!s}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>

        <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">null</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

        <span class="c1"># pass non-null values through the user-provided converter</span>
        <span class="n">converted</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fconvert</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">value</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">null</span><span class="p">:</span>
            <span class="n">converted</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fconvert</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">fset</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">converted</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__set_name__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">owner</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span></div>



<div class="viewcode-block" id="InputsContainer">
<a class="viewcode-back" href="../../../_apidoc/pipeline.infrastructure.html#pipeline.hifa.tasks.polcal.polcal.InputsContainer">[docs]</a>
<span class="k">class</span> <span class="nc">InputsContainer</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    InputsContainer is the top-level container object for all task Inputs.</span>

<span class="sd">    InputsContainer contains machinery to let Inputs classes operate purely in</span>
<span class="sd">    the scope of a single measurement set, to make both Inputs and Task</span>
<span class="sd">    implementation much simpler.</span>

<span class="sd">    The InputsContainer operates in the scope of multiple measurement sets,</span>
<span class="sd">    and holds one Inputs instance for every measurement set within the context</span>
<span class="sd">    At task execution time, the task is executed for each active Inputs</span>
<span class="sd">    instance. Not all the Inputs instances held by the InputsContainer need be</span>
<span class="sd">    active: the user can reduce the scope of the task to a subset of</span>
<span class="sd">    measurement sets by setting vis, which makes an Inputs instance hidden and</span>
<span class="sd">    inactive.</span>

<span class="sd">    Tasks that operate in the scope of more than one measurement set, e.g,</span>
<span class="sd">    imaging and session-aware tasks, can disable the InputsContainer machinery</span>
<span class="sd">    by setting is_multi_vis_task to True. For these multivis tasks, one Inputs</span>
<span class="sd">    instance is held in an InputsContainer, but all property sets and gets pass</span>
<span class="sd">    directly through the one underlying inputs instance.</span>


<span class="sd">    For tasks that operate in the scope of a single measurement set, the</span>
<span class="sd">    InputsContainer class works in conjunction with VisDependentProperty to</span>
<span class="sd">    provide and process user input (eg. inputs.solint = 123) according to a set</span>
<span class="sd">    of rules:</span>

<span class="sd">    1. If the input is scalar and equal to &#39;&#39; or None, all measurement sets</span>
<span class="sd">       will be mapped back to NullMarker, therefore returning the default</span>
<span class="sd">       value or custom getter function on subsequent access.</span>

<span class="sd">    2. If the input is a list with number of items equal to the number of</span>
<span class="sd">       measurement sets, the items will be divided up and treated as mapping</span>
<span class="sd">       one value per measurement set.</span>

<span class="sd">    3. Otherwise, the user input is considered as the new default value for</span>
<span class="sd">       all measurement sets.</span>

<span class="sd">    Before the user input is stored in the dictionary, however, the input is</span>
<span class="sd">    passed through the convert function, assuming one has been provided. The</span>
<span class="sd">    convert function allows the developer to validate or convert user input to</span>
<span class="sd">    a standard format before accepting it as a new argument.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">task_cls</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_context</span> <span class="o">=</span> <span class="n">context</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_task_cls</span> <span class="o">=</span> <span class="n">task_cls</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initargs</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># For ModeInputs, the scope attribute is defined by one of the classes</span>
        <span class="c1"># that the ModeInputs switches between, rather than the ModeInputs</span>
        <span class="c1"># constructor itself.</span>
        <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">task_cls</span><span class="o">.</span><span class="n">Inputs</span><span class="p">,</span> <span class="n">ModeInputs</span><span class="p">):</span>
            <span class="k">if</span> <span class="s1">&#39;mode&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="c1"># user intends for the class to use the default mode. Inspect</span>
                <span class="c1"># the constructor to find what that value is.</span>
                <span class="n">constructor</span> <span class="o">=</span> <span class="n">task_cls</span><span class="o">.</span><span class="n">Inputs</span><span class="o">.</span><span class="fm">__init__</span>
                <span class="n">argdefs</span> <span class="o">=</span> <span class="p">{</span><span class="n">name</span><span class="p">:</span> <span class="n">param</span><span class="o">.</span><span class="n">default</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">signature</span><span class="p">(</span>
                    <span class="n">constructor</span><span class="p">)</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">param</span><span class="o">.</span><span class="n">default</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">param</span><span class="o">.</span><span class="n">empty</span><span class="p">}</span>

                <span class="c1"># user intends for the class to use the default mode. Inspect</span>
                <span class="c1"># the constructor to find what that value is</span>
                <span class="k">if</span> <span class="s1">&#39;mode&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">argdefs</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s1">&#39;The mode attribute must be specified for ModeInputs constructors&#39;</span><span class="p">)</span>
                <span class="n">mode</span> <span class="o">=</span> <span class="n">argdefs</span><span class="p">[</span><span class="s1">&#39;mode&#39;</span><span class="p">]</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">mode</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;mode&#39;</span><span class="p">]</span>

            <span class="n">current_inputs_cls</span> <span class="o">=</span> <span class="n">task_cls</span><span class="o">.</span><span class="n">Inputs</span><span class="o">.</span><span class="n">_modes</span><span class="p">[</span><span class="n">mode</span><span class="p">]</span><span class="o">.</span><span class="n">Inputs</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">current_inputs_cls</span> <span class="o">=</span> <span class="n">task_cls</span><span class="o">.</span><span class="n">Inputs</span>

        <span class="c1"># to support ModeInputs we introduce a level of indirection: this</span>
        <span class="c1"># variable points to the Inputs class that code should inspect</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_current_inputs_cls</span> <span class="o">=</span> <span class="n">current_inputs_cls</span>

        <span class="c1"># Inspect the targeted Inputs constructor specification to find out</span>
        <span class="c1"># which attribute sets the scope (=the data sets to process) for that</span>
        <span class="c1"># task.</span>
        <span class="c1">#</span>
        <span class="c1"># note: _scope_attr must be set for __setattr__ to function correctly</span>
        <span class="c1">#</span>
        <span class="n">constructor_spec</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getfullargspec</span><span class="p">(</span><span class="n">current_inputs_cls</span><span class="o">.</span><span class="fm">__init__</span><span class="p">)</span>

        <span class="k">if</span> <span class="s1">&#39;vis&#39;</span> <span class="ow">in</span> <span class="n">constructor_spec</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_scope_attr</span> <span class="o">=</span> <span class="s1">&#39;vis&#39;</span>
        <span class="k">elif</span> <span class="s1">&#39;infiles&#39;</span> <span class="ow">in</span> <span class="n">constructor_spec</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_scope_attr</span> <span class="o">=</span> <span class="s1">&#39;infiles&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;No scope argument recognised in </span><span class="si">{!s}</span><span class="s1"> constructor&#39;</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">task_cls</span><span class="o">.</span><span class="n">Inputs</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="c1"># all arguments must be of kev/value type for processing</span>
        <span class="n">named_args</span> <span class="o">=</span> <span class="n">name_all_arguments</span><span class="p">(</span><span class="n">current_inputs_cls</span><span class="o">.</span><span class="fm">__init__</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># if no datasets are specified, set the dataset scope to all those</span>
        <span class="c1"># registered with the context</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">scope_property</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">current_inputs_cls</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scope_attr</span><span class="p">)</span>
            <span class="n">scope_null</span> <span class="o">=</span> <span class="n">scope_property</span><span class="o">.</span><span class="n">null</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">scope_null</span> <span class="o">=</span> <span class="n">_NULL</span>
        <span class="n">scope_value</span> <span class="o">=</span> <span class="n">named_args</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_scope_attr</span><span class="p">,</span> <span class="n">scope_null</span><span class="p">)</span>
        <span class="n">scope_is_null</span> <span class="o">=</span> <span class="n">scope_null</span> <span class="o">==</span> <span class="n">scope_null</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">scope_value</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">scope_is_null</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">current_inputs_cls</span><span class="p">,</span> <span class="s1">&#39;processing_data_type&#39;</span><span class="p">):</span>
                <span class="n">data_types</span> <span class="o">=</span> <span class="n">current_inputs_cls</span><span class="o">.</span><span class="n">processing_data_type</span>
                <span class="n">ms_pool</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_context</span><span class="o">.</span><span class="n">observing_run</span><span class="o">.</span><span class="n">get_measurement_sets_of_type</span><span class="p">(</span><span class="n">data_types</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">ms</span> <span class="ow">in</span> <span class="n">ms_pool</span><span class="p">:</span>
                    <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ms</span><span class="o">.</span><span class="n">basename</span><span class="p">,</span> <span class="n">ms</span><span class="o">.</span><span class="n">data_column</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">LOG</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;Unable to get processing data type from input class.&#39;</span><span class="p">)</span>
<span class="c1">#                 # note that for ModeInputs this queries whether the ModeInputs is</span>
<span class="c1">#                 # registered for imaging MSes, not the Inputs that is selected.</span>
<span class="c1"># Note that the imaging_preferred flag has been removed as part of the work for PIPE-1062, PIPE-1112 and PIPE-1222.</span>
<span class="c1">#                 imaging_preferred = issubclass(self._task_cls.Inputs, api.ImagingMeasurementSetsPreferred)</span>
<span class="c1">#                 ms_pool = self._context.observing_run.get_measurement_sets(imaging_preferred=imaging_preferred)</span>

            <span class="n">named_args</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_scope_attr</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">ms</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">ms</span> <span class="ow">in</span> <span class="n">ms_pool</span><span class="p">]</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;MS to be processed: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">named_args</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_scope_attr</span><span class="p">]))</span>

        <span class="c1"># multi-vis tasks do not require any further processing</span>
        <span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">sessionutils</span>
        <span class="c1"># CAS-11443. ParallelTaskTemplate is a multivis task, in the sense that</span>
        <span class="c1"># one instance of ParallelTaskTemplate executes for all MSes, but the</span>
        <span class="c1"># Inputs should be treated as non-multivis so that the input arguments</span>
        <span class="c1"># for HPC tasks can be mapped to MSes using the same VDP logic as for</span>
        <span class="c1"># non-HPC tasks.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_multivis</span> <span class="o">=</span> <span class="n">task_cls</span><span class="o">.</span><span class="n">is_multi_vis_task</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">task_cls</span><span class="p">,</span> <span class="n">sessionutils</span><span class="o">.</span><span class="n">ParallelTemplate</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_multivis</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cls_instances</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;all&#39;</span><span class="p">:</span> <span class="n">task_cls</span><span class="o">.</span><span class="n">Inputs</span><span class="p">(</span><span class="o">**</span><span class="n">named_args</span><span class="p">)}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_active_instances</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cls_instances</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
            <span class="k">return</span>

        <span class="c1"># assign constructor args to data sets</span>
        <span class="n">constructor_args</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_remap_constructor_args</span><span class="p">(</span><span class="o">**</span><span class="n">named_args</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># create dict of &lt;data name&gt;: Inputs instance</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cls_instances</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">(</span>
                <span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">kw</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_scope_attr</span><span class="p">]),</span> <span class="n">task_cls</span><span class="o">.</span><span class="n">Inputs</span><span class="p">(</span><span class="o">**</span><span class="n">kw</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">kw</span> <span class="ow">in</span> <span class="n">constructor_args</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="c1"># catch TypeError exceptions from unexpected keyword arguments</span>
            <span class="c1"># so that we can add some more context to the debug message</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;Error creating </span><span class="si">{!s}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">task_cls</span><span class="o">.</span><span class="n">Inputs</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>
            <span class="k">raise</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_active_instances</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cls_instances</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">_remap_constructor_args</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># find out how many datasets are in this call. This number is used to</span>
        <span class="c1"># multiply scalar values appropriately</span>
        <span class="n">scope_val</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_scope_attr</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">scope_val</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">scope_val</span> <span class="o">=</span> <span class="n">scope_val</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">scope_val</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Illegal format for </span><span class="si">{!s}</span><span class="s1">: </span><span class="si">{!r}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_scope_attr</span><span class="p">,</span> <span class="n">scope_val</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="n">num_datasets</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">scope_val</span><span class="p">)</span>

        <span class="c1"># Process each argument value. In the resulting dict, each key is an</span>
        <span class="c1"># argument name with values containing one value per dataset</span>
        <span class="n">processed</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_arg_val</span><span class="p">(</span><span class="n">num_datasets</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

        <span class="c1"># Split the dict so that we have n dicts for n datasets, with each</span>
        <span class="c1"># dict containing just the values for that data.</span>
        <span class="k">return</span> <span class="p">[{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">processed</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_datasets</span><span class="p">)]</span>

    <span class="k">def</span> <span class="nf">_process_arg_val</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_datasets</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scope_attr</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">val</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">val</span>

        <span class="c1"># n values, n vis =&gt; distribute values</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="o">==</span> <span class="n">num_datasets</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">val</span>

        <span class="c1"># n values, m vis =&gt; assign value to all</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">val</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_datasets</span><span class="p">)]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_pipeline_casa_task</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Map the Inputs class to the hif* equivalent. Note that registry maps</span>
        <span class="c1"># maps Task classes, not Inputs classes, to their CASA task equivalent.</span>
        <span class="c1"># However, Task.Inputs *does* point to an Inputs class so we can</span>
        <span class="c1"># compare self against that.</span>
        <span class="n">casa_tasks</span> <span class="o">=</span> <span class="p">[</span><span class="n">m</span><span class="o">.</span><span class="n">casa_task</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">task_registry</span><span class="o">.</span><span class="n">task_map</span> <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">pipeline_class</span><span class="o">.</span><span class="n">Inputs</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_task_cls</span><span class="o">.</span><span class="n">Inputs</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">casa_tasks</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="c1"># map Python Inputs arguments back to their CASA equivalent</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">remapped</span> <span class="o">=</span> <span class="n">argmapper</span><span class="o">.</span><span class="n">inputs_to_casa</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_task_cls</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initargs</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="c1"># When Inputs class is shared among top-level task and underlying</span>
            <span class="c1"># worker task, argmapper.inputs_to_casa can throw KeyError.</span>
            <span class="c1"># Typically, it happens when Inputs class is shared among HPC</span>
            <span class="c1"># task and its serial worker class.</span>
            <span class="k">return</span>

        <span class="c1"># CAS-6299. Extra request from Liz:</span>
        <span class="c1">#</span>
        <span class="c1"># &quot;the full directory path of the ASDM location is given from the Pipeline</span>
        <span class="c1"># observatory run, so a PI/DRMs would have to edit this. Could it be</span>
        <span class="c1"># replaced just by the name of the ASDM/ASDMs?&quot;</span>
        <span class="c1">#</span>
        <span class="c1"># this means we have to take the basename of the vis argument for the</span>
        <span class="c1"># importdata calls</span>
        <span class="k">if</span> <span class="s1">&#39;_importdata&#39;</span> <span class="ow">in</span> <span class="n">casa_tasks</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scope_attr</span>
            <span class="n">remove_slash</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">remapped</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">remapped</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">remove_slash</span><span class="p">(</span><span class="n">remapped</span><span class="p">[</span><span class="n">key</span><span class="p">]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">remapped</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">remove_slash</span><span class="p">(</span><span class="n">v</span><span class="p">))</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">remapped</span><span class="p">[</span><span class="n">key</span><span class="p">]]</span>

        <span class="n">task_args</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">=</span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">remapped</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                     <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;self&#39;</span><span class="p">,</span> <span class="s1">&#39;context&#39;</span><span class="p">]</span>
                     <span class="ow">and</span> <span class="n">v</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>

        <span class="n">casa_call</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">(</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">casa_tasks</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">task_args</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">casa_call</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_active_instances</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_active_instances</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="bp">cls</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Integral</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_active_instances</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cls_instances</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{cls.__name__}</span><span class="s1"> indices must either be integers or the name of a measurement set&#39;</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">cls</span><span class="o">=</span><span class="bp">cls</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__members__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="bp">NotImplemented</span>

    <span class="k">def</span> <span class="nf">__methods__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="bp">NotImplemented</span>

    <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="c1"># __getattr__ is only called when this object&#39;s __dict__ does not</span>
        <span class="c1"># contain the requested property. When this happens, we delegate to</span>
        <span class="c1"># the currently selected Inputs. First, however, we check whether</span>
        <span class="c1"># the requested property is one of the Python magic methods. If so,</span>
        <span class="c1"># we return the standard implementation. This is necessary for</span>
        <span class="c1"># pickle, which checks for __getnewargs__ and __getstate__.</span>
        <span class="k">if</span> <span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;__&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">name</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;__&#39;</span><span class="p">):</span>
            <span class="c1"># LOG.error(&#39;Implement {!s} in InputsContainer&#39;.format(name))</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">InputsContainer</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__getattr__</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">dir</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">InputsContainer</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__getattr__</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scope_attr</span><span class="p">:</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;Retrieving scope from </span><span class="si">{!s}</span><span class="s1">.</span><span class="si">{!s}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_task_cls</span><span class="o">.</span><span class="n">Inputs</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_scope</span><span class="p">()</span>

        <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;InputsContainer.</span><span class="si">{!s}</span><span class="s1">: delegating to </span><span class="si">{!s}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_task_cls</span><span class="o">.</span><span class="n">Inputs</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="nb">getattr</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_active_instances</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">format_value_list</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="c1"># If the property we&#39;re trying to set is one of this base class&#39;s</span>
        <span class="c1"># private variables, add it to our __dict__ using the standard</span>
        <span class="c1"># __setattr__ method</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;_context&#39;</span><span class="p">,</span> <span class="s1">&#39;_task_cls&#39;</span><span class="p">,</span> <span class="s1">&#39;_cls_instances&#39;</span><span class="p">,</span> <span class="s1">&#39;_active_instances&#39;</span><span class="p">,</span> <span class="s1">&#39;_scope_attr&#39;</span><span class="p">,</span> <span class="s1">&#39;_initargs&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;_multivis&#39;</span><span class="p">,</span> <span class="s1">&#39;_current_inputs_cls&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">LOG</span><span class="o">.</span><span class="n">isEnabledFor</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">TRACE</span><span class="p">):</span>
                <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;Setting </span><span class="si">{!s}</span><span class="s1">.</span><span class="si">{!s}</span><span class="s1"> = </span><span class="si">{!r}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">val</span><span class="p">))</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">InputsContainer</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>

        <span class="c1"># check whether this class has a getter/setter by this name. If so,</span>
        <span class="c1"># allow the write to __dict__</span>
        <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scope_attr</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">LOG</span><span class="o">.</span><span class="n">isEnabledFor</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">TRACE</span><span class="p">):</span>
                <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;Setting scope: </span><span class="si">{!s}</span><span class="s1">.</span><span class="si">{!s}</span><span class="s1"> = </span><span class="si">{!r}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">val</span><span class="p">))</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set_scope</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">user_arg</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_map_args_to_vis</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">LOG</span><span class="o">.</span><span class="n">isEnabledFor</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">TRACE</span><span class="p">):</span>
                <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;Setting </span><span class="si">{!s}</span><span class="s1">.</span><span class="si">{!s}</span><span class="s1"> = </span><span class="si">{!r}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">inputs</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">user_arg</span><span class="p">))</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">user_arg</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;mode&#39;</span> <span class="ow">and</span> <span class="nb">issubclass</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_task_cls</span><span class="o">.</span><span class="n">Inputs</span><span class="p">,</span> <span class="n">ModeInputs</span><span class="p">):</span>
            <span class="c1"># can only have one active class at a time, so it&#39;s safe to take</span>
            <span class="c1"># the first instance</span>
            <span class="n">new_cls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_active_instances</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">_active</span><span class="o">.</span><span class="vm">__class__</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;Setting VDP target inputs class to </span><span class="si">{!s}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">new_cls</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_current_inputs_cls</span> <span class="o">=</span> <span class="n">new_cls</span>

    <span class="k">def</span> <span class="nf">_map_args_to_vis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        distribute a incoming user argument amongst the active instances.</span>

<span class="sd">        :param val:</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="n">val</span> <span class="o">=</span> <span class="p">[</span><span class="n">val</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_active_instances</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_active_instances</span><span class="p">,</span> <span class="n">val</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_get_scope</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">scope</span> <span class="o">=</span> <span class="p">[</span><span class="nb">getattr</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scope_attr</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_active_instances</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">format_value_list</span><span class="p">(</span><span class="n">scope</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_set_scope</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scope</span><span class="p">):</span>
        <span class="c1"># for multivis tasks, all we should do is set vis on the contained</span>
        <span class="c1"># inputs. As there only ever one active inputs instance, no further</span>
        <span class="c1"># processing is required so we can exit.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_multivis</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_active_instances</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scope_attr</span><span class="p">,</span> <span class="n">scope</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="c1"># reset to all MSes if the input arg signals a reset, which expands</span>
        <span class="c1"># task scope to all MSes</span>
        <span class="k">if</span> <span class="n">_NULL</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">scope</span><span class="p">)</span> <span class="o">==</span> <span class="n">_NULL</span><span class="p">:</span>
            <span class="n">scope</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cls_instances</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

        <span class="c1"># the key for inputs instances is the basename vis</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">scope</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">scope</span> <span class="o">=</span> <span class="p">[</span><span class="n">scope</span><span class="p">]</span>
        <span class="n">basenames</span> <span class="o">=</span> <span class="p">[</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">scope</span><span class="p">]</span>

        <span class="c1">#</span>
        <span class="c1"># TODO: the code below should be removed after constructor refactoring</span>
        <span class="c1">#</span>
        <span class="c1"># create a new inputs instance if one cannot be found</span>
        <span class="k">for</span> <span class="n">basename</span><span class="p">,</span> <span class="n">path</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">basenames</span><span class="p">,</span> <span class="n">scope</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">basename</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cls_instances</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_scope_attr</span><span class="p">:</span> <span class="n">path</span><span class="p">}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cls_instances</span><span class="p">[</span><span class="n">basename</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_task_cls</span><span class="o">.</span><span class="n">Inputs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_context</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># set the task scope to the vises set here</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_active_instances</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_cls_instances</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">basenames</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;&lt;InputsContainer(</span><span class="si">{!s}</span><span class="s1">, </span><span class="si">{!r}</span><span class="s1">&gt;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_task_cls</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_context</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_active_instances</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;Empty&#39;</span>

        <span class="n">attrs</span> <span class="o">=</span> <span class="p">{</span><span class="n">name</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">dir</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_current_inputs_cls</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)}</span>
        <span class="c1"># We should also print the mode for ModeInputs</span>
        <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_task_cls</span><span class="o">.</span><span class="n">Inputs</span><span class="p">,</span> <span class="n">ModeInputs</span><span class="p">):</span>
            <span class="n">attrs</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s1">&#39;mode&#39;</span><span class="p">)</span>

        <span class="n">methods</span> <span class="o">=</span> <span class="p">{</span><span class="n">fn_name</span> <span class="k">for</span> <span class="n">fn_name</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getmembers</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_current_inputs_cls</span><span class="p">,</span> <span class="n">inspect</span><span class="o">.</span><span class="n">ismethod</span><span class="p">)}</span>
        <span class="n">props</span> <span class="o">=</span> <span class="n">attrs</span> <span class="o">-</span> <span class="n">methods</span>
        <span class="n">props</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="s1">&#39;context&#39;</span><span class="p">)</span>
        <span class="n">props</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="s1">&#39;ms&#39;</span><span class="p">)</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">props</span><span class="p">}</span>
        <span class="k">return</span> <span class="n">pprint</span><span class="o">.</span><span class="n">pformat</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span>

<div class="viewcode-block" id="InputsContainer.as_dict">
<a class="viewcode-back" href="../../../_apidoc/pipeline.infrastructure.html#pipeline.hifa.tasks.polcal.polcal.InputsContainer.as_dict">[docs]</a>
    <span class="k">def</span> <span class="nf">as_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">properties</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="n">input_dicts</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="o">.</span><span class="n">as_dict</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_active_instances</span><span class="p">]</span>
        <span class="n">all_keys</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">deduplicate</span><span class="p">([</span><span class="n">key</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">input_dicts</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">d</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">all_keys</span><span class="p">:</span>
            <span class="n">vals</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="p">[])</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">input_dicts</span><span class="p">]</span>
            <span class="n">properties</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">format_value_list</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">properties</span></div>
</div>



<span class="k">def</span> <span class="nf">get_properties</span><span class="p">(</span><span class="n">inputs_cls</span><span class="p">):</span>
    <span class="n">attrs</span> <span class="o">=</span> <span class="p">{</span><span class="n">name</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">dir</span><span class="p">(</span><span class="n">inputs_cls</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)}</span>
    <span class="n">methods</span> <span class="o">=</span> <span class="p">{</span><span class="n">fn_name</span> <span class="k">for</span> <span class="n">fn_name</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getmembers</span><span class="p">(</span><span class="n">inputs_cls</span><span class="p">,</span> <span class="n">inspect</span><span class="o">.</span><span class="n">ismethod</span><span class="p">)}</span>
    <span class="n">props</span> <span class="o">=</span> <span class="n">attrs</span> <span class="o">-</span> <span class="n">methods</span>
    <span class="n">props</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="s1">&#39;context&#39;</span><span class="p">)</span>
    <span class="n">props</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="s1">&#39;ms&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">props</span>


<div class="viewcode-block" id="StandardInputs">
<a class="viewcode-back" href="../../../_apidoc/pipeline.infrastructure.html#pipeline.hifa.tasks.polcal.polcal.StandardInputs">[docs]</a>
<span class="k">class</span> <span class="nc">StandardInputs</span><span class="p">(</span><span class="n">api</span><span class="o">.</span><span class="n">Inputs</span><span class="p">,</span> <span class="n">metaclass</span><span class="o">=</span><span class="n">PipelineInputsMeta</span><span class="p">):</span>

    <span class="c1"># - standard non-vis-dependent properties --------------------------------</span>
    <span class="n">processing_data_type</span> <span class="o">=</span> <span class="p">[</span><span class="n">DataType</span><span class="o">.</span><span class="n">RAW</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">context</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the context used as the base for the parameters for this Inputs.</span>

<span class="sd">        :rtype: :class:`~pipeline.infrastructure.launcher.Context`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># A product of the prepare/analyse refactoring is that we always need</span>
        <span class="c1"># a context. This message is to ensure it was set by the implementing</span>
        <span class="c1"># subclass. We could remove this once refactoring is complete, but it</span>
        <span class="c1"># should be a cheap comparison so we leave it in.</span>
        <span class="c1">#</span>
        <span class="c1"># Note that the Context is NOT vis-dependent. The same context is used</span>
        <span class="c1"># to source all MeasurementSets.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_context</span><span class="p">,</span> <span class="n">launcher</span><span class="o">.</span><span class="n">Context</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{!s}</span><span class="s1"> did not set the pipeline context&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_context</span>

    <span class="nd">@context</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">context</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">launcher</span><span class="o">.</span><span class="n">Context</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;context not a pipeline context: </span><span class="si">{!s}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_context</span> <span class="o">=</span> <span class="n">value</span>

    <span class="c1"># - vis-dependent properties ---------------------------------------------</span>

    <span class="n">vis</span> <span class="o">=</span> <span class="n">VisDependentProperty</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">null_input</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="p">[],</span> <span class="p">[</span><span class="s1">&#39;&#39;</span><span class="p">]])</span>

<div class="viewcode-block" id="StandardInputs.ms">
<a class="viewcode-back" href="../../../_apidoc/pipeline.infrastructure.html#pipeline.hifa.tasks.polcal.polcal.StandardInputs.ms">[docs]</a>
    <span class="nd">@VisDependentProperty</span><span class="p">(</span><span class="n">readonly</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">hidden</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">ms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the MeasurementSet for the current value of vis.</span>

<span class="sd">        :rtype: :class:`~pipeline.domain.MeasurementSet`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vis</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">observing_run</span><span class="o">.</span><span class="n">get_ms</span><span class="p">(</span><span class="n">vis</span><span class="p">)</span> <span class="k">for</span> <span class="n">vis</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">vis</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">observing_run</span><span class="o">.</span><span class="n">get_ms</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vis</span><span class="p">)</span></div>


<div class="viewcode-block" id="StandardInputs.output_dir">
<a class="viewcode-back" href="../../../_apidoc/pipeline.infrastructure.html#pipeline.hifa.tasks.polcal.polcal.StandardInputs.output_dir">[docs]</a>
    <span class="nd">@VisDependentProperty</span>
    <span class="k">def</span> <span class="nf">output_dir</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">output_dir</span></div>


    <span class="k">def</span> <span class="nf">_get_task_args</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ignore</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Express this class as a dictionary of CASA arguments, listing all</span>
<span class="sd">        inputs except those named in ignore.</span>

<span class="sd">        The main purpose of the ignore argument is used to prevent an infinite</span>
<span class="sd">        loop in :meth:`~CommonCalibrationInputs.caltable`, which determines the</span>
<span class="sd">        value of caltable based on the value of the other CASA task arguments.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ignore</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ignore</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># get the signature of this Inputs class. We want to return a</span>
        <span class="c1"># of dictionary of all kw argument names except self, the</span>
        <span class="c1"># pipeline-specific arguments (context, output_dir, run_qa2 etc.) and</span>
        <span class="c1"># caltable.</span>
        <span class="n">skip</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;self&#39;</span><span class="p">,</span> <span class="s1">&#39;context&#39;</span><span class="p">,</span> <span class="s1">&#39;output_dir&#39;</span><span class="p">,</span> <span class="s1">&#39;ms&#39;</span><span class="p">,</span> <span class="s1">&#39;calstate&#39;</span><span class="p">]</span>
        <span class="n">skip</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">ignore</span><span class="p">)</span>

        <span class="n">kw_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getfullargspec</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="fm">__init__</span><span class="p">)</span><span class="o">.</span><span class="n">args</span> <span class="k">if</span> <span class="n">a</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">skip</span><span class="p">]</span>
        <span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">kw_names</span><span class="p">}</span>

        <span class="c1"># add any read-only properties too</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getmembers</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">inspect</span><span class="o">.</span><span class="n">isdatadescriptor</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">d</span> <span class="ow">or</span> <span class="n">k</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">skip</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="n">d</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Could not get input property </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">k</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">d</span>

<div class="viewcode-block" id="StandardInputs.to_casa_args">
<a class="viewcode-back" href="../../../_apidoc/pipeline.infrastructure.html#pipeline.hifa.tasks.polcal.polcal.StandardInputs.to_casa_args">[docs]</a>
    <span class="k">def</span> <span class="nf">to_casa_args</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Express these inputs as a dictionary of CASA arguments. The values</span>
<span class="sd">        in the dictionary are in a format suitable for CASA and can be</span>
<span class="sd">        directly passed to the CASA task.</span>

<span class="sd">        :rtype: a dictionary of string/??? kw/val pairs</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">args</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_task_args</span><span class="p">()</span>

        <span class="c1"># spw needs to be a string and not a number</span>
        <span class="k">if</span> <span class="s1">&#39;spw&#39;</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
            <span class="n">args</span><span class="p">[</span><span class="s1">&#39;spw&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="s1">&#39;spw&#39;</span><span class="p">])</span>

        <span class="c1"># Handle VLA-specific arguments and peculiarities</span>
        <span class="n">ms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ms</span>
        <span class="k">if</span> <span class="n">ms</span><span class="o">.</span><span class="n">antenna_array</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;VLA&#39;</span><span class="p">:</span>
            <span class="c1"># CASA believes that VLA data are not labelled with calibration</span>
            <span class="c1"># intent, so must remove the intent from the task call</span>
            <span class="n">args</span><span class="p">[</span><span class="s1">&#39;intent&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">args</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;intent&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">args</span><span class="p">[</span><span class="s1">&#39;intent&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">to_CASA_intent</span><span class="p">(</span><span class="n">ms</span><span class="p">,</span> <span class="n">args</span><span class="p">[</span><span class="s1">&#39;intent&#39;</span><span class="p">])</span>

        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
            <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">del</span> <span class="n">args</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">args</span></div>


    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_dict</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">pprint</span><span class="o">.</span><span class="n">pformat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">as_dict</span><span class="p">())</span>

<div class="viewcode-block" id="StandardInputs.as_dict">
<a class="viewcode-back" href="../../../_apidoc/pipeline.infrastructure.html#pipeline.hifa.tasks.polcal.polcal.StandardInputs.as_dict">[docs]</a>
    <span class="k">def</span> <span class="nf">as_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">utils</span><span class="o">.</span><span class="n">collect_properties</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="ModeInputs">
<a class="viewcode-back" href="../../../_apidoc/pipeline.infrastructure.html#pipeline.hifa.tasks.polcal.polcal.ModeInputs">[docs]</a>
<span class="k">class</span> <span class="nc">ModeInputs</span><span class="p">(</span><span class="n">api</span><span class="o">.</span><span class="n">Inputs</span><span class="p">,</span> <span class="n">metaclass</span><span class="o">=</span><span class="n">PipelineInputsMeta</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ModeInputs is a facade for Inputs of a common task type, allowing the user</span>
<span class="sd">    to switch between task implementations by changing the &#39;mode&#39; parameter.</span>

<span class="sd">    Extending classes should override the _modes dictionary with a set of</span>
<span class="sd">    key/value pairs, each pair mapping the mode name key to the task class</span>
<span class="sd">    value.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_modes</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">parameters</span><span class="p">):</span>
        <span class="c1"># create a dictionary of Inputs objects, one of each type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_delegates</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">task_cls</span><span class="o">.</span><span class="n">Inputs</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">vis</span><span class="o">=</span><span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;vis&#39;</span><span class="p">])</span>
                           <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">task_cls</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_modes</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

        <span class="c1"># set the mode to the requested mode, thus setting the active Inputs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">mode</span>

        <span class="c1"># set any parameters provided by the user</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">parameters</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="c1"># __getattr__ is only called when this object&#39;s __dict__ does not</span>
        <span class="c1"># contain the requested property. When this happens, we delegate to</span>
        <span class="c1"># the currently selected Inputs. First, however, we check whether</span>
        <span class="c1"># the requested property is one of the Python magic methods. If so,</span>
        <span class="c1"># we return the standard implementation. This is necessary for</span>
        <span class="c1"># pickle, which checks for __getnewargs__ and __getstate__.</span>
        <span class="k">if</span> <span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;__&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">name</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;__&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">ModeInputs</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__getattr__</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">dir</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">ModeInputs</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__getattr__</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

        <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;ModeInputs.</span><span class="si">{!s}</span><span class="s1">: delegating to </span><span class="si">{!s}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_active</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_active</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="c1"># If the property we&#39;re trying to set is one of this base class&#39;s</span>
        <span class="c1"># private variables, add it to our __dict__ using the standard</span>
        <span class="c1"># __setattr__ method</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;_active&#39;</span><span class="p">,</span> <span class="s1">&#39;_delegates&#39;</span><span class="p">,</span> <span class="s1">&#39;_mode&#39;</span><span class="p">,</span> <span class="s1">&#39;_pipeline_casa_task&#39;</span><span class="p">):</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;Setting </span><span class="si">{!s}</span><span class="s1">.</span><span class="si">{!s}</span><span class="s1"> = </span><span class="si">{!r}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">val</span><span class="p">))</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">ModeInputs</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>

<span class="c1">#         # check whether this class has a getter/setter by this name. If so,</span>
<span class="c1">#         # allow the write to __dict__</span>
<span class="c1">#         for (fn_name, _) in inspect.getmembers(self.__class__,</span>
<span class="c1">#                                                inspect.isdatadescriptor):</span>
<span class="c1">#             # our convention is to prefix the data variable for a</span>
<span class="c1">#             # getter/setter with an underscore.</span>
<span class="c1">#             if name in (fn_name, &#39;_&#39; + fn_name):</span>
<span class="c1">#                 LOG.trace(&#39;Getter/setter found on {0}. Setting \&#39;{1}\&#39; &#39;</span>
<span class="c1">#                           &#39;attribute to \&#39;{2}\&#39;&#39;.format(self.__class__.__name__,</span>
<span class="c1">#                                                         name, val))</span>
<span class="c1">#                 super(ModeInputs, self).__setattr__(name, val)</span>
<span class="c1">#</span>
<span class="c1">#                 # overriding defaults of wrapped classes requires us to re-get</span>
<span class="c1">#                 # the value after setting it, as the property setter of this</span>
<span class="c1">#                 # superclass has probably transformed it, eg. None =&gt; &#39;inf&#39;.</span>
<span class="c1">#                 # Furthermore, we do not return early, giving this function a</span>
<span class="c1">#                 # chance to set the parameter - with this new value - on the</span>
<span class="c1">#                 # wrapped classes too.</span>
<span class="c1">#                 val = getattr(self, name)</span>

        <span class="c1"># check whether this class has a getter/setter by this name. If so,</span>
        <span class="c1"># allow the write to __dict__</span>
        <span class="k">for</span> <span class="n">fn_name</span> <span class="ow">in</span> <span class="nb">dir</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="c1"># our convention is to prefix the data variable for a</span>
            <span class="c1"># getter/setter with an underscore.</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">(</span><span class="n">fn_name</span><span class="p">,</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">fn_name</span><span class="p">):</span>
            <span class="c1"># if name == fn_name:</span>
                <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;Getter/setter found: setting </span><span class="si">{!s}</span><span class="s1">.</span><span class="si">{!s}</span><span class="s1"> = </span><span class="si">{!r}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">val</span><span class="p">))</span>
                <span class="nb">super</span><span class="p">(</span><span class="n">ModeInputs</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>

                <span class="c1"># overriding defaults of wrapped classes requires us to re-get</span>
                <span class="c1"># the value after setting it, as the property setter of this</span>
                <span class="c1"># superclass has probably transformed it, eg. None =&gt; &#39;inf&#39;.</span>
                <span class="c1"># Furthermore, we do not return early, giving this function a</span>
                <span class="c1"># chance to set the parameter - with this new value - on the</span>
                <span class="c1"># wrapped classes too.</span>
                <span class="n">val</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

        <span class="c1"># otherwise, set the said attribute on all of our delegate Inputs. In</span>
        <span class="c1"># doing so, the user can switch mode at any time and have the new</span>
        <span class="c1"># Inputs present with all their previously set parameters.</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_delegates</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
                <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;Setting </span><span class="si">{!s}</span><span class="s1">.</span><span class="si">{!s}</span><span class="s1"> = </span><span class="si">{!r}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">val</span><span class="p">))</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">mode</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span>

    <span class="nd">@mode</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">mode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_modes</span><span class="p">:</span>
            <span class="n">keys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_modes</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Mode must be one of </span><span class="se">\&#39;</span><span class="si">{0}</span><span class="se">\&#39;</span><span class="s1"> but got </span><span class="se">\&#39;</span><span class="si">{1}</span><span class="se">\&#39;</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="s1">&#39;</span><span class="se">\&#39;</span><span class="s1">, </span><span class="se">\&#39;</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">keys</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\&#39;</span><span class="s1"> or </span><span class="se">\&#39;</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="n">keys</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">value</span><span class="p">)</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_active</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_delegates</span><span class="p">[</span><span class="n">value</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span> <span class="o">=</span> <span class="n">value</span>

<div class="viewcode-block" id="ModeInputs.get_task">
<a class="viewcode-back" href="../../../_apidoc/pipeline.infrastructure.html#pipeline.hifa.tasks.polcal.polcal.ModeInputs.get_task">[docs]</a>
    <span class="k">def</span> <span class="nf">get_task</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the task appropriate to the current Inputs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">task_cls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_modes</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_mode</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">task_cls</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_active</span><span class="p">)</span></div>


<div class="viewcode-block" id="ModeInputs.as_dict">
<a class="viewcode-back" href="../../../_apidoc/pipeline.infrastructure.html#pipeline.hifa.tasks.polcal.polcal.ModeInputs.as_dict">[docs]</a>
    <span class="k">def</span> <span class="nf">as_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">props</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">collect_properties</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_active</span><span class="p">)</span>
        <span class="n">props</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">utils</span><span class="o">.</span><span class="n">collect_properties</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">props</span></div>


<div class="viewcode-block" id="ModeInputs.to_casa_args">
<a class="viewcode-back" href="../../../_apidoc/pipeline.infrastructure.html#pipeline.hifa.tasks.polcal.polcal.ModeInputs.to_casa_args">[docs]</a>
    <span class="k">def</span> <span class="nf">to_casa_args</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_active</span><span class="o">.</span><span class="n">to_casa_args</span><span class="p">()</span></div>


    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">pprint</span><span class="o">.</span><span class="n">pformat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">as_dict</span><span class="p">())</span>

<div class="viewcode-block" id="ModeInputs.get_constructor_args">
<a class="viewcode-back" href="../../../_apidoc/pipeline.infrastructure.html#pipeline.hifa.tasks.polcal.polcal.ModeInputs.get_constructor_args">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">get_constructor_args</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">ignore</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;self&#39;</span><span class="p">,</span> <span class="s1">&#39;context&#39;</span><span class="p">)):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the union of all arguments accepted by this class&#39;s constructor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">all_args</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="c1"># get the arguments for this class&#39;s contructor</span>
        <span class="n">args</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getfullargspec</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="fm">__init__</span><span class="p">)</span><span class="o">.</span><span class="n">args</span>
        <span class="c1"># and add them to our collection</span>
        <span class="n">all_args</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>

        <span class="c1"># now do the same for each inputs class we can switch between</span>
        <span class="k">for</span> <span class="n">task_cls</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_modes</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="c1"># get the arguments of the task Inputs constructor</span>
            <span class="n">args</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getfullargspec</span><span class="p">(</span><span class="n">task_cls</span><span class="o">.</span><span class="n">Inputs</span><span class="o">.</span><span class="fm">__init__</span><span class="p">)</span><span class="o">.</span><span class="n">args</span>
            <span class="c1"># and add them to our set</span>
            <span class="n">all_args</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">ignore</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ignore</span><span class="p">:</span>
                <span class="n">all_args</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">all_args</span></div>
</div>



<span class="c1"># module utility functions ---------------------------------------------------</span>


<span class="k">def</span> <span class="nf">all_unique</span><span class="p">(</span><span class="n">o</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return True if all elements in the iterable argument are unique.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># LOG.trace(&#39;all_unique(%s)&#39; % str(o))</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Iterable</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Cannot determine uniqueness of non-iterables&#39;</span><span class="p">)</span>

    <span class="n">hashes</span> <span class="o">=</span> <span class="p">{</span><span class="n">gen_hash</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">o</span><span class="p">}</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">hashes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span>


<span class="k">def</span> <span class="nf">gen_hash</span><span class="p">(</span><span class="n">o</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Makes a hash from a dictionary, list, tuple or set to any level, that</span>
<span class="sd">    contains only other hashable types (including any lists, tuples, sets,</span>
<span class="sd">    and dictionaries).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># LOG.trace(&#39;gen_hash(%s)&#39; % str(o))</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="p">(</span><span class="nb">set</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">gen_hash</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">o</span><span class="p">])</span>

    <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="c1"># LOG.trace(&#39;Hash: %s=%s&#39; % (o, hash(o)))</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>

    <span class="n">new_o</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">new_o</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">new_o</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">gen_hash</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

    <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">frozenset</span><span class="p">(</span><span class="n">new_o</span><span class="o">.</span><span class="n">items</span><span class="p">())))</span>


<span class="k">def</span> <span class="nf">format_value_list</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
    <span class="c1"># return single values where possible, which is when only one value</span>
    <span class="c1"># is present because the inputs covers one ms or because the values</span>
    <span class="c1"># for each ms are all the same.</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">val</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">all_unique</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">val</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">name_all_arguments</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="c1"># we need to know the names of any non-key/value arguments supplied</span>
    <span class="c1"># in the constructor. The names of the argument can be found in the</span>
    <span class="c1"># constructor specification.</span>
    <span class="n">argspec</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getfullargspec</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>

    <span class="c1"># The constructor specification includes &#39;self&#39;, which is not passed</span>
    <span class="c1"># in either args or kwargs. Hence, a dummy value for self is supplied</span>
    <span class="c1"># as the first argument so that the argument indices do not need to be</span>
    <span class="c1"># shifted.</span>
    <span class="k">if</span> <span class="n">argspec</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;self&#39;</span><span class="p">:</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;dummy self&#39;</span><span class="p">,)</span> <span class="o">+</span> <span class="n">args</span>

    <span class="c1"># get args passed positionally (=args with no default)</span>
    <span class="n">num_positional_args</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">argspec</span><span class="o">.</span><span class="n">args</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">argspec</span><span class="o">.</span><span class="n">defaults</span><span class="p">)</span>
    <span class="n">positional_args</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">argspec</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="n">args</span><span class="p">[:</span><span class="n">num_positional_args</span><span class="p">])}</span>
    <span class="c1"># get kw args passed by position (=args with a default, but key not</span>
    <span class="c1"># specified in call)</span>
    <span class="n">positional_kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">argspec</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="n">num_positional_args</span><span class="p">:],</span> <span class="n">args</span><span class="p">[</span><span class="n">num_positional_args</span><span class="p">:])}</span>

    <span class="n">named_args</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">named_args</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">positional_args</span><span class="p">)</span>
    <span class="n">named_args</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">positional_kwargs</span><span class="p">)</span>
    <span class="n">named_args</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="c1"># having inserted self, we now remove it as the instance value is</span>
    <span class="c1"># supplied automatically by Python during instance creation</span>
    <span class="k">if</span> <span class="s1">&#39;self&#39;</span> <span class="ow">in</span> <span class="n">named_args</span><span class="p">:</span>
        <span class="k">del</span> <span class="n">named_args</span><span class="p">[</span><span class="s1">&#39;self&#39;</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">named_args</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 20202024, Pipeline Dev. Team.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>