

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>pipeline.infrastructure.callibrary &mdash; Pipeline unknown documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css?v=4ae1632d" />
      <link rel="stylesheet" type="text/css" href="../../../_static/custom_theme.css?v=678032d9" />

  
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=3f1b9271"></script>
      <script src="../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            Pipeline
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Releases etc.</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../releases.html">Past Releases</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../modular.html">Run the Pipeline in a Conda environment</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../dependencies.html">Dependencies of <code class="docutils literal notranslate"><span class="pre">Pipeline</span></code></a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Pipeline Tasks</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../pipeline_tasks/pipeline_tasks.html">Pipeline Heuristics Tasks</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Pipeline Tasks (autosummary)</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../_autosummary/pipeline.h.cli.html">pipeline.h.cli</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../_autosummary/pipeline.hif.cli.html">pipeline.hif.cli</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../_autosummary/pipeline.hifa.cli.html">pipeline.hifa.cli</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../_autosummary/pipeline.hifv.cli.html">pipeline.hifv.cli</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../_autosummary/pipeline.hsd.cli.html">pipeline.hsd.cli</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../_autosummary/pipeline.hsdn.cli.html">pipeline.hsdn.cli</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Pipeline Heuristics</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../heuristics/field_parameter.html">Field parameter</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../heuristics/FlaggingTasks.html">Pipeline Flagging Tasks</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Developer Notes</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../develdocmd/ways_to_run_the_pipeline.html">Ways to run the Pipeline</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../develdocmd/comparing_pipeline_executions.html">Comparing pipeline executions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../develdocmd/building_the_pipeline.html">Building the pipeline</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../develdocmd/ALMA-Imaging-Workflow.html">ALMA interferometry imaging workflow</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../develdocmd/VLA-Imaging-Workflow.html">VLA interferometry imaging workflow</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../develdocmd/VLASS-SE-CONT-Imaging-Workflow.html">VLASS-SE-CONT imaging workflow</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../develdocmd/VLASS-SE-CUBE-Imaging-Workflow.html">VLASS-SE-CUBE imaging workflow</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../develdocmd/selfcal_workflow.html">VLASS Selfcal &amp; Restore workflows</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../develdocmd/pipeline_tests.html">Pipeline testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../develdocmd/DataType_Testing.html">DataType Testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../develdocmd/QA_scores.html">Pipeline Quality Assurance (QA) Score Class Design</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../develdocmd/DeveloperDocumentation.html">Pipeline developer documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../develdocmd/python3_conversion_notes.html">Python 3 conversion notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../develdocmd/recipes.html">Pipeline Recipes</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Pipeline Domain/Context (automodapi)</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../basics.html"><code class="docutils literal notranslate"><span class="pre">pipeline.domain</span></code> module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../basics.html#module-pipeline.infrastructure.launcher"><code class="docutils literal notranslate"><span class="pre">pipeline.infrastructure.launcher</span></code> module</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Pipeline Domain/Context (autosummary)</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../_autosummary/pipeline.domain.html">pipeline.domain</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../_autosummary/pipeline.infrastructure.launcher.html">pipeline.infrastructure.launcher</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Pipeline Task/Inputs/Results Classes</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../classes.html">Classes in <code class="docutils literal notranslate"><span class="pre">pipeline.h*.tasks</span></code> modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../classes.html#inheritance-diagrams">Inheritance Diagrams</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Examples Notes (from Jupyter Notebooks)</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/test1.html">test</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Example Notes (from .rst)</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/test2.html">Example 1</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">Pipeline</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
          <li class="breadcrumb-item"><a href="../../pipeline.html">pipeline</a></li>
          <li class="breadcrumb-item"><a href="../infrastructure.html">pipeline.infrastructure</a></li>
      <li class="breadcrumb-item active">pipeline.infrastructure.callibrary</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for pipeline.infrastructure.callibrary</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">datetime</span>
<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">operator</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">uuid</span>
<span class="kn">import</span> <span class="nn">weakref</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Set</span><span class="p">,</span> <span class="n">Tuple</span>

<span class="kn">import</span> <span class="nn">cachetools</span>
<span class="kn">import</span> <span class="nn">intervaltree</span>
<span class="kn">from</span> <span class="nn">casatasks.private.callibrary</span> <span class="kn">import</span> <span class="n">applycaltocallib</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">casa_tools</span><span class="p">,</span> <span class="n">launcher</span><span class="p">,</span> <span class="n">logging</span><span class="p">,</span> <span class="n">utils</span>

<span class="n">LOG</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">get_logger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>

<span class="n">CalToArgs</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;CalToArgs&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;vis&#39;</span><span class="p">,</span> <span class="s1">&#39;spw&#39;</span><span class="p">,</span> <span class="s1">&#39;field&#39;</span><span class="p">,</span> <span class="s1">&#39;intent&#39;</span><span class="p">,</span> <span class="s1">&#39;antenna&#39;</span><span class="p">])</span>

<span class="c1"># struct used to link calapplication to the task and inputs that created it</span>
<span class="n">CalAppOrigin</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;CalAppOrigin&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;task&#39;</span><span class="p">,</span> <span class="s1">&#39;inputs&#39;</span><span class="p">])</span>

<span class="c1"># observations before this date are considered Cycle 0 observations</span>
<span class="n">CYCLE_0_END_DATE</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">(</span><span class="mi">2013</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">21</span><span class="p">)</span>


<div class="viewcode-block" id="CalApplication">
<a class="viewcode-back" href="../../../_apidoc/pipeline.infrastructure.html#pipeline.infrastructure.callibrary.CalApplication">[docs]</a>
<span class="k">class</span> <span class="nc">CalApplication</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    CalApplication maps calibration tables and their application arguments to</span>
<span class="sd">    a target data selection, encapsulated as |CalFrom| and |CalTo| objects </span>
<span class="sd">    respectively.</span>

<span class="sd">    .. py:attribute:: calto</span>

<span class="sd">        the |CalTo| representing the data selection to which the calibration</span>
<span class="sd">        should apply.</span>

<span class="sd">    .. py:attribute:: calfrom</span>

<span class="sd">        the |CalFrom| representing the calibration and application parameters</span>

<span class="sd">    .. py:attribute:: origin</span>

<span class="sd">        the |CalAppOrigin| marking how this calibration was created</span>

<span class="sd">.. |CalTo| replace:: :class:`CalTo`</span>
<span class="sd">.. |CalFrom| replace:: :class:`CalFrom`</span>
<span class="sd">.. |CalAppOrigin| replace:: :class:`CalAppOrigin`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">calto</span><span class="p">,</span> <span class="n">calfrom</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">calto</span> <span class="o">=</span> <span class="n">calto</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">calfrom</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">calfrom</span> <span class="o">=</span> <span class="p">[</span><span class="n">calfrom</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">calfrom</span> <span class="o">=</span> <span class="n">calfrom</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">origin</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">origin</span> <span class="o">=</span> <span class="p">[</span><span class="n">origin</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">origin</span> <span class="o">=</span> <span class="n">origin</span>

<div class="viewcode-block" id="CalApplication.from_export">
<a class="viewcode-back" href="../../../_apidoc/pipeline.infrastructure.html#pipeline.infrastructure.callibrary.CalApplication.from_export">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_export</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Unmarshal a CalApplication from a string.</span>

<span class="sd">        :rtype: the unmarshalled :class:`CalApplication` object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;applycal(&#39;</span><span class="p">,</span> <span class="s1">&#39;dict(&#39;</span><span class="p">))</span>
        <span class="n">calto</span> <span class="o">=</span> <span class="n">CalTo</span><span class="p">(</span><span class="n">vis</span><span class="o">=</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;vis&#39;</span><span class="p">],</span> <span class="n">field</span><span class="o">=</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;field&#39;</span><span class="p">],</span> <span class="n">spw</span><span class="o">=</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;spw&#39;</span><span class="p">],</span>
                      <span class="n">antenna</span><span class="o">=</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;antenna&#39;</span><span class="p">],</span> <span class="n">intent</span><span class="o">=</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;intent&#39;</span><span class="p">])</span>

        <span class="c1"># wrap these values in a list if they are single valued,</span>
        <span class="c1"># eg. &#39;m31&#39; -&gt; [&#39;m31&#39;]</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;gainfield&#39;</span><span class="p">,</span> <span class="s1">&#39;gaintable&#39;</span><span class="p">,</span> <span class="s1">&#39;interp&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]]</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;calwt&#39;</span><span class="p">,):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="nb">bool</span><span class="p">):</span>
                <span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]]</span>

        <span class="c1"># do the same for spwmap. A bit more complicated, as a single valued</span>
        <span class="c1"># spwmap is a list of integers, or may not have any values at all.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;spwmap&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">d</span><span class="p">[</span><span class="s1">&#39;spwmap&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;spwmap&#39;</span><span class="p">]]</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="n">d</span><span class="p">[</span><span class="s1">&#39;spwmap&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;spwmap&#39;</span><span class="p">]]</span>

        <span class="n">zipped</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;gaintable&#39;</span><span class="p">],</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;gainfield&#39;</span><span class="p">],</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;interp&#39;</span><span class="p">],</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;spwmap&#39;</span><span class="p">],</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;calwt&#39;</span><span class="p">]))</span>

        <span class="n">calfroms</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">gaintable</span><span class="p">,</span> <span class="n">gainfield</span><span class="p">,</span> <span class="n">interp</span><span class="p">,</span> <span class="n">spwmap</span><span class="p">,</span> <span class="n">calwt</span><span class="p">)</span> <span class="ow">in</span> <span class="n">zipped</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">gaintable</span><span class="p">):</span>
                <span class="k">with</span> <span class="n">casa_tools</span><span class="o">.</span><span class="n">TableReader</span><span class="p">(</span><span class="n">gaintable</span><span class="p">)</span> <span class="k">as</span> <span class="n">caltable</span><span class="p">:</span>
                    <span class="n">viscal</span> <span class="o">=</span> <span class="n">caltable</span><span class="o">.</span><span class="n">getkeyword</span><span class="p">(</span><span class="s1">&#39;VisCal&#39;</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">LOG</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Could not access </span><span class="si">{}</span><span class="s1">. Using heuristics to determine caltable type&#39;</span>
                            <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">gaintable</span><span class="p">)))</span>
                <span class="k">if</span> <span class="s1">&#39;tsys&#39;</span> <span class="ow">in</span> <span class="n">gaintable</span><span class="p">:</span>
                    <span class="n">viscal</span> <span class="o">=</span> <span class="s1">&#39;B TSYS&#39;</span>
                <span class="k">elif</span> <span class="s1">&#39;bcal&#39;</span> <span class="ow">in</span> <span class="n">gaintable</span><span class="p">:</span>
                    <span class="n">viscal</span> <span class="o">=</span> <span class="s1">&#39;B JONES&#39;</span>
                <span class="k">elif</span> <span class="s1">&#39;gpcal&#39;</span> <span class="ow">in</span> <span class="n">gaintable</span><span class="p">:</span>
                    <span class="n">viscal</span> <span class="o">=</span> <span class="s1">&#39;G JONES&#39;</span>
                <span class="k">elif</span> <span class="s1">&#39;gcal&#39;</span> <span class="ow">in</span> <span class="n">gaintable</span><span class="p">:</span>
                    <span class="n">viscal</span> <span class="o">=</span> <span class="s1">&#39;G JONES&#39;</span>
                <span class="k">elif</span> <span class="s1">&#39;gacal&#39;</span> <span class="ow">in</span> <span class="n">gaintable</span><span class="p">:</span>
                    <span class="n">viscal</span> <span class="o">=</span> <span class="s1">&#39;G JONES&#39;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">gaintable</span><span class="p">)</span>

            <span class="n">caltype</span> <span class="o">=</span> <span class="n">CalFrom</span><span class="o">.</span><span class="n">get_caltype_for_viscal</span><span class="p">(</span><span class="n">viscal</span><span class="p">)</span>
            <span class="n">calfrom</span> <span class="o">=</span> <span class="n">CalFrom</span><span class="p">(</span><span class="n">gaintable</span><span class="p">,</span> <span class="n">gainfield</span><span class="o">=</span><span class="n">gainfield</span><span class="p">,</span> <span class="n">interp</span><span class="o">=</span><span class="n">interp</span><span class="p">,</span>
                              <span class="n">spwmap</span><span class="o">=</span><span class="n">spwmap</span><span class="p">,</span> <span class="n">calwt</span><span class="o">=</span><span class="n">calwt</span><span class="p">,</span> <span class="n">caltype</span><span class="o">=</span><span class="n">caltype</span><span class="p">)</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;Marking caltable </span><span class="se">\&#39;</span><span class="si">%s</span><span class="se">\&#39;</span><span class="s1"> as caltype </span><span class="se">\&#39;</span><span class="si">%s</span><span class="se">\&#39;</span><span class="s1">&#39;</span>
                      <span class="s1">&#39;&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">gaintable</span><span class="p">,</span> <span class="n">calfrom</span><span class="o">.</span><span class="n">caltype</span><span class="p">))</span>

            <span class="n">calfroms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">calfrom</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">CalApplication</span><span class="p">(</span><span class="n">calto</span><span class="p">,</span> <span class="n">calfroms</span><span class="p">)</span></div>


<div class="viewcode-block" id="CalApplication.as_applycal">
<a class="viewcode-back" href="../../../_apidoc/pipeline.infrastructure.html#pipeline.infrastructure.callibrary.CalApplication.as_applycal">[docs]</a>
    <span class="k">def</span> <span class="nf">as_applycal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get a representation of this object as a CASA applycal call.</span>

<span class="sd">        :rtype: string</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;vis&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">vis</span><span class="p">,</span>
            <span class="s1">&#39;field&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">field</span><span class="p">,</span>
            <span class="s1">&#39;intent&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">intent</span><span class="p">,</span>
            <span class="s1">&#39;spw&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">spw</span><span class="p">,</span>
            <span class="s1">&#39;antenna&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">antenna</span><span class="p">,</span>
            <span class="s1">&#39;gaintable&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">gaintable</span><span class="p">,</span>
            <span class="s1">&#39;gainfield&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">gainfield</span><span class="p">,</span>
            <span class="s1">&#39;spwmap&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">spwmap</span><span class="p">,</span>
            <span class="s1">&#39;interp&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">interp</span><span class="p">,</span>
            <span class="s1">&#39;calwt&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">calwt</span>
        <span class="p">}</span>

        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;gaintable&#39;</span><span class="p">,</span> <span class="s1">&#39;gainfield&#39;</span><span class="p">,</span> <span class="s1">&#39;spwmap&#39;</span><span class="p">,</span> <span class="s1">&#39;interp&#39;</span><span class="p">,</span> <span class="s1">&#39;calwt&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">args</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\&#39;</span><span class="si">%s</span><span class="se">\&#39;</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">args</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

        <span class="k">return</span> <span class="p">(</span><span class="s1">&#39;applycal(vis=</span><span class="se">\&#39;</span><span class="si">{vis}</span><span class="se">\&#39;</span><span class="s1">, field=</span><span class="se">\&#39;</span><span class="si">{field}</span><span class="se">\&#39;</span><span class="s1">, &#39;</span>
                <span class="s1">&#39;intent=</span><span class="se">\&#39;</span><span class="si">{intent}</span><span class="se">\&#39;</span><span class="s1">, spw=</span><span class="se">\&#39;</span><span class="si">{spw}</span><span class="se">\&#39;</span><span class="s1">, antenna=</span><span class="se">\&#39;</span><span class="si">{antenna}</span><span class="se">\&#39;</span><span class="s1">, &#39;</span>
                <span class="s1">&#39;gaintable=</span><span class="si">{gaintable}</span><span class="s1">, gainfield=</span><span class="si">{gainfield}</span><span class="s1">, &#39;</span>
                <span class="s1">&#39;spwmap=</span><span class="si">{spwmap}</span><span class="s1">, interp=</span><span class="si">{interp}</span><span class="s1">, calwt=</span><span class="si">{calwt}</span><span class="s1">)&#39;</span>
                <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">**</span><span class="n">args</span><span class="p">))</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">antenna</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The antennas to which the calibrations apply.</span>

<span class="sd">        :rtype: string</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">calto</span><span class="o">.</span><span class="n">antenna</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">calwt</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The calwt parameters to be used when applying these calibrations.</span>

<span class="sd">        :rtype: a scalar string if representing 1 calibration, otherwise a</span>
<span class="sd">                list of strings</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">l</span> <span class="o">=</span> <span class="p">[</span><span class="n">cf</span><span class="o">.</span><span class="n">calwt</span> <span class="k">for</span> <span class="n">cf</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">calfrom</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">l</span>

<div class="viewcode-block" id="CalApplication.exists">
<a class="viewcode-back" href="../../../_apidoc/pipeline.infrastructure.html#pipeline.infrastructure.callibrary.CalApplication.exists">[docs]</a>
    <span class="k">def</span> <span class="nf">exists</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Test whether all calibration tables referred to by this application exist.</span>

<span class="sd">        :rtype: boolean</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">cf</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">calfrom</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">cf</span><span class="o">.</span><span class="n">gaintable</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">field</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The fields to which the calibrations apply.</span>

<span class="sd">        :rtype: string</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">calto</span><span class="o">.</span><span class="n">field</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">gainfield</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The gainfield parameters to be used when applying these calibrations.</span>

<span class="sd">        :rtype: a scalar string if representing 1 calibration, otherwise a</span>
<span class="sd">                list of strings</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">l</span> <span class="o">=</span> <span class="p">[</span><span class="n">cf</span><span class="o">.</span><span class="n">gainfield</span> <span class="k">for</span> <span class="n">cf</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">calfrom</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">l</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">gaintable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The gaintable parameters to be used when applying these calibrations.</span>

<span class="sd">        :rtype: a scalar string if representing 1 calibration, otherwise a</span>
<span class="sd">                list of strings</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">l</span> <span class="o">=</span> <span class="p">[</span><span class="n">cf</span><span class="o">.</span><span class="n">gaintable</span> <span class="k">for</span> <span class="n">cf</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">calfrom</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">l</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">intent</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The observing intents to which the calibrations apply.</span>

<span class="sd">        :rtype: string</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">calto</span><span class="o">.</span><span class="n">intent</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">interp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The interp parameters to be used when applying these calibrations.</span>

<span class="sd">        :rtype: a scalar string if representing 1 calibration, otherwise a</span>
<span class="sd">                list of strings</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">l</span> <span class="o">=</span> <span class="p">[</span><span class="n">cf</span><span class="o">.</span><span class="n">interp</span> <span class="k">for</span> <span class="n">cf</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">calfrom</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">l</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">spw</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The spectral windows to which the calibrations apply.</span>

<span class="sd">        :rtype: string</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">calto</span><span class="o">.</span><span class="n">spw</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">spwmap</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The spwmap parameters to be used when applying these calibrations.</span>

<span class="sd">        :rtype: a scalar string if representing 1 calibration, otherwise a</span>
<span class="sd">                list of strings</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># convert tuples back into lists for the CASA argument</span>
        <span class="n">l</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">cf</span><span class="o">.</span><span class="n">spwmap</span><span class="p">)</span> <span class="k">for</span> <span class="n">cf</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">calfrom</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">l</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">vis</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The name of the measurement set to which the calibrations apply.</span>

<span class="sd">        :rtype: string</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">calto</span><span class="o">.</span><span class="n">vis</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_applycal</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;CalApplication(</span><span class="si">%s</span><span class="s1">, </span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">calto</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">calfrom</span><span class="p">)</span></div>



<div class="viewcode-block" id="CalTo">
<a class="viewcode-back" href="../../../_apidoc/pipeline.infrastructure.html#pipeline.infrastructure.callibrary.CalTo">[docs]</a>
<span class="k">class</span> <span class="nc">CalTo</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    CalTo represents a target data selection to which a calibration can be</span>
<span class="sd">    applied.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;_antenna&#39;</span><span class="p">,</span> <span class="s1">&#39;_intent&#39;</span><span class="p">,</span> <span class="s1">&#39;_field&#39;</span><span class="p">,</span> <span class="s1">&#39;_spw&#39;</span><span class="p">,</span> <span class="s1">&#39;_vis&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_antenna</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_intent</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_field</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_spw</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vis</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_antenna</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_intent</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_field</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_spw</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vis</span> <span class="o">=</span> <span class="n">state</span>

<div class="viewcode-block" id="CalTo.from_caltoargs">
<a class="viewcode-back" href="../../../_apidoc/pipeline.infrastructure.html#pipeline.infrastructure.callibrary.CalTo.from_caltoargs">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_caltoargs</span><span class="p">(</span><span class="n">cta</span><span class="p">:</span> <span class="n">CalToArgs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;CalTo&quot;</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">join</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">((</span><span class="nb">str</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">s</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">CalTo</span><span class="p">(</span><span class="n">vis</span><span class="o">=</span><span class="n">join</span><span class="p">(</span><span class="n">cta</span><span class="o">.</span><span class="n">vis</span><span class="p">),</span> <span class="n">field</span><span class="o">=</span><span class="n">join</span><span class="p">(</span><span class="n">cta</span><span class="o">.</span><span class="n">field</span><span class="p">),</span> <span class="n">spw</span><span class="o">=</span><span class="n">join</span><span class="p">(</span><span class="n">cta</span><span class="o">.</span><span class="n">spw</span><span class="p">),</span> <span class="n">antenna</span><span class="o">=</span><span class="n">join</span><span class="p">(</span><span class="n">cta</span><span class="o">.</span><span class="n">antenna</span><span class="p">),</span> <span class="n">intent</span><span class="o">=</span><span class="n">join</span><span class="p">(</span><span class="n">cta</span><span class="o">.</span><span class="n">intent</span><span class="p">))</span></div>


    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">field</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">spw</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">antenna</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">intent</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vis</span> <span class="o">=</span> <span class="n">vis</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">field</span> <span class="o">=</span> <span class="n">field</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spw</span> <span class="o">=</span> <span class="n">spw</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">antenna</span> <span class="o">=</span> <span class="n">antenna</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">intent</span> <span class="o">=</span> <span class="n">intent</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">antenna</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_antenna</span>

    <span class="nd">@antenna</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">antenna</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_antenna</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">find_ranges</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">field</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_field</span>

    <span class="nd">@field</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">field</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_field</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">intent</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_intent</span>

    <span class="nd">@intent</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">intent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_intent</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">spw</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_spw</span>

    <span class="nd">@spw</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">spw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_spw</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">find_ranges</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">vis</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vis</span>

    <span class="nd">@vis</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">vis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_vis</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="s1">&#39;CalTo(vis=</span><span class="se">\&#39;</span><span class="si">%s</span><span class="se">\&#39;</span><span class="s1">, field=</span><span class="se">\&#39;</span><span class="si">%s</span><span class="se">\&#39;</span><span class="s1">, spw=</span><span class="se">\&#39;</span><span class="si">%s</span><span class="se">\&#39;</span><span class="s1">, antenna=</span><span class="se">\&#39;</span><span class="si">%s</span><span class="se">\&#39;</span><span class="s1">,&#39;</span>
                <span class="s1">&#39;intent=</span><span class="se">\&#39;</span><span class="si">%s</span><span class="se">\&#39;</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vis</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">field</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spw</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">antenna</span><span class="p">,</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">intent</span><span class="p">))</span></div>



<div class="viewcode-block" id="CalFrom">
<a class="viewcode-back" href="../../../_apidoc/pipeline.infrastructure.html#pipeline.infrastructure.callibrary.CalFrom">[docs]</a>
<span class="k">class</span> <span class="nc">CalFrom</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    CalFrom represents a calibration table and the CASA arguments that should</span>
<span class="sd">    be used when applying that calibration table.</span>

<span class="sd">    .. py:attribute:: CALTYPES</span>

<span class="sd">        an enumeration of calibration table types identified by this code.</span>

<span class="sd">    .. py:attribute:: CALTYPE_TO_VISCAL</span>

<span class="sd">        mapping of calibration type to caltable identifier as store in the table</span>
<span class="sd">        header</span>

<span class="sd">    .. py:attribute:: VISCAL</span>

<span class="sd">        mapping of calibration table header information to a description of</span>
<span class="sd">        that table type</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">CALTYPES</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;unknown&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="s1">&#39;gaincal&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
        <span class="s1">&#39;bandpass&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
        <span class="s1">&#39;tsys&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
        <span class="s1">&#39;wvr&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span>
        <span class="s1">&#39;polarization&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
        <span class="s1">&#39;antpos&#39;</span><span class="p">:</span> <span class="mi">6</span><span class="p">,</span>
        <span class="s1">&#39;gc&#39;</span><span class="p">:</span> <span class="mi">7</span><span class="p">,</span>
        <span class="s1">&#39;opac&#39;</span><span class="p">:</span> <span class="mi">8</span><span class="p">,</span>
        <span class="s1">&#39;rq&#39;</span><span class="p">:</span> <span class="mi">9</span><span class="p">,</span>
        <span class="s1">&#39;swpow&#39;</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span>
        <span class="s1">&#39;finalcal&#39;</span><span class="p">:</span> <span class="mi">11</span><span class="p">,</span>
        <span class="s1">&#39;uvcont&#39;</span><span class="p">:</span> <span class="mi">12</span><span class="p">,</span>
        <span class="s1">&#39;amp&#39;</span><span class="p">:</span> <span class="mi">13</span><span class="p">,</span>
        <span class="s1">&#39;ps&#39;</span><span class="p">:</span> <span class="mi">14</span><span class="p">,</span>
        <span class="s1">&#39;otfraster&#39;</span><span class="p">:</span> <span class="mi">15</span><span class="p">,</span>
        <span class="s1">&#39;tecim&#39;</span><span class="p">:</span> <span class="mi">16</span><span class="p">,</span>
        <span class="s1">&#39;kcross&#39;</span><span class="p">:</span> <span class="mi">17</span><span class="p">,</span>
        <span class="s1">&#39;otf&#39;</span><span class="p">:</span> <span class="mi">18</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="n">CALTYPE_TO_VISCAL</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;gaincal&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;G JONES&#39;</span><span class="p">,</span> <span class="s1">&#39;GSPLINE&#39;</span><span class="p">,</span> <span class="s1">&#39;T JONES&#39;</span><span class="p">),</span>
        <span class="s1">&#39;bandpass&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;B JONES&#39;</span><span class="p">,</span> <span class="s1">&#39;BPOLY&#39;</span><span class="p">),</span>
        <span class="s1">&#39;tsys&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;B TSYS&#39;</span><span class="p">,),</span>
        <span class="s1">&#39;antpos&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;KANTPOS JONES&#39;</span><span class="p">,),</span>
        <span class="s1">&#39;uvcont&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;A MUELLER&#39;</span><span class="p">,),</span>
        <span class="c1"># &#39;amp&#39;: (&#39;G JONES&#39;,),</span>
        <span class="s1">&#39;ps&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;SDSKY_PS&#39;</span><span class="p">,),</span>
        <span class="s1">&#39;otfraster&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;SDSKY_RASTER&#39;</span><span class="p">,),</span>
        <span class="s1">&#39;otf&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;SDSKY_OTF&#39;</span><span class="p">,),</span>
    <span class="p">}</span>

    <span class="n">VISCAL</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;P JONES&#39;</span><span class="p">:</span> <span class="s1">&#39;P Jones (parallactic angle phase)&#39;</span><span class="p">,</span>
        <span class="s1">&#39;T JONES&#39;</span><span class="p">:</span> <span class="s1">&#39;T Jones (polarization-independent troposphere)&#39;</span><span class="p">,</span>
        <span class="s1">&#39;TF JONES&#39;</span><span class="p">:</span> <span class="s1">&#39;Tf Jones (frequency-dependent atmospheric complex gain)&#39;</span><span class="p">,</span>
        <span class="s1">&#39;G JONES&#39;</span><span class="p">:</span> <span class="s1">&#39;G Jones (electronic Gain)&#39;</span><span class="p">,</span>
        <span class="s1">&#39;B JONES&#39;</span><span class="p">:</span> <span class="s1">&#39;B Jones (bandpass)&#39;</span><span class="p">,</span>
        <span class="s1">&#39;DGEN JONES&#39;</span><span class="p">:</span> <span class="s1">&#39;Dgen Jones (instrumental polarization)&#39;</span><span class="p">,</span>
        <span class="s1">&#39;DFGEN JONES&#39;</span><span class="p">:</span> <span class="s1">&#39;Dfgen Jones (frequency-dependent instrumental polarization)&#39;</span><span class="p">,</span>
        <span class="s1">&#39;D JONES&#39;</span><span class="p">:</span> <span class="s1">&#39;D Jones (instrumental polarization)&#39;</span><span class="p">,</span>
        <span class="s1">&#39;DF JONES&#39;</span><span class="p">:</span> <span class="s1">&#39;Df Jones (frequency-dependent instrumental polarization)&#39;</span><span class="p">,</span>
        <span class="s1">&#39;J JONES&#39;</span><span class="p">:</span> <span class="s1">&#39;J Jones (generic polarized gain)&#39;</span><span class="p">,</span>
        <span class="s1">&#39;M MUELLER&#39;</span><span class="p">:</span> <span class="s1">&#39;M Mueller (baseline-based)&#39;</span><span class="p">,</span>
        <span class="s1">&#39;MF MUELLER&#39;</span><span class="p">:</span> <span class="s1">&#39;Mf Mueller (closure bandpass)&#39;</span><span class="p">,</span>
        <span class="s1">&#39;TOPAC&#39;</span><span class="p">:</span> <span class="s1">&#39;TOpac (Opacity corrections in amplitude)&#39;</span><span class="p">,</span>
        <span class="s1">&#39;TFOPAC&#39;</span><span class="p">:</span> <span class="s1">&#39;TfOpac (frequency-dependent opacity)&#39;</span><span class="p">,</span>
        <span class="s1">&#39;X MUELLER&#39;</span><span class="p">:</span> <span class="s1">&#39;X Mueller (baseline-based)&#39;</span><span class="p">,</span>
        <span class="s1">&#39;X JONES&#39;</span><span class="p">:</span> <span class="s1">&#39;X Jones (antenna-based)&#39;</span><span class="p">,</span>
        <span class="s1">&#39;XF JONES&#39;</span><span class="p">:</span> <span class="s1">&#39;Xf Jones (antenna-based)&#39;</span><span class="p">,</span>
        <span class="s1">&#39;GLINXPH JONES&#39;</span><span class="p">:</span> <span class="s1">&#39;GlinXph Jones (X-Y phase)&#39;</span><span class="p">,</span>
        <span class="s1">&#39;B TSYS&#39;</span><span class="p">:</span> <span class="s1">&#39;B TSYS (freq-dep Tsys)&#39;</span><span class="p">,</span>
        <span class="s1">&#39;BPOLY&#39;</span><span class="p">:</span> <span class="s1">&#39;B Jones Poly (bandpass)&#39;</span><span class="p">,</span>
        <span class="s1">&#39;GSPLINE&#39;</span><span class="p">:</span> <span class="s1">&#39;G Jones SPLINE (elec. gain)&#39;</span><span class="p">,</span>
        <span class="s1">&#39;KANTPOS JONES&#39;</span><span class="p">:</span> <span class="s1">&#39;KAntPos Jones (antenna position errors)&#39;</span><span class="p">,</span>
        <span class="s1">&#39;A MUELLER&#39;</span><span class="p">:</span> <span class="s1">&#39;A Mueller (baseline-based)&#39;</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="c1"># Hundreds of thousands of CalFroms can be created and stored in a context.</span>
    <span class="c1"># To save memory, CalFrom uses a Flyweight pattern, caching objects in</span>
    <span class="c1"># _CalFromPool and returning a shared immutable instance for CalFroms</span>
    <span class="c1"># constructed with the same arguments.</span>
    <span class="n">_CalFromPool</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">WeakValueDictionary</span><span class="p">()</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_calc_hash</span><span class="p">(</span><span class="n">gaintable</span><span class="p">,</span> <span class="n">gainfield</span><span class="p">,</span> <span class="n">interp</span><span class="p">,</span> <span class="n">spwmap</span><span class="p">,</span> <span class="n">calwt</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate a hash code unique to the given arguments.</span>

<span class="sd">        :rtype: integer</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="mi">17</span>
        <span class="n">result</span> <span class="o">=</span> <span class="mi">37</span> <span class="o">*</span> <span class="n">result</span> <span class="o">+</span> <span class="nb">hash</span><span class="p">(</span><span class="n">gaintable</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="mi">37</span> <span class="o">*</span> <span class="n">result</span> <span class="o">+</span> <span class="nb">hash</span><span class="p">(</span><span class="n">gainfield</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="mi">37</span> <span class="o">*</span> <span class="n">result</span> <span class="o">+</span> <span class="nb">hash</span><span class="p">(</span><span class="n">interp</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="mi">37</span> <span class="o">*</span> <span class="n">result</span> <span class="o">+</span> <span class="nb">hash</span><span class="p">(</span><span class="n">spwmap</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="mi">37</span> <span class="o">*</span> <span class="n">result</span> <span class="o">+</span> <span class="nb">hash</span><span class="p">(</span><span class="n">calwt</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">gaintable</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">gainfield</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">interp</span><span class="o">=</span><span class="s1">&#39;linear,linear&#39;</span><span class="p">,</span>
                <span class="n">spwmap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">caltype</span><span class="o">=</span><span class="s1">&#39;unknown&#39;</span><span class="p">,</span> <span class="n">calwt</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">spwmap</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">spwmap</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="n">gaintable</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;gaintable must be specified. Got None&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">gainfield</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;gainfield must be a string. Got </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">gainfield</span><span class="p">))</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">interp</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;interp must be a string. Got </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">interp</span><span class="p">))</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">spwmap</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">spwmap</span> <span class="o">=</span> <span class="p">[</span><span class="n">spw</span> <span class="k">for</span> <span class="n">spw</span> <span class="ow">in</span> <span class="n">spwmap</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">spwmap</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;spwmap must be a list. Got </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">spwmap</span><span class="p">))</span>
        <span class="c1"># Flyweight instances should be immutable, so convert spwmap to a</span>
        <span class="c1"># tuple. This also makes spwmap hashable for our hash function.</span>
        <span class="n">spwmap</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">o</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">spwmap</span><span class="p">])</span>

        <span class="n">caltype</span> <span class="o">=</span> <span class="n">caltype</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="k">assert</span> <span class="n">caltype</span> <span class="ow">in</span> <span class="n">CalFrom</span><span class="o">.</span><span class="n">CALTYPES</span>

        <span class="n">arg_hash</span> <span class="o">=</span> <span class="n">CalFrom</span><span class="o">.</span><span class="n">_calc_hash</span><span class="p">(</span><span class="n">gaintable</span><span class="p">,</span> <span class="n">gainfield</span><span class="p">,</span> <span class="n">interp</span><span class="p">,</span> <span class="n">spwmap</span><span class="p">,</span>
                                      <span class="n">calwt</span><span class="p">)</span>

        <span class="n">obj</span> <span class="o">=</span> <span class="n">CalFrom</span><span class="o">.</span><span class="n">_CalFromPool</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">arg_hash</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">obj</span><span class="p">:</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;Creating new CalFrom(gaintable=</span><span class="se">\&#39;</span><span class="si">%s</span><span class="se">\&#39;</span><span class="s1">, &#39;</span>
                      <span class="s1">&#39;gainfield=</span><span class="se">\&#39;</span><span class="si">%s</span><span class="se">\&#39;</span><span class="s1">, interp=</span><span class="se">\&#39;</span><span class="si">%s</span><span class="se">\&#39;</span><span class="s1">, spwmap=</span><span class="si">%s</span><span class="s1">, &#39;</span>
                      <span class="s1">&#39;caltype=</span><span class="se">\&#39;</span><span class="si">%s</span><span class="se">\&#39;</span><span class="s1">, calwt=</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span>
                      <span class="p">(</span><span class="n">gaintable</span><span class="p">,</span> <span class="n">gainfield</span><span class="p">,</span> <span class="n">interp</span><span class="p">,</span> <span class="n">spwmap</span><span class="p">,</span> <span class="n">caltype</span><span class="p">,</span> <span class="n">calwt</span><span class="p">))</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="nb">object</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">__gaintable</span> <span class="o">=</span> <span class="n">gaintable</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">__gainfield</span> <span class="o">=</span> <span class="n">gainfield</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">__interp</span> <span class="o">=</span> <span class="n">interp</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">__spwmap</span> <span class="o">=</span> <span class="n">spwmap</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">__caltype</span> <span class="o">=</span> <span class="n">caltype</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">__calwt</span> <span class="o">=</span> <span class="n">calwt</span>

            <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Adding new CalFrom to pool: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">obj</span><span class="p">)</span>
            <span class="n">CalFrom</span><span class="o">.</span><span class="n">_CalFromPool</span><span class="p">[</span><span class="n">arg_hash</span><span class="p">]</span> <span class="o">=</span> <span class="n">obj</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;New pool contents: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="nb">list</span><span class="p">(</span><span class="n">CalFrom</span><span class="o">.</span><span class="n">_CalFromPool</span><span class="o">.</span><span class="n">items</span><span class="p">()))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;Reusing existing CalFrom(gaintable=</span><span class="se">\&#39;</span><span class="si">%s</span><span class="se">\&#39;</span><span class="s1">, &#39;</span>
                      <span class="s1">&#39;gainfield=</span><span class="se">\&#39;</span><span class="si">%s</span><span class="se">\&#39;</span><span class="s1">, interp=</span><span class="se">\&#39;</span><span class="si">%s</span><span class="se">\&#39;</span><span class="s1">, spwmap=</span><span class="se">\&#39;</span><span class="si">%s</span><span class="se">\&#39;</span><span class="s1">, &#39;</span>
                      <span class="s1">&#39;caltype=</span><span class="se">\&#39;</span><span class="si">%s</span><span class="se">\&#39;</span><span class="s1">, calwt=</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span>
                      <span class="p">(</span><span class="n">gaintable</span><span class="p">,</span> <span class="n">gainfield</span><span class="p">,</span> <span class="n">interp</span><span class="p">,</span> <span class="n">spwmap</span><span class="p">,</span> <span class="n">caltype</span><span class="p">,</span> <span class="n">calwt</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">obj</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;__caltype&#39;</span><span class="p">,</span> <span class="s1">&#39;__calwt&#39;</span><span class="p">,</span> <span class="s1">&#39;__gainfield&#39;</span><span class="p">,</span> <span class="s1">&#39;__gaintable&#39;</span><span class="p">,</span>
                 <span class="s1">&#39;__interp&#39;</span><span class="p">,</span> <span class="s1">&#39;__spwmap&#39;</span><span class="p">,</span> <span class="s1">&#39;__weakref__&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__caltype</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__calwt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__gainfield</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__gaintable</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__interp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__spwmap</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="c1"># a misguided attempt to clear stale CalFroms when loading from a</span>
        <span class="c1"># pickle. I don&#39;t think this should be done here.</span>
        <span class="c1">#         # prevent exception with pickle format #1 by calling hash on properties</span>
        <span class="c1">#         # rather than the object</span>
        <span class="c1">#         (_, calwt, gainfield, gaintable, interp, spwmap) = state</span>
        <span class="c1">#         old_hash = CalFrom._calc_hash(gaintable, gainfield, interp, spwmap, calwt)</span>
        <span class="c1">#         if old_hash in CalFrom._CalFromPool:</span>
        <span class="c1">#             del CalFrom._CalFromPool[old_hash]</span>

        <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__caltype</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__calwt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__gainfield</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__gaintable</span><span class="p">,</span>
         <span class="bp">self</span><span class="o">.</span><span class="n">__interp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__spwmap</span><span class="p">)</span> <span class="o">=</span> <span class="n">state</span>

    <span class="k">def</span> <span class="nf">__getnewargs__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gaintable</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gainfield</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">interp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spwmap</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">caltype</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">calwt</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">caltype</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__caltype</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">calwt</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__calwt</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">gainfield</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__gainfield</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">gaintable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__gaintable</span>

<div class="viewcode-block" id="CalFrom.get_caltype_for_viscal">
<a class="viewcode-back" href="../../../_apidoc/pipeline.infrastructure.html#pipeline.infrastructure.callibrary.CalFrom.get_caltype_for_viscal">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">get_caltype_for_viscal</span><span class="p">(</span><span class="n">viscal</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">viscal</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">caltype</span><span class="p">,</span> <span class="n">viscals</span> <span class="ow">in</span> <span class="n">CalFrom</span><span class="o">.</span><span class="n">CALTYPE_TO_VISCAL</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">viscals</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">caltype</span>
        <span class="k">return</span> <span class="s1">&#39;unknown&#39;</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">interp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__interp</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">spwmap</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__spwmap</span>

    <span class="c1">#     def __eq__(self, other):</span>
    <span class="c1">#         return (self.gaintable == other.gaintable and</span>
    <span class="c1">#                 self.gainfield == other.gainfield and</span>
    <span class="c1">#                 self.interp    == other.interp    and</span>
    <span class="c1">#                 self.spwmap    == other.spwmap    and</span>
    <span class="c1">#                 self.calwt     == other.calwt)</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">CalFrom</span><span class="o">.</span><span class="n">_calc_hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gaintable</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gainfield</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">interp</span><span class="p">,</span>
                                  <span class="bp">self</span><span class="o">.</span><span class="n">spwmap</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">calwt</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="s1">&#39;CalFrom(</span><span class="se">\&#39;</span><span class="si">%s</span><span class="se">\&#39;</span><span class="s1">, gainfield=</span><span class="se">\&#39;</span><span class="si">%s</span><span class="se">\&#39;</span><span class="s1">, interp=</span><span class="se">\&#39;</span><span class="si">%s</span><span class="se">\&#39;</span><span class="s1">, spwmap=</span><span class="si">%s</span><span class="s1">, &#39;</span>
                <span class="s1">&#39;caltype=</span><span class="se">\&#39;</span><span class="si">%s</span><span class="se">\&#39;</span><span class="s1">, calwt=</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gaintable</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gainfield</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">interp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spwmap</span><span class="p">,</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">caltype</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">calwt</span><span class="p">))</span></div>



<div class="viewcode-block" id="CalToIdAdapter">
<a class="viewcode-back" href="../../../_apidoc/pipeline.infrastructure.html#pipeline.infrastructure.callibrary.CalToIdAdapter">[docs]</a>
<span class="k">class</span> <span class="nc">CalToIdAdapter</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">calto</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_context</span> <span class="o">=</span> <span class="n">context</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_calto</span> <span class="o">=</span> <span class="n">calto</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">antenna</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">id</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ms</span><span class="o">.</span><span class="n">get_antenna</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_calto</span><span class="o">.</span><span class="n">antenna</span><span class="p">)]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">field</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">fields</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ms</span><span class="o">.</span><span class="n">get_fields</span><span class="p">(</span><span class="n">task_arg</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_calto</span><span class="o">.</span><span class="n">field</span><span class="p">)]</span>
        <span class="c1"># if the field names are unique, we can return field names. Otherwise,</span>
        <span class="c1"># we fall back to field IDs.</span>
        <span class="n">all_field_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ms</span><span class="o">.</span><span class="n">get_fields</span><span class="p">()]</span>
        <span class="c1">### Activate the following line for NRO ###</span>
        <span class="c1">#         return [f.id for f in fields]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">all_field_names</span><span class="p">))</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_field_names</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">f</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">fields</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">f</span><span class="o">.</span><span class="n">id</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">fields</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">intent</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># return the intents present in the CalTo</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calto</span><span class="o">.</span><span class="n">intent</span>

<div class="viewcode-block" id="CalToIdAdapter.get_field_intents">
<a class="viewcode-back" href="../../../_apidoc/pipeline.infrastructure.html#pipeline.infrastructure.callibrary.CalToIdAdapter.get_field_intents">[docs]</a>
    <span class="k">def</span> <span class="nf">get_field_intents</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">field_id</span><span class="p">,</span> <span class="n">spw_id</span><span class="p">):</span>
        <span class="n">field</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_field</span><span class="p">(</span><span class="n">field_id</span><span class="p">)</span>
        <span class="n">field_intents</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="n">intents</span>

        <span class="n">spw</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_spw</span><span class="p">(</span><span class="n">spw_id</span><span class="p">)</span>
        <span class="n">spw_intents</span> <span class="o">=</span> <span class="n">spw</span><span class="o">.</span><span class="n">intents</span>

        <span class="n">user_intents</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_calto</span><span class="o">.</span><span class="n">intent</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calto</span><span class="o">.</span><span class="n">intent</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
            <span class="n">user_intents</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="n">intents</span>

        <span class="k">return</span> <span class="n">user_intents</span> <span class="o">&amp;</span> <span class="n">field_intents</span> <span class="o">&amp;</span> <span class="n">spw_intents</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_context</span><span class="o">.</span><span class="n">observing_run</span><span class="o">.</span><span class="n">get_ms</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_calto</span><span class="o">.</span><span class="n">vis</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">spw</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">spw</span><span class="o">.</span><span class="n">id</span> <span class="k">for</span> <span class="n">spw</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ms</span><span class="o">.</span><span class="n">get_spectral_windows</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_calto</span><span class="o">.</span><span class="n">spw</span><span class="p">,</span> <span class="n">science_windows_only</span><span class="o">=</span><span class="kc">False</span><span class="p">)]</span>

    <span class="k">def</span> <span class="nf">_get_field</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">field_id</span><span class="p">):</span>
        <span class="n">fields</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ms</span><span class="o">.</span><span class="n">get_fields</span><span class="p">(</span><span class="n">task_arg</span><span class="o">=</span><span class="n">field_id</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">fields</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Illegal field ID </span><span class="se">\&#39;</span><span class="si">%s</span><span class="se">\&#39;</span><span class="s1"> for vis </span><span class="se">\&#39;</span><span class="si">%s</span><span class="se">\&#39;</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">field_id</span><span class="p">,</span>
                                                              <span class="bp">self</span><span class="o">.</span><span class="n">_calto</span><span class="o">.</span><span class="n">vis</span><span class="p">)</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fields</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_get_spw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spw_id</span><span class="p">):</span>
        <span class="n">spws</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ms</span><span class="o">.</span><span class="n">get_spectral_windows</span><span class="p">(</span><span class="n">spw_id</span><span class="p">,</span>
                                            <span class="n">science_windows_only</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">spws</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Illegal spw ID </span><span class="se">\&#39;</span><span class="si">%s</span><span class="se">\&#39;</span><span class="s1"> for vis </span><span class="se">\&#39;</span><span class="si">%s</span><span class="se">\&#39;</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">spw_id</span><span class="p">,</span>
                                                            <span class="bp">self</span><span class="o">.</span><span class="n">_calto</span><span class="o">.</span><span class="n">vis</span><span class="p">)</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">spws</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="s1">&#39;CalToIdAdapter(ms=</span><span class="se">\&#39;</span><span class="si">%s</span><span class="se">\&#39;</span><span class="s1">, field=</span><span class="se">\&#39;</span><span class="si">%s</span><span class="se">\&#39;</span><span class="s1">, intent=</span><span class="se">\&#39;</span><span class="si">%s</span><span class="se">\&#39;</span><span class="s1">, &#39;</span>
                <span class="s1">&#39;spw=</span><span class="si">%s</span><span class="s1">, antenna=</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ms</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">field</span><span class="p">,</span>
                                         <span class="bp">self</span><span class="o">.</span><span class="n">intent</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spw</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">antenna</span><span class="p">))</span></div>



<span class="c1"># CalState extends defaultdict. For defaultdicts to be pickleable, their</span>
<span class="c1"># default factories must be defined at the module level.</span>
<span class="k">def</span> <span class="nf">_antenna_dim</span><span class="p">():</span> <span class="k">return</span> <span class="p">[]</span>


<span class="k">def</span> <span class="nf">_intent_dim</span><span class="p">():</span> <span class="k">return</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="n">_antenna_dim</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_field_dim</span><span class="p">():</span> <span class="k">return</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="n">_intent_dim</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_spw_dim</span><span class="p">():</span> <span class="k">return</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="n">_field_dim</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_ms_dim</span><span class="p">():</span> <span class="k">return</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="n">_spw_dim</span><span class="p">)</span>


<div class="viewcode-block" id="DictCalState">
<a class="viewcode-back" href="../../../_apidoc/pipeline.infrastructure.html#pipeline.infrastructure.callibrary.DictCalState">[docs]</a>
<span class="k">class</span> <span class="nc">DictCalState</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    DictCalState is a data structure used to map calibrations for all data</span>
<span class="sd">    registered with the pipeline.</span>

<span class="sd">    It is implemented as a multi-dimensional array indexed by data selection</span>
<span class="sd">    parameters (ms, spw, field, intent, antenna), with the end value being a</span>
<span class="sd">    list of CalFroms, representing the calibrations to be applied to that data</span>
<span class="sd">    selection.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">default_factory</span><span class="o">=</span><span class="n">_ms_dim</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">DictCalState</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">default_factory</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_removed</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__reduce__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  <span class="c1"># optional, for pickle support</span>
        <span class="n">super_state</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">DictCalState</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__reduce__</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">super_state</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_removed</span><span class="p">,</span> <span class="n">super_state</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">super_state</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_removed</span> <span class="o">=</span> <span class="n">state</span>

<div class="viewcode-block" id="DictCalState.global_remove">
<a class="viewcode-back" href="../../../_apidoc/pipeline.infrastructure.html#pipeline.infrastructure.callibrary.DictCalState.global_remove">[docs]</a>
    <span class="k">def</span> <span class="nf">global_remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">calfrom</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Mark a CalFrom as being removed from the calibration state. Rather than</span>
<span class="sd">        iterating through the registered calibrations, this adds the CalFrom to</span>
<span class="sd">        a set of object to be ignored. When the calibrations are subsequently</span>
<span class="sd">        inspected, CalFroms marked as removed will be bypassed.</span>

<span class="sd">        :param calfrom: the CalFrom to remove</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_removed</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">calfrom</span><span class="p">)</span></div>


<div class="viewcode-block" id="DictCalState.global_reactivate">
<a class="viewcode-back" href="../../../_apidoc/pipeline.infrastructure.html#pipeline.infrastructure.callibrary.DictCalState.global_reactivate">[docs]</a>
    <span class="k">def</span> <span class="nf">global_reactivate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">calfroms</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reactivate a CalFrom that was marked as ignored through a call to</span>
<span class="sd">        global_remove.</span>

<span class="sd">        This will reactivate the CalFrom entry, making it appear at whatever</span>
<span class="sd">        index in the CalApplications that it was originally registered, e.g.</span>
<span class="sd">        if a CalFrom was &#39;deleted&#39; via a call to global_remove and 3 more</span>
<span class="sd">        CalFroms were added to the CalState, when the CalFrom is reactivated</span>
<span class="sd">        it will appear in the original position - that is, before the 3</span>
<span class="sd">        subsequent CalFroms, rather than appearing at the end of the list.</span>

<span class="sd">        :param calfroms: the CalFroms to reactivate</span>
<span class="sd">        :type calfroms: a set of CalFrom objects</span>
<span class="sd">        :return: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;Globally reactivating </span><span class="si">%s</span><span class="s1"> CalFroms: </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span>
                  <span class="nb">len</span><span class="p">(</span><span class="n">calfroms</span><span class="p">),</span> <span class="n">calfroms</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_removed</span> <span class="o">-=</span> <span class="n">calfroms</span></div>


<div class="viewcode-block" id="DictCalState.get_caltable">
<a class="viewcode-back" href="../../../_apidoc/pipeline.infrastructure.html#pipeline.infrastructure.callibrary.DictCalState.get_caltable">[docs]</a>
    <span class="k">def</span> <span class="nf">get_caltable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">caltypes</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the names of all caltables registered with this CalState.</span>

<span class="sd">        If an optional caltypes argument is given, only caltables of the</span>
<span class="sd">        requested type will be returned.</span>

<span class="sd">        :param caltypes: Caltypes should be one or/a list of table</span>
<span class="sd">        types known in CalFrom.CALTYPES.</span>

<span class="sd">        :rtype: set of strings</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">caltypes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">caltypes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">CalFrom</span><span class="o">.</span><span class="n">CALTYPES</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">caltypes</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">caltypes</span> <span class="o">=</span> <span class="p">(</span><span class="n">caltypes</span><span class="p">,)</span>

        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">caltypes</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">CalFrom</span><span class="o">.</span><span class="n">CALTYPES</span>

        <span class="n">calfroms</span> <span class="o">=</span> <span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">merged</span><span class="p">()</span><span class="o">.</span><span class="n">values</span><span class="p">())))</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">cf</span><span class="o">.</span><span class="n">gaintable</span> <span class="k">for</span> <span class="n">cf</span> <span class="ow">in</span> <span class="n">calfroms</span> <span class="k">if</span> <span class="n">cf</span><span class="o">.</span><span class="n">caltype</span> <span class="ow">in</span> <span class="n">caltypes</span><span class="p">}</span></div>


<div class="viewcode-block" id="DictCalState.dictify">
<a class="viewcode-back" href="../../../_apidoc/pipeline.infrastructure.html#pipeline.infrastructure.callibrary.DictCalState.dictify">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">dictify</span><span class="p">(</span><span class="n">dd</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get a standard dictionary of the items in the tree.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">k</span><span class="p">,</span> <span class="p">(</span><span class="n">DictCalState</span><span class="o">.</span><span class="n">dictify</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> <span class="k">else</span> <span class="n">v</span><span class="p">))</span>
                     <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="n">dd</span><span class="o">.</span><span class="n">items</span><span class="p">()])</span></div>


<div class="viewcode-block" id="DictCalState.merged">
<a class="viewcode-back" href="../../../_apidoc/pipeline.infrastructure.html#pipeline.infrastructure.callibrary.DictCalState.merged">[docs]</a>
    <span class="k">def</span> <span class="nf">merged</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hide_empty</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">hashes</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">flattened</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flattened</span><span class="p">(</span><span class="n">hide_empty</span><span class="o">=</span><span class="n">hide_empty</span><span class="p">)</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">calto_tup</span><span class="p">,</span> <span class="n">calfrom</span><span class="p">)</span> <span class="ow">in</span> <span class="n">flattened</span><span class="p">:</span>
            <span class="c1"># create a tuple, as lists are not hashable</span>
            <span class="n">calfrom_hash</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="nb">hash</span><span class="p">(</span><span class="n">cf</span><span class="p">)</span> <span class="k">for</span> <span class="n">cf</span> <span class="ow">in</span> <span class="n">calfrom</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">calfrom_hash</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">hashes</span><span class="p">:</span>
                <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;Creating new CalFrom hash for </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">calfrom</span><span class="p">)</span>
                <span class="n">calto_args</span> <span class="o">=</span> <span class="n">CalToArgs</span><span class="p">(</span><span class="o">*</span><span class="p">[[</span><span class="n">x</span><span class="p">,</span> <span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">calto_tup</span><span class="p">])</span>
                <span class="n">hashes</span><span class="p">[</span><span class="n">calfrom_hash</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">calto_args</span><span class="p">,</span> <span class="n">calfrom</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">calto_args</span> <span class="o">=</span> <span class="n">hashes</span><span class="p">[</span><span class="n">calfrom_hash</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

                <span class="k">for</span> <span class="n">old_key</span><span class="p">,</span> <span class="n">new_key</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">calto_args</span><span class="p">,</span> <span class="n">calto_tup</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">new_key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">old_key</span><span class="p">:</span>
                        <span class="n">old_key</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_key</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">calto_tup</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">hashes</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">calto_tup</span><span class="p">:</span>
                <span class="n">l</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

        <span class="n">result</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">calto_args</span><span class="p">,</span> <span class="n">calfrom</span> <span class="ow">in</span> <span class="n">hashes</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">vis</span> <span class="ow">in</span> <span class="n">calto_args</span><span class="o">.</span><span class="n">vis</span><span class="p">:</span>
                <span class="n">calto</span> <span class="o">=</span> <span class="n">CalTo</span><span class="p">(</span><span class="n">vis</span><span class="o">=</span><span class="n">vis</span><span class="p">,</span>
                              <span class="n">spw</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_commafy</span><span class="p">(</span><span class="n">calto_args</span><span class="o">.</span><span class="n">spw</span><span class="p">),</span>
                              <span class="n">field</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_commafy</span><span class="p">(</span><span class="n">calto_args</span><span class="o">.</span><span class="n">field</span><span class="p">),</span>
                              <span class="n">intent</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_commafy</span><span class="p">(</span><span class="n">calto_args</span><span class="o">.</span><span class="n">intent</span><span class="p">),</span>
                              <span class="n">antenna</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_commafy</span><span class="p">(</span><span class="n">calto_args</span><span class="o">.</span><span class="n">antenna</span><span class="p">))</span>
                <span class="n">result</span><span class="p">[</span><span class="n">calto</span><span class="p">]</span> <span class="o">=</span> <span class="n">calfrom</span>

        <span class="k">return</span> <span class="n">result</span></div>


    <span class="k">def</span> <span class="nf">_commafy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">l</span><span class="o">=</span><span class="p">[]):</span>
        <span class="k">return</span> <span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">l</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">_flattened</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hide_empty</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="n">active</span> <span class="o">=</span> <span class="p">((</span><span class="n">ct_tuple</span><span class="p">,</span> <span class="p">[</span><span class="n">cf</span> <span class="k">for</span> <span class="n">cf</span> <span class="ow">in</span> <span class="n">cf_list</span> <span class="k">if</span> <span class="n">cf</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_removed</span><span class="p">])</span>
                  <span class="k">for</span> <span class="p">(</span><span class="n">ct_tuple</span><span class="p">,</span> <span class="n">cf_list</span><span class="p">)</span> <span class="ow">in</span> <span class="n">utils</span><span class="o">.</span><span class="n">flatten_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">hide_empty</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">((</span><span class="n">ct_tuple</span><span class="p">,</span> <span class="n">cf_list</span><span class="p">)</span> <span class="k">for</span> <span class="n">ct_tuple</span><span class="p">,</span> <span class="n">cf_list</span> <span class="ow">in</span> <span class="n">active</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cf_list</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">active</span>

<div class="viewcode-block" id="DictCalState.as_applycal">
<a class="viewcode-back" href="../../../_apidoc/pipeline.infrastructure.html#pipeline.infrastructure.callibrary.DictCalState.as_applycal">[docs]</a>
    <span class="k">def</span> <span class="nf">as_applycal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">calapps</span> <span class="o">=</span> <span class="p">[</span><span class="n">CalApplication</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
                   <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">merged</span><span class="p">(</span><span class="n">hide_empty</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">()]</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">calapps</span><span class="p">])</span></div>


    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_applycal</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_applycal</span><span class="p">()</span></div>



<span class="c1">#        return &#39;CalState(%s)&#39; % repr(CalState.dictify(self.merged))</span>


<div class="viewcode-block" id="DictCalLibrary">
<a class="viewcode-back" href="../../../_apidoc/pipeline.infrastructure.html#pipeline.infrastructure.callibrary.DictCalLibrary">[docs]</a>
<span class="k">class</span> <span class="nc">DictCalLibrary</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    CalLibrary is the root object for the pipeline calibration state.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_context</span> <span class="o">=</span> <span class="n">context</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_active</span> <span class="o">=</span> <span class="n">DictCalState</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_applied</span> <span class="o">=</span> <span class="n">DictCalState</span><span class="p">()</span>

<div class="viewcode-block" id="DictCalLibrary.clear">
<a class="viewcode-back" href="../../../_apidoc/pipeline.infrastructure.html#pipeline.infrastructure.callibrary.DictCalLibrary.clear">[docs]</a>
    <span class="k">def</span> <span class="nf">clear</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_active</span> <span class="o">=</span> <span class="n">DictCalState</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_applied</span> <span class="o">=</span> <span class="n">DictCalState</span><span class="p">()</span></div>


    <span class="k">def</span> <span class="nf">_add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">calto</span><span class="p">,</span> <span class="n">calfroms</span><span class="p">,</span> <span class="n">calstate</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">calfroms</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">calfroms</span> <span class="o">=</span> <span class="p">[</span><span class="n">calfroms</span><span class="p">]</span>

        <span class="n">calto</span> <span class="o">=</span> <span class="n">CalToIdAdapter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_context</span><span class="p">,</span> <span class="n">calto</span><span class="p">)</span>
        <span class="n">ms_name</span> <span class="o">=</span> <span class="n">calto</span><span class="o">.</span><span class="n">ms</span><span class="o">.</span><span class="n">name</span>

        <span class="k">for</span> <span class="n">spw_id</span> <span class="ow">in</span> <span class="n">calto</span><span class="o">.</span><span class="n">spw</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">field_id</span> <span class="ow">in</span> <span class="n">calto</span><span class="o">.</span><span class="n">field</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">intent</span> <span class="ow">in</span> <span class="n">calto</span><span class="o">.</span><span class="n">get_field_intents</span><span class="p">(</span><span class="n">field_id</span><span class="p">,</span> <span class="n">spw_id</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">antenna_id</span> <span class="ow">in</span> <span class="n">calto</span><span class="o">.</span><span class="n">antenna</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">cf</span> <span class="ow">in</span> <span class="n">calfroms</span><span class="p">:</span>
                            <span class="c1"># now that we use immutable CalFroms, we don&#39;t</span>
                            <span class="c1"># need to deepcopy the object we are appending</span>
                            <span class="n">calstate</span><span class="p">[</span><span class="n">ms_name</span><span class="p">][</span><span class="n">spw_id</span><span class="p">][</span><span class="n">field_id</span><span class="p">][</span><span class="n">intent</span><span class="p">][</span><span class="n">antenna_id</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cf</span><span class="p">)</span>

        <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;Calstate after _add:</span><span class="se">\n</span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">calstate</span><span class="o">.</span><span class="n">as_applycal</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">_calc_filename</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">filename</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">filename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_context</span><span class="o">.</span><span class="n">output_dir</span><span class="p">,</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">_context</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;.calstate&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">filename</span>

    <span class="k">def</span> <span class="nf">_export</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">calstate</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calc_filename</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>

        <span class="n">calapps</span> <span class="o">=</span> <span class="p">[</span><span class="n">CalApplication</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">calstate</span><span class="o">.</span><span class="n">merged</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">()]</span>

        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">export_file</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ca</span> <span class="ow">in</span> <span class="n">calapps</span><span class="p">:</span>
                <span class="n">export_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">ca</span><span class="o">.</span><span class="n">as_applycal</span><span class="p">())</span>
                <span class="n">export_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">calstate</span><span class="p">,</span> <span class="n">calfrom</span><span class="p">,</span> <span class="n">calto</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># If this is a global removal, as signified by the lack of a CalTo to</span>
        <span class="c1"># give any target data selection, we can simply mark the CalFrom as</span>
        <span class="c1"># removed</span>
        <span class="k">if</span> <span class="n">calto</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">calstate</span><span class="o">.</span><span class="n">global_remove</span><span class="p">(</span><span class="n">calfrom</span><span class="p">)</span>

        <span class="c1"># But if this is a partial removal, go through the dictionary</span>
        <span class="c1"># dimensions and remove it from the data selection specified by the</span>
        <span class="c1"># CalTo</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">calfrom</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">calfrom</span> <span class="o">=</span> <span class="p">[</span><span class="n">calfrom</span><span class="p">]</span>

            <span class="n">calto</span> <span class="o">=</span> <span class="n">CalToIdAdapter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_context</span><span class="p">,</span> <span class="n">calto</span><span class="p">)</span>
            <span class="n">ms_name</span> <span class="o">=</span> <span class="n">calto</span><span class="o">.</span><span class="n">ms</span><span class="o">.</span><span class="n">name</span>

            <span class="k">for</span> <span class="n">spw_id</span> <span class="ow">in</span> <span class="n">calto</span><span class="o">.</span><span class="n">spw</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">field_id</span> <span class="ow">in</span> <span class="n">calto</span><span class="o">.</span><span class="n">field</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">intent</span> <span class="ow">in</span> <span class="n">calto</span><span class="o">.</span><span class="n">get_field_intents</span><span class="p">(</span><span class="n">field_id</span><span class="p">,</span> <span class="n">spw_id</span><span class="p">):</span>
                        <span class="k">for</span> <span class="n">antenna_id</span> <span class="ow">in</span> <span class="n">calto</span><span class="o">.</span><span class="n">antenna</span><span class="p">:</span>
                            <span class="n">current</span> <span class="o">=</span> <span class="n">calstate</span><span class="p">[</span><span class="n">ms_name</span><span class="p">][</span><span class="n">spw_id</span><span class="p">][</span><span class="n">field_id</span><span class="p">][</span><span class="n">intent</span><span class="p">][</span><span class="n">antenna_id</span><span class="p">]</span>
                            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">calfrom</span><span class="p">:</span>
                                <span class="k">try</span><span class="p">:</span>
                                    <span class="n">current</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
                                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                                    <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> not found in calstate&#39;</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">LOG</span><span class="o">.</span><span class="n">isEnabledFor</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">TRACE</span><span class="p">):</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;Calstate after _remove:</span><span class="se">\n</span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">calstate</span><span class="o">.</span><span class="n">as_applycal</span><span class="p">())</span>

<div class="viewcode-block" id="DictCalLibrary.add">
<a class="viewcode-back" href="../../../_apidoc/pipeline.infrastructure.html#pipeline.infrastructure.callibrary.DictCalLibrary.add">[docs]</a>
    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">calto</span><span class="p">,</span> <span class="n">calfroms</span><span class="p">):</span>
        <span class="c1"># If we are adding a previously removed CalFrom back into a</span>
        <span class="c1"># CalState, we assume that the user really want the previous</span>
        <span class="c1"># CalFrom not to be ignored in future runs rather than adding</span>
        <span class="c1"># a second entry for this CalFrom into the CalState.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">calfroms</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Iterable</span><span class="p">):</span>
            <span class="n">calfroms</span> <span class="o">=</span> <span class="p">[</span><span class="n">calfroms</span><span class="p">]</span>

        <span class="n">calfroms_to_reactivate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_active</span><span class="o">.</span><span class="n">_removed</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">calfroms</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_active</span><span class="o">.</span><span class="n">global_reactivate</span><span class="p">(</span><span class="n">calfroms_to_reactivate</span><span class="p">)</span>

        <span class="n">calfroms_to_add</span> <span class="o">=</span> <span class="p">[</span><span class="n">cf</span> <span class="k">for</span> <span class="n">cf</span> <span class="ow">in</span> <span class="n">calfroms</span> <span class="k">if</span> <span class="n">cf</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">calfroms_to_reactivate</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">calfroms_to_add</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_add</span><span class="p">(</span><span class="n">calto</span><span class="p">,</span> <span class="n">calfroms_to_add</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_active</span><span class="p">)</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">active</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        CalState holding CalApplications to be (pre-)applied to the MS.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_active</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">applied</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        CalState holding CalApplications that have been applied to the MS via</span>
<span class="sd">        the pipeline applycal task.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_applied</span>

<div class="viewcode-block" id="DictCalLibrary.export">
<a class="viewcode-back" href="../../../_apidoc/pipeline.infrastructure.html#pipeline.infrastructure.callibrary.DictCalLibrary.export">[docs]</a>
    <span class="k">def</span> <span class="nf">export</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Export the pre-apply calibration state to disk.</span>

<span class="sd">        The pre-apply calibrations held in the &#39;active&#39; CalState will be</span>
<span class="sd">        written to disk as a set of equivalent applycal calls.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calc_filename</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Exporting current calibration state to </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_export</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_active</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span></div>


<div class="viewcode-block" id="DictCalLibrary.export_applied">
<a class="viewcode-back" href="../../../_apidoc/pipeline.infrastructure.html#pipeline.infrastructure.callibrary.DictCalLibrary.export_applied">[docs]</a>
    <span class="k">def</span> <span class="nf">export_applied</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Export the applied calibration state to disk.</span>

<span class="sd">        The calibrations held in the &#39;applied&#39; CalState will be written to</span>
<span class="sd">        disk as a set of equivalent applycal calls.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calc_filename</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Exporting applied calibration state to </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_export</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_applied</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span></div>


<div class="viewcode-block" id="DictCalLibrary.get_calstate">
<a class="viewcode-back" href="../../../_apidoc/pipeline.infrastructure.html#pipeline.infrastructure.callibrary.DictCalLibrary.get_calstate">[docs]</a>
    <span class="k">def</span> <span class="nf">get_calstate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">calto</span><span class="p">,</span> <span class="n">hide_null</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">ignore</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the calibration state for a target data selection.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ignore</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ignore</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># wrap the text-only CalTo in a CalToIdAdapter, which will parse the</span>
        <span class="c1"># CalTo properties and give us the appropriate subtable IDs to iterate</span>
        <span class="c1"># over</span>
        <span class="n">id_resolver</span> <span class="o">=</span> <span class="n">CalToIdAdapter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_context</span><span class="p">,</span> <span class="n">calto</span><span class="p">)</span>
        <span class="n">ms_name</span> <span class="o">=</span> <span class="n">id_resolver</span><span class="o">.</span><span class="n">ms</span><span class="o">.</span><span class="n">name</span>

        <span class="n">result</span> <span class="o">=</span> <span class="n">DictCalState</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">spw_id</span> <span class="ow">in</span> <span class="n">id_resolver</span><span class="o">.</span><span class="n">spw</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">field_id</span> <span class="ow">in</span> <span class="n">id_resolver</span><span class="o">.</span><span class="n">field</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">intent</span> <span class="ow">in</span> <span class="n">id_resolver</span><span class="o">.</span><span class="n">get_field_intents</span><span class="p">(</span><span class="n">field_id</span><span class="p">,</span> <span class="n">spw_id</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">antenna_id</span> <span class="ow">in</span> <span class="n">id_resolver</span><span class="o">.</span><span class="n">antenna</span><span class="p">:</span>
                        <span class="n">calfroms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_active</span><span class="p">[</span><span class="n">ms_name</span><span class="p">][</span><span class="n">spw_id</span><span class="p">][</span><span class="n">field_id</span><span class="p">][</span><span class="n">intent</span><span class="p">][</span><span class="n">antenna_id</span><span class="p">]</span>

                        <span class="c1"># Make the hash function ignore the ignored properties</span>
                        <span class="c1"># by setting their value to the default (and equal)</span>
                        <span class="c1"># value.</span>
                        <span class="n">calfrom_copies</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_copy_calfrom</span><span class="p">(</span><span class="n">cf</span><span class="p">,</span> <span class="n">ignore</span><span class="p">)</span>
                                          <span class="k">for</span> <span class="n">cf</span> <span class="ow">in</span> <span class="n">calfroms</span>
                                          <span class="k">if</span> <span class="n">cf</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_active</span><span class="o">.</span><span class="n">_removed</span><span class="p">]</span>

                        <span class="n">result</span><span class="p">[</span><span class="n">ms_name</span><span class="p">][</span><span class="n">spw_id</span><span class="p">][</span><span class="n">field_id</span><span class="p">][</span><span class="n">intent</span><span class="p">][</span><span class="n">antenna_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">calfrom_copies</span>

        <span class="k">return</span> <span class="n">result</span></div>


    <span class="k">def</span> <span class="nf">_copy_calfrom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">to_copy</span><span class="p">,</span> <span class="n">ignore</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">ignore</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ignore</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">calfrom_properties</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;caltype&#39;</span><span class="p">,</span> <span class="s1">&#39;calwt&#39;</span><span class="p">,</span> <span class="s1">&#39;gainfield&#39;</span><span class="p">,</span> <span class="s1">&#39;gaintable&#39;</span><span class="p">,</span>
                              <span class="s1">&#39;interp&#39;</span><span class="p">,</span> <span class="s1">&#39;spwmap&#39;</span><span class="p">]</span>

        <span class="n">copied</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">to_copy</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">calfrom_properties</span>
                  <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ignore</span><span class="p">}</span>

        <span class="k">return</span> <span class="n">CalFrom</span><span class="p">(</span><span class="o">**</span><span class="n">copied</span><span class="p">)</span>

<div class="viewcode-block" id="DictCalLibrary.import_state">
<a class="viewcode-back" href="../../../_apidoc/pipeline.infrastructure.html#pipeline.infrastructure.callibrary.DictCalLibrary.import_state">[docs]</a>
    <span class="k">def</span> <span class="nf">import_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calc_filename</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>

        <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Importing calibration state from </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">filename</span><span class="p">)</span>
        <span class="n">calapps</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">import_file</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="p">[</span><span class="n">l</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">import_file</span> <span class="k">if</span> <span class="n">l</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;applycal(&#39;</span><span class="p">)]:</span>
                <span class="n">calapp</span> <span class="o">=</span> <span class="n">CalApplication</span><span class="o">.</span><span class="n">from_export</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
                <span class="n">calapps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">calapp</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">append</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_active</span> <span class="o">=</span> <span class="n">DictCalState</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">calapp</span> <span class="ow">in</span> <span class="n">calapps</span><span class="p">:</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Adding </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">calapp</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">calapp</span><span class="o">.</span><span class="n">calto</span><span class="p">,</span> <span class="n">calapp</span><span class="o">.</span><span class="n">calfrom</span><span class="p">)</span>

        <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Calibration state after import:</span><span class="se">\n</span><span class="s1">&#39;</span>
                 <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">active</span><span class="o">.</span><span class="n">as_applycal</span><span class="p">())</span></div>


<div class="viewcode-block" id="DictCalLibrary.mark_as_applied">
<a class="viewcode-back" href="../../../_apidoc/pipeline.infrastructure.html#pipeline.infrastructure.callibrary.DictCalLibrary.mark_as_applied">[docs]</a>
    <span class="k">def</span> <span class="nf">mark_as_applied</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">calto</span><span class="p">,</span> <span class="n">calfrom</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_remove</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_active</span><span class="p">,</span> <span class="n">calfrom</span><span class="p">,</span> <span class="n">calto</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_add</span><span class="p">(</span><span class="n">calto</span><span class="p">,</span> <span class="n">calfrom</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_applied</span><span class="p">)</span>

        <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;New calibration state:</span><span class="se">\n</span><span class="s1">&#39;</span>
                  <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">active</span><span class="o">.</span><span class="n">as_applycal</span><span class="p">())</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Applied calibration state:</span><span class="se">\n</span><span class="s1">&#39;</span>
                  <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">applied</span><span class="o">.</span><span class="n">as_applycal</span><span class="p">())</span></div>
</div>



<span class="c1"># CalLibrary based on interval trees -----------------------------------------</span>


<div class="viewcode-block" id="unit">
<a class="viewcode-back" href="../../../_apidoc/pipeline.infrastructure.html#pipeline.infrastructure.callibrary.unit">[docs]</a>
<span class="k">def</span> <span class="nf">unit</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span></div>



<div class="viewcode-block" id="contiguous_sequences">
<a class="viewcode-back" href="../../../_apidoc/pipeline.infrastructure.html#pipeline.infrastructure.callibrary.contiguous_sequences">[docs]</a>
<span class="k">def</span> <span class="nf">contiguous_sequences</span><span class="p">(</span><span class="n">l</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Group a sequence of numbers into contiguous groups</span>

<span class="sd">    :param l: a sequence</span>
<span class="sd">    :return: list of Intervals</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">s</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">([</span><span class="nb">int</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">l</span><span class="p">])</span>

    <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="k">lambda</span> <span class="n">i_x</span><span class="p">:</span> <span class="n">i_x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">i_x</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
        <span class="n">rng</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">itemgetter</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">g</span><span class="p">))</span>
        <span class="k">yield</span> <span class="n">rng</span></div>



<span class="c1"># intervals are not inclusive of the upper bound, hence the +1 on the right bound</span>
<span class="n">sequence_to_range</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">l</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>


<div class="viewcode-block" id="sequence_to_casa_range">
<a class="viewcode-back" href="../../../_apidoc/pipeline.infrastructure.html#pipeline.infrastructure.callibrary.sequence_to_casa_range">[docs]</a>
<span class="k">def</span> <span class="nf">sequence_to_casa_range</span><span class="p">(</span><span class="n">seq</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">as_casa_range</span><span class="p">(</span><span class="n">seq</span><span class="p">):</span>
        <span class="n">size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;&#39;</span>
        <span class="k">elif</span> <span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">seq</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">~</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">seq</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">seq</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">as_casa_range</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span> <span class="k">for</span> <span class="n">seq</span> <span class="ow">in</span> <span class="n">contiguous_sequences</span><span class="p">(</span><span class="n">seq</span><span class="p">))</span></div>



<div class="viewcode-block" id="CalToIntervalAdapter">
<a class="viewcode-back" href="../../../_apidoc/pipeline.infrastructure.html#pipeline.infrastructure.callibrary.CalToIntervalAdapter">[docs]</a>
<span class="k">class</span> <span class="nc">CalToIntervalAdapter</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">calto</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_context</span> <span class="o">=</span> <span class="n">context</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_calto</span> <span class="o">=</span> <span class="n">calto</span>

        <span class="n">ms</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">observing_run</span><span class="o">.</span><span class="n">get_ms</span><span class="p">(</span><span class="n">calto</span><span class="o">.</span><span class="n">vis</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ms</span> <span class="o">=</span> <span class="n">ms</span>

        <span class="n">antenna_ids</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">id</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">ms</span><span class="o">.</span><span class="n">get_antenna</span><span class="p">(</span><span class="n">calto</span><span class="o">.</span><span class="n">antenna</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">antenna</span> <span class="o">=</span> <span class="p">[</span><span class="n">sequence_to_range</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span> <span class="k">for</span> <span class="n">seq</span> <span class="ow">in</span> <span class="n">contiguous_sequences</span><span class="p">(</span><span class="n">antenna_ids</span><span class="p">)]</span>

        <span class="n">field_ids</span> <span class="o">=</span> <span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">id</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">ms</span><span class="o">.</span><span class="n">get_fields</span><span class="p">(</span><span class="n">task_arg</span><span class="o">=</span><span class="n">calto</span><span class="o">.</span><span class="n">field</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">field</span> <span class="o">=</span> <span class="p">[</span><span class="n">sequence_to_range</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span> <span class="k">for</span> <span class="n">seq</span> <span class="ow">in</span> <span class="n">contiguous_sequences</span><span class="p">(</span><span class="n">field_ids</span><span class="p">)]</span>

        <span class="n">spw_ids</span> <span class="o">=</span> <span class="p">(</span><span class="n">spw</span><span class="o">.</span><span class="n">id</span> <span class="k">for</span> <span class="n">spw</span> <span class="ow">in</span> <span class="n">ms</span><span class="o">.</span><span class="n">get_spectral_windows</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_calto</span><span class="o">.</span><span class="n">spw</span><span class="p">,</span> <span class="n">science_windows_only</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spw</span> <span class="o">=</span> <span class="p">[</span><span class="n">sequence_to_range</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span> <span class="k">for</span> <span class="n">seq</span> <span class="ow">in</span> <span class="n">contiguous_sequences</span><span class="p">(</span><span class="n">spw_ids</span><span class="p">)]</span>

        <span class="n">id_to_intent</span> <span class="o">=</span> <span class="n">get_intent_id_map</span><span class="p">(</span><span class="n">ms</span><span class="p">)</span>
        <span class="n">intent_to_id</span> <span class="o">=</span> <span class="p">{</span><span class="n">v</span><span class="p">:</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">id_to_intent</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calto</span><span class="o">.</span><span class="n">intent</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">intent</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">intent_to_id</span><span class="p">))]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">str_intents</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calto</span><span class="o">.</span><span class="n">intent</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)</span>
            <span class="c1"># the conditional check for intent is required as task parameters may</span>
            <span class="c1"># specify an intent that is not in the MS, such as CHECK.</span>
            <span class="n">intent_ids</span> <span class="o">=</span> <span class="p">(</span><span class="n">intent_to_id</span><span class="p">[</span><span class="n">intent</span><span class="p">]</span> <span class="k">for</span> <span class="n">intent</span> <span class="ow">in</span> <span class="n">str_intents</span>
                          <span class="k">if</span> <span class="n">intent</span> <span class="ow">in</span> <span class="n">intent_to_id</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">intent</span> <span class="o">=</span> <span class="p">[</span><span class="n">sequence_to_range</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span> <span class="k">for</span> <span class="n">seq</span> <span class="ow">in</span> <span class="n">contiguous_sequences</span><span class="p">(</span><span class="n">intent_ids</span><span class="p">)]</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="s1">&#39;CalToIntervalAdapter(ms=</span><span class="si">{!r}</span><span class="s1">, field=</span><span class="si">{!r}</span><span class="s1">, intent=</span><span class="si">{!r}</span><span class="s1">, spw=</span><span class="si">{!r}</span><span class="s1">, antenna=</span><span class="si">{!r}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_calto</span><span class="o">.</span><span class="n">vis</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">field</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">intent</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spw</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">antenna</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;CalToIntervalAdapter(</span><span class="si">{!s}</span><span class="s1">, </span><span class="si">{!s}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_context</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calto</span><span class="p">)</span></div>



<div class="viewcode-block" id="create_data_reducer">
<a class="viewcode-back" href="../../../_apidoc/pipeline.infrastructure.html#pipeline.infrastructure.callibrary.create_data_reducer">[docs]</a>
<span class="k">def</span> <span class="nf">create_data_reducer</span><span class="p">(</span><span class="n">join</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a function that creates a new TimestampedData object containing the</span>
<span class="sd">    result of executing the given operation on two TimestampedData objects.</span>

<span class="sd">    The use case for this function is actually quite simple: perform an</span>
<span class="sd">    operation on two TimestampedData objects (add, subtract, etc.) and put the</span>
<span class="sd">    result in a new TimestampedData object.</span>

<span class="sd">    The resulting TimestampedData object has a creation time equal to that of</span>
<span class="sd">    the oldest input object.</span>

<span class="sd">    :param join: the function to call on the two input objects</span>
<span class="sd">    :return:</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">m</span><span class="p">(</span><span class="n">td1</span><span class="p">,</span> <span class="n">td2</span><span class="p">,</span> <span class="n">join</span><span class="o">=</span><span class="n">join</span><span class="p">):</span>
        <span class="n">oldest</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">td1</span><span class="p">,</span> <span class="n">td2</span><span class="p">)</span>
        <span class="n">newest</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">td1</span><span class="p">,</span> <span class="n">td2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">TimestampedData</span><span class="p">(</span><span class="n">oldest</span><span class="o">.</span><span class="n">time</span><span class="p">,</span> <span class="n">join</span><span class="p">(</span><span class="n">oldest</span><span class="p">,</span> <span class="n">newest</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">m</span></div>



<div class="viewcode-block" id="merge_lists">
<a class="viewcode-back" href="../../../_apidoc/pipeline.infrastructure.html#pipeline.infrastructure.callibrary.merge_lists">[docs]</a>
<span class="k">def</span> <span class="nf">merge_lists</span><span class="p">(</span><span class="n">join_fn</span><span class="o">=</span><span class="n">operator</span><span class="o">.</span><span class="n">add</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a function that merge two lists by calling the input operation</span>
<span class="sd">    on the two input arguments.</span>

<span class="sd">    :param join_fn:</span>
<span class="sd">    :return:</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">m</span><span class="p">(</span><span class="n">oldest</span><span class="p">,</span> <span class="n">newest</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">join_fn</span><span class="p">(</span><span class="n">oldest</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">newest</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">m</span></div>



<div class="viewcode-block" id="merge_intervaltrees">
<a class="viewcode-back" href="../../../_apidoc/pipeline.infrastructure.html#pipeline.infrastructure.callibrary.merge_intervaltrees">[docs]</a>
<span class="k">def</span> <span class="nf">merge_intervaltrees</span><span class="p">(</span><span class="n">on_intersect</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a function that merges two IntervalTrees, executing a function</span>
<span class="sd">    on the intersecting Interval ranges in the resulting merged IntervalTree.</span>

<span class="sd">    :param on_intersect: the function to call on overlapping Intervals</span>
<span class="sd">    :return: function</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">m</span><span class="p">(</span><span class="n">oldest</span><span class="p">,</span> <span class="n">newest</span><span class="p">):</span>
        <span class="n">union</span> <span class="o">=</span> <span class="n">oldest</span><span class="o">.</span><span class="n">data</span> <span class="o">|</span> <span class="n">newest</span><span class="o">.</span><span class="n">data</span>
        <span class="n">union</span><span class="o">.</span><span class="n">split_overlaps</span><span class="p">()</span>
        <span class="n">union</span><span class="o">.</span><span class="n">merge_equals</span><span class="p">(</span><span class="n">data_reducer</span><span class="o">=</span><span class="n">on_intersect</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">union</span>

    <span class="k">return</span> <span class="n">m</span></div>



<div class="viewcode-block" id="ranges">
<a class="viewcode-back" href="../../../_apidoc/pipeline.infrastructure.html#pipeline.infrastructure.callibrary.ranges">[docs]</a>
<span class="k">def</span> <span class="nf">ranges</span><span class="p">(</span><span class="n">lst</span><span class="p">):</span>
    <span class="n">pos</span> <span class="o">=</span> <span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">lst</span><span class="p">))</span>
    <span class="n">t</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">els</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">pos</span><span class="p">):</span>
        <span class="n">l</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">els</span><span class="p">))</span>
        <span class="n">el</span> <span class="o">=</span> <span class="n">lst</span><span class="p">[</span><span class="n">t</span><span class="p">]</span>
        <span class="n">t</span> <span class="o">+=</span> <span class="n">l</span>
        <span class="k">yield</span> <span class="p">(</span><span class="n">el</span><span class="p">,</span> <span class="n">el</span> <span class="o">+</span> <span class="n">l</span><span class="p">)</span></div>



<div class="viewcode-block" id="safe_join">
<a class="viewcode-back" href="../../../_apidoc/pipeline.infrastructure.html#pipeline.infrastructure.callibrary.safe_join">[docs]</a>
<span class="k">def</span> <span class="nf">safe_join</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="n">separator</span><span class="o">=</span><span class="s1">&#39;,&#39;</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">separator</span><span class="o">.</span><span class="n">join</span><span class="p">((</span><span class="nb">str</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">vals</span><span class="p">))</span></div>



<div class="viewcode-block" id="merge_contiguous_intervals">
<a class="viewcode-back" href="../../../_apidoc/pipeline.infrastructure.html#pipeline.infrastructure.callibrary.merge_contiguous_intervals">[docs]</a>
<span class="k">def</span> <span class="nf">merge_contiguous_intervals</span><span class="p">(</span><span class="n">tree</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Merge contiguous Intervals with the same value into one Interval.</span>

<span class="sd">    :param tree: an IntervalTree</span>
<span class="sd">    :return: new IntervalTree with merged Intervals</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">merged_tree</span> <span class="o">=</span> <span class="n">intervaltree</span><span class="o">.</span><span class="n">IntervalTree</span><span class="p">()</span>

    <span class="c1"># sort the tree by the list values. This is a prerequisite of using the</span>
    <span class="c1"># itertools.groupby function</span>
    <span class="n">data</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">tsd_accessor</span><span class="p">)</span>

    <span class="c1"># create groups of Intervals that have the same list values. These are the</span>
    <span class="c1"># Intervals we can merge.</span>
    <span class="k">for</span> <span class="n">l</span><span class="p">,</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">tsd_accessor</span><span class="p">):</span>
        <span class="c1"># create a tree for these Intervals with the same list values</span>
        <span class="n">candidate_tree</span> <span class="o">=</span> <span class="n">intervaltree</span><span class="o">.</span><span class="n">IntervalTree</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
        <span class="c1"># expand the Interval ranges to a list of integers (e.g. 1,3,6,7,8),</span>
        <span class="c1"># then find the contiguous ranges</span>
        <span class="n">sequence</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">begin</span><span class="p">,</span> <span class="n">i</span><span class="o">.</span><span class="n">end</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">candidate_tree</span><span class="p">)]))</span>
        <span class="k">for</span> <span class="n">begin</span><span class="p">,</span> <span class="n">end</span> <span class="ow">in</span> <span class="n">ranges</span><span class="p">(</span><span class="n">sequence</span><span class="p">):</span>
            <span class="n">vals</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">candidate_tree</span><span class="p">[</span><span class="n">begin</span><span class="p">:</span><span class="n">end</span><span class="p">],</span> <span class="n">key</span><span class="o">=</span><span class="n">tsd_accessor</span><span class="p">)</span>
            <span class="c1"># create a new Interval for the contiguous range but using an</span>
            <span class="c1"># existing value, thus reusing the timestamp</span>
            <span class="n">merged_tree</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">intervaltree</span><span class="o">.</span><span class="n">Interval</span><span class="p">(</span><span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">vals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">merged_tree</span></div>



<span class="c1"># function to access the value of a TimestampedData inside an Interval</span>
<span class="n">tsd_accessor</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">attrgetter</span><span class="p">(</span><span class="s1">&#39;data.data&#39;</span><span class="p">)</span>


<div class="viewcode-block" id="defrag_interval_tree">
<a class="viewcode-back" href="../../../_apidoc/pipeline.infrastructure.html#pipeline.infrastructure.callibrary.defrag_interval_tree">[docs]</a>
<span class="k">def</span> <span class="nf">defrag_interval_tree</span><span class="p">(</span><span class="n">tree</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Condense an IntervalTree by consolidating fragmented entries with the same</span>
<span class="sd">    value into contiguous Intervals.</span>

<span class="sd">    :param tree:</span>
<span class="sd">    :return:</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># if the intervals in this tree do not contain IntervalTrees, we&#39;re at the final</span>
    <span class="c1"># branch - the branch with the list of CalApplications. The intervals in this</span>
    <span class="c1"># branch can be merged</span>
    <span class="n">leaf_values</span> <span class="o">=</span> <span class="p">[</span><span class="n">tsd_accessor</span><span class="p">(</span><span class="n">interval</span><span class="p">)</span> <span class="k">for</span> <span class="n">interval</span> <span class="ow">in</span> <span class="n">tree</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">((</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">intervaltree</span><span class="o">.</span><span class="n">IntervalTree</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">leaf_values</span><span class="p">)):</span>
        <span class="k">return</span> <span class="n">merge_contiguous_intervals</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>

    <span class="c1"># otherwise call recursively</span>
    <span class="n">merged_tree</span> <span class="o">=</span> <span class="n">intervaltree</span><span class="o">.</span><span class="n">IntervalTree</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">interval</span> <span class="ow">in</span> <span class="n">tree</span><span class="p">:</span>
        <span class="n">new_leaf</span> <span class="o">=</span> <span class="n">intervaltree</span><span class="o">.</span><span class="n">Interval</span><span class="p">(</span><span class="n">interval</span><span class="o">.</span><span class="n">begin</span><span class="p">,</span>
                                         <span class="n">interval</span><span class="o">.</span><span class="n">end</span><span class="p">,</span>
                                         <span class="n">defrag_interval_tree</span><span class="p">(</span><span class="n">tsd_accessor</span><span class="p">(</span><span class="n">interval</span><span class="p">)))</span>
        <span class="n">merged_tree</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">new_leaf</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">merged_tree</span></div>



<span class="c1"># this chain of functions defines how to add overlapping Intervals when adding</span>
<span class="c1"># IntervalTrees</span>
<span class="n">intent_add</span> <span class="o">=</span> <span class="n">create_data_reducer</span><span class="p">(</span><span class="n">join</span><span class="o">=</span><span class="n">merge_lists</span><span class="p">(</span><span class="n">join_fn</span><span class="o">=</span><span class="n">operator</span><span class="o">.</span><span class="n">add</span><span class="p">))</span>
<span class="n">field_add</span> <span class="o">=</span> <span class="n">create_data_reducer</span><span class="p">(</span><span class="n">join</span><span class="o">=</span><span class="n">merge_intervaltrees</span><span class="p">(</span><span class="n">intent_add</span><span class="p">))</span>
<span class="n">spw_add</span> <span class="o">=</span> <span class="n">create_data_reducer</span><span class="p">(</span><span class="n">join</span><span class="o">=</span><span class="n">merge_intervaltrees</span><span class="p">(</span><span class="n">field_add</span><span class="p">))</span>
<span class="n">ant_add</span> <span class="o">=</span> <span class="n">create_data_reducer</span><span class="p">(</span><span class="n">join</span><span class="o">=</span><span class="n">merge_intervaltrees</span><span class="p">(</span><span class="n">spw_add</span><span class="p">))</span>

<span class="c1"># this chain of functions defines how to subtract overlapping Intervals when</span>
<span class="c1"># subtracting IntervalTrees</span>
<span class="n">intent_sub</span> <span class="o">=</span> <span class="n">create_data_reducer</span><span class="p">(</span><span class="n">join</span><span class="o">=</span><span class="n">merge_lists</span><span class="p">(</span><span class="n">join_fn</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="p">[</span><span class="n">item</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">x</span> <span class="k">if</span> <span class="n">item</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">y</span><span class="p">]))</span>
<span class="n">field_sub</span> <span class="o">=</span> <span class="n">create_data_reducer</span><span class="p">(</span><span class="n">join</span><span class="o">=</span><span class="n">merge_intervaltrees</span><span class="p">(</span><span class="n">intent_sub</span><span class="p">))</span>
<span class="n">spw_sub</span> <span class="o">=</span> <span class="n">create_data_reducer</span><span class="p">(</span><span class="n">join</span><span class="o">=</span><span class="n">merge_intervaltrees</span><span class="p">(</span><span class="n">field_sub</span><span class="p">))</span>
<span class="n">ant_sub</span> <span class="o">=</span> <span class="n">create_data_reducer</span><span class="p">(</span><span class="n">join</span><span class="o">=</span><span class="n">merge_intervaltrees</span><span class="p">(</span><span class="n">spw_sub</span><span class="p">))</span>


<div class="viewcode-block" id="interval_to_set">
<a class="viewcode-back" href="../../../_apidoc/pipeline.infrastructure.html#pipeline.infrastructure.callibrary.interval_to_set">[docs]</a>
<span class="k">def</span> <span class="nf">interval_to_set</span><span class="p">(</span><span class="n">interval</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the all the indexes covered by an Interval.</span>

<span class="sd">    :param interval:</span>
<span class="sd">    :return:</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">interval</span><span class="o">.</span><span class="n">begin</span><span class="p">,</span> <span class="n">interval</span><span class="o">.</span><span class="n">end</span><span class="p">))</span></div>



<div class="viewcode-block" id="get_id_to_intent_fn">
<a class="viewcode-back" href="../../../_apidoc/pipeline.infrastructure.html#pipeline.infrastructure.callibrary.get_id_to_intent_fn">[docs]</a>
<span class="k">def</span> <span class="nf">get_id_to_intent_fn</span><span class="p">(</span><span class="n">id_to_intent</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a function that can convert intent IDs to a string intent.</span>

<span class="sd">    Takes a dict of dicts, first key mapping measurement set name and second</span>
<span class="sd">    key mapping numeric intent ID to string intent for that MS, e.g.</span>

<span class="sd">    {&#39;a.ms&#39;: {0: &#39;PHASE&#39;, 1: &#39;BANDPASS&#39;}</span>

<span class="sd">    :param id_to_intent: dict of vis : intent ID : string intent</span>
<span class="sd">    :return: set of intents</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">vis</span><span class="p">,</span> <span class="n">intent_ids</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">vis</span> <span class="ow">in</span> <span class="n">id_to_intent</span>

        <span class="n">mapping</span> <span class="o">=</span> <span class="n">id_to_intent</span><span class="p">[</span><span class="n">vis</span><span class="p">]</span>

        <span class="c1"># if the intent range spans all intents for this measurement set,</span>
        <span class="c1"># transform it back to &#39;&#39; to indicate all intents</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">((</span><span class="n">i</span> <span class="ow">in</span> <span class="n">intent_ids</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">mapping</span><span class="p">)):</span>
            <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">set</span><span class="p">((</span><span class="n">mapping</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">intent_ids</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">f</span></div>



<div class="viewcode-block" id="get_id_to_field_fn">
<a class="viewcode-back" href="../../../_apidoc/pipeline.infrastructure.html#pipeline.infrastructure.callibrary.get_id_to_field_fn">[docs]</a>
<span class="k">def</span> <span class="nf">get_id_to_field_fn</span><span class="p">(</span><span class="n">ms_to_id_to_field</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a function that can convert field IDs to a field name.</span>

<span class="sd">    Takes a dict of dicts, first key mapping measurement set name and second</span>
<span class="sd">    key mapping numeric field ID to field name, eg.</span>

<span class="sd">    {&#39;a.ms&#39;: {0: &#39;field 1&#39;, 1: &#39;field 2&#39;}</span>

<span class="sd">    :param ms_to_id_to_field: dict of vis : field ID : field name</span>
<span class="sd">    :return: set of field names (or field IDs if names are not unique)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">id_to_identifier</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">ms_name</span><span class="p">,</span> <span class="n">id_to_field</span> <span class="ow">in</span> <span class="n">ms_to_id_to_field</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">counter</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">Counter</span><span class="p">()</span>
        <span class="n">counter</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">id_to_field</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>

        <span class="c1"># construct an id:name mapping using the ID for non-unique field names</span>
        <span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="n">field_id</span><span class="p">:</span> <span class="n">field_name</span> <span class="k">if</span> <span class="n">counter</span><span class="p">[</span><span class="n">field_name</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">field_id</span>
             <span class="k">for</span> <span class="n">field_id</span><span class="p">,</span> <span class="n">field_name</span> <span class="ow">in</span> <span class="n">id_to_field</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="n">id_to_identifier</span><span class="p">[</span><span class="n">ms_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span>

    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">vis</span><span class="p">,</span> <span class="n">field_ids</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">vis</span> <span class="ow">in</span> <span class="n">id_to_identifier</span>

        <span class="n">field_id_to_field_name</span> <span class="o">=</span> <span class="n">id_to_identifier</span><span class="p">[</span><span class="n">vis</span><span class="p">]</span>

        <span class="c1"># if the field range spans all fields for this measurement set,</span>
        <span class="c1"># transform it back to &#39;&#39; to indicate all fields</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">i</span> <span class="ow">in</span> <span class="n">field_ids</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">field_id_to_field_name</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="n">field_id_to_field_name</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">field_ids</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">f</span></div>



<div class="viewcode-block" id="expand_interval">
<a class="viewcode-back" href="../../../_apidoc/pipeline.infrastructure.html#pipeline.infrastructure.callibrary.expand_interval">[docs]</a>
<span class="k">def</span> <span class="nf">expand_interval</span><span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="n">calto_args</span><span class="p">,</span> <span class="n">calto_fn</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert an Interval into the equivalent list of (CalTo, [CalFrom..])</span>
<span class="sd">    2-tuples.</span>

<span class="sd">    This function is the partner function to expand_intervaltree. See the</span>
<span class="sd">    documention for expand_intervaltree for more details on the argument</span>
<span class="sd">    format for this function.</span>

<span class="sd">    :param interval: the Interval to convert</span>
<span class="sd">    :param calto_args: the list of (argument name, conversion function) 2-tuples</span>
<span class="sd">     for the remaining dimensions</span>
<span class="sd">    :param calto_fn: the partial CalToArgs application</span>
<span class="sd">    :return:  a list of (CalTo, [CalFrom..]) tuples</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">tsd_accessor</span><span class="p">(</span><span class="n">interval</span><span class="p">)</span>
    <span class="n">numeric_ids</span> <span class="o">=</span> <span class="n">interval_to_set</span><span class="p">(</span><span class="n">interval</span><span class="p">)</span>

    <span class="n">arg_name</span><span class="p">,</span> <span class="n">conversion_fn</span> <span class="o">=</span> <span class="n">calto_args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">processed</span> <span class="o">=</span> <span class="n">conversion_fn</span><span class="p">(</span><span class="n">numeric_ids</span><span class="p">)</span>
    <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="n">arg_name</span><span class="p">:</span> <span class="n">processed</span><span class="p">}</span>

    <span class="n">calto_fn</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">calto_fn</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">intervaltree</span><span class="o">.</span><span class="n">IntervalTree</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">expand_intervaltree</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">calto_args</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">calto_fn</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># the return type is an iterable of 2-tuples</span>
        <span class="k">return</span> <span class="p">((</span><span class="n">calto_fn</span><span class="p">(),</span> <span class="n">data</span><span class="p">),)</span></div>



<div class="viewcode-block" id="expand_intervaltree">
<a class="viewcode-back" href="../../../_apidoc/pipeline.infrastructure.html#pipeline.infrastructure.callibrary.expand_intervaltree">[docs]</a>
<span class="k">def</span> <span class="nf">expand_intervaltree</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">convert_fns</span><span class="p">,</span> <span class="n">calto_fn</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert an IntervalTree into the equivalent list of (CalTo, [CalFrom..])</span>
<span class="sd">    2-tuples.</span>

<span class="sd">    The second argument for this function is a list of 2-tuples of (CalToArgs</span>
<span class="sd">    constructor argument for this dimension, value conversion function for</span>
<span class="sd">    this dimension). The conversion function takes in a set of integer indexes</span>
<span class="sd">    and converts it to a suitable (probably more human-readable value) for that</span>
<span class="sd">    dimension, e.g. a conversion from field ID to field name. So, for a</span>
<span class="sd">    dimension that supplies the &#39;antenna&#39; argument to CalToArgs and should</span>
<span class="sd">    prefix &#39;DV&#39; to each antenna index, the tuple for that dimension could be</span>
<span class="sd">    (&#39;antenna&#39;, lambda id: {&#39;DV%s&#39; % i for i in field_ids}).</span>

<span class="sd">    The third argument is the partially-applied CalToArgs constructor. A</span>
<span class="sd">    CalToArgs needs a number of arguments (vis, field, spw, etc.), each of</span>
<span class="sd">    which corresponds to a dimension of the IntervalTree and which must be</span>
<span class="sd">    supplied at CalToArgs creation time. To achieve this while iterating</span>
<span class="sd">    through the dimensions (when the constructor arguments are not fully</span>
<span class="sd">    known), object creation is delayed by performing just a partial</span>
<span class="sd">    application, adding the keyword for the current dimension to the partial</span>
<span class="sd">    application. At the final leaf node, when all constructor arguments have</span>
<span class="sd">    been partially applied, we can call the partial function and get the</span>
<span class="sd">    CalToArgs.</span>

<span class="sd">    :param tree: the IntervalTree to convert</span>
<span class="sd">    :param convert_fns: the list of (argument name, conversion function) 2-tuples</span>
<span class="sd">     for the remaining dimensions</span>
<span class="sd">    :param calto_fn: the partial CalToArgs application</span>
<span class="sd">    :return: a list of (CalTo, [CalFrom..]) tuples</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">x</span>
            <span class="k">for</span> <span class="n">interval</span> <span class="ow">in</span> <span class="n">tree</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">expand_interval</span><span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="n">convert_fns</span><span class="p">,</span> <span class="n">calto_fn</span><span class="p">))</span></div>



<div class="viewcode-block" id="expand_calstate_to_calapps">
<a class="viewcode-back" href="../../../_apidoc/pipeline.infrastructure.html#pipeline.infrastructure.callibrary.expand_calstate_to_calapps">[docs]</a>
<span class="k">def</span> <span class="nf">expand_calstate_to_calapps</span><span class="p">(</span><span class="n">calstate</span><span class="p">:</span> <span class="s2">&quot;IntervalCalState&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">CalTo</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">CalFrom</span><span class="p">]]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert an IntervalCalState into a list of (CalTo, [CalFrom..]) tuples.</span>

<span class="sd">    :param calstate: the IntervalCalState to convert</span>
<span class="sd">    :return: a list of 2-tuples, first element a Calto, second element a list</span>
<span class="sd">    of CalFroms</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># get functions to map from integer IDs to field and intent for this MS</span>
    <span class="n">id_to_field_fn</span> <span class="o">=</span> <span class="n">get_id_to_field_fn</span><span class="p">(</span><span class="n">calstate</span><span class="o">.</span><span class="n">id_to_field</span><span class="p">)</span>
    <span class="n">id_to_intent_fn</span> <span class="o">=</span> <span class="n">get_id_to_intent_fn</span><span class="p">(</span><span class="n">calstate</span><span class="o">.</span><span class="n">id_to_intent</span><span class="p">)</span>

    <span class="n">calapps</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">CalTo</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">CalFrom</span><span class="p">]]]</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">vis</span> <span class="ow">in</span> <span class="n">calstate</span><span class="p">:</span>
        <span class="c1"># Set the vis argument for the CalToArgs constructor through partial</span>
        <span class="c1"># application. The subsequent calls will set the other arguments for</span>
        <span class="c1"># CalToArgs (field, intent, spw, etc.)</span>
        <span class="n">caltoarg_fn</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">CalToArgs</span><span class="p">,</span> <span class="n">vis</span><span class="o">=</span><span class="p">{</span><span class="n">vis</span><span class="p">})</span>

        <span class="c1"># partially apply vis so that callees can call id-to-X functions</span>
        <span class="c1"># directly rather than having to push the vis arg through the layers</span>
        <span class="n">intent_fn</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">id_to_intent_fn</span><span class="p">,</span> <span class="n">vis</span><span class="p">)</span>
        <span class="n">field_fn</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">id_to_field_fn</span><span class="p">,</span> <span class="n">vis</span><span class="p">)</span>

        <span class="c1"># maps dimension order to the CalToArgs argument and value processing</span>
        <span class="c1"># function for that dimension. We have to process values at this point</span>
        <span class="c1"># while vis is still atomic, as once it&#39;s a set for the CalTo (as it</span>
        <span class="c1"># justly needs to be to handle sessions) we can&#39;t determine vis to</span>
        <span class="c1"># perform the mapping.</span>
        <span class="n">caltoarg_dimension</span> <span class="o">=</span> <span class="p">((</span><span class="s1">&#39;antenna&#39;</span><span class="p">,</span> <span class="n">unit</span><span class="p">),</span>
                              <span class="p">(</span><span class="s1">&#39;spw&#39;</span><span class="p">,</span> <span class="n">unit</span><span class="p">),</span>
                              <span class="p">(</span><span class="s1">&#39;field&#39;</span><span class="p">,</span> <span class="n">field_fn</span><span class="p">),</span>
                              <span class="p">(</span><span class="s1">&#39;intent&#39;</span><span class="p">,</span> <span class="n">intent_fn</span><span class="p">))</span>

        <span class="n">vis_tree</span> <span class="o">=</span> <span class="n">calstate</span><span class="p">[</span><span class="n">vis</span><span class="p">]</span>
        <span class="n">vis_calapps</span> <span class="o">=</span> <span class="n">expand_intervaltree</span><span class="p">(</span><span class="n">vis_tree</span><span class="p">,</span> <span class="n">caltoarg_dimension</span><span class="p">,</span> <span class="n">caltoarg_fn</span><span class="p">)</span>
        <span class="n">calapps</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">vis_calapps</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">calapps</span></div>



<div class="viewcode-block" id="consolidate_calibrations">
<a class="viewcode-back" href="../../../_apidoc/pipeline.infrastructure.html#pipeline.infrastructure.callibrary.consolidate_calibrations">[docs]</a>
<span class="k">def</span> <span class="nf">consolidate_calibrations</span><span class="p">(</span><span class="n">all_my_calapps</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Consolidate a list of (CalTo, [CalFrom..]) 2-tuples into a smaller set of</span>
<span class="sd">    equivalent applications by consolidating their data selection arguments.</span>

<span class="sd">    This function works by merging the data selections of CalTo objects that</span>
<span class="sd">    have the same calibration application, as determined by the values and</span>
<span class="sd">    data selection present in the CalFroms.</span>

<span class="sd">    :param calapps: an iterable of (CalTo, [CalFrom..]) 2-tuples</span>
<span class="sd">    :return: a list of (CalTo, [CalFrom..]) tuples</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># When faced with a large number of EBs, trying to merge calibrations</span>
    <span class="c1"># across all MSes results in a huge number of iterations - most of them</span>
    <span class="c1"># pointless as the caltables only apply to one MS. So, partition the</span>
    <span class="c1"># calapps, grouping them by MS, and merge within these partitions and not</span>
    <span class="c1"># across them.</span>
    <span class="n">vis_to_calapps</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">calto</span><span class="p">,</span> <span class="n">calfroms</span> <span class="ow">in</span> <span class="n">all_my_calapps</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">calto</span><span class="o">.</span><span class="n">vis</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Cannot handle calibrations that apply to multiple MSes&#39;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="n">vis</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">calto</span><span class="o">.</span><span class="n">vis</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">vis_to_calapps</span><span class="p">[</span><span class="n">vis</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">calto</span><span class="p">,</span> <span class="n">calfroms</span><span class="p">))</span>

    <span class="n">all_accepted</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">vis</span><span class="p">,</span> <span class="n">calapps_for_vis</span> <span class="ow">in</span> <span class="n">vis_to_calapps</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Consolidating calibrations for </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">vis</span><span class="p">)))</span>

        <span class="c1"># dict mapping an object hash to the object itself:</span>
        <span class="c1">#     hash([CalFrom, ...]): [CalFrom, ...]</span>
        <span class="n">hash_to_calfroms</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># dict mapping from object hash to corresponding list of CalToArgs</span>
        <span class="n">hash_to_calto_args</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

        <span class="c1"># create our maps of hashes, which we need to test for overlapping data</span>
        <span class="c1"># selections</span>
        <span class="k">for</span> <span class="n">calto_args</span><span class="p">,</span> <span class="n">calfroms</span> <span class="ow">in</span> <span class="n">calapps_for_vis</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">calfroms</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># create a tuple, as lists are not hashable</span>
            <span class="n">hashable_calfroms</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">hash</span><span class="p">(</span><span class="n">cf</span><span class="p">)</span> <span class="k">for</span> <span class="n">cf</span> <span class="ow">in</span> <span class="n">calfroms</span><span class="p">)</span>
            <span class="n">hash_to_calto_args</span><span class="p">[</span><span class="n">hashable_calfroms</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">calto_args</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">hashable_calfroms</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">hash_to_calfroms</span><span class="p">:</span>
                <span class="n">hash_to_calfroms</span><span class="p">[</span><span class="n">hashable_calfroms</span><span class="p">]</span> <span class="o">=</span> <span class="n">calfroms</span>

        <span class="c1"># dict that maps holds accepted data selections and their CalFroms</span>
        <span class="n">accepted</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">hashable_calfroms</span><span class="p">,</span> <span class="n">calto_args</span> <span class="ow">in</span> <span class="n">hash_to_calto_args</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># assemble the other data selections (the other CalToArgs) which we</span>
            <span class="c1"># will use to search for conflicting data selections</span>
            <span class="n">other_data_selections</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="p">[</span><span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">hash_to_calto_args</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="o">!=</span> <span class="n">hashable_calfroms</span><span class="p">]:</span>
                <span class="n">other_data_selections</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">to_merge</span> <span class="ow">in</span> <span class="n">calto_args</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">hashable_calfroms</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">accepted</span><span class="p">:</span>
                    <span class="c1"># first time round for this calibration application, therefore it can always be added</span>
                    <span class="c1"># as there will be nothing to merge</span>
                    <span class="n">accepted</span><span class="p">[</span><span class="n">hashable_calfroms</span><span class="p">]</span> <span class="o">=</span> <span class="p">[(</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">to_merge</span><span class="p">),</span> <span class="n">hash_to_calfroms</span><span class="p">[</span><span class="n">hashable_calfroms</span><span class="p">])]</span>
                    <span class="k">continue</span>

                <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="p">(</span><span class="n">existing_calto</span><span class="p">,</span> <span class="n">calfroms</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">accepted</span><span class="p">[</span><span class="n">hashable_calfroms</span><span class="p">]):</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">calfroms</span><span class="p">:</span>
                        <span class="k">continue</span>

                    <span class="n">proposed_calto</span> <span class="o">=</span> <span class="n">CalToArgs</span><span class="p">(</span><span class="o">*</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">existing_calto</span><span class="p">))</span>

                    <span class="k">for</span> <span class="n">proposed_values</span><span class="p">,</span> <span class="n">to_merge_values</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">proposed_calto</span><span class="p">,</span> <span class="n">to_merge</span><span class="p">):</span>
                        <span class="n">proposed_values</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">to_merge_values</span><span class="p">)</span>

                    <span class="c1"># if the merged data selection does not conflict with any of</span>
                    <span class="c1"># the explicitly registered data selections that require a</span>
                    <span class="c1"># different calibration application, then it is safe to add</span>
                    <span class="c1"># the merged data selection and discard the unmerged data</span>
                    <span class="c1"># selection</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">((</span><span class="n">data_selection_contains</span><span class="p">(</span><span class="n">proposed_calto</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="k">for</span> <span class="n">other</span> <span class="ow">in</span> <span class="n">other_data_selections</span><span class="p">)):</span>
                        <span class="k">if</span> <span class="n">LOG</span><span class="o">.</span><span class="n">isEnabledFor</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">TRACE</span><span class="p">):</span>
                            <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;No conflicting data selection detected&#39;</span><span class="p">)</span>
                            <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;Accepting merged data selection: </span><span class="si">{!s}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">proposed_calto</span><span class="p">))</span>
                            <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;Discarding unmerged data selection: </span><span class="si">{!s}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">to_merge</span><span class="p">))</span>
                        <span class="n">accepted</span><span class="p">[</span><span class="n">hashable_calfroms</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">proposed_calto</span><span class="p">,</span> <span class="n">hash_to_calfroms</span><span class="p">[</span><span class="n">hashable_calfroms</span><span class="p">])</span>
                        <span class="k">break</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># we get here if all of the proposed merged data selections</span>
                    <span class="c1"># conflict with the data selection in hand. In this case, it</span>
                    <span class="c1"># should be added as it stands, completely unaltered.</span>
                    <span class="k">if</span> <span class="n">LOG</span><span class="o">.</span><span class="n">isEnabledFor</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">TRACE</span><span class="p">):</span>
                        <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;Merged data selection conflicts with other registrations&#39;</span><span class="p">)</span>
                        <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;Abandoning proposed data selection: </span><span class="si">{!s}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">proposed_calto</span><span class="p">))</span>
                        <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;Appending new unmerged data selection: </span><span class="si">{!s}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">to_merge</span><span class="p">))</span>
                    <span class="n">unmergeable</span> <span class="o">=</span> <span class="p">(</span><span class="n">to_merge</span><span class="p">,</span> <span class="n">hash_to_calfroms</span><span class="p">[</span><span class="n">hashable_calfroms</span><span class="p">])</span>
                    <span class="n">accepted</span><span class="p">[</span><span class="n">hashable_calfroms</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">unmergeable</span><span class="p">)</span>

            <span class="n">all_accepted</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">accepted</span><span class="p">)</span>

    <span class="c1"># dict values are lists, which we need to flatten into a single list</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">all_accepted</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
        <span class="n">result</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span></div>



<div class="viewcode-block" id="data_selection_contains">
<a class="viewcode-back" href="../../../_apidoc/pipeline.infrastructure.html#pipeline.infrastructure.callibrary.data_selection_contains">[docs]</a>
<span class="k">def</span> <span class="nf">data_selection_contains</span><span class="p">(</span><span class="n">proposed</span><span class="p">,</span> <span class="n">calto_args</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return True if one data selection is contained within another.</span>

<span class="sd">    :param proposed: data selection 1</span>
<span class="sd">    :type proposed: CalToArgs</span>
<span class="sd">    :param calto_args: data selection 2</span>
<span class="sd">    :type calto_args: CalToArgs</span>
<span class="sd">    :return: True if data selection 2 is contained within data selection 1</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">all</span><span class="p">([</span><span class="ow">not</span> <span class="n">proposed</span><span class="o">.</span><span class="n">vis</span><span class="o">.</span><span class="n">isdisjoint</span><span class="p">(</span><span class="n">calto_args</span><span class="o">.</span><span class="n">vis</span><span class="p">),</span>
                <span class="ow">not</span> <span class="n">proposed</span><span class="o">.</span><span class="n">antenna</span><span class="o">.</span><span class="n">isdisjoint</span><span class="p">(</span><span class="n">calto_args</span><span class="o">.</span><span class="n">antenna</span><span class="p">),</span>
                <span class="ow">not</span> <span class="n">proposed</span><span class="o">.</span><span class="n">field</span><span class="o">.</span><span class="n">isdisjoint</span><span class="p">(</span><span class="n">calto_args</span><span class="o">.</span><span class="n">field</span><span class="p">),</span>
                <span class="ow">not</span> <span class="n">proposed</span><span class="o">.</span><span class="n">spw</span><span class="o">.</span><span class="n">isdisjoint</span><span class="p">(</span><span class="n">calto_args</span><span class="o">.</span><span class="n">spw</span><span class="p">),</span>
                <span class="ow">not</span> <span class="n">proposed</span><span class="o">.</span><span class="n">intent</span><span class="o">.</span><span class="n">isdisjoint</span><span class="p">(</span><span class="n">calto_args</span><span class="o">.</span><span class="n">intent</span><span class="p">)])</span></div>



<div class="viewcode-block" id="expand_calstate">
<a class="viewcode-back" href="../../../_apidoc/pipeline.infrastructure.html#pipeline.infrastructure.callibrary.expand_calstate">[docs]</a>
<span class="k">def</span> <span class="nf">expand_calstate</span><span class="p">(</span><span class="n">calstate</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert an IntervalCalState into the equivalent consolidated list of</span>
<span class="sd">    (CalTo, [CalFrom..]) 2-tuples.</span>

<span class="sd">    This function is is the top-level entry point for converting a calibration</span>
<span class="sd">    state to 2-tuples. It consolidates data selections and converts numeric</span>
<span class="sd">    data selection IDs to friendly equivalents through downstream processing,</span>

<span class="sd">    :param calstate: the IntervalCalState to convert</span>
<span class="sd">    :return: a list of (CalTo, [CalFrom..]) tuples</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># step 1: convert to [(CalTo, [CalFrom..]), ..]</span>
    <span class="n">unmerged</span> <span class="o">=</span> <span class="n">expand_calstate_to_calapps</span><span class="p">(</span><span class="n">calstate</span><span class="p">)</span>

    <span class="c1"># step 2: consolidate entries with identical calibrations</span>
    <span class="n">consolidated</span> <span class="o">=</span> <span class="n">consolidate_calibrations</span><span class="p">(</span><span class="n">unmerged</span><span class="p">)</span>

    <span class="c1"># step 3: take the list of (CalToArgs, [CalFrom]) tuples, taking any</span>
    <span class="c1"># CalToArgs whose vis property targets multiple MSes and dividing them</span>
    <span class="c1"># into n entries each targeting a single MS. This keeps the export data</span>
    <span class="c1"># format more readable as each entry targets a single measurement set.</span>
    <span class="n">per_ms</span> <span class="o">=</span> <span class="p">[(</span><span class="n">CalToArgs</span><span class="p">({</span><span class="n">vis</span><span class="p">},</span> <span class="o">*</span><span class="n">cta</span><span class="p">[</span><span class="mi">1</span><span class="p">:]),</span> <span class="n">calfroms</span><span class="p">)</span>
              <span class="k">for</span> <span class="n">cta</span><span class="p">,</span> <span class="n">calfroms</span> <span class="ow">in</span> <span class="n">consolidated</span> <span class="k">for</span> <span class="n">vis</span> <span class="ow">in</span> <span class="n">cta</span><span class="o">.</span><span class="n">vis</span><span class="p">]</span>

    <span class="c1"># step 4: convert integer ranges in data selection to friendlier CASA range</span>
    <span class="c1"># syntax, e.g.  [1,2,3,4,6,8] =&gt; [&#39;1~4&#39;,&#39;6&#39;,&#39;8&#39;]</span>
    <span class="n">casa_format</span> <span class="o">=</span> <span class="p">[(</span><span class="n">CalToArgs</span><span class="p">(</span><span class="n">vis</span><span class="o">=</span><span class="n">calto_args</span><span class="o">.</span><span class="n">vis</span><span class="p">,</span>
                              <span class="n">antenna</span><span class="o">=</span><span class="n">sequence_to_casa_range</span><span class="p">(</span><span class="n">calto_args</span><span class="o">.</span><span class="n">antenna</span><span class="p">),</span>
                              <span class="n">spw</span><span class="o">=</span><span class="n">sequence_to_casa_range</span><span class="p">(</span><span class="n">calto_args</span><span class="o">.</span><span class="n">spw</span><span class="p">),</span>
                              <span class="n">field</span><span class="o">=</span><span class="n">calto_args</span><span class="o">.</span><span class="n">field</span><span class="p">,</span>
                              <span class="n">intent</span><span class="o">=</span><span class="n">calto_args</span><span class="o">.</span><span class="n">intent</span><span class="p">),</span> <span class="n">calfroms</span><span class="p">)</span>
                   <span class="k">for</span> <span class="n">calto_args</span><span class="p">,</span> <span class="n">calfroms</span> <span class="ow">in</span> <span class="n">per_ms</span><span class="p">]</span>

    <span class="c1"># step 5: convert each iterable argument to a comma-separated string</span>
    <span class="k">return</span> <span class="p">[(</span><span class="n">CalToArgs</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">safe_join</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">calto_args</span><span class="p">]),</span> <span class="n">calfroms</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">calto_args</span><span class="p">,</span> <span class="n">calfroms</span> <span class="ow">in</span> <span class="n">casa_format</span><span class="p">]</span></div>



<div class="viewcode-block" id="get_min_max">
<a class="viewcode-back" href="../../../_apidoc/pipeline.infrastructure.html#pipeline.infrastructure.callibrary.get_min_max">[docs]</a>
<span class="k">def</span> <span class="nf">get_min_max</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">keyfunc</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">keyfunc</span><span class="p">:</span>
        <span class="n">l</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">keyfunc</span><span class="p">,</span> <span class="n">l</span><span class="p">))</span>
    <span class="c1"># this function is used to specify Interval ranges, which are not</span>
    <span class="c1"># inclusive of the upper bound - hence the +1.</span>
    <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">l</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span></div>



<div class="viewcode-block" id="create_interval_tree">
<a class="viewcode-back" href="../../../_apidoc/pipeline.infrastructure.html#pipeline.infrastructure.callibrary.create_interval_tree">[docs]</a>
<span class="k">def</span> <span class="nf">create_interval_tree</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create an IntervalTree containing a set of Intervals.</span>

<span class="sd">    The input argument used to create the Intervals is an iterable of</span>
<span class="sd">    3-tuples, each 3-tuple defined as:</span>

<span class="sd">    (interval start, interval end, function giving value for that interval).</span>

<span class="sd">    :param a: the iterable of argument tuples</span>
<span class="sd">    :return: IntervalTree</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">intervals</span> <span class="o">=</span> <span class="p">(</span><span class="n">intervaltree</span><span class="o">.</span><span class="n">Interval</span><span class="p">(</span><span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">data_fn</span><span class="p">())</span>
                 <span class="k">for</span> <span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">data_fn</span> <span class="ow">in</span> <span class="n">a</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">intervaltree</span><span class="o">.</span><span class="n">IntervalTree</span><span class="p">(</span><span class="n">intervals</span><span class="p">)</span></div>



<div class="viewcode-block" id="create_interval_tree_nd">
<a class="viewcode-back" href="../../../_apidoc/pipeline.infrastructure.html#pipeline.infrastructure.callibrary.create_interval_tree_nd">[docs]</a>
<span class="k">def</span> <span class="nf">create_interval_tree_nd</span><span class="p">(</span><span class="n">intervals</span><span class="p">,</span> <span class="n">value_fn</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a multidimensional IntervalTree. Each Interval within the</span>
<span class="sd">    IntervalTree points to the next dimension, with the final Interval</span>
<span class="sd">    containing the value given by calling value_fn.</span>

<span class="sd">    :param intervals: a list of Interval lists, with range of the final</span>
<span class="sd">    (deepest) first, ending with the range of the root dimension</span>
<span class="sd">    :param value_fn: function that returns value for the final dimension</span>
<span class="sd">    :return: an IntervalTree</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># wrapper to create TimestampedData objects with a fixed timestamp of now</span>
    <span class="n">tsd_now</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">TimestampedData</span><span class="p">,</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">())</span>

    <span class="c1"># Intervals have to point to the next dimension, so we must create the</span>
    <span class="c1"># dimensions in reverse order, starting with the deepest dimension.</span>
    <span class="n">final_tree</span> <span class="o">=</span> <span class="n">create_interval_tree</span><span class="p">([(</span><span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="k">lambda</span><span class="p">:</span> <span class="n">tsd_now</span><span class="p">(</span><span class="n">value_fn</span><span class="p">()))</span>
                                       <span class="k">for</span> <span class="n">begin</span><span class="p">,</span> <span class="n">end</span> <span class="ow">in</span> <span class="n">intervals</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
    <span class="n">root</span> <span class="o">=</span> <span class="n">final_tree</span>

    <span class="c1"># the parent dimensions just link to their child dimensions, similar to a</span>
    <span class="c1"># linked list</span>
    <span class="k">for</span> <span class="n">current_dim_intervals</span> <span class="ow">in</span> <span class="n">intervals</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
        <span class="n">dim_args</span> <span class="o">=</span> <span class="p">[(</span><span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="k">lambda</span><span class="p">:</span> <span class="n">tsd_now</span><span class="p">(</span><span class="n">root</span><span class="p">))</span>
                    <span class="k">for</span> <span class="n">begin</span><span class="p">,</span> <span class="n">end</span> <span class="ow">in</span> <span class="n">current_dim_intervals</span><span class="p">]</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">create_interval_tree</span><span class="p">(</span><span class="n">dim_args</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">root</span></div>



<div class="viewcode-block" id="create_interval_tree_for_ms">
<a class="viewcode-back" href="../../../_apidoc/pipeline.infrastructure.html#pipeline.infrastructure.callibrary.create_interval_tree_for_ms">[docs]</a>
<span class="k">def</span> <span class="nf">create_interval_tree_for_ms</span><span class="p">(</span><span class="n">ms</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a new IntervalTree fitted to the dimensions of a measurement set.</span>

<span class="sd">    This function creates a new IntervalTree with the size of the antenna,</span>
<span class="sd">    spw, field and intent dimensions fitted to envelop of the input measurement</span>
<span class="sd">    set.</span>

<span class="sd">    :param ms:</span>
<span class="sd">    :return: an IntervalTree</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">id_getter</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">attrgetter</span><span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
    <span class="n">tree_intervals</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">ms</span><span class="o">.</span><span class="n">intents</span><span class="p">))],</span>
        <span class="p">[</span><span class="n">get_min_max</span><span class="p">(</span><span class="n">ms</span><span class="o">.</span><span class="n">fields</span><span class="p">,</span> <span class="n">keyfunc</span><span class="o">=</span><span class="n">id_getter</span><span class="p">)],</span>
        <span class="p">[</span><span class="n">get_min_max</span><span class="p">(</span><span class="n">ms</span><span class="o">.</span><span class="n">spectral_windows</span><span class="p">,</span> <span class="n">keyfunc</span><span class="o">=</span><span class="n">id_getter</span><span class="p">)],</span>
        <span class="p">[</span><span class="n">get_min_max</span><span class="p">(</span><span class="n">ms</span><span class="o">.</span><span class="n">antennas</span><span class="p">,</span> <span class="n">keyfunc</span><span class="o">=</span><span class="n">id_getter</span><span class="p">)]</span>
    <span class="p">]</span>

    <span class="k">return</span> <span class="n">create_interval_tree_nd</span><span class="p">(</span><span class="n">tree_intervals</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span></div>



<div class="viewcode-block" id="trim">
<a class="viewcode-back" href="../../../_apidoc/pipeline.infrastructure.html#pipeline.infrastructure.callibrary.trim">[docs]</a>
<span class="k">def</span> <span class="nf">trim</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">ranges</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return an IntervalTree trimmed to the specified ranges.</span>

<span class="sd">    Ranges are specified as tuples of (begin, end).</span>

<span class="sd">    :param tree: the IntervalTree to trim</span>
<span class="sd">    :param ranges: a list of range tuples</span>
<span class="sd">    :return: the trimmed IntervalTree</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">insertions</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">begin</span><span class="p">,</span> <span class="n">end</span> <span class="ow">in</span> <span class="n">ranges</span><span class="p">:</span>
        <span class="c1"># locate Intervals overlapping the range, not just those completely</span>
        <span class="c1"># contained within the range</span>
        <span class="n">overlapping</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">overlap</span><span class="p">(</span><span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>

        <span class="c1"># truncate the Intervals to the range boundaries</span>
        <span class="n">truncated</span> <span class="o">=</span> <span class="p">{</span><span class="n">intervaltree</span><span class="o">.</span><span class="n">Interval</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">iv</span><span class="o">.</span><span class="n">begin</span><span class="p">,</span> <span class="n">begin</span><span class="p">),</span>
                                           <span class="nb">min</span><span class="p">(</span><span class="n">iv</span><span class="o">.</span><span class="n">end</span><span class="p">,</span> <span class="n">end</span><span class="p">),</span>
                                           <span class="n">iv</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
                     <span class="k">for</span> <span class="n">iv</span> <span class="ow">in</span> <span class="n">overlapping</span><span class="p">}</span>
        <span class="n">insertions</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">truncated</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">intervaltree</span><span class="o">.</span><span class="n">IntervalTree</span><span class="p">(</span><span class="n">insertions</span><span class="p">)</span></div>



<div class="viewcode-block" id="trim_nd">
<a class="viewcode-back" href="../../../_apidoc/pipeline.infrastructure.html#pipeline.infrastructure.callibrary.trim_nd">[docs]</a>
<span class="k">def</span> <span class="nf">trim_nd</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">selection</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return an IntervalTree with each dimension trimmed to the specified</span>
<span class="sd">    set of ranges.</span>

<span class="sd">    The data selection for each dimension is specified as a sequence of</span>
<span class="sd">    (begin, end) tuples; the data selection for the tree as a whole is a</span>
<span class="sd">    sequence of these dimension sequences. For example, the data selection</span>

<span class="sd">        [ [(1, 3)], [(0, 5), (7, 8)] ]</span>

<span class="sd">    would select 1-3 from the first dimension and 0-5, and 7 from the</span>
<span class="sd">    second dimension.</span>

<span class="sd">    :param tree: the IntervalTree to trim</span>
<span class="sd">    :param selection: the sequence of data selections for each dimension</span>
<span class="sd">    :return:</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># print(&#39;tree={}\nselection={}&#39;.format(tree, selection))</span>
    <span class="n">root</span> <span class="o">=</span> <span class="n">trim</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">selection</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">selection</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># TimestampedData objects are immutable namedtuples, so to change the</span>
        <span class="c1"># data they point to we must replace the whole Interval. These</span>
        <span class="c1"># replacement Intervals are identical to those they replace except for</span>
        <span class="c1"># the TimestampedData.data property, which is trimmed to the next set</span>
        <span class="c1"># of dimensions</span>
        <span class="n">replacements</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">intervaltree</span><span class="o">.</span><span class="n">Interval</span><span class="p">(</span><span class="n">iv</span><span class="o">.</span><span class="n">begin</span><span class="p">,</span>
                                  <span class="n">iv</span><span class="o">.</span><span class="n">end</span><span class="p">,</span>
                                  <span class="n">TimestampedData</span><span class="p">(</span><span class="n">iv</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">time</span><span class="p">,</span>
                                                  <span class="n">trim_nd</span><span class="p">(</span><span class="n">tsd_accessor</span><span class="p">(</span><span class="n">iv</span><span class="p">),</span> <span class="n">selection</span><span class="p">[</span><span class="mi">1</span><span class="p">:])))</span>
            <span class="k">for</span> <span class="n">iv</span> <span class="ow">in</span> <span class="n">root</span>
        <span class="p">}</span>
        <span class="c1"># now remove the untrimmed Intervals and replace them with our trimmed</span>
        <span class="c1"># versions</span>
        <span class="n">root</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="n">root</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">replacements</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">root</span></div>



<div class="viewcode-block" id="get_intent_id_map">
<a class="viewcode-back" href="../../../_apidoc/pipeline.infrastructure.html#pipeline.infrastructure.callibrary.get_intent_id_map">[docs]</a>
<span class="k">def</span> <span class="nf">get_intent_id_map</span><span class="p">(</span><span class="n">ms</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the mapping of intent ID to string intent for a measurement set.</span>

<span class="sd">    :param ms: the measurement set to analyse</span>
<span class="sd">    :return: a dict of intent ID: intent</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># intents are sorted to ensure consistent ordering</span>
    <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">ms</span><span class="o">.</span><span class="n">intents</span><span class="p">)))</span></div>



<div class="viewcode-block" id="IntervalCalState">
<a class="viewcode-back" href="../../../_apidoc/pipeline.infrastructure.html#pipeline.infrastructure.callibrary.IntervalCalState">[docs]</a>
<span class="k">class</span> <span class="nc">IntervalCalState</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    CalState is a data structure used to map calibrations for all data</span>
<span class="sd">    registered with the pipeline.</span>

<span class="sd">    It is implemented as a multi-dimensional array indexed by data selection</span>
<span class="sd">    parameters (ms, spw, field, intent, antenna), with the end value being a</span>
<span class="sd">    list of CalFroms, representing the calibrations to be applied to that data</span>
<span class="sd">    selection.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">id_to_intent</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">id_to_field</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">{}</span>

<div class="viewcode-block" id="IntervalCalState.from_calapplication">
<a class="viewcode-back" href="../../../_apidoc/pipeline.infrastructure.html#pipeline.infrastructure.callibrary.IntervalCalState.from_calapplication">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_calapplication</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">calto</span><span class="p">,</span> <span class="n">calfroms</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">calfroms</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">calfroms</span> <span class="o">=</span> <span class="p">[</span><span class="n">calfroms</span><span class="p">]</span>

        <span class="n">adapted</span> <span class="o">=</span> <span class="n">CalToIntervalAdapter</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">calto</span><span class="p">)</span>

        <span class="n">selection_intervals</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">adapted</span><span class="o">.</span><span class="n">intent</span><span class="p">,</span>
            <span class="n">adapted</span><span class="o">.</span><span class="n">field</span><span class="p">,</span>
            <span class="n">adapted</span><span class="o">.</span><span class="n">spw</span><span class="p">,</span>
            <span class="n">adapted</span><span class="o">.</span><span class="n">antenna</span>
        <span class="p">]</span>
        <span class="n">selection</span> <span class="o">=</span> <span class="n">create_interval_tree_nd</span><span class="p">(</span><span class="n">selection_intervals</span><span class="p">,</span> <span class="k">lambda</span><span class="p">:</span> <span class="n">calfroms</span><span class="p">)</span>

        <span class="n">calstate</span> <span class="o">=</span> <span class="n">IntervalCalState</span><span class="o">.</span><span class="n">create_from_context</span><span class="p">(</span><span class="n">context</span><span class="p">)</span>
        <span class="n">ms</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">observing_run</span><span class="o">.</span><span class="n">get_ms</span><span class="p">(</span><span class="n">calto</span><span class="o">.</span><span class="n">vis</span><span class="p">)</span>
        <span class="n">calstate</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">ms</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">selection</span>

        <span class="n">calstate</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">ms</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">trim_to_valid_data_selection</span><span class="p">(</span><span class="n">calstate</span><span class="p">,</span> <span class="n">ms</span><span class="o">.</span><span class="n">name</span><span class="p">)[</span><span class="n">ms</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">calstate</span></div>


<div class="viewcode-block" id="IntervalCalState.create_from_context">
<a class="viewcode-back" href="../../../_apidoc/pipeline.infrastructure.html#pipeline.infrastructure.callibrary.IntervalCalState.create_from_context">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">create_from_context</span><span class="p">(</span><span class="n">context</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">LOG</span><span class="o">.</span><span class="n">isEnabledFor</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">TRACE</span><span class="p">):</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;Creating new CalLibrary from context&#39;</span><span class="p">)</span>

        <span class="c1"># holds a mapping of numeric intent ID to string intent for each ms.</span>
        <span class="n">id_to_intent</span> <span class="o">=</span> <span class="p">{</span><span class="n">ms</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="n">get_intent_id_map</span><span class="p">(</span><span class="n">ms</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">ms</span> <span class="ow">in</span> <span class="n">context</span><span class="o">.</span><span class="n">observing_run</span><span class="o">.</span><span class="n">measurement_sets</span><span class="p">}</span>

        <span class="c1"># holds a mapping of numeric ID to field name for each ms.</span>
        <span class="n">id_to_field</span> <span class="o">=</span> <span class="p">{</span><span class="n">ms</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="p">{</span><span class="n">field</span><span class="o">.</span><span class="n">id</span><span class="p">:</span> <span class="n">field</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">ms</span><span class="o">.</span><span class="n">fields</span><span class="p">}</span>
                       <span class="k">for</span> <span class="n">ms</span> <span class="ow">in</span> <span class="n">context</span><span class="o">.</span><span class="n">observing_run</span><span class="o">.</span><span class="n">measurement_sets</span><span class="p">}</span>

        <span class="n">calstate</span> <span class="o">=</span> <span class="n">IntervalCalState</span><span class="p">()</span>
        <span class="n">calstate</span><span class="o">.</span><span class="n">id_to_intent</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">id_to_intent</span><span class="p">)</span>
        <span class="n">calstate</span><span class="o">.</span><span class="n">id_to_field</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">id_to_field</span><span class="p">)</span>

        <span class="n">interval_trees</span> <span class="o">=</span> <span class="p">{</span><span class="n">ms</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="n">create_interval_tree_for_ms</span><span class="p">(</span><span class="n">ms</span><span class="p">)</span>
                          <span class="k">for</span> <span class="n">ms</span> <span class="ow">in</span> <span class="n">context</span><span class="o">.</span><span class="n">observing_run</span><span class="o">.</span><span class="n">measurement_sets</span><span class="p">}</span>
        <span class="n">calstate</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">interval_trees</span><span class="p">)</span>

        <span class="c1"># the shape is never modified and hence can be shared between calstates</span>
        <span class="k">for</span> <span class="n">ms</span> <span class="ow">in</span> <span class="n">context</span><span class="o">.</span><span class="n">observing_run</span><span class="o">.</span><span class="n">measurement_sets</span><span class="p">:</span>
            <span class="n">calstate</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">ms</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_calstate_shape</span><span class="p">(</span><span class="n">ms</span><span class="p">)</span>

        <span class="n">calstate</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">trim_to_valid_data_selection</span><span class="p">(</span><span class="n">calstate</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">calstate</span></div>


<div class="viewcode-block" id="IntervalCalState.clear">
<a class="viewcode-back" href="../../../_apidoc/pipeline.infrastructure.html#pipeline.infrastructure.callibrary.IntervalCalState.clear">[docs]</a>
    <span class="k">def</span> <span class="nf">clear</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">calstate</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">calstate</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span></div>

        <span class="c1"># do NOT clear the id mapping dicts as without access to the context</span>
        <span class="c1"># we have no way to repopulate them.</span>
        <span class="c1"># self.id_to_intent.clear()</span>
        <span class="c1"># self.id_to_field.clear()</span>

<div class="viewcode-block" id="IntervalCalState.trimmed">
<a class="viewcode-back" href="../../../_apidoc/pipeline.infrastructure.html#pipeline.infrastructure.callibrary.IntervalCalState.trimmed">[docs]</a>
    <span class="k">def</span> <span class="nf">trimmed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">calto</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a copy of this IntervalCalState trimmed to the specified CalTo data selection.</span>
<span class="sd">        :param calto:</span>
<span class="sd">        :param selection_intervals:</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># wrap the text-only CalTo in a CalToIntervalAdapter, which will parse</span>
        <span class="c1"># the CalTo properties and give us the appropriate subtable IDs to</span>
        <span class="c1"># iterate over</span>
        <span class="n">adapted</span> <span class="o">=</span> <span class="n">CalToIntervalAdapter</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">calto</span><span class="p">)</span>

        <span class="c1"># get the data selection as numeric IDs</span>
        <span class="n">selection_intervals</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">adapted</span><span class="o">.</span><span class="n">antenna</span><span class="p">,</span>
            <span class="n">adapted</span><span class="o">.</span><span class="n">spw</span><span class="p">,</span>
            <span class="n">adapted</span><span class="o">.</span><span class="n">field</span><span class="p">,</span>
            <span class="n">adapted</span><span class="o">.</span><span class="n">intent</span>
        <span class="p">]</span>

        <span class="c1"># get a copy of this calstate trimmed to the CalTo data selection</span>
        <span class="n">vis</span> <span class="o">=</span> <span class="n">adapted</span><span class="o">.</span><span class="n">ms</span><span class="o">.</span><span class="n">name</span>

        <span class="c1"># if the data has not been registered with the CalLibrary, create a</span>
        <span class="c1"># new and empty calibration application and register it, thereby</span>
        <span class="c1"># creating all the IntervalTrees necessary for the MS.</span>
        <span class="k">if</span> <span class="n">vis</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">:</span>
            <span class="n">ms</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">observing_run</span><span class="o">.</span><span class="n">get_ms</span><span class="p">(</span><span class="n">vis</span><span class="p">)</span>
            <span class="n">calto</span> <span class="o">=</span> <span class="n">CalTo</span><span class="p">(</span><span class="n">vis</span><span class="o">=</span><span class="n">ms</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="n">to_add</span> <span class="o">=</span> <span class="n">IntervalCalState</span><span class="o">.</span><span class="n">from_calapplication</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">calto</span><span class="p">,</span> <span class="p">[])</span>
            <span class="bp">self</span><span class="o">.</span><span class="fm">__iadd__</span><span class="p">(</span><span class="n">to_add</span><span class="p">)</span>

        <span class="n">copied</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">vis</span><span class="p">])</span>
        <span class="n">trimmed</span> <span class="o">=</span> <span class="n">trim_nd</span><span class="p">(</span><span class="n">copied</span><span class="p">,</span> <span class="n">selection_intervals</span><span class="p">)</span>

        <span class="n">calstate</span> <span class="o">=</span> <span class="n">IntervalCalState</span><span class="p">()</span>
        <span class="n">calstate</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">vis</span><span class="p">]</span> <span class="o">=</span> <span class="n">trimmed</span>
        <span class="n">calstate</span><span class="o">.</span><span class="n">id_to_intent</span><span class="p">[</span><span class="n">vis</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">id_to_intent</span><span class="p">[</span><span class="n">vis</span><span class="p">]</span>
        <span class="n">calstate</span><span class="o">.</span><span class="n">id_to_field</span><span class="p">[</span><span class="n">vis</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">id_to_field</span><span class="p">[</span><span class="n">vis</span><span class="p">]</span>
        <span class="n">calstate</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span>

        <span class="k">return</span> <span class="n">calstate</span></div>


<div class="viewcode-block" id="IntervalCalState.get_caltable">
<a class="viewcode-back" href="../../../_apidoc/pipeline.infrastructure.html#pipeline.infrastructure.callibrary.IntervalCalState.get_caltable">[docs]</a>
    <span class="k">def</span> <span class="nf">get_caltable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">caltypes</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the names of all caltables registered with this CalState.</span>

<span class="sd">        If an optional caltypes argument is given, only caltables of the</span>
<span class="sd">        requested type will be returned.</span>

<span class="sd">        :param caltypes: Caltypes should be one or/a list of table</span>
<span class="sd">        types known in CalFrom.CALTYPES.</span>

<span class="sd">        :rtype: set of strings</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">caltypes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">caltypes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">CalFrom</span><span class="o">.</span><span class="n">CALTYPES</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">caltypes</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">caltypes</span> <span class="o">=</span> <span class="p">(</span><span class="n">caltypes</span><span class="p">,)</span>

        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">caltypes</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">CalFrom</span><span class="o">.</span><span class="n">CALTYPES</span>

        <span class="k">return</span> <span class="p">{</span><span class="n">calfrom</span><span class="o">.</span><span class="n">gaintable</span> <span class="k">for</span> <span class="n">calfroms</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">merged</span><span class="p">()</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">calfrom</span> <span class="ow">in</span> <span class="n">calfroms</span>
                <span class="k">if</span> <span class="n">calfrom</span><span class="o">.</span><span class="n">caltype</span> <span class="ow">in</span> <span class="n">caltypes</span><span class="p">}</span></div>


<div class="viewcode-block" id="IntervalCalState.merged">
<a class="viewcode-back" href="../../../_apidoc/pipeline.infrastructure.html#pipeline.infrastructure.callibrary.IntervalCalState.merged">[docs]</a>
    <span class="k">def</span> <span class="nf">merged</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hide_empty</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">calapps</span> <span class="o">=</span> <span class="n">expand_calstate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">hide_empty</span><span class="p">:</span>
            <span class="n">calapps</span> <span class="o">=</span> <span class="p">[</span><span class="n">ca</span> <span class="k">for</span> <span class="n">ca</span> <span class="ow">in</span> <span class="n">calapps</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ca</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>

        <span class="c1"># TODO dict is unnecessary. refactor all usages of this class to use</span>
        <span class="c1"># the tuple</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">calapps</span><span class="p">)</span></div>


<div class="viewcode-block" id="IntervalCalState.export_to_casa_callibrary">
<a class="viewcode-back" href="../../../_apidoc/pipeline.infrastructure.html#pipeline.infrastructure.callibrary.IntervalCalState.export_to_casa_callibrary">[docs]</a>
    <span class="k">def</span> <span class="nf">export_to_casa_callibrary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ms</span><span class="p">,</span> <span class="n">callibfile</span><span class="p">):</span>
        <span class="n">calapps</span> <span class="o">=</span> <span class="p">(</span><span class="n">CalApplication</span><span class="p">(</span><span class="n">calto</span><span class="p">,</span> <span class="n">calfroms</span><span class="p">)</span>
                   <span class="k">for</span> <span class="n">calto</span><span class="p">,</span> <span class="n">calfroms</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">merged</span><span class="p">(</span><span class="n">hide_empty</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
        <span class="n">append</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">calapp</span> <span class="ow">in</span> <span class="n">calapps</span><span class="p">:</span>
            <span class="n">casa_intents</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">to_CASA_intent</span><span class="p">(</span><span class="n">ms</span><span class="p">,</span> <span class="n">calapp</span><span class="o">.</span><span class="n">intent</span><span class="p">)</span>
            <span class="n">applycaltocallib</span><span class="p">(</span><span class="n">callibfile</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="n">append</span><span class="p">,</span> <span class="n">field</span><span class="o">=</span><span class="n">calapp</span><span class="o">.</span><span class="n">field</span><span class="p">,</span> <span class="n">intent</span><span class="o">=</span><span class="n">casa_intents</span><span class="p">,</span> <span class="n">spw</span><span class="o">=</span><span class="n">calapp</span><span class="o">.</span><span class="n">spw</span><span class="p">,</span>
                             <span class="n">gaintable</span><span class="o">=</span><span class="n">calapp</span><span class="o">.</span><span class="n">gaintable</span><span class="p">,</span> <span class="n">gainfield</span><span class="o">=</span><span class="n">calapp</span><span class="o">.</span><span class="n">gainfield</span><span class="p">,</span> <span class="n">interp</span><span class="o">=</span><span class="n">calapp</span><span class="o">.</span><span class="n">interp</span><span class="p">,</span>
                             <span class="n">spwmap</span><span class="o">=</span><span class="n">calapp</span><span class="o">.</span><span class="n">spwmap</span><span class="p">,</span> <span class="n">calwt</span><span class="o">=</span><span class="n">calapp</span><span class="o">.</span><span class="n">calwt</span><span class="p">)</span>
            <span class="n">append</span> <span class="o">=</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="IntervalCalState.as_applycal">
<a class="viewcode-back" href="../../../_apidoc/pipeline.infrastructure.html#pipeline.infrastructure.callibrary.IntervalCalState.as_applycal">[docs]</a>
    <span class="k">def</span> <span class="nf">as_applycal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">calapps</span> <span class="o">=</span> <span class="p">(</span><span class="n">CalApplication</span><span class="p">(</span><span class="n">calto</span><span class="p">,</span> <span class="n">calfroms</span><span class="p">)</span>
                   <span class="k">for</span> <span class="n">calto</span><span class="p">,</span> <span class="n">calfroms</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">merged</span><span class="p">(</span><span class="n">hide_empty</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>

        <span class="k">return</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">calapps</span><span class="p">])</span></div>


    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_applycal</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_combine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">combine_fn</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the union of this object combined with another IntervalCalState,</span>
<span class="sd">        applying a function to any Intervals that overlap.</span>

<span class="sd">        :param other: the other IntervalCalState</span>
<span class="sd">        :param combine_fn: the combining function to apply</span>
<span class="sd">        :return: IntervalCalState</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">calstate</span> <span class="o">=</span> <span class="n">IntervalCalState</span><span class="p">()</span>

        <span class="c1"># ensure that the other calstate is not considered equal to this</span>
        <span class="c1"># calstate, even if they the values they hold are identical. This step</span>
        <span class="c1"># is required so that all entries are added to in the union</span>
        <span class="c1"># (my_root | other_root) operation, and ensures that arithmetic like</span>
        <span class="c1"># &#39;calstate_x - calstate_x = 0&#39; holds true.</span>
        <span class="n">marker</span> <span class="o">=</span> <span class="n">uuid</span><span class="o">.</span><span class="n">uuid4</span><span class="p">()</span>
        <span class="n">other_marked</span> <span class="o">=</span> <span class="n">set_calstate_marker</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">marker</span><span class="p">)</span>

        <span class="c1"># copy the ID mapping and shape data across.</span>
        <span class="n">calstate</span><span class="o">.</span><span class="n">id_to_intent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">id_to_intent</span>
        <span class="n">calstate</span><span class="o">.</span><span class="n">id_to_field</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">id_to_field</span>
        <span class="n">calstate</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span>

        <span class="k">for</span> <span class="n">vis</span><span class="p">,</span> <span class="n">my_root</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">LOG</span><span class="o">.</span><span class="n">isEnabledFor</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">TRACE</span><span class="p">):</span>
                <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;Combining callibrary entries for </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">vis</span><span class="p">)))</span>
            <span class="c1"># adopt IntervalTrees present in just this object</span>
            <span class="k">if</span> <span class="n">vis</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">other_marked</span><span class="o">.</span><span class="n">data</span><span class="p">:</span>
                <span class="c1"># TODO think: does this need to be a deep copy?</span>
                <span class="n">calstate</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">vis</span><span class="p">]</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">vis</span><span class="p">])</span>
                <span class="k">continue</span>

            <span class="c1"># get the union of IntervalTrees for MSes present in both objects</span>
            <span class="n">other_root</span> <span class="o">=</span> <span class="n">other_marked</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">vis</span><span class="p">]</span>
            <span class="n">union</span> <span class="o">=</span> <span class="n">my_root</span> <span class="o">|</span> <span class="n">other_root</span>
            <span class="n">union</span><span class="o">.</span><span class="n">split_overlaps</span><span class="p">()</span>
            <span class="n">union</span><span class="o">.</span><span class="n">merge_equals</span><span class="p">(</span><span class="n">data_reducer</span><span class="o">=</span><span class="n">combine_fn</span><span class="p">)</span>

            <span class="n">calstate</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">vis</span><span class="p">]</span> <span class="o">=</span> <span class="n">union</span>

        <span class="n">calstate</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">trim_to_valid_data_selection</span><span class="p">(</span><span class="n">calstate</span><span class="p">)</span>

        <span class="c1"># Unmark the result calstate, thus eliminating any residual uuids</span>
        <span class="n">unmarked</span> <span class="o">=</span> <span class="n">set_calstate_marker</span><span class="p">(</span><span class="n">calstate</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">unmarked</span>

    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="n">calstate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_combine</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ant_add</span><span class="p">)</span>

        <span class="c1"># also adopt IntervalTrees only present in the other object</span>
        <span class="k">for</span> <span class="n">vis</span><span class="p">,</span> <span class="n">other_root</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">vis</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">:</span>
                <span class="n">calstate</span><span class="p">[</span><span class="n">vis</span><span class="p">]</span> <span class="o">=</span> <span class="n">other_root</span>
                <span class="n">calstate</span><span class="o">.</span><span class="n">id_to_intent</span><span class="p">[</span><span class="n">vis</span><span class="p">]</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">id_to_intent</span><span class="p">[</span><span class="n">vis</span><span class="p">]</span>
                <span class="n">calstate</span><span class="o">.</span><span class="n">id_to_field</span><span class="p">[</span><span class="n">vis</span><span class="p">]</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">id_to_field</span><span class="p">[</span><span class="n">vis</span><span class="p">]</span>
                <span class="n">calstate</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">vis</span><span class="p">]</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">vis</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">calstate</span>

    <span class="k">def</span> <span class="fm">__iadd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="n">sum_state</span> <span class="o">=</span> <span class="bp">self</span> <span class="o">+</span> <span class="n">other</span>

        <span class="c1"># adopt all properties from the added states</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">sum_state</span><span class="o">.</span><span class="n">data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">id_to_field</span> <span class="o">=</span> <span class="n">sum_state</span><span class="o">.</span><span class="n">id_to_field</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">id_to_intent</span> <span class="o">=</span> <span class="n">sum_state</span><span class="o">.</span><span class="n">id_to_intent</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">sum_state</span><span class="o">.</span><span class="n">shape</span>

        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="fm">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_combine</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ant_sub</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="fm">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span></div>



<div class="viewcode-block" id="fix_cycle0_data_selection">
<a class="viewcode-back" href="../../../_apidoc/pipeline.infrastructure.html#pipeline.infrastructure.callibrary.fix_cycle0_data_selection">[docs]</a>
<span class="k">def</span> <span class="nf">fix_cycle0_data_selection</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">calstate</span><span class="p">):</span>
    <span class="c1"># shortcut to minimise processing for data from Cycle 1 onwards.</span>
    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">utils</span><span class="o">.</span><span class="n">get_epoch_as_datetime</span><span class="p">(</span><span class="n">ms</span><span class="o">.</span><span class="n">start_time</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">CYCLE_0_END_DATE</span>
           <span class="k">for</span> <span class="n">ms</span> <span class="ow">in</span> <span class="n">context</span><span class="o">.</span><span class="n">observing_run</span><span class="o">.</span><span class="n">measurement_sets</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">calstate</span>

    <span class="n">final_calstate</span> <span class="o">=</span> <span class="n">IntervalCalState</span><span class="o">.</span><span class="n">create_from_context</span><span class="p">(</span><span class="n">context</span><span class="p">)</span>

    <span class="c1"># We can&#39;t trust Cycle 0 data intents. If this is Cycle 0 data we need</span>
    <span class="c1"># to resolve the intents to fields and add them to the CalTo data</span>
    <span class="c1"># selection to ensure that the correct data is selected.</span>
    <span class="k">for</span> <span class="n">calto</span><span class="p">,</span> <span class="n">calfroms</span> <span class="ow">in</span> <span class="n">calstate</span><span class="o">.</span><span class="n">merged</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">vis</span> <span class="o">=</span> <span class="n">calto</span><span class="o">.</span><span class="n">vis</span>
        <span class="n">ms</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">observing_run</span><span class="o">.</span><span class="n">get_ms</span><span class="p">(</span><span class="n">vis</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">utils</span><span class="o">.</span><span class="n">get_epoch_as_datetime</span><span class="p">(</span><span class="n">ms</span><span class="o">.</span><span class="n">start_time</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">CYCLE_0_END_DATE</span><span class="p">:</span>
            <span class="n">final_calstate</span> <span class="o">+=</span> <span class="n">IntervalCalState</span><span class="o">.</span><span class="n">from_calapplication</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">calto</span><span class="p">,</span> <span class="n">calfroms</span><span class="p">)</span>
            <span class="k">continue</span>

        <span class="k">if</span> <span class="n">calto</span><span class="o">.</span><span class="n">intent</span> <span class="o">!=</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
            <span class="n">fields_with_intent</span> <span class="o">=</span> <span class="n">ms</span><span class="o">.</span><span class="n">get_fields</span><span class="p">(</span><span class="n">task_arg</span><span class="o">=</span><span class="n">calto</span><span class="o">.</span><span class="n">field</span><span class="p">,</span> <span class="n">intent</span><span class="o">=</span><span class="n">calto</span><span class="o">.</span><span class="n">intent</span><span class="p">)</span>
            <span class="n">field_names</span> <span class="o">=</span> <span class="p">{</span><span class="n">f</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">fields_with_intent</span><span class="p">}</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">field_names</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">fields_with_intent</span><span class="p">):</span>
                <span class="n">new_field_arg</span> <span class="o">=</span> <span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">field_names</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_field_arg</span> <span class="o">=</span> <span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">field</span><span class="o">.</span><span class="n">id</span><span class="p">)</span> <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">fields_with_intent</span><span class="p">])</span>

            <span class="k">if</span> <span class="n">new_field_arg</span> <span class="o">!=</span> <span class="n">calto</span><span class="o">.</span><span class="n">field</span><span class="p">:</span>
                <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Rewriting data selection to work around mislabeled Cycle 0 data intents. &#39;</span>
                         <span class="s1">&#39;Old field selection: </span><span class="si">%r</span><span class="s1">; new field selection: </span><span class="si">%r</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">calto</span><span class="o">.</span><span class="n">field</span><span class="p">,</span> <span class="n">new_field_arg</span><span class="p">)</span>
                <span class="n">calto</span> <span class="o">=</span> <span class="n">CalTo</span><span class="p">(</span><span class="n">vis</span><span class="o">=</span><span class="n">calto</span><span class="o">.</span><span class="n">vis</span><span class="p">,</span> <span class="n">field</span><span class="o">=</span><span class="n">new_field_arg</span><span class="p">,</span> <span class="n">spw</span><span class="o">=</span><span class="n">calto</span><span class="o">.</span><span class="n">spw</span><span class="p">,</span> <span class="n">antenna</span><span class="o">=</span><span class="n">calto</span><span class="o">.</span><span class="n">antenna</span><span class="p">,</span>
                              <span class="n">intent</span><span class="o">=</span><span class="n">calto</span><span class="o">.</span><span class="n">intent</span><span class="p">)</span>

        <span class="n">to_add</span> <span class="o">=</span> <span class="n">IntervalCalState</span><span class="o">.</span><span class="n">from_calapplication</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">calto</span><span class="p">,</span> <span class="n">calfroms</span><span class="p">)</span>
        <span class="n">final_calstate</span> <span class="o">+=</span> <span class="n">to_add</span>

    <span class="k">return</span> <span class="n">final_calstate</span></div>



<div class="viewcode-block" id="IntervalCalLibrary">
<a class="viewcode-back" href="../../../_apidoc/pipeline.infrastructure.html#pipeline.infrastructure.callibrary.IntervalCalLibrary">[docs]</a>
<span class="k">class</span> <span class="nc">IntervalCalLibrary</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    CalLibrary is the root object for the pipeline calibration state.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_context</span> <span class="o">=</span> <span class="n">context</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_active</span> <span class="o">=</span> <span class="n">IntervalCalState</span><span class="o">.</span><span class="n">create_from_context</span><span class="p">(</span><span class="n">context</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_applied</span> <span class="o">=</span> <span class="n">IntervalCalState</span><span class="o">.</span><span class="n">create_from_context</span><span class="p">(</span><span class="n">context</span><span class="p">)</span>

<div class="viewcode-block" id="IntervalCalLibrary.clear">
<a class="viewcode-back" href="../../../_apidoc/pipeline.infrastructure.html#pipeline.infrastructure.callibrary.IntervalCalLibrary.clear">[docs]</a>
    <span class="k">def</span> <span class="nf">clear</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_active</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_applied</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span></div>


    <span class="k">def</span> <span class="nf">_calc_filename</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">filename</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">filename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_context</span><span class="o">.</span><span class="n">output_dir</span><span class="p">,</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">_context</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;.calstate&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">filename</span>

    <span class="k">def</span> <span class="nf">_export</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">calstate</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calc_filename</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>

        <span class="n">calapps</span> <span class="o">=</span> <span class="p">[</span><span class="n">CalApplication</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">calstate</span><span class="o">.</span><span class="n">merged</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">()]</span>

        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">export_file</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ca</span> <span class="ow">in</span> <span class="n">calapps</span><span class="p">:</span>
                <span class="n">export_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">ca</span><span class="o">.</span><span class="n">as_applycal</span><span class="p">())</span>
                <span class="n">export_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="IntervalCalLibrary.add">
<a class="viewcode-back" href="../../../_apidoc/pipeline.infrastructure.html#pipeline.infrastructure.callibrary.IntervalCalLibrary.add">[docs]</a>
    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">calto</span><span class="p">,</span> <span class="n">calfroms</span><span class="p">):</span>
        <span class="n">to_add</span> <span class="o">=</span> <span class="n">IntervalCalState</span><span class="o">.</span><span class="n">from_calapplication</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_context</span><span class="p">,</span> <span class="n">calto</span><span class="p">,</span> <span class="n">calfroms</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_active</span> <span class="o">+=</span> <span class="n">to_add</span>

        <span class="k">if</span> <span class="n">LOG</span><span class="o">.</span><span class="n">isEnabledFor</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">TRACE</span><span class="p">):</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;Calstate after _add:</span><span class="se">\n</span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_active</span><span class="o">.</span><span class="n">as_applycal</span><span class="p">())</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">active</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        CalState holding CalApplications to be (pre-)applied to the MS.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_active</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">applied</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        CalState holding CalApplications that have been applied to the MS via</span>
<span class="sd">        the pipeline applycal task.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_applied</span>

<div class="viewcode-block" id="IntervalCalLibrary.export">
<a class="viewcode-back" href="../../../_apidoc/pipeline.infrastructure.html#pipeline.infrastructure.callibrary.IntervalCalLibrary.export">[docs]</a>
    <span class="k">def</span> <span class="nf">export</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Export the pre-apply calibration state to disk.</span>

<span class="sd">        The pre-apply calibrations held in the &#39;active&#39; CalState will be</span>
<span class="sd">        written to disk as a set of equivalent applycal calls.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calc_filename</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Exporting current calibration state to </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_export</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_active</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span></div>


<div class="viewcode-block" id="IntervalCalLibrary.export_applied">
<a class="viewcode-back" href="../../../_apidoc/pipeline.infrastructure.html#pipeline.infrastructure.callibrary.IntervalCalLibrary.export_applied">[docs]</a>
    <span class="k">def</span> <span class="nf">export_applied</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Export the applied calibration state to disk.</span>

<span class="sd">        The calibrations held in the &#39;applied&#39; CalState will be written to</span>
<span class="sd">        disk as a set of equivalent applycal calls.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calc_filename</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Exporting applied calibration state to </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_export</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_applied</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span></div>


<div class="viewcode-block" id="IntervalCalLibrary.get_calstate">
<a class="viewcode-back" href="../../../_apidoc/pipeline.infrastructure.html#pipeline.infrastructure.callibrary.IntervalCalLibrary.get_calstate">[docs]</a>
    <span class="k">def</span> <span class="nf">get_calstate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">calto</span><span class="p">,</span> <span class="n">ignore</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the active calibration state for a target data selection.</span>

<span class="sd">        :param calto: the data selection</span>
<span class="sd">        :param ignore:</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ignore</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ignore</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">trimmed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">active</span><span class="o">.</span><span class="n">trimmed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_context</span><span class="p">,</span> <span class="n">calto</span><span class="p">)</span>

        <span class="c1"># TODO replace with something like defrag_tree implementation</span>
        <span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="n">trimmed</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">antenna_interval</span> <span class="ow">in</span> <span class="n">tree</span><span class="p">:</span>
                <span class="n">spw_tree</span> <span class="o">=</span> <span class="n">tsd_accessor</span><span class="p">(</span><span class="n">antenna_interval</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">spw_interval</span> <span class="ow">in</span> <span class="n">spw_tree</span><span class="p">:</span>
                    <span class="n">field_tree</span> <span class="o">=</span> <span class="n">tsd_accessor</span><span class="p">(</span><span class="n">spw_interval</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">field_interval</span> <span class="ow">in</span> <span class="n">field_tree</span><span class="p">:</span>
                        <span class="n">intent_tree</span> <span class="o">=</span> <span class="n">tsd_accessor</span><span class="p">(</span><span class="n">field_interval</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">intent_interval</span> <span class="ow">in</span> <span class="n">intent_tree</span><span class="p">:</span>
                            <span class="n">old_vals</span> <span class="o">=</span> <span class="n">tsd_accessor</span><span class="p">(</span><span class="n">intent_interval</span><span class="p">)</span>
                            <span class="n">old_vals</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_copy_calfrom</span><span class="p">(</span><span class="n">cf</span><span class="p">,</span> <span class="n">ignore</span><span class="p">)</span>
                                           <span class="k">for</span> <span class="n">cf</span> <span class="ow">in</span> <span class="n">old_vals</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">trimmed</span></div>


    <span class="k">def</span> <span class="nf">_copy_calfrom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">to_copy</span><span class="p">,</span> <span class="n">ignore</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">ignore</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ignore</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">calfrom_properties</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;caltype&#39;</span><span class="p">,</span> <span class="s1">&#39;calwt&#39;</span><span class="p">,</span> <span class="s1">&#39;gainfield&#39;</span><span class="p">,</span> <span class="s1">&#39;gaintable&#39;</span><span class="p">,</span>
                              <span class="s1">&#39;interp&#39;</span><span class="p">,</span> <span class="s1">&#39;spwmap&#39;</span><span class="p">]</span>

        <span class="n">copied</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">to_copy</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">calfrom_properties</span>
                  <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ignore</span><span class="p">}</span>

        <span class="k">return</span> <span class="n">CalFrom</span><span class="p">(</span><span class="o">**</span><span class="n">copied</span><span class="p">)</span>

<div class="viewcode-block" id="IntervalCalLibrary.import_state">
<a class="viewcode-back" href="../../../_apidoc/pipeline.infrastructure.html#pipeline.infrastructure.callibrary.IntervalCalLibrary.import_state">[docs]</a>
    <span class="k">def</span> <span class="nf">import_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calc_filename</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>

        <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Importing calibration state from </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">filename</span><span class="p">)</span>
        <span class="n">calapps</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">import_file</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="p">[</span><span class="n">l</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">import_file</span> <span class="k">if</span> <span class="n">l</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;applycal(&#39;</span><span class="p">)]:</span>
                <span class="n">calapp</span> <span class="o">=</span> <span class="n">CalApplication</span><span class="o">.</span><span class="n">from_export</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
                <span class="n">calapps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">calapp</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">append</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">calstate</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_active</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">calstate</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">calapp</span> <span class="ow">in</span> <span class="n">calapps</span><span class="p">:</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Adding </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">calapp</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">calapp</span><span class="o">.</span><span class="n">calto</span><span class="p">,</span> <span class="n">calapp</span><span class="o">.</span><span class="n">calfrom</span><span class="p">)</span>

        <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Calibration state after import:</span><span class="se">\n</span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">active</span><span class="o">.</span><span class="n">as_applycal</span><span class="p">())</span></div>


<div class="viewcode-block" id="IntervalCalLibrary.mark_as_applied">
<a class="viewcode-back" href="../../../_apidoc/pipeline.infrastructure.html#pipeline.infrastructure.callibrary.IntervalCalLibrary.mark_as_applied">[docs]</a>
    <span class="k">def</span> <span class="nf">mark_as_applied</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">calto</span><span class="p">,</span> <span class="n">calfrom</span><span class="p">):</span>
        <span class="n">application</span> <span class="o">=</span> <span class="n">IntervalCalState</span><span class="o">.</span><span class="n">from_calapplication</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_context</span><span class="p">,</span> <span class="n">calto</span><span class="p">,</span> <span class="n">calfrom</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_active</span> <span class="o">-=</span> <span class="n">application</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_applied</span> <span class="o">+=</span> <span class="n">application</span>

        <span class="k">if</span> <span class="n">LOG</span><span class="o">.</span><span class="n">isEnabledFor</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">):</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;New calibration state:</span><span class="se">\n</span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">active</span><span class="o">.</span><span class="n">as_applycal</span><span class="p">())</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Applied calibration state:</span><span class="se">\n</span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">applied</span><span class="o">.</span><span class="n">as_applycal</span><span class="p">())</span></div>


<div class="viewcode-block" id="IntervalCalLibrary.unregister_calibrations">
<a class="viewcode-back" href="../../../_apidoc/pipeline.infrastructure.html#pipeline.infrastructure.callibrary.IntervalCalLibrary.unregister_calibrations">[docs]</a>
    <span class="k">def</span> <span class="nf">unregister_calibrations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">predicate_fn</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">CalToArgs</span><span class="p">,</span> <span class="n">CalFrom</span><span class="p">],</span> <span class="nb">bool</span><span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Delete active calibrations that match the input predicate function.</span>

<span class="sd">        Context</span>
<span class="sd">        =======</span>

<span class="sd">        Previously, calibration had to be removed by calling private callibrary</span>
<span class="sd">        functions, e.g.,</span>

<span class="sd">            calto = callibrary.CalTo(self.inputs.vis)</span>
<span class="sd">            calfrom = callibrary.CalFrom(gaintable=ktypecaltable, interp=&#39;&#39;, calwt=False)</span>
<span class="sd">            context.callibrary._remove(calto, calfrom, context.callibrary._active)</span>

<span class="sd">        This function makes calibration removal a first-class public function</span>
<span class="sd">        of the callibrary, and requires less knowledge of the calibration to remove.</span>

<span class="sd">        Example usage</span>
<span class="sd">        =============</span>

<span class="sd">        The predicate function passed in by the caller defines which</span>
<span class="sd">        calibrations should be unregistered. For example, Tsys caltable</span>
<span class="sd">        removal can be achieved with the code below.</span>

<span class="sd">            def match_tsys(calto, calfrom):</span>
<span class="sd">                return calfrom.type == &#39;tsys&#39;</span>
<span class="sd">            callibrary.unregister_calibrations(match_tsys)</span>

<span class="sd">        The pipeline inserts the task name into the caltable filename,</span>
<span class="sd">        which can be used to unregister caltables generated by that task. For</span>
<span class="sd">        example,</span>

<span class="sd">            def match_task_caltable(calto, calfrom):</span>
<span class="sd">                return &#39;hifa_bandpass&#39; in calfrom.gaintable</span>
<span class="sd">            context.callibrary.unregister_calibrations(match_task_caltable)</span>

<span class="sd">        If you wanted to match calwt, interp, vis, etc. then that could be</span>
<span class="sd">        done in the matcher function too, but if it&#39;s not necessary to</span>
<span class="sd">        identify the caltable then it doesn&#39;t need to be tested in the</span>
<span class="sd">        predicate function.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">to_remove</span> <span class="o">=</span> <span class="n">get_matching_calstate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_context</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">active</span><span class="p">,</span> <span class="n">predicate_fn</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_active</span> <span class="o">-=</span> <span class="n">to_remove</span></div>
</div>



<span class="c1"># CalState = DictCalState</span>
<span class="c1"># CalLibrary = DictCalLibrary</span>
<span class="n">CalState</span> <span class="o">=</span> <span class="n">IntervalCalState</span>
<span class="n">CalLibrary</span> <span class="o">=</span> <span class="n">IntervalCalLibrary</span>


<div class="viewcode-block" id="TimestampedData">
<a class="viewcode-back" href="../../../_apidoc/pipeline.infrastructure.html#pipeline.infrastructure.callibrary.TimestampedData">[docs]</a>
<span class="k">class</span> <span class="nc">TimestampedData</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;TimestampedDataBase&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="s1">&#39;marker&#39;</span><span class="p">])):</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">()</span>  <span class="c1"># Saves memory, avoiding the need to create __dict__ for each interval</span>

    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">TimestampedData</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">marker</span><span class="p">)</span>

<div class="viewcode-block" id="TimestampedData.cmp">
<a class="viewcode-back" href="../../../_apidoc/pipeline.infrastructure.html#pipeline.infrastructure.callibrary.TimestampedData.cmp">[docs]</a>
    <span class="k">def</span> <span class="nf">cmp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Tells whether other sorts before, after or equal to this</span>
<span class="sd">        Interval.</span>

<span class="sd">        Sorting is by time then by data fields.</span>

<span class="sd">        If data fields are not both sortable types, data fields are</span>
<span class="sd">        compared alphabetically by type name.</span>
<span class="sd">        :param other: Interval</span>
<span class="sd">        :return: -1, 0, 1</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">time</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="n">time</span> <span class="k">else</span> <span class="mi">1</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">data</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">0</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="n">data</span> <span class="k">else</span> <span class="mi">1</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span>
            <span class="n">o</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span>
            <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="n">o</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">0</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="n">s</span> <span class="o">&lt;</span> <span class="n">o</span> <span class="k">else</span> <span class="mi">1</span></div>


    <span class="k">def</span> <span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Less than operator. Parrots __cmp__()</span>
<span class="sd">        :param other: Interval or point</span>
<span class="sd">        :return: True or False</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cmp</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="fm">__gt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Greater than operator. Parrots __cmp__()</span>
<span class="sd">        :param other: Interval or point</span>
<span class="sd">        :return: True or False</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cmp</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Executable string representation of this Interval.</span>
<span class="sd">        :return: string representation</span>
<span class="sd">        :rtype: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">marker</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;TSD(</span><span class="si">{0}</span><span class="s1">, </span><span class="si">{1}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">,</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">))</span>
        <span class="k">return</span> <span class="s1">&#39;TSD(</span><span class="si">{0}</span><span class="s1">, </span><span class="si">{1}</span><span class="s1">, </span><span class="si">{2}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">,</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">marker</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        String representation of this Interval.</span>
<span class="sd">        :return: string representation</span>
<span class="sd">        :rtype: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s1">&#39;TSD(</span><span class="si">{0}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Whether the begins equal, the ends equal, and the data fields</span>
<span class="sd">        equal. Compare range_matches().</span>
<span class="sd">        :param other: Interval</span>
<span class="sd">        :return: True or False</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">TimestampedData</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">time</span> <span class="ow">and</span> \
               <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">data</span> <span class="ow">and</span> \
               <span class="bp">self</span><span class="o">.</span><span class="n">marker</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">marker</span></div>



<div class="viewcode-block" id="trim_to_valid_data_selection">
<a class="viewcode-back" href="../../../_apidoc/pipeline.infrastructure.html#pipeline.infrastructure.callibrary.trim_to_valid_data_selection">[docs]</a>
<span class="k">def</span> <span class="nf">trim_to_valid_data_selection</span><span class="p">(</span><span class="n">calstate</span><span class="p">,</span> <span class="n">vis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Trim an IntervalCalState to the shape of valid (present) data selections.</span>

<span class="sd">    This is achieved by trimming Intervals for each dimension (antenna, spw,</span>
<span class="sd">    field, intent) to exclude ranges for which no data is present.</span>

<span class="sd">    See CAS-9415: CalLibrary needs a way to filter out calibration</span>
<span class="sd">    applications for missing data selections</span>

<span class="sd">    :param calstate: the calstate to shape</span>
<span class="sd">    :param vis: name of the calstate to shape. If not defined, shape all.</span>
<span class="sd">    :return: a new, shaped IntervalCalState</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">vis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">vislist</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">calstate</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">vislist</span> <span class="o">=</span> <span class="p">[</span><span class="n">vis</span><span class="p">]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">vis</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="n">vis</span>

    <span class="n">results</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">vis</span> <span class="ow">in</span> <span class="n">vislist</span><span class="p">:</span>
        <span class="n">antenna_tree</span> <span class="o">=</span> <span class="n">calstate</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">vis</span><span class="p">]</span>

        <span class="n">new_root</span> <span class="o">=</span> <span class="n">intervaltree</span><span class="o">.</span><span class="n">IntervalTree</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">antenna_tuple</span> <span class="ow">in</span> <span class="n">calstate</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">vis</span><span class="p">]:</span>
            <span class="k">for</span> <span class="n">antenna_ranges</span><span class="p">,</span> <span class="n">spw_tuple</span> <span class="ow">in</span> <span class="n">antenna_tuple</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">spw_ranges</span><span class="p">,</span> <span class="n">field_tuple</span> <span class="ow">in</span> <span class="n">spw_tuple</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">field_ranges</span><span class="p">,</span> <span class="n">intent_ranges</span> <span class="ow">in</span> <span class="n">field_tuple</span><span class="p">:</span>
                        <span class="n">tree_intervals</span> <span class="o">=</span> <span class="p">(</span><span class="n">antenna_ranges</span><span class="p">,</span> <span class="n">spw_ranges</span><span class="p">,</span> <span class="n">field_ranges</span><span class="p">,</span> <span class="n">intent_ranges</span><span class="p">)</span>
                        <span class="c1"># print(&#39;Shaping to {!r}&#39;.format(tree_intervals))</span>
                        <span class="n">new_root</span> <span class="o">|=</span> <span class="n">trim_nd</span><span class="p">(</span><span class="n">antenna_tree</span><span class="p">,</span> <span class="n">tree_intervals</span><span class="p">)</span>

        <span class="n">results</span><span class="p">[</span><span class="n">vis</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_root</span>

    <span class="k">return</span> <span class="n">results</span></div>



<span class="k">def</span> <span class="nf">_merge_intervals</span><span class="p">(</span><span class="n">unmerged</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Merge adjacent Intervals (represented by the keys within the input dict)</span>
<span class="sd">    that have identical values and output an IntervalTree-friendly tuple of</span>
<span class="sd">    constructor arguments.</span>

<span class="sd">    For example, a dict containing</span>

<span class="sd">        {1: A, 2: B, 3:A, 4:A}</span>

<span class="sd">    would be converted to</span>

<span class="sd">        ((((1, 2), (3, 5)), &#39;A&#39;), (((2, 3),), &#39;B&#39;))</span>

<span class="sd">    :param unmerged: a dict mapping IDs to values</span>
<span class="sd">    :return: tuple of constructor arguments ready for create_interval_tree_nd</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">reversed</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">set</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">unmerged</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="nb">reversed</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">((</span><span class="nb">tuple</span><span class="p">(</span><span class="n">sequence_to_range</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span> <span class="k">for</span> <span class="n">seq</span> <span class="ow">in</span> <span class="n">contiguous_sequences</span><span class="p">(</span><span class="n">v</span><span class="p">)),</span> <span class="n">k</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="o">.</span><span class="n">items</span><span class="p">()))</span>


<span class="k">def</span> <span class="nf">_print_dimensions</span><span class="p">(</span><span class="n">calstate</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Debugging function used to print the dimensions of an IntervalCalState.</span>

<span class="sd">    :param calstate: the calstate to inspect</span>
<span class="sd">    :return:</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">vis</span><span class="p">,</span> <span class="n">antenna_tree</span> <span class="ow">in</span> <span class="n">calstate</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">antenna_interval</span> <span class="ow">in</span> <span class="n">antenna_tree</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">antenna_ranges</span> <span class="o">=</span> <span class="p">(</span><span class="n">antenna_interval</span><span class="o">.</span><span class="n">begin</span><span class="p">,</span> <span class="n">antenna_interval</span><span class="o">.</span><span class="n">end</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">spw_interval</span> <span class="ow">in</span> <span class="n">antenna_interval</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">data</span><span class="p">:</span>
                <span class="n">spw_ranges</span> <span class="o">=</span> <span class="p">(</span><span class="n">spw_interval</span><span class="o">.</span><span class="n">begin</span><span class="p">,</span> <span class="n">spw_interval</span><span class="o">.</span><span class="n">end</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">field_interval</span> <span class="ow">in</span> <span class="n">spw_interval</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">data</span><span class="p">:</span>
                    <span class="n">field_ranges</span> <span class="o">=</span> <span class="p">(</span><span class="n">field_interval</span><span class="o">.</span><span class="n">begin</span><span class="p">,</span> <span class="n">field_interval</span><span class="o">.</span><span class="n">end</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">intent_interval</span> <span class="ow">in</span> <span class="n">field_interval</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">data</span><span class="p">:</span>
                        <span class="n">intent_ranges</span> <span class="o">=</span> <span class="p">(</span><span class="n">intent_interval</span><span class="o">.</span><span class="n">begin</span><span class="p">,</span> <span class="n">intent_interval</span><span class="o">.</span><span class="n">end</span><span class="p">)</span>

                        <span class="n">tree_intervals</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">vis</span><span class="p">),</span> <span class="n">antenna_ranges</span><span class="p">,</span> <span class="n">spw_ranges</span><span class="p">,</span> <span class="n">field_ranges</span><span class="p">,</span> <span class="n">intent_ranges</span><span class="p">)</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{!r}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tree_intervals</span><span class="p">))</span>


<div class="viewcode-block" id="get_calto_from_inputs">
<a class="viewcode-back" href="../../../_apidoc/pipeline.infrastructure.html#pipeline.infrastructure.callibrary.get_calto_from_inputs">[docs]</a>
<span class="k">def</span> <span class="nf">get_calto_from_inputs</span><span class="p">(</span><span class="n">inputs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get a CalTo data selection object based on the state of an Inputs object</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">CalTo</span><span class="p">(</span><span class="n">vis</span><span class="o">=</span><span class="n">inputs</span><span class="o">.</span><span class="n">vis</span><span class="p">,</span> <span class="n">field</span><span class="o">=</span><span class="n">inputs</span><span class="o">.</span><span class="n">field</span><span class="p">,</span> <span class="n">spw</span><span class="o">=</span><span class="n">inputs</span><span class="o">.</span><span class="n">spw</span><span class="p">,</span> <span class="n">intent</span><span class="o">=</span><span class="n">inputs</span><span class="o">.</span><span class="n">intent</span><span class="p">,</span> <span class="n">antenna</span><span class="o">=</span><span class="n">inputs</span><span class="o">.</span><span class="n">antenna</span><span class="p">)</span></div>



<div class="viewcode-block" id="set_calstate_marker">
<a class="viewcode-back" href="../../../_apidoc/pipeline.infrastructure.html#pipeline.infrastructure.callibrary.set_calstate_marker">[docs]</a>
<span class="k">def</span> <span class="nf">set_calstate_marker</span><span class="p">(</span><span class="n">calstate</span><span class="p">,</span> <span class="n">marker</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a copy of a calstate, modified so that TimeStampedData objects in</span>
<span class="sd">    the final leaf node are annotated with the given marker object.</span>

<span class="sd">    Technical details:</span>

<span class="sd">    CalFroms are flyweight objects, so two identical CalFroms have the same</span>
<span class="sd">    hash. Identical hashes stop the IntervalTree union function from working</span>
<span class="sd">    as expected: IntervalTrees are based on sets, and as such adding two</span>
<span class="sd">    lists of CalFrom with identical hashes results in just one CalFrom list in</span>
<span class="sd">    the final IntervalTree, when we actually *wanted* the duplicate to be</span>
<span class="sd">    added.</span>

<span class="sd">    This function is used to ensure that CalState arithmetic works as</span>
<span class="sd">    expected. By changing the TimeStampedData marker and thus making the</span>
<span class="sd">    hashes different, &#39;identical&#39; calibrations can indeed be duplicated in the</span>
<span class="sd">    IntervalTree union operation, and subsequently operated on in a</span>
<span class="sd">    merge_equals step.</span>

<span class="sd">    :param calstate: the calstate to modify</span>
<span class="sd">    :param marker: the object to annotate calstates with</span>
<span class="sd">    :return: annotated calstate </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">calstate_copy</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">calstate</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">vis</span><span class="p">,</span> <span class="n">antenna_tree</span> <span class="ow">in</span> <span class="n">calstate_copy</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">antenna_interval</span> <span class="ow">in</span> <span class="n">antenna_tree</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">spw_interval</span> <span class="ow">in</span> <span class="n">antenna_interval</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">data</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">field_interval</span> <span class="ow">in</span> <span class="n">spw_interval</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">data</span><span class="p">:</span>

                    <span class="n">to_remove</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">field_interval</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">data</span><span class="p">]</span>
                    <span class="n">to_add</span> <span class="o">=</span> <span class="p">[]</span>

                    <span class="n">intent_intervaltree</span> <span class="o">=</span> <span class="n">field_interval</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">data</span>
                    <span class="k">for</span> <span class="n">intent_interval</span> <span class="ow">in</span> <span class="n">intent_intervaltree</span><span class="p">:</span>
                        <span class="n">old_tsd</span> <span class="o">=</span> <span class="n">intent_interval</span><span class="o">.</span><span class="n">data</span>
                        <span class="n">new_tsd</span> <span class="o">=</span> <span class="n">TimestampedData</span><span class="p">(</span><span class="n">time</span><span class="o">=</span><span class="n">old_tsd</span><span class="o">.</span><span class="n">time</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">old_tsd</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="n">marker</span><span class="p">)</span>
                        <span class="n">to_add</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">intervaltree</span><span class="o">.</span><span class="n">Interval</span><span class="p">(</span><span class="n">intent_interval</span><span class="o">.</span><span class="n">begin</span><span class="p">,</span> <span class="n">intent_interval</span><span class="o">.</span><span class="n">end</span><span class="p">,</span> <span class="n">new_tsd</span><span class="p">))</span>

                    <span class="k">for</span> <span class="n">interval</span> <span class="ow">in</span> <span class="n">to_remove</span><span class="p">:</span>
                        <span class="n">intent_intervaltree</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">interval</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">interval</span> <span class="ow">in</span> <span class="n">to_add</span><span class="p">:</span>
                        <span class="n">intent_intervaltree</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">interval</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">calstate_copy</span></div>



<span class="k">def</span> <span class="nf">_copy_calfrom</span><span class="p">(</span><span class="n">calfrom</span><span class="p">,</span> <span class="o">**</span><span class="n">overrides</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Copy a CalFrom, overwriting any CalFrom properties with the specified</span>
<span class="sd">    override values.</span>

<span class="sd">    For instance, to create a copy of a CalFrom with calwt set to True:</span>

<span class="sd">    modified = _copy_calfrom(calfrom, calwt=True)</span>

<span class="sd">    :param calapp: CalFrom to copy</span>
<span class="sd">    :param overrides: kw/val pairs of CalFrom properties to override</span>
<span class="sd">    :return: CalFrom instance</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">new_kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">gaintable</span><span class="o">=</span><span class="n">calfrom</span><span class="o">.</span><span class="n">gaintable</span><span class="p">,</span> <span class="n">gainfield</span><span class="o">=</span><span class="n">calfrom</span><span class="o">.</span><span class="n">gainfield</span><span class="p">,</span> <span class="n">interp</span><span class="o">=</span><span class="n">calfrom</span><span class="o">.</span><span class="n">interp</span><span class="p">,</span>
                      <span class="n">spwmap</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">calfrom</span><span class="o">.</span><span class="n">spwmap</span><span class="p">),</span> <span class="n">caltype</span><span class="o">=</span><span class="n">calfrom</span><span class="o">.</span><span class="n">caltype</span><span class="p">,</span> <span class="n">calwt</span><span class="o">=</span><span class="n">calfrom</span><span class="o">.</span><span class="n">calwt</span><span class="p">)</span>
    <span class="n">new_kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">overrides</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">CalFrom</span><span class="p">(</span><span class="o">**</span><span class="n">new_kwargs</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_copy_calto</span><span class="p">(</span><span class="n">calto</span><span class="p">,</span> <span class="o">**</span><span class="n">overrides</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Copy a CalTo, overwriting any CalFrom properties with the specified</span>
<span class="sd">    override values.</span>

<span class="sd">    For instance, to create a copy of a CalTo with spw set to 9:</span>

<span class="sd">    modified = _copy_calto(calto, spw=9)</span>

<span class="sd">    :param calapp: CalTo to copy</span>
<span class="sd">    :param overrides: kw/val pairs of CalTo properties to override</span>
<span class="sd">    :return: CalTo instance</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">new_kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">vis</span><span class="o">=</span><span class="n">calto</span><span class="o">.</span><span class="n">vis</span><span class="p">,</span> <span class="n">field</span><span class="o">=</span><span class="n">calto</span><span class="o">.</span><span class="n">field</span><span class="p">,</span> <span class="n">spw</span><span class="o">=</span><span class="n">calto</span><span class="o">.</span><span class="n">spw</span><span class="p">,</span> <span class="n">antenna</span><span class="o">=</span><span class="n">calto</span><span class="o">.</span><span class="n">antenna</span><span class="p">,</span> <span class="n">intent</span><span class="o">=</span><span class="n">calto</span><span class="o">.</span><span class="n">intent</span><span class="p">)</span>
    <span class="n">new_kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">overrides</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">CalTo</span><span class="p">(</span><span class="o">**</span><span class="n">new_kwargs</span><span class="p">)</span>


<div class="viewcode-block" id="copy_calapplication">
<a class="viewcode-back" href="../../../_apidoc/pipeline.infrastructure.html#pipeline.infrastructure.callibrary.copy_calapplication">[docs]</a>
<span class="k">def</span> <span class="nf">copy_calapplication</span><span class="p">(</span><span class="n">calapp</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">overrides</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Copy a CalApplication, overwriting any CalTo or CalFrom values with the</span>
<span class="sd">    given override values.</span>

<span class="sd">    For instance, to create a copy of a CalApplication with the CalFrom.calwt</span>
<span class="sd">    set to True and the CalTo.spw set to 9:</span>

<span class="sd">    modified = copy_calapplication(calapp, calwt=True, spw=9)</span>

<span class="sd">    :param calapp: CalApplication to copy</span>
<span class="sd">    :param origin: origin to set, or None to copy the origin from calapp</span>
<span class="sd">    :param overrides: kw/val pairs of calto/calfrom attributes to override</span>
<span class="sd">    :return: CalApplication instance</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">origin</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">origin</span> <span class="o">=</span> <span class="n">calapp</span><span class="o">.</span><span class="n">origin</span>

    <span class="n">calto_kw</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;vis&#39;</span><span class="p">,</span> <span class="s1">&#39;field&#39;</span><span class="p">,</span> <span class="s1">&#39;spw&#39;</span><span class="p">,</span> <span class="s1">&#39;antenna&#39;</span><span class="p">,</span> <span class="s1">&#39;intent&#39;</span><span class="p">]</span>
    <span class="n">calto_overrides</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">overrides</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">calto_kw</span><span class="p">}</span>
    <span class="n">calto</span> <span class="o">=</span> <span class="n">_copy_calto</span><span class="p">(</span><span class="n">calapp</span><span class="o">.</span><span class="n">calto</span><span class="p">,</span> <span class="o">**</span><span class="n">calto_overrides</span><span class="p">)</span>

    <span class="n">calfrom_kw</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;gaintable&#39;</span><span class="p">,</span> <span class="s1">&#39;gainfield&#39;</span><span class="p">,</span> <span class="s1">&#39;interp&#39;</span><span class="p">,</span> <span class="s1">&#39;spwmap&#39;</span><span class="p">,</span> <span class="s1">&#39;caltype&#39;</span><span class="p">,</span> <span class="s1">&#39;calwt&#39;</span><span class="p">]</span>
    <span class="n">calfrom_overrides</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">overrides</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">calfrom_kw</span><span class="p">}</span>
    <span class="n">calfrom</span> <span class="o">=</span> <span class="p">[</span><span class="n">_copy_calfrom</span><span class="p">(</span><span class="n">calfrom</span><span class="p">,</span> <span class="o">**</span><span class="n">calfrom_overrides</span><span class="p">)</span> <span class="k">for</span> <span class="n">calfrom</span> <span class="ow">in</span> <span class="n">calapp</span><span class="o">.</span><span class="n">calfrom</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">CalApplication</span><span class="p">(</span><span class="n">calto</span><span class="p">,</span> <span class="n">calfrom</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="n">origin</span><span class="p">)</span></div>



<span class="c1"># def consolidate_calibrations(calapps):</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     Consolidate a list of (CalTo, [CalFrom..]) 2-tuples into a smaller set of</span>
<span class="c1">#     equivalent applications by consolidating their data selection arguments.</span>
<span class="c1">#</span>
<span class="c1">#     This function works by merging the data selections of CalTo objects that</span>
<span class="c1">#     have the same calibration application, as determined by the values and</span>
<span class="c1">#     data selection present in the CalFroms.</span>
<span class="c1">#</span>
<span class="c1">#     :param calapps: an iterable of (CalTo, [CalFrom..]) 2-tuples</span>
<span class="c1">#     :return: a list of (CalTo, [CalFrom..]) tuples</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#</span>
<span class="c1">#     # dict mapping an object hash to the object itself:</span>
<span class="c1">#     #     hash([CalFrom, ...]): [CalFrom, ...]</span>
<span class="c1">#     hash_to_calfroms = {}</span>
<span class="c1">#     # dict mapping from object hash to corresponding list of CalToArgs</span>
<span class="c1">#     hash_to_calto_args = collections.defaultdict(list)</span>
<span class="c1">#</span>
<span class="c1">#     # create our maps of hashes, which we need to test for overlapping data</span>
<span class="c1">#     # selections</span>
<span class="c1">#     for calto_args, calfroms in calapps:</span>
<span class="c1">#         # create a tuple, as lists are not hashable</span>
<span class="c1">#         calfrom_hash = tuple([hash(cf) for cf in calfroms])</span>
<span class="c1">#         hash_to_calto_args[calfrom_hash].append(calto_args)</span>
<span class="c1">#</span>
<span class="c1">#         if calfrom_hash not in hash_to_calfroms:</span>
<span class="c1">#             hash_to_calfroms[calfrom_hash] = calfroms</span>
<span class="c1">#</span>
<span class="c1">#     LOG.info(&#39;Consolidating calibrations&#39;)</span>
<span class="c1">#     # dict that maps holds accepted data selections and their CalFroms</span>
<span class="c1">#     accepted = {}</span>
<span class="c1">#     for calfrom_hash, calto_args in hash_to_calto_args.items():</span>
<span class="c1">#         # assemble the other data selections (the other CalToArgs) which we</span>
<span class="c1">#         # will use to search for conflicting data selections</span>
<span class="c1">#         other_data_selections = []</span>
<span class="c1">#         for v in [v for k, v in hash_to_calto_args.items() if k != calfrom_hash]:</span>
<span class="c1">#             other_data_selections.extend(v)</span>
<span class="c1">#</span>
<span class="c1">#         for to_merge in calto_args:</span>
<span class="c1">#             if calfrom_hash not in accepted:</span>
<span class="c1">#                 # first time round for this calibration application, therefore it can always be added</span>
<span class="c1">#                 # as there will be nothing to merge</span>
<span class="c1">#                 accepted[calfrom_hash] = [(copy.deepcopy(to_merge), hash_to_calfroms[calfrom_hash])]</span>
<span class="c1">#                 continue</span>
<span class="c1">#</span>
<span class="c1">#             for idx, (existing_calto, calfroms) in enumerate(accepted[calfrom_hash]):</span>
<span class="c1">#                 proposed_calto = CalToArgs(*copy.deepcopy(existing_calto))</span>
<span class="c1">#</span>
<span class="c1">#                 for proposed_values, to_merge_values in zip(proposed_calto, to_merge):</span>
<span class="c1">#                     proposed_values.update(to_merge_values)</span>
<span class="c1">#</span>
<span class="c1">#                 # if the merged data selection does not conflict with any of</span>
<span class="c1">#                 # the explicitly registered data selections that require a</span>
<span class="c1">#                 # different calibration application, then it is safe to add</span>
<span class="c1">#                 # the merged data selection and discard the unmerged data</span>
<span class="c1">#                 # selection</span>
<span class="c1">#                 if not any((data_selection_contains(proposed_calto, other) for other in other_data_selections)):</span>
<span class="c1">#                     LOG.trace(&#39;No conflicting data selection detected&#39;)</span>
<span class="c1">#                     LOG.trace(&#39;Accepting merged data selection: {!s}&#39;.format(proposed_calto))</span>
<span class="c1">#                     LOG.trace(&#39;Discarding unmerged data selection: {!s}&#39;.format(to_merge))</span>
<span class="c1">#                     accepted[calfrom_hash][idx] = (proposed_calto, hash_to_calfroms[calfrom_hash])</span>
<span class="c1">#                     break</span>
<span class="c1">#</span>
<span class="c1">#             else:</span>
<span class="c1">#                 # we get here if all of the proposed merged data selections</span>
<span class="c1">#                 # conflict with the data selection in hand. In this case, it</span>
<span class="c1">#                 # should be added as it stands, completely unaltered.</span>
<span class="c1">#                 LOG.trace(&#39;Merged data selection conflicts with other registrations&#39;)</span>
<span class="c1">#                 LOG.trace(&#39;Abandoning proposed data selection: {!s}&#39;.format(proposed_calto))</span>
<span class="c1">#                 LOG.trace(&#39;Appending new unmerged data selection: {!s}&#39;.format(to_merge))</span>
<span class="c1">#                 unmergeable = (to_merge, hash_to_calfroms[calfrom_hash])</span>
<span class="c1">#                 accepted[calfrom_hash].append(unmergeable)</span>
<span class="c1">#</span>
<span class="c1">#     # dict values are lists, which we need to flatten into a single list</span>
<span class="c1">#     result = []</span>
<span class="c1">#     for l in accepted.itervalues():</span>
<span class="c1">#         result.extend(l)</span>
<span class="c1">#     return result</span>


<div class="viewcode-block" id="get_calstate_shape">
<a class="viewcode-back" href="../../../_apidoc/pipeline.infrastructure.html#pipeline.infrastructure.callibrary.get_calstate_shape">[docs]</a>
<span class="nd">@cachetools</span><span class="o">.</span><span class="n">cached</span><span class="p">(</span><span class="n">cachetools</span><span class="o">.</span><span class="n">LRUCache</span><span class="p">(</span><span class="mi">50</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="n">operator</span><span class="o">.</span><span class="n">attrgetter</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">get_calstate_shape</span><span class="p">(</span><span class="n">ms</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get an IntervalTree shaped to the dimensions of the given measurement set.</span>

<span class="sd">    This function calculates the size of each metadata dimension (spw; intent;</span>
<span class="sd">    field; antenna), creating and returning an IntervalTree shaped to match.</span>
<span class="sd">    The output of this function is used to trim a calibration applied globally</span>
<span class="sd">    in one or more dimensions to a valid data selection.</span>

<span class="sd">    Output from this function is cached as it can take several seconds to</span>
<span class="sd">    calculate the result, which is done repeatedly when importing a calstate</span>
<span class="sd">    containing many entries.</span>

<span class="sd">    Note: this assumes that shape of an MS never changes, which should be</span>
<span class="sd">    true; the number of spws, fields, ants, etc. never changes.</span>

<span class="sd">    :param ms: the MeasurementSet to analyse</span>
<span class="sd">    :return: IntervalTree shaped to match valid data dimensions</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Calculating callibrary shape for </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ms</span><span class="o">.</span><span class="n">basename</span><span class="p">))</span>

    <span class="c1"># holds a mapping of numeric intent ID to string intent</span>
    <span class="n">id_to_intent</span> <span class="o">=</span> <span class="n">get_intent_id_map</span><span class="p">(</span><span class="n">ms</span><span class="p">)</span>
    <span class="c1"># create map of observing intent to intent ID by inverting existing map</span>
    <span class="n">intent_to_id</span> <span class="o">=</span> <span class="p">{</span><span class="n">v</span><span class="p">:</span> <span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">id_to_intent</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

    <span class="c1"># create interval tree. root branch is antenna</span>
    <span class="n">antenna_tree</span> <span class="o">=</span> <span class="n">create_interval_tree_for_ms</span><span class="p">(</span><span class="n">ms</span><span class="p">)</span>

    <span class="n">spw_shape</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">spw</span> <span class="ow">in</span> <span class="n">ms</span><span class="o">.</span><span class="n">spectral_windows</span><span class="p">:</span>
        <span class="n">intents_for_field</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">ms</span><span class="o">.</span><span class="n">fields</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">spw</span> <span class="ow">in</span> <span class="n">field</span><span class="o">.</span><span class="n">valid_spws</span><span class="p">:</span>
                <span class="c1"># construct the list of observed intent IDs for this field</span>
                <span class="c1">#</span>
                <span class="c1"># we can&#39;t rely on field.intents as this property</span>
                <span class="c1"># aggregates all intents across all spws, which may</span>
                <span class="c1"># differ across spws when there are multiple tunings</span>
                <span class="c1">#</span>
                <span class="c1"># DON&#39;T DO THIS!</span>
                <span class="c1"># observed_intent_ids = (intent_to_id[i] for i in field.intents)</span>
                <span class="n">scans_for_field_and_spw</span> <span class="o">=</span> <span class="n">ms</span><span class="o">.</span><span class="n">get_scans</span><span class="p">(</span><span class="n">spw</span><span class="o">=</span><span class="n">spw</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">field</span><span class="o">=</span><span class="n">field</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
                <span class="n">observed_intent_ids</span> <span class="o">=</span> <span class="p">[</span><span class="n">intent_to_id</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                                       <span class="k">for</span> <span class="n">scan</span> <span class="ow">in</span> <span class="n">scans_for_field_and_spw</span>
                                       <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">scan</span><span class="o">.</span><span class="n">intents</span><span class="p">]</span>

                <span class="c1"># SD scans can have subscans, where each subscan observes a</span>
                <span class="c1"># different field with different intent, e.g., TARGET alternating</span>
                <span class="c1"># with REFERENCE. Non-SD data should have a single target per</span>
                <span class="c1"># scan, so the following code should be a no-op.</span>
                <span class="n">subscan_fields</span> <span class="o">=</span> <span class="p">{</span><span class="n">scan_field</span> <span class="k">for</span> <span class="n">scan</span> <span class="ow">in</span> <span class="n">scans_for_field_and_spw</span> <span class="k">for</span> <span class="n">scan_field</span> <span class="ow">in</span> <span class="n">scan</span><span class="o">.</span><span class="n">fields</span><span class="p">}</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">subscan_fields</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="c1"># unfortunately, we have to fall back to the field.intents</span>
                    <span class="c1"># method. Expect this to break for multituning SD EBs.</span>
                    <span class="n">observed_intent_ids</span> <span class="o">=</span> <span class="p">(</span><span class="n">intent_to_id</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">field</span><span class="o">.</span><span class="n">intents</span><span class="p">)</span>

                <span class="c1"># convert the intent IDs to an IntervalTree-friendly range</span>
                <span class="c1"># and record it against the field ID</span>
                <span class="n">intents_for_field</span><span class="p">[</span><span class="n">field</span><span class="o">.</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
                    <span class="n">sequence_to_range</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span> <span class="k">for</span> <span class="n">seq</span> <span class="ow">in</span> <span class="n">contiguous_sequences</span><span class="p">(</span><span class="n">observed_intent_ids</span><span class="p">)</span>
                <span class="p">)</span>
        <span class="c1"># merge adjacent field intervals that have identical values</span>
        <span class="n">spw_shape</span><span class="p">[</span><span class="n">spw</span><span class="o">.</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">_merge_intervals</span><span class="p">(</span><span class="n">intents_for_field</span><span class="p">)</span>
    <span class="c1"># merge adjacent spw intervals that have identical values</span>
    <span class="n">spw_shape</span> <span class="o">=</span> <span class="n">_merge_intervals</span><span class="p">(</span><span class="n">spw_shape</span><span class="p">)</span>

    <span class="c1"># assume that spws are observed by all antennas. Note the trailing comma to make it a tuple!</span>
    <span class="c1"># the inner tuple is needed to convert the generator comprehension to objects</span>
    <span class="n">antenna_shape</span> <span class="o">=</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">((((</span><span class="n">interval</span><span class="o">.</span><span class="n">begin</span><span class="p">,</span> <span class="n">interval</span><span class="o">.</span><span class="n">end</span><span class="p">),),</span> <span class="n">spw_shape</span><span class="p">)</span> <span class="k">for</span> <span class="n">interval</span> <span class="ow">in</span> <span class="n">antenna_tree</span><span class="p">),)</span>

    <span class="k">return</span> <span class="n">antenna_shape</span></div>



<div class="viewcode-block" id="get_matching_calstate">
<a class="viewcode-back" href="../../../_apidoc/pipeline.infrastructure.html#pipeline.infrastructure.callibrary.get_matching_calstate">[docs]</a>
<span class="k">def</span> <span class="nf">get_matching_calstate</span><span class="p">(</span><span class="n">context</span><span class="p">:</span> <span class="n">launcher</span><span class="o">.</span><span class="n">Context</span><span class="p">,</span>
                           <span class="n">calstate</span><span class="p">:</span> <span class="n">IntervalCalState</span><span class="p">,</span>
                           <span class="n">predicate_fn</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">CalToArgs</span><span class="p">,</span> <span class="n">CalFrom</span><span class="p">],</span> <span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">IntervalCalState</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return an IntervalCalState contain calibrations in the input </span>
<span class="sd">    IntervalCalState that match the predicate function.</span>

<span class="sd">    The use case for this function is to identify calibrations matching a</span>
<span class="sd">    pattern so that those calibrations can be deleted or modified. For</span>
<span class="sd">    instance, matching registered bandpass caltables so they can be removed</span>
<span class="sd">    from the active CalState.</span>

<span class="sd">    :param context: pipeline context (required to create IntervalCalState)</span>
<span class="sd">    :param calstate: calibration state to inspect</span>
<span class="sd">    :predicate_fn: matching function that returns True when the selection is</span>
<span class="sd">        to be added to the output IntervalCalState</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">expanded</span> <span class="o">=</span> <span class="n">expand_calstate_to_calapps</span><span class="p">(</span><span class="n">calstate</span><span class="p">)</span>

    <span class="n">matching</span> <span class="o">=</span> <span class="p">[</span><span class="n">IntervalCalState</span><span class="o">.</span><span class="n">from_calapplication</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">CalTo</span><span class="o">.</span><span class="n">from_caltoargs</span><span class="p">(</span><span class="n">caltoargs</span><span class="p">),</span> <span class="n">calfrom</span><span class="p">)</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">caltoargs</span><span class="p">,</span> <span class="n">calfroms</span><span class="p">)</span> <span class="ow">in</span> <span class="n">expanded</span>
                <span class="k">for</span> <span class="n">calfrom</span> <span class="ow">in</span> <span class="n">calfroms</span>
                <span class="k">if</span> <span class="n">predicate_fn</span><span class="p">(</span><span class="n">caltoargs</span><span class="p">,</span> <span class="n">calfrom</span><span class="p">)]</span>

    <span class="n">consolidated</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">add</span><span class="p">,</span> <span class="n">matching</span><span class="p">,</span> <span class="n">IntervalCalState</span><span class="o">.</span><span class="n">create_from_context</span><span class="p">(</span><span class="n">context</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">consolidated</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020–2024, Pipeline Dev. Team.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>