

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>pipeline.hsd.tasks.baseline.validation &mdash; Pipeline unknown documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../../../_static/graphviz.css?v=4ae1632d" />
      <link rel="stylesheet" type="text/css" href="../../../../../_static/sphinx_astrorefs.css?v=f03c384a" />
      <link rel="stylesheet" type="text/css" href="../../../../../_static/custom_theme.css?v=678032d9" />

  
      <script src="../../../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../../../_static/documentation_options.js?v=3f1b9271"></script>
      <script src="../../../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../../index.html" class="icon icon-home">
            Pipeline
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Releases etc.</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../releases.html">Past Releases</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../dependencies.html">Dependencies of <code class="docutils literal notranslate"><span class="pre">Pipeline</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../modular.html">Run the Pipeline in a Conda environment</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../apisummary.html">Pipeline Tasks (from autosummary)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../apisummary.html#full-list">Full List</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">TaskRef (create_docs.py)</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../_taskdocs/taskdocs.html">List of Heuristics Tasks (Pipeline 2023)</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Pipeline Heuristics</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../heuristics/field_parameter.html">Field parameter</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../heuristics/FlaggingTasks.html">Pipeline Flagging Tasks</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Developer Notes</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../develdocmd/ways_to_run_the_pipeline.html">Ways to run the Pipeline</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../develdocmd/comparing_pipeline_executions.html">Comparing pipeline executions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../develdocmd/building_the_pipeline.html">Building the pipeline</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../develdocmd/ALMA-Imaging-Workflow.html">ALMA interferometry imaging workflow</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../develdocmd/VLA-Imaging-Workflow.html">VLA interferometry imaging workflow</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../develdocmd/VLASS-SE-CONT-Imaging-Workflow.html">VLASS-SE-CONT imaging workflow</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../develdocmd/VLASS-SE-CUBE-Imaging-Workflow.html">VLASS-SE-CUBE imaging workflow</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../develdocmd/selfcal_workflow.html">VLASS Selfcal &amp; Restore workflows</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../develdocmd/pipeline_tests.html">Pipeline testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../develdocmd/DataType_Testing.html">DataType Testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../develdocmd/QA_scores.html">Pipeline Quality Assurance (QA) Score Class Design</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../develdocmd/DeveloperDocumentation.html">Pipeline developer documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../develdocmd/python3_conversion_notes.html">Python 3 conversion notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../develdocmd/recipes.html">Pipeline Recipes</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Pipeline Domain/Context/etc. (automodapi)</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../basics.html"><code class="docutils literal notranslate"><span class="pre">pipeline.domain</span></code> module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../basics.html#module-pipeline.infrastructure.launcher"><code class="docutils literal notranslate"><span class="pre">pipeline.infrastructure.launcher</span></code> module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../basics.html#module-pipeline.infrastructure.callibrary"><code class="docutils literal notranslate"><span class="pre">pipeline.infrastructure.project</span></code> module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../basics.html#pipeline-infrastructure-callibrary-module"><code class="docutils literal notranslate"><span class="pre">pipeline.infrastructure.callibrary</span></code> module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../basics.html#pipeline-infrastructure-imagelibrary-module"><code class="docutils literal notranslate"><span class="pre">pipeline.infrastructure.imagelibrary</span></code> module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../basics.html#module-pipeline.infrastructure.vdp"><code class="docutils literal notranslate"><span class="pre">pipeline.infrastructure.vdp</span></code> module</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Pipeline Domain/Context (autosummary)</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../_autosummary/pipeline.domain.html">pipeline.domain</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../_autosummary/pipeline.infrastructure.launcher.html">pipeline.infrastructure.launcher</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Pipeline Task/Inputs/Results Classes</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../classes.html">Classes in <code class="docutils literal notranslate"><span class="pre">pipeline.h*.tasks</span></code> modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../classes.html#inheritance-diagrams">Inheritance Diagrams</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Notebooks</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../notebooks/context.html">Pipeline Context</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../notebooks/tier0dask.html">“Tier0” Parallelization with Dask/Futures</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Examples Notes (from Jupyter Notebooks)</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../examples/test1.html">test</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Example Notes (from .rst)</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../examples/test2.html">Example 1</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../../index.html">Pipeline</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../../../index.html">Module code</a></li>
          <li class="breadcrumb-item"><a href="../../../../pipeline.html">pipeline</a></li>
      <li class="breadcrumb-item active">pipeline.hsd.tasks.baseline.validation</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for pipeline.hsd.tasks.baseline.validation</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Task to perform line validation based on clustering analysis.&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">sqrt</span>
<span class="kn">from</span> <span class="nn">numbers</span> <span class="kn">import</span> <span class="n">Integral</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">TYPE_CHECKING</span><span class="p">,</span> <span class="n">Any</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Type</span><span class="p">,</span> <span class="n">Union</span>

<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">import</span> <span class="nn">numpy.linalg</span> <span class="k">as</span> <span class="nn">LA</span>
<span class="kn">import</span> <span class="nn">scipy.cluster.hierarchy</span> <span class="k">as</span> <span class="nn">HIERARCHY</span>
<span class="kn">import</span> <span class="nn">scipy.cluster.vq</span> <span class="k">as</span> <span class="nn">VQ</span>

<span class="kn">import</span> <span class="nn">pipeline.infrastructure</span> <span class="k">as</span> <span class="nn">infrastructure</span>
<span class="kn">import</span> <span class="nn">pipeline.infrastructure.basetask</span> <span class="k">as</span> <span class="nn">basetask</span>
<span class="kn">import</span> <span class="nn">pipeline.infrastructure.vdp</span> <span class="k">as</span> <span class="nn">vdp</span>
<span class="kn">from</span> <span class="nn">pipeline.domain</span> <span class="kn">import</span> <span class="n">DataType</span>
<span class="kn">from</span> <span class="nn">pipeline.domain.datatable</span> <span class="kn">import</span> <span class="n">DataTableIndexer</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">rules</span>
<span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">common</span>
<span class="kn">from</span> <span class="nn">..common</span> <span class="kn">import</span> <span class="n">utils</span>

<span class="kn">from</span> <span class="nn">.typing</span> <span class="kn">import</span> <span class="n">ClusteringResult</span><span class="p">,</span> <span class="n">DetectedLineList</span><span class="p">,</span> <span class="n">LineWindow</span>

<span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">pipeline.domain.singledish</span> <span class="kn">import</span> <span class="n">MSReductionGroupDesc</span><span class="p">,</span> <span class="n">MSReductionGroupMember</span>
    <span class="kn">from</span> <span class="nn">pipeline.infrastructure.launcher</span> <span class="kn">import</span> <span class="n">Context</span>

<span class="n">LOG</span> <span class="o">=</span> <span class="n">infrastructure</span><span class="o">.</span><span class="n">get_logger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>


<div class="viewcode-block" id="ValidateLineInputs">
<a class="viewcode-back" href="../../../../../_autosummary/pipeline.hsd.tasks.baseline.validation.ValidateLineInputs.html#pipeline.hsd.tasks.baseline.validation.ValidateLineInputs">[docs]</a>
<span class="k">class</span> <span class="nc">ValidateLineInputs</span><span class="p">(</span><span class="n">vdp</span><span class="o">.</span><span class="n">StandardInputs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Inputs class for line validation tasks.&quot;&quot;&quot;</span>

    <span class="c1"># Search order of input vis</span>
    <span class="n">processing_data_type</span> <span class="o">=</span> <span class="p">[</span><span class="n">DataType</span><span class="o">.</span><span class="n">ATMCORR</span><span class="p">,</span> <span class="n">DataType</span><span class="o">.</span><span class="n">REGCAL_CONTLINE_ALL</span><span class="p">,</span> <span class="n">DataType</span><span class="o">.</span><span class="n">RAW</span><span class="p">]</span>

    <span class="n">edge</span> <span class="o">=</span> <span class="n">vdp</span><span class="o">.</span><span class="n">VisDependentProperty</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
    <span class="n">nsigma</span> <span class="o">=</span> <span class="n">vdp</span><span class="o">.</span><span class="n">VisDependentProperty</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="mf">3.0</span><span class="p">)</span>
    <span class="n">xorder</span> <span class="o">=</span> <span class="n">vdp</span><span class="o">.</span><span class="n">VisDependentProperty</span><span class="p">(</span><span class="n">default</span><span class="o">=-</span><span class="mf">1.0</span><span class="p">)</span>
    <span class="n">yorder</span> <span class="o">=</span> <span class="n">vdp</span><span class="o">.</span><span class="n">VisDependentProperty</span><span class="p">(</span><span class="n">default</span><span class="o">=-</span><span class="mf">1.0</span><span class="p">)</span>
    <span class="n">broad_component</span> <span class="o">=</span> <span class="n">vdp</span><span class="o">.</span><span class="n">VisDependentProperty</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">clusteringalgorithm</span> <span class="o">=</span> <span class="n">vdp</span><span class="o">.</span><span class="n">VisDependentProperty</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="n">rules</span><span class="o">.</span><span class="n">ClusterRule</span><span class="p">[</span><span class="s1">&#39;ClusterAlgorithm&#39;</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">group_desc</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;MSReductionGroupDesc&#39;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return reduction group instance of the current group.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">observing_run</span><span class="o">.</span><span class="n">ms_reduction_group</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">group_id</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">reference_member</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;MSReductionGroupMember&#39;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the first reduction group member instance in the current group.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">group_desc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">member_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">windowmode</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return windowmode value. Defaults to &#39;replace&#39;.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_windowmode&#39;</span><span class="p">,</span> <span class="s1">&#39;replace&#39;</span><span class="p">)</span>

    <span class="nd">@windowmode</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">windowmode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set windowmode value.</span>

<span class="sd">        Args:</span>
<span class="sd">            value: Either &#39;replace&#39; or &#39;merge&#39;</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: Invalid windowmode value</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;replace&#39;</span><span class="p">,</span> <span class="s1">&#39;merge&#39;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;linewindowmode must be either &#39;replace&#39; or &#39;merge&#39;.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_windowmode</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">context</span><span class="p">:</span> <span class="s1">&#39;Context&#39;</span><span class="p">,</span>
                 <span class="n">group_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                 <span class="n">member_list</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
                 <span class="n">iteration</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                 <span class="n">grid_ra</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
                 <span class="n">grid_dec</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
                 <span class="n">window</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">LineWindow</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">windowmode</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">edge</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">nsigma</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">xorder</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">yorder</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">broad_component</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">clusteringalgorithm</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Construct ValidateLineInputs instance.</span>

<span class="sd">        Args:</span>
<span class="sd">            context: Pipeline context</span>
<span class="sd">            group_id: Reduction group ID</span>
<span class="sd">            member_list: List of reduction group member IDs</span>
<span class="sd">            iteration: Iteration counter for baseline/blflag loop</span>
<span class="sd">            grid_ra: Horizontal (longitudinal) spacing of spatial grids.</span>
<span class="sd">                     The value should be the one without declination correction.</span>
<span class="sd">            grid_dec: Vertical (latitudinal) spacing of spatial grids.</span>
<span class="sd">            window: Manual line window. Defaults to None, which means that no user-defined</span>
<span class="sd">                    line window is given.</span>
<span class="sd">            windowmode: Line window handling mode. &#39;replace&#39; exclusively uses manual line window</span>
<span class="sd">                        while &#39;merge&#39; merges manual line window into automatic line detection</span>
<span class="sd">                        and validation result. Defaults to &#39;replace&#39; if None is given.</span>
<span class="sd">            edge: Edge channels to exclude. Defaults to None, which means that all channels</span>
<span class="sd">                  are processed.</span>
<span class="sd">            nsigma: Threshold for iterative N-sigma clipping. No iterative clipping is done if</span>
<span class="sd">                    nsigma is None or negative value. Defaults to 3 if None is given.</span>
<span class="sd">            xorder: Polynomial order for two-dimensional fitting of line properties</span>
<span class="sd">                    along horizontal (longitudinal) axis. The order is automatically determined</span>
<span class="sd">                    if None or negative value is given.</span>
<span class="sd">            yorder: Polynomial order for two-dimensional fitting of line properties</span>
<span class="sd">                    along vertical (latitudinal) axis. The order is automatically determined</span>
<span class="sd">                    if None or negative value is given.</span>
<span class="sd">            broad_component: Process broad component if True. Defaults to False if None is given.</span>
<span class="sd">            clusteringalgorithm: Clustering algorithm to use. Allowed values are &#39;kmean&#39;,</span>
<span class="sd">                                 &#39;hierarchy&#39;, or &#39;both&#39;. Defaults to &#39;hierarchy&#39; if None is given.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">ValidateLineInputs</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">context</span> <span class="o">=</span> <span class="n">context</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">group_id</span> <span class="o">=</span> <span class="n">group_id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">member_list</span> <span class="o">=</span> <span class="n">member_list</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iteration</span> <span class="o">=</span> <span class="n">iteration</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid_ra</span> <span class="o">=</span> <span class="n">grid_ra</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid_dec</span> <span class="o">=</span> <span class="n">grid_dec</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">window</span> <span class="o">=</span> <span class="n">window</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">windowmode</span> <span class="o">=</span> <span class="n">windowmode</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edge</span> <span class="o">=</span> <span class="n">edge</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nsigma</span> <span class="o">=</span> <span class="n">nsigma</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xorder</span> <span class="o">=</span> <span class="n">xorder</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">yorder</span> <span class="o">=</span> <span class="n">yorder</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">broad_component</span> <span class="o">=</span> <span class="n">broad_component</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clusteringalgorithm</span> <span class="o">=</span> <span class="n">clusteringalgorithm</span></div>



<div class="viewcode-block" id="ValidateLineResults">
<a class="viewcode-back" href="../../../../../_autosummary/pipeline.hsd.tasks.baseline.validation.ValidateLineResults.html#pipeline.hsd.tasks.baseline.validation.ValidateLineResults">[docs]</a>
<span class="k">class</span> <span class="nc">ValidateLineResults</span><span class="p">(</span><span class="n">common</span><span class="o">.</span><span class="n">SingleDishResults</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Results class to hold the result of line validation.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">task</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Type</span><span class="p">[</span><span class="n">basetask</span><span class="o">.</span><span class="n">StandardTaskTemplate</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">success</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">outcome</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Construct ValidateLineResults instance.</span>

<span class="sd">        Args:</span>
<span class="sd">            task: Task class that produced the result.</span>
<span class="sd">            success: Whether task execution is successful or not.</span>
<span class="sd">            outcome: Outcome of the task execution.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">ValidateLineResults</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">success</span><span class="p">,</span> <span class="n">outcome</span><span class="p">)</span>

<div class="viewcode-block" id="ValidateLineResults.merge_with_context">
<a class="viewcode-back" href="../../../../../_autosummary/pipeline.hsd.tasks.baseline.validation.ValidateLineResults.html#pipeline.hsd.tasks.baseline.validation.ValidateLineResults.merge_with_context">[docs]</a>
    <span class="k">def</span> <span class="nf">merge_with_context</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">:</span> <span class="s1">&#39;Context&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Merge result instance into context.</span>

<span class="sd">        No specific merge operation is done.</span>

<span class="sd">        Args:</span>
<span class="sd">            context: Pipeline context.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">ValidateLineResults</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">merge_with_context</span><span class="p">(</span><span class="n">context</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">_outcome_name</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return string representing the outcome.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Empty string</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s1">&#39;&#39;</span></div>



<div class="viewcode-block" id="ValidateLineSinglePointing">
<a class="viewcode-back" href="../../../../../_autosummary/pipeline.hsd.tasks.baseline.validation.ValidateLineSinglePointing.html#pipeline.hsd.tasks.baseline.validation.ValidateLineSinglePointing">[docs]</a>
<span class="k">class</span> <span class="nc">ValidateLineSinglePointing</span><span class="p">(</span><span class="n">basetask</span><span class="o">.</span><span class="n">StandardTaskTemplate</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Line validation task for single/multi pointing observation.</span>

<span class="sd">    This class is for single-pointing or multi-pointing (collection of</span>
<span class="sd">    fields with single-pointing).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">Inputs</span> <span class="o">=</span> <span class="n">ValidateLineInputs</span>

<div class="viewcode-block" id="ValidateLineSinglePointing.prepare">
<a class="viewcode-back" href="../../../../../_autosummary/pipeline.hsd.tasks.baseline.validation.ValidateLineSinglePointing.html#pipeline.hsd.tasks.baseline.validation.ValidateLineSinglePointing.prepare">[docs]</a>
    <span class="k">def</span> <span class="nf">prepare</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                <span class="n">datatable_dict</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
                <span class="n">index_list</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
                <span class="n">grid_table</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                <span class="n">detect_signal</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Perform line validation for single/multi pointing observation.</span>

<span class="sd">        Accept all detected lines without clustering analysis.</span>

<span class="sd">        Args:</span>
<span class="sd">            datatable_dict: Dictionary holding datatable instance per MS.</span>
<span class="sd">            index_list: List of consecutive datatable row numbers.</span>
<span class="sd">            grid_table: Not used</span>
<span class="sd">            detect_signal: List of detected lines per spatial position. Its format is</span>
<span class="sd">                           as follows.</span>

<span class="sd">                detect_signal = {</span>
<span class="sd">                    ID1: [RA, DEC, [[LineStartChannel1, LineEndChannel1],</span>
<span class="sd">                                    [LineStartChannel2, LineEndChannel2],</span>
<span class="sd">                                    ...,</span>
<span class="sd">                                    [LineStartChannelN, LineEndChannelN]]],</span>
<span class="sd">                    IDn: [RA, DEC, [[LineStartChannel1, LineEndChannel1],</span>
<span class="sd">                                    ...,</span>
<span class="sd">                                    [LineStartChannelN, LineEndChannelN]]]</span>
<span class="sd">                }</span>

<span class="sd">        Returns:</span>
<span class="sd">            ValidateLineResults instance, which contains list of line parameters</span>
<span class="sd">            with validation results. The list is stored in outcome[&#39;lines&#39;] and</span>
<span class="sd">            its format is as follows:</span>

<span class="sd">                [LineCenter, LineWidth, Validity]</span>

<span class="sd">            where Validity is boolean value that indicates whether or not the</span>
<span class="sd">            detected line is validated. OK (validated) for True while NG for False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">window</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">window</span>
        <span class="n">windowmode</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">windowmode</span>

        <span class="k">assert</span> <span class="n">detect_signal</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

        <span class="c1"># indexer translates serial index into per-MS index</span>
        <span class="n">indexer</span> <span class="o">=</span> <span class="n">DataTableIndexer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">context</span><span class="p">)</span>

        <span class="c1"># for Pre-Defined Spectrum Window</span>
        <span class="k">if</span> <span class="n">windowmode</span> <span class="o">==</span> <span class="s1">&#39;replace&#39;</span> <span class="ow">and</span> <span class="p">(</span><span class="n">window</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">window</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Skip line validation: windowmode=&quot;</span><span class="si">{</span><span class="n">windowmode</span><span class="si">}</span><span class="s1">&quot;, window=&quot;</span><span class="si">{</span><span class="n">window</span><span class="si">}</span><span class="s1">&quot;&#39;</span><span class="p">)</span>
            <span class="n">lines</span> <span class="o">=</span> <span class="n">_to_validated_lines</span><span class="p">(</span><span class="n">detect_signal</span><span class="p">)</span>
            <span class="c1"># TODO: review whether this relies on order of dictionary values.</span>
            <span class="n">signal</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">detect_signal</span><span class="o">.</span><span class="n">values</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">index_list</span><span class="p">:</span>
                <span class="n">origin_vis</span><span class="p">,</span> <span class="n">row</span> <span class="o">=</span> <span class="n">indexer</span><span class="o">.</span><span class="n">serial2perms</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">datatable</span> <span class="o">=</span> <span class="n">datatable_dict</span><span class="p">[</span><span class="n">origin_vis</span><span class="p">]</span>
                <span class="n">datatable</span><span class="o">.</span><span class="n">putcell</span><span class="p">(</span><span class="s1">&#39;MASKLIST&#39;</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">signal</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                <span class="n">datatable</span><span class="o">.</span><span class="n">putcell</span><span class="p">(</span><span class="s1">&#39;NOCHANGE&#39;</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
            <span class="n">outcome</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;lines&#39;</span><span class="p">:</span> <span class="n">lines</span><span class="p">,</span>
                       <span class="s1">&#39;channelmap_range&#39;</span><span class="p">:</span> <span class="n">lines</span><span class="p">,</span>
                       <span class="s1">&#39;cluster_info&#39;</span><span class="p">:</span> <span class="p">{},</span>
                       <span class="s1">&#39;flag_digits&#39;</span><span class="p">:</span> <span class="p">{}</span> <span class="p">}</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">ValidateLineResults</span><span class="p">(</span><span class="n">task</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span>
                                         <span class="n">success</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                         <span class="n">outcome</span><span class="o">=</span><span class="n">outcome</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">result</span>

        <span class="c1"># Dictionary for final output</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># register manually specified line windows to lines</span>
        <span class="k">if</span> <span class="n">window</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">window</span><span class="p">:</span>
                <span class="n">center</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">w</span><span class="p">))</span> <span class="o">/</span> <span class="mi">2</span>
                <span class="n">width</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="o">-</span> <span class="nb">min</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
                <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">center</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="kc">True</span><span class="p">])</span>

        <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Accept all detected lines without clustering analysis.&#39;</span><span class="p">)</span>

        <span class="n">iteration</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">iteration</span>

        <span class="c1"># First cycle</span>
        <span class="c1">#if len(grid_table) == 0:</span>
        <span class="k">if</span> <span class="n">iteration</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">index_list</span><span class="p">:</span>
                <span class="n">origin_vis</span><span class="p">,</span> <span class="n">row</span> <span class="o">=</span> <span class="n">indexer</span><span class="o">.</span><span class="n">serial2perms</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">datatable</span> <span class="o">=</span> <span class="n">datatable_dict</span><span class="p">[</span><span class="n">origin_vis</span><span class="p">]</span>
                <span class="n">mask_list</span> <span class="o">=</span> <span class="n">datatable</span><span class="o">.</span><span class="n">getcell</span><span class="p">(</span><span class="s1">&#39;MASKLIST&#39;</span><span class="p">,</span> <span class="n">row</span><span class="p">)</span>
                <span class="n">no_change</span> <span class="o">=</span> <span class="n">datatable</span><span class="o">.</span><span class="n">getcell</span><span class="p">(</span><span class="s1">&#39;NOCHANGE&#39;</span><span class="p">,</span> <span class="n">row</span><span class="p">)</span>
                <span class="c1">#LOG.debug(&#39;DataTable = %s, detect_signal = %s, OldFlag = %s&#39; % (mask_list, detect_signal[row][2], no_change))</span>
                <span class="c1"># datatable.putcell(&#39;MASKLIST&#39;, row, detect_signal[row][2])</span>
                <span class="n">datatable</span><span class="o">.</span><span class="n">putcell</span><span class="p">(</span><span class="s1">&#39;MASKLIST&#39;</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">detect_signal</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span>
                <span class="n">datatable</span><span class="o">.</span><span class="n">putcell</span><span class="p">(</span><span class="s1">&#39;NOCHANGE&#39;</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Iteration case</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">index_list</span><span class="p">:</span>
                <span class="n">origin_vis</span><span class="p">,</span> <span class="n">row</span> <span class="o">=</span> <span class="n">indexer</span><span class="o">.</span><span class="n">serial2perms</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">datatable</span> <span class="o">=</span> <span class="n">datatable_dict</span><span class="p">[</span><span class="n">origin_vis</span><span class="p">]</span>
                <span class="n">mask_list</span> <span class="o">=</span> <span class="n">datatable</span><span class="o">.</span><span class="n">getcell</span><span class="p">(</span><span class="s1">&#39;MASKLIST&#39;</span><span class="p">,</span> <span class="n">row</span><span class="p">)</span>
                <span class="n">no_change</span> <span class="o">=</span> <span class="n">datatable</span><span class="o">.</span><span class="n">getcell</span><span class="p">(</span><span class="s1">&#39;NOCHANGE&#39;</span><span class="p">,</span> <span class="n">row</span><span class="p">)</span>
                <span class="c1">#LOG.debug(&#39;DataTable = %s, detect_signal = %s, OldFlag = %s&#39; % (mask_list, detect_signal[0][2], no_change))</span>
                <span class="k">if</span> <span class="n">mask_list</span> <span class="o">==</span> <span class="n">detect_signal</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]:</span>
                    <span class="c1">#if type(no_change) != int:</span>
                    <span class="k">if</span> <span class="n">no_change</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="c1"># 2013/05/17 TN</span>
                        <span class="c1"># Put iteration itself instead to subtract 1 since</span>
                        <span class="c1"># iteration counter is incremented *after* the</span>
                        <span class="c1"># baseline subtraction in refactorred code.</span>
                        <span class="c1">#datatable.putcell(&#39;NOCHANGE&#39;,row,iteration - 1)</span>
                        <span class="n">datatable</span><span class="o">.</span><span class="n">putcell</span><span class="p">(</span><span class="s1">&#39;NOCHANGE&#39;</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">iteration</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">datatable</span><span class="o">.</span><span class="n">putcell</span><span class="p">(</span><span class="s1">&#39;MASKLIST&#39;</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">detect_signal</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span>
                    <span class="n">datatable</span><span class="o">.</span><span class="n">putcell</span><span class="p">(</span><span class="s1">&#39;NOCHANGE&#39;</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">outcome</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;lines&#39;</span><span class="p">:</span> <span class="n">lines</span><span class="p">,</span>
                   <span class="s1">&#39;channelmap_range&#39;</span><span class="p">:</span> <span class="n">lines</span><span class="p">,</span>
                   <span class="s1">&#39;cluster_info&#39;</span><span class="p">:</span> <span class="p">{},</span>
                   <span class="s1">&#39;flag_digits&#39;</span><span class="p">:</span> <span class="p">{}</span> <span class="p">}</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">ValidateLineResults</span><span class="p">(</span><span class="n">task</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span>
                                     <span class="n">success</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                     <span class="n">outcome</span><span class="o">=</span><span class="n">outcome</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="ValidateLineSinglePointing.analyse">
<a class="viewcode-back" href="../../../../../_autosummary/pipeline.hsd.tasks.baseline.validation.ValidateLineSinglePointing.html#pipeline.hsd.tasks.baseline.validation.ValidateLineSinglePointing.analyse">[docs]</a>
    <span class="k">def</span> <span class="nf">analyse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="p">:</span> <span class="n">ValidateLineResults</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ValidateLineResults</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Analyse results instance generated by prepare.</span>

<span class="sd">        Do nothing.</span>

<span class="sd">        Returns:</span>
<span class="sd">            ValidateLineResutls instance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">result</span></div>
</div>



<div class="viewcode-block" id="ValidateLineRaster">
<a class="viewcode-back" href="../../../../../_autosummary/pipeline.hsd.tasks.baseline.validation.ValidateLineRaster.html#pipeline.hsd.tasks.baseline.validation.ValidateLineRaster">[docs]</a>
<span class="k">class</span> <span class="nc">ValidateLineRaster</span><span class="p">(</span><span class="n">basetask</span><span class="o">.</span><span class="n">StandardTaskTemplate</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Line validation task for OTF raster observation.&quot;&quot;&quot;</span>

    <span class="n">Inputs</span> <span class="o">=</span> <span class="n">ValidateLineInputs</span>

    <span class="n">CLUSTER_WHITEN</span> <span class="o">=</span> <span class="mf">1.0</span>

    <span class="c1"># as of 2017/7/4 Valid=0.5, Marginal=0.35, Questionable=0.2</span>
    <span class="c1"># should be Valid=0.7, Marginal=0.5, Questionable=0.3</span>
    <span class="n">Valid</span> <span class="o">=</span> <span class="n">rules</span><span class="o">.</span><span class="n">ClusterRule</span><span class="p">[</span><span class="s1">&#39;ThresholdValid&#39;</span><span class="p">]</span>
    <span class="n">Marginal</span> <span class="o">=</span> <span class="n">rules</span><span class="o">.</span><span class="n">ClusterRule</span><span class="p">[</span><span class="s1">&#39;ThresholdMarginal&#39;</span><span class="p">]</span>
    <span class="n">Questionable</span> <span class="o">=</span> <span class="n">rules</span><span class="o">.</span><span class="n">ClusterRule</span><span class="p">[</span><span class="s1">&#39;ThresholdQuestionable&#39;</span><span class="p">]</span>
    <span class="n">MinFWHM</span> <span class="o">=</span> <span class="n">rules</span><span class="o">.</span><span class="n">LineFinderRule</span><span class="p">[</span><span class="s1">&#39;MinFWHM&#39;</span><span class="p">]</span>
    <span class="c1">#MaxFWHM = rules.LineFinderRule[&#39;MaxFWHM&#39;]</span>
    <span class="c1">#Clustering_Algorithm = rules.ClusterRule[&#39;ClusterAlgorithm&#39;]</span>
    <span class="n">DebugOutName</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%05d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">())</span><span class="o">%</span><span class="mi">100000</span><span class="p">)</span>
    <span class="n">DebugOutVer</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">MaxFWHM</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return maximum FWHM to consider for line validation.</span>

<span class="sd">        Max FWHM is 1/3 of total number of channels excluding edge channels</span>
<span class="sd">        specified by inputs.edge.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Maximum FWHM in number of channels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">num_edge</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">edge</span><span class="p">)</span>
        <span class="n">spw</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">reference_member</span><span class="o">.</span><span class="n">spw</span>
        <span class="n">nchan</span> <span class="o">=</span> <span class="n">spw</span><span class="o">.</span><span class="n">num_channels</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nchan</span> <span class="o">-</span> <span class="n">num_edge</span><span class="p">)</span> <span class="o">//</span> <span class="mi">3</span><span class="p">)</span>

<div class="viewcode-block" id="ValidateLineRaster.validate_cluster">
<a class="viewcode-back" href="../../../../../_autosummary/pipeline.hsd.tasks.baseline.validation.ValidateLineRaster.html#pipeline.hsd.tasks.baseline.validation.ValidateLineRaster.validate_cluster">[docs]</a>
    <span class="k">def</span> <span class="nf">validate_cluster</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">clustering_result</span><span class="p">:</span> <span class="n">ClusteringResult</span><span class="p">,</span>
        <span class="n">index_list</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
        <span class="n">detect_signal</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
        <span class="n">PosList</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">Region2</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">dict</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]]],</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]]],</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Validate cluster detected by clustering analysis.</span>

<span class="sd">        This method validates clusters detected in line center vs line width space.</span>
<span class="sd">        Validation utilizes spatial distribution of lines associated with the cluster.</span>
<span class="sd">        Property of validated lines are interpolated in two-dimensional space and</span>
<span class="sd">        set to each spatial data point.</span>

<span class="sd">        Args:</span>
<span class="sd">            clustering_result: Clustering result</span>
<span class="sd">            index_list: List of consecutive datatable row numbers</span>
<span class="sd">            detect_signal: List of detected lines per spatial position. Its format is</span>
<span class="sd">                           as follows.</span>

<span class="sd">                detect_signal = {</span>
<span class="sd">                    ID1: [RA, DEC, [[LineStartChannel1, LineEndChannel1],</span>
<span class="sd">                                    [LineStartChannel2, LineEndChannel2],</span>
<span class="sd">                                    ...,</span>
<span class="sd">                                    [LineStartChannelN, LineEndChannelN]]],</span>
<span class="sd">                    IDn: [RA, DEC, [[LineStartChannel1, LineEndChannel1],</span>
<span class="sd">                                    ...,</span>
<span class="sd">                                    [LineStartChannelN, LineEndChannelN]]]</span>
<span class="sd">                }</span>
<span class="sd">            PosList: List of pointings (RA and Dec) of ON_SOURCE data</span>
<span class="sd">            Region2: List of line properties (line width and line center)</span>
<span class="sd">                     for each data</span>

<span class="sd">        Returns:</span>
<span class="sd">            4-tuple of final line properties for each ON_SOURCE pointings (RealSignal),</span>
<span class="sd">            line property of detected clusters (lines), line property for plotting</span>
<span class="sd">            (channelmap_range), and flag per validation stage for each cluster (cluster_flag).</span>

<span class="sd">            cluster_flag is data for plotting clustering analysis results.</span>
<span class="sd">            It stores GridCluster quantized by given thresholds.</span>
<span class="sd">            it is defined as integer array and one digit is assigned to</span>
<span class="sd">            one clustering stage in each integer value:</span>

<span class="sd">                1st digit: detection</span>
<span class="sd">                2nd digit: validation</span>
<span class="sd">                3rd digit: smoothing</span>
<span class="sd">                4th digit: final</span>

<span class="sd">            If GridCluster value exceeds any threshold, corresponding</span>
<span class="sd">            digit is incremented. For example, flag 3210 stands for,</span>

<span class="sd">                value didn&#39;t exceed any thresholds in detection, and</span>
<span class="sd">                exceeded one (out of three) threshold in validation, and</span>
<span class="sd">                exceeded two (out of three) thresholds in smoothing, and</span>
<span class="sd">                exceeded three (out of four) thresholds in final.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># input parameters</span>
        <span class="n">grid_ra</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">grid_ra</span>
        <span class="n">grid_dec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">grid_dec</span>
        <span class="n">broad_component</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">broad_component</span>
        <span class="n">xorder</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">xorder</span>
        <span class="n">yorder</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">yorder</span>

        <span class="c1"># decompose clustering result</span>
        <span class="p">(</span><span class="n">Ncluster</span><span class="p">,</span> <span class="n">Bestlines</span><span class="p">,</span> <span class="n">BestCategory</span><span class="p">,</span> <span class="n">Region</span><span class="p">)</span> <span class="o">=</span> <span class="n">clustering_result</span>

        <span class="c1"># Calculate Parameters for Gridding</span>
        <span class="n">DecCorrection</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">PosList</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="mf">180.0</span> <span class="o">*</span> <span class="mf">3.141592653</span><span class="p">)</span>
        <span class="n">grid_ra</span> <span class="o">*=</span> <span class="n">DecCorrection</span>
        <span class="n">wra</span> <span class="o">=</span> <span class="n">PosList</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="n">PosList</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
        <span class="n">wdec</span> <span class="o">=</span> <span class="n">PosList</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="n">PosList</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
        <span class="n">cra</span> <span class="o">=</span> <span class="n">PosList</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">+</span> <span class="n">wra</span><span class="o">/</span><span class="mf">2.0</span>
        <span class="n">cdec</span> <span class="o">=</span> <span class="n">PosList</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">+</span> <span class="n">wdec</span><span class="o">/</span><span class="mf">2.0</span>
        <span class="c1"># 2010/6/11 +1.0 -&gt; +1.01: if wra is n x grid_ra (n is a integer), int(wra/grid_ra) is not n in some cases because of the lack of accuracy.</span>
        <span class="n">nra</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="nb">int</span><span class="p">((</span><span class="n">wra</span><span class="o">/</span><span class="mf">2.0</span> <span class="o">-</span> <span class="n">grid_ra</span><span class="o">/</span><span class="mf">2.0</span><span class="p">)</span><span class="o">/</span><span class="n">grid_ra</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">ndec</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="nb">int</span><span class="p">((</span><span class="n">wdec</span><span class="o">/</span><span class="mf">2.0</span> <span class="o">-</span> <span class="n">grid_dec</span><span class="o">/</span><span class="mf">2.0</span><span class="p">)</span><span class="o">/</span><span class="n">grid_dec</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">x0</span> <span class="o">=</span> <span class="n">cra</span> <span class="o">-</span> <span class="n">grid_ra</span><span class="o">/</span><span class="mf">2.0</span> <span class="o">-</span> <span class="n">grid_ra</span><span class="o">*</span><span class="p">(</span><span class="n">nra</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mf">2.0</span>
        <span class="n">y0</span> <span class="o">=</span> <span class="n">cdec</span> <span class="o">-</span> <span class="n">grid_dec</span><span class="o">/</span><span class="mf">2.0</span> <span class="o">-</span> <span class="n">grid_dec</span><span class="o">*</span><span class="p">(</span><span class="n">ndec</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mf">2.0</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Grid = </span><span class="si">%s</span><span class="s1"> x </span><span class="si">%s</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">nra</span><span class="p">,</span> <span class="n">ndec</span><span class="p">)</span>
        <span class="k">if</span> <span class="s1">&#39;grid&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cluster_info</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cluster_info</span><span class="p">[</span><span class="s1">&#39;grid&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;ra_min&#39;</span><span class="p">:</span> <span class="n">x0</span><span class="p">,</span>
                <span class="s1">&#39;dec_min&#39;</span><span class="p">:</span> <span class="n">y0</span><span class="p">,</span>
                <span class="s1">&#39;grid_ra&#39;</span><span class="p">:</span> <span class="n">grid_ra</span><span class="p">,</span>
                <span class="s1">&#39;grid_dec&#39;</span><span class="p">:</span> <span class="n">grid_dec</span>
            <span class="p">}</span>
        <span class="c1"># Create Space for storing the list of spectrum (ID) in the Grid</span>
        <span class="c1"># 2013/03/27 TN</span>
        <span class="c1"># Grid2SpectrumID stores index of index_list instead of row numbers</span>
        <span class="c1"># that are held by index_list.</span>
        <span class="n">Grid2SpectrumID</span> <span class="o">=</span> <span class="p">[[[]</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ndec</span><span class="p">)]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nra</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">PosList</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
            <span class="n">Grid2SpectrumID</span><span class="p">[</span><span class="nb">int</span><span class="p">((</span><span class="n">PosList</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">x0</span><span class="p">)</span><span class="o">/</span><span class="n">grid_ra</span><span class="p">)][</span><span class="nb">int</span><span class="p">((</span><span class="n">PosList</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">y0</span><span class="p">)</span><span class="o">/</span><span class="n">grid_dec</span><span class="p">)]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

        <span class="c1"># Sort lines and Category by LineCenter: lines[][0]</span>
        <span class="n">LineIndex</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">argsort</span><span class="p">([</span><span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">Bestlines</span><span class="p">[:</span><span class="n">Ncluster</span><span class="p">]])</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="p">[</span><span class="n">Bestlines</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">LineIndex</span><span class="p">]</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Ncluster, lines: </span><span class="si">{}</span><span class="s1"> </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">Ncluster</span><span class="p">,</span> <span class="n">lines</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;LineIndex: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">LineIndex</span><span class="p">))</span>

        <span class="c1">### 2011/05/17 anti-scaling of the line width</span>
        <span class="k">for</span> <span class="n">Nc</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Ncluster</span><span class="p">):</span>
            <span class="n">lines</span><span class="p">[</span><span class="n">Nc</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">CLUSTER_WHITEN</span>

        <span class="n">LineIndex2</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">LineIndex</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;LineIndex2: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">LineIndex2</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;BestCategory: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">BestCategory</span><span class="p">))</span>

        <span class="n">category</span> <span class="o">=</span> <span class="p">[</span><span class="n">LineIndex2</span><span class="p">[</span><span class="n">bc</span><span class="p">]</span> <span class="k">for</span> <span class="n">bc</span> <span class="ow">in</span> <span class="n">BestCategory</span><span class="p">]</span>

        <span class="c1">######## Clustering: Detection Stage ########</span>
        <span class="n">ProcStartTime</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Clustering: Detection Stage Start&#39;</span><span class="p">)</span>

        <span class="p">(</span><span class="n">GridCluster</span><span class="p">,</span> <span class="n">GridMember</span><span class="p">,</span> <span class="n">cluster_flag</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">detection_stage</span><span class="p">(</span><span class="n">Ncluster</span><span class="p">,</span> <span class="n">nra</span><span class="p">,</span> <span class="n">ndec</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">grid_ra</span><span class="p">,</span> <span class="n">grid_dec</span><span class="p">,</span> <span class="n">category</span><span class="p">,</span>
                                                         <span class="n">Region</span><span class="p">,</span> <span class="n">detect_signal</span><span class="p">)</span>

        <span class="n">ProcEndTime</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Clustering: Detection Stage End: Elapsed time = </span><span class="si">%s</span><span class="s1"> sec&#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">ProcEndTime</span> <span class="o">-</span> <span class="n">ProcStartTime</span><span class="p">))</span>

        <span class="c1">######## Clustering: Validation Stage ########</span>
        <span class="n">ProcStartTime</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Clustering: Validation Stage Start&#39;</span><span class="p">)</span>

        <span class="p">(</span><span class="n">GridCluster</span><span class="p">,</span> <span class="n">GridMember</span><span class="p">,</span> <span class="n">lines</span><span class="p">,</span> <span class="n">cluster_flag</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">validation_stage</span><span class="p">(</span><span class="n">GridCluster</span><span class="p">,</span> <span class="n">GridMember</span><span class="p">,</span> <span class="n">lines</span><span class="p">,</span> <span class="n">cluster_flag</span><span class="p">)</span>

        <span class="n">ProcEndTime</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Clustering: Validation Stage End: Elapsed time = </span><span class="si">%s</span><span class="s1"> sec&#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">ProcEndTime</span> <span class="o">-</span> <span class="n">ProcStartTime</span><span class="p">))</span>

        <span class="c1">######## Clustering: Smoothing Stage ########</span>
        <span class="c1"># Rating:  [0.0, 0.4, 0.5, 0.4, 0.0]</span>
        <span class="c1">#          [0.4, 0.7, 1.0, 0.7, 0.4]</span>
        <span class="c1">#          [0.5, 1.0, 6.0, 1.0, 0.5]</span>
        <span class="c1">#          [0.4, 0.7, 1.0, 0.7, 0.4]</span>
        <span class="c1">#          [0.0, 0.4, 0.5, 0.4, 0.0]</span>
        <span class="c1"># Rating = 1.0 / (Dx**2 + Dy**2)**(0.5) : if (Dx, Dy) == (0, 0) rating = 6.0</span>

        <span class="n">ProcStartTime</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Clustering: Smoothing Stage Start&#39;</span><span class="p">)</span>

        <span class="p">(</span><span class="n">GridCluster</span><span class="p">,</span> <span class="n">lines</span><span class="p">,</span> <span class="n">cluster_flag</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">smoothing_stage</span><span class="p">(</span><span class="n">GridCluster</span><span class="p">,</span> <span class="n">lines</span><span class="p">,</span> <span class="n">cluster_flag</span><span class="p">)</span>

        <span class="n">ProcEndTime</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Clustering: Smoothing Stage End: Elapsed time = </span><span class="si">%s</span><span class="s1"> sec&#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">ProcEndTime</span> <span class="o">-</span> <span class="n">ProcStartTime</span><span class="p">))</span>

        <span class="c1">######## Clustering: Final Stage ########</span>
        <span class="n">ProcStartTime</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Clustering: Final Stage Start&#39;</span><span class="p">)</span>

        <span class="c1"># create virtual index_list</span>
        <span class="p">(</span><span class="n">RealSignal</span><span class="p">,</span> <span class="n">lines</span><span class="p">,</span> <span class="n">channelmap_range</span><span class="p">,</span> <span class="n">cluster_flag</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">final_stage</span><span class="p">(</span><span class="n">GridCluster</span><span class="p">,</span> <span class="n">GridMember</span><span class="p">,</span> <span class="n">Region</span><span class="p">,</span> <span class="n">Region2</span><span class="p">,</span>
                                                                 <span class="n">lines</span><span class="p">,</span> <span class="n">category</span><span class="p">,</span> <span class="n">grid_ra</span><span class="p">,</span> <span class="n">grid_dec</span><span class="p">,</span> <span class="n">broad_component</span><span class="p">,</span>
                                                                 <span class="n">xorder</span><span class="p">,</span> <span class="n">yorder</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">Grid2SpectrumID</span><span class="p">,</span> <span class="n">index_list</span><span class="p">,</span>
                                                                 <span class="n">PosList</span><span class="p">,</span> <span class="n">cluster_flag</span><span class="p">)</span>

        <span class="n">ProcEndTime</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Clustering: Final Stage End: Elapsed time = </span><span class="si">%s</span><span class="s1"> sec&#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">ProcEndTime</span> <span class="o">-</span> <span class="n">ProcStartTime</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">RealSignal</span><span class="p">,</span> <span class="n">lines</span><span class="p">,</span> <span class="n">channelmap_range</span><span class="p">,</span> <span class="n">cluster_flag</span></div>


<div class="viewcode-block" id="ValidateLineRaster.prepare">
<a class="viewcode-back" href="../../../../../_autosummary/pipeline.hsd.tasks.baseline.validation.ValidateLineRaster.html#pipeline.hsd.tasks.baseline.validation.ValidateLineRaster.prepare">[docs]</a>
    <span class="k">def</span> <span class="nf">prepare</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                <span class="n">datatable_dict</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
                <span class="n">index_list</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                <span class="n">grid_table</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]],</span>
                <span class="n">detect_signal</span><span class="p">:</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ValidateLineResults</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Validate spectral lines detected by detection module.</span>

<span class="sd">        As a first step, the method performs clustering analysis on detected</span>
<span class="sd">        lines in line width vs line center space. Detected clusters are then</span>
<span class="sd">        analyzed and set True/False flag based on the spatial distribution</span>
<span class="sd">        of the cluster members in celestial coordinate. Finally, cluster</span>
<span class="sd">        line properties are interpolated in two-dimensional celestial space</span>
<span class="sd">        and are distributed to each ON_SOURCE data point.</span>

<span class="sd">        Sigma clipping iterations will be applied if inputs.nsigma is positive</span>

<span class="sd">        Args:</span>
<span class="sd">            datatable_dict: Dictionary holding datatable instance per MS.</span>
<span class="sd">            index_list: List of consecutive datatable row numbers. Defaults to None.</span>
<span class="sd">            grid_table: Metadata for gridding. See simplegrid.py for detail.</span>
<span class="sd">            detect_signal: List of detected lines per spatial position. Its format is</span>
<span class="sd">                           as follows.</span>

<span class="sd">                detect_signal = {</span>
<span class="sd">                    ID1: [RA, DEC, [[LineStartChannel1, LineEndChannel1],</span>
<span class="sd">                                    [LineStartChannel2, LineEndChannel2],</span>
<span class="sd">                                    ...,</span>
<span class="sd">                                    [LineStartChannelN, LineEndChannelN]]],</span>
<span class="sd">                    IDn: [RA, DEC, [[LineStartChannel1, LineEndChannel1],</span>
<span class="sd">                                    ...,</span>
<span class="sd">                                    [LineStartChannelN, LineEndChannelN]]]</span>
<span class="sd">                }</span>

<span class="sd">        Returns:</span>
<span class="sd">            ValidateLineResults instance, which contains list of line parameters</span>
<span class="sd">            with validation results. The list is stored in outcome[&#39;lines&#39;] and</span>
<span class="sd">            its format is as follows:</span>

<span class="sd">                [LineCenter, LineWidth, Validity]</span>

<span class="sd">            where Validity is boolean value that indicates whether or not the</span>
<span class="sd">            detected line is validated. OK (validated) for True while NG for False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">window</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">window</span>
        <span class="n">windowmode</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">windowmode</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">: window=</span><span class="si">{}</span><span class="s1">, windowmode=</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">window</span><span class="p">,</span> <span class="n">windowmode</span><span class="p">))</span>

        <span class="c1"># indexer translates serial index into per-MS index</span>
        <span class="n">indexer</span> <span class="o">=</span> <span class="n">DataTableIndexer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">context</span><span class="p">)</span>

        <span class="c1"># for Pre-Defined Spectrum Window</span>
        <span class="k">if</span> <span class="n">windowmode</span> <span class="o">==</span> <span class="s1">&#39;replace&#39;</span> <span class="ow">and</span> <span class="p">(</span><span class="n">window</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">window</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Skip line validation: windowmode=&quot;</span><span class="si">{</span><span class="n">windowmode</span><span class="si">}</span><span class="s1">&quot;, window=&quot;</span><span class="si">{</span><span class="n">window</span><span class="si">}</span><span class="s1">&quot;&#39;</span><span class="p">)</span>
            <span class="n">lines</span> <span class="o">=</span> <span class="n">_to_validated_lines</span><span class="p">(</span><span class="n">detect_signal</span><span class="p">)</span>
            <span class="c1"># TODO: review whether this relies on order of dictionary values.</span>
            <span class="n">signal</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">detect_signal</span><span class="o">.</span><span class="n">values</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">index_list</span><span class="p">:</span>
                <span class="n">origin_vis</span><span class="p">,</span> <span class="n">row</span> <span class="o">=</span> <span class="n">indexer</span><span class="o">.</span><span class="n">serial2perms</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">datatable</span> <span class="o">=</span> <span class="n">datatable_dict</span><span class="p">[</span><span class="n">origin_vis</span><span class="p">]</span>
                <span class="n">datatable</span><span class="o">.</span><span class="n">putcell</span><span class="p">(</span><span class="s1">&#39;MASKLIST&#39;</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">signal</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                <span class="n">datatable</span><span class="o">.</span><span class="n">putcell</span><span class="p">(</span><span class="s1">&#39;NOCHANGE&#39;</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
            <span class="n">outcome</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;lines&#39;</span><span class="p">:</span> <span class="n">lines</span><span class="p">,</span>
                       <span class="s1">&#39;channelmap_range&#39;</span><span class="p">:</span> <span class="n">lines</span><span class="p">,</span>
                       <span class="s1">&#39;cluster_info&#39;</span><span class="p">:</span> <span class="p">{},</span>
                       <span class="s1">&#39;flag_digits&#39;</span><span class="p">:</span> <span class="p">{}</span> <span class="p">}</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">ValidateLineResults</span><span class="p">(</span><span class="n">task</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span>
                                         <span class="n">success</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                         <span class="n">outcome</span><span class="o">=</span><span class="n">outcome</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">result</span>

        <span class="n">manual_window</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">manual_range</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># register manually specified line windows to lines</span>
        <span class="k">if</span> <span class="n">window</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">window</span><span class="p">:</span>
                <span class="n">center</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">w</span><span class="p">))</span> <span class="o">/</span> <span class="mi">2</span>
                <span class="n">width</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="o">-</span> <span class="nb">min</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
                <span class="n">manual_window</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">center</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">])</span>
            <span class="n">manual_range</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">window</span><span class="p">)</span>

        <span class="n">iteration</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">iteration</span>

        <span class="n">origin_vis</span><span class="p">,</span> <span class="n">_row</span> <span class="o">=</span> <span class="n">indexer</span><span class="o">.</span><span class="n">serial2perms</span><span class="p">(</span><span class="n">index_list</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nchan</span> <span class="o">=</span> <span class="n">datatable_dict</span><span class="p">[</span><span class="n">origin_vis</span><span class="p">]</span><span class="o">.</span><span class="n">getcell</span><span class="p">(</span><span class="s1">&#39;NCHAN&#39;</span><span class="p">,</span> <span class="n">_row</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nsigma</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">nsigma</span>

        <span class="n">ProcStartTime</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;2D fit the line characteristics...&#39;</span><span class="p">)</span>

        <span class="c1">#tSFLAG = datatable.getcol(&#39;FLAG_SUMMARY&#39;)</span>
        <span class="n">Totallines</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">RMS0</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cluster_info</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flag_digits</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;detection&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;validation&#39;</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span>
                            <span class="s1">&#39;smoothing&#39;</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span> <span class="s1">&#39;final&#39;</span><span class="p">:</span> <span class="mi">1000</span><span class="p">}</span>

        <span class="c1"># RASTER CASE</span>
        <span class="c1"># Read data from Table to generate ID -&gt; RA, DEC conversion table</span>
        <span class="n">Region</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">dummy</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">flag</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">Npos</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># 2017/7/4 clean-up detect_signal</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;Before: Detect_Signal = </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">detect_signal</span><span class="p">)</span>
        <span class="n">detect_signal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">clean_detect_signal</span><span class="p">(</span><span class="n">detect_signal</span><span class="p">)</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;After: Detect_Signal = </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">detect_signal</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">grid_table</span><span class="p">)):</span>
            <span class="c1"># detect_signal[row][2]: [[LineStartChannelN, LineEndChannelN, Binning],[],,,[]]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">detect_signal</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">detect_signal</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">Npos</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">detect_signal</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="mi">2</span><span class="p">]:</span>
                    <span class="c1"># Check statistics flag. tSFLAG[row]==1 =&gt; Valid Spectra 2008/1/17</span>
                    <span class="c1"># Bug fix 2008/5/29</span>
                    <span class="c1">#if (line[0] != line[1]) and ((len(grid_table) == 0 and tSFLAG[row] == 1) or len(grid_table) != 0):</span>
                    <span class="c1"># refering tSFLAG is not correct</span>
                    <span class="k">if</span> <span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">line</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span> <span class="c1">#and tSFLAG[row] == 1:</span>
                        <span class="c1">#2014/11/28 add Binning info into Region</span>
                        <span class="n">Region</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">row</span><span class="p">,</span> <span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">line</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">detect_signal</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">detect_signal</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">flag</span><span class="p">,</span> <span class="n">line</span><span class="p">[</span><span class="mi">2</span><span class="p">]])</span>
                        <span class="c1">### 2011/05/17 make cluster insensitive to the line width: Whiten</span>
                        <span class="n">dummy</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="nb">float</span><span class="p">(</span><span class="n">line</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">CLUSTER_WHITEN</span><span class="p">,</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="nb">float</span><span class="p">(</span><span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">line</span><span class="p">[</span><span class="mi">1</span><span class="p">])])</span>
        <span class="n">Region2</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dummy</span><span class="p">)</span> <span class="c1"># [FullWidth, Center]</span>
        <span class="c1">### 2015/04/22 save Region to file for test</span>
        <span class="k">if</span> <span class="n">infrastructure</span><span class="o">.</span><span class="n">logging</span><span class="o">.</span><span class="n">logging_level</span> <span class="o">==</span> <span class="n">infrastructure</span><span class="o">.</span><span class="n">logging</span><span class="o">.</span><span class="n">LOGGING_LEVELS</span><span class="p">[</span><span class="s1">&#39;trace&#39;</span><span class="p">]</span> <span class="ow">or</span> \
           <span class="n">infrastructure</span><span class="o">.</span><span class="n">logging</span><span class="o">.</span><span class="n">logging_level</span> <span class="o">==</span> <span class="n">infrastructure</span><span class="o">.</span><span class="n">logging</span><span class="o">.</span><span class="n">LOGGING_LEVELS</span><span class="p">[</span><span class="s1">&#39;debug&#39;</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">DebugOutVer</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;ClstRegion.</span><span class="si">%s</span><span class="s1">.</span><span class="si">%02d</span><span class="s1">.txt&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">DebugOutName</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">DebugOutVer</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Region</span><span class="p">)):</span>
                    <span class="n">fp</span><span class="o">.</span><span class="n">writelines</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%d</span><span class="s1"> </span><span class="si">%f</span><span class="s1"> </span><span class="si">%f</span><span class="s1"> </span><span class="si">%f</span><span class="s1"> </span><span class="si">%f</span><span class="s1"> </span><span class="si">%d</span><span class="s1"> </span><span class="si">%d</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">Region</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">Region</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">Region</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span> <span class="n">Region</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">3</span><span class="p">],</span>
                                                              <span class="n">Region</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">4</span><span class="p">],</span> <span class="n">Region</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">5</span><span class="p">],</span> <span class="n">Region</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">6</span><span class="p">]))</span>

        <span class="k">del</span> <span class="n">dummy</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Npos = </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">Npos</span><span class="p">)</span>
        <span class="c1"># 2010/6/9 for non-detection</span>
        <span class="k">if</span> <span class="n">Npos</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">Region2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">manual_range</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">signal</span> <span class="o">=</span> <span class="p">[[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">signal</span> <span class="o">=</span> <span class="n">manual_range</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">index_list</span><span class="p">:</span>
                <span class="n">origin_vis</span><span class="p">,</span> <span class="n">row</span> <span class="o">=</span> <span class="n">indexer</span><span class="o">.</span><span class="n">serial2perms</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">datatable</span> <span class="o">=</span> <span class="n">datatable_dict</span><span class="p">[</span><span class="n">origin_vis</span><span class="p">]</span>
                <span class="n">datatable</span><span class="o">.</span><span class="n">putcell</span><span class="p">(</span><span class="s1">&#39;MASKLIST&#39;</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">signal</span><span class="p">)</span>
                <span class="n">datatable</span><span class="o">.</span><span class="n">putcell</span><span class="p">(</span><span class="s1">&#39;NOCHANGE&#39;</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
            <span class="n">outcome</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;lines&#39;</span><span class="p">:</span> <span class="n">manual_window</span><span class="p">,</span>
                       <span class="s1">&#39;channelmap_range&#39;</span><span class="p">:</span> <span class="n">manual_window</span><span class="p">,</span>
                       <span class="s1">&#39;cluster_info&#39;</span><span class="p">:</span> <span class="p">{},</span>
                       <span class="s1">&#39;flag_digits&#39;</span><span class="p">:</span> <span class="p">{}</span> <span class="p">}</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">ValidateLineResults</span><span class="p">(</span><span class="n">task</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span>
                                         <span class="n">success</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                         <span class="n">outcome</span><span class="o">=</span><span class="n">outcome</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">result</span>

        <span class="c1"># 2008/9/20 Dec Effect was corrected</span>
        <span class="k">def</span> <span class="nf">_g</span><span class="p">(</span><span class="n">colname</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">index_list</span><span class="p">:</span>
                <span class="n">origin_vis</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">indexer</span><span class="o">.</span><span class="n">serial2perms</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">datatable</span> <span class="o">=</span> <span class="n">datatable_dict</span><span class="p">[</span><span class="n">origin_vis</span><span class="p">]</span>
                <span class="k">yield</span> <span class="n">datatable</span><span class="o">.</span><span class="n">getcell</span><span class="p">(</span><span class="n">colname</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
        <span class="n">ras</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">fromiter</span><span class="p">(</span><span class="n">_g</span><span class="p">(</span><span class="s1">&#39;OFS_RA&#39;</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">decs</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">fromiter</span><span class="p">(</span><span class="n">_g</span><span class="p">(</span><span class="s1">&#39;OFS_DEC&#39;</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">PosList</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">ras</span><span class="p">,</span> <span class="n">decs</span><span class="p">])</span>
        <span class="n">ProcEndTime</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Clustering: Initialization End: Elapsed time = </span><span class="si">%s</span><span class="s1"> sec&#39;</span><span class="p">,</span> <span class="n">ProcEndTime</span> <span class="o">-</span> <span class="n">ProcStartTime</span><span class="p">)</span>


        <span class="c1">######## Clustering: K-mean Stage ########</span>
        <span class="c1"># K-mean Clustering Analysis with LineWidth and LineCenter</span>
        <span class="c1"># Max number of protect regions are SDC.SDParam[&#39;Cluster&#39;][&#39;MaxCluster&#39;] (Max lines)</span>
        <span class="n">ProcStartTime</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Clustering Analysis Start&#39;</span><span class="p">)</span>

        <span class="c1"># Bestlines: [[center, width, T/F],[],,,[]]</span>
        <span class="n">clustering_algorithm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">clusteringalgorithm</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;clustering algorithm is </span><span class="se">\&#39;</span><span class="si">%s</span><span class="se">\&#39;</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">clustering_algorithm</span><span class="p">)</span>
        <span class="n">clustering_results</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">clustering_algorithm</span> <span class="o">==</span> <span class="s1">&#39;kmean&#39;</span><span class="p">:</span>
            <span class="c1">#(Ncluster, Bestlines, BestCategory, Region) = self.clustering_kmean(Region, Region2)</span>
            <span class="n">clustering_results</span><span class="p">[</span><span class="n">clustering_algorithm</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">clustering_kmean</span><span class="p">(</span><span class="n">Region</span><span class="p">,</span> <span class="n">Region2</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">clustering_algorithm</span> <span class="o">==</span> <span class="s1">&#39;hierarchy&#39;</span><span class="p">:</span>
            <span class="c1">#(Ncluster, Bestlines, BestCategory, Region) = self.clustering_hierarchy(Region, Region2, nThreshold=rules.ClusterRule[&#39;ThresholdHierarchy&#39;], method=&#39;single&#39;)</span>
            <span class="n">clustering_results</span><span class="p">[</span><span class="n">clustering_algorithm</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">clustering_hierarchy</span><span class="p">(</span><span class="n">Region</span><span class="p">,</span> <span class="n">Region2</span><span class="p">,</span> <span class="n">nThreshold</span><span class="o">=</span><span class="n">rules</span><span class="o">.</span><span class="n">ClusterRule</span><span class="p">[</span><span class="s1">&#39;ThresholdHierarchy&#39;</span><span class="p">],</span>
                                                                                 <span class="n">nThreshold2</span><span class="o">=</span><span class="n">rules</span><span class="o">.</span><span class="n">ClusterRule</span><span class="p">[</span><span class="s1">&#39;ThresholdHierarchy2&#39;</span><span class="p">],</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;single&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">clustering_algorithm</span> <span class="o">==</span> <span class="s1">&#39;both&#39;</span><span class="p">:</span>
            <span class="n">clustering_results</span><span class="p">[</span><span class="s1">&#39;kmean&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">clustering_kmean</span><span class="p">(</span><span class="n">Region</span><span class="p">,</span> <span class="n">Region2</span><span class="p">)</span>
            <span class="n">clustering_results</span><span class="p">[</span><span class="s1">&#39;hierarchy&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">clustering_hierarchy</span><span class="p">(</span><span class="n">Region</span><span class="p">,</span> <span class="n">Region2</span><span class="p">,</span> <span class="n">nThreshold</span><span class="o">=</span><span class="n">rules</span><span class="o">.</span><span class="n">ClusterRule</span><span class="p">[</span><span class="s1">&#39;ThresholdHierarchy&#39;</span><span class="p">],</span>
                                                                        <span class="n">nThreshold2</span><span class="o">=</span><span class="n">rules</span><span class="o">.</span><span class="n">ClusterRule</span><span class="p">[</span><span class="s1">&#39;ThresholdHierarchy2&#39;</span><span class="p">],</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;single&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;Invalid clustering algorithm: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">clustering_algorithm</span><span class="p">))</span>

        <span class="n">ProcEndTime</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Clustering Analysis End: Elapsed time = </span><span class="si">%s</span><span class="s1"> sec&#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">ProcEndTime</span> <span class="o">-</span> <span class="n">ProcStartTime</span><span class="p">))</span>
        <span class="c1"># 2017/8/15 for non-detection after cleaninig</span>
        <span class="c1">#if Ncluster == 0:</span>
        <span class="k">if</span> <span class="nb">sum</span><span class="p">([</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">clustering_results</span><span class="o">.</span><span class="n">values</span><span class="p">()])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">manual_range</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">signal</span> <span class="o">=</span> <span class="p">[[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">signal</span> <span class="o">=</span> <span class="n">manual_range</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">index_list</span><span class="p">:</span>
                <span class="n">origin_vis</span><span class="p">,</span> <span class="n">row</span> <span class="o">=</span> <span class="n">indexer</span><span class="o">.</span><span class="n">serial2perms</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">datatable</span> <span class="o">=</span> <span class="n">datatable_dict</span><span class="p">[</span><span class="n">origin_vis</span><span class="p">]</span>
                <span class="n">datatable</span><span class="o">.</span><span class="n">putcell</span><span class="p">(</span><span class="s1">&#39;MASKLIST&#39;</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">signal</span><span class="p">)</span>
                <span class="n">datatable</span><span class="o">.</span><span class="n">putcell</span><span class="p">(</span><span class="s1">&#39;NOCHANGE&#39;</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
            <span class="n">outcome</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;lines&#39;</span><span class="p">:</span> <span class="n">manual_window</span><span class="p">,</span>
                       <span class="s1">&#39;channelmap_range&#39;</span><span class="p">:</span> <span class="n">manual_window</span><span class="p">,</span>
                       <span class="s1">&#39;cluster_info&#39;</span><span class="p">:</span> <span class="p">{},</span>
                       <span class="s1">&#39;flag_digits&#39;</span><span class="p">:</span> <span class="p">{}</span> <span class="p">}</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">ValidateLineResults</span><span class="p">(</span><span class="n">task</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span>
                                         <span class="n">success</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                         <span class="n">outcome</span><span class="o">=</span><span class="n">outcome</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">result</span>

        <span class="c1">### 2011/05/17 anti-scaling of the line width</span>
        <span class="n">Region2</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">Region2</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">CLUSTER_WHITEN</span>
        <span class="c1"># validate cluster</span>
        <span class="k">assert</span> <span class="n">clustering_algorithm</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;kmean&#39;</span><span class="p">,</span> <span class="s1">&#39;hierarchy&#39;</span><span class="p">,</span> <span class="s1">&#39;both&#39;</span><span class="p">]</span>
        <span class="n">validated</span> <span class="o">=</span> <span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">validate_cluster</span><span class="p">(</span><span class="n">v</span><span class="p">,</span>
                                  <span class="n">index_list</span><span class="p">,</span>
                                  <span class="n">detect_signal</span><span class="p">,</span>
                                  <span class="n">PosList</span><span class="p">,</span>
                                  <span class="n">Region2</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">clustering_results</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="p">]</span>
        <span class="c1"># Merge results from multiple clustering analysises</span>
        <span class="c1"># If more than one results exist, minimum contents of RealSignal will be merged</span>
        <span class="c1"># and remaining items (PolList) will be lost</span>
        <span class="c1"># Original RealSignal data will be stored in validated[x][0]</span>
        <span class="p">(</span><span class="n">RealSignal</span><span class="p">,</span> <span class="n">lines</span><span class="p">,</span> <span class="n">channelmap_range</span><span class="p">,</span> <span class="n">cluster_flag</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_merge_cluster_result</span><span class="p">(</span><span class="n">validated</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cluster_info</span><span class="p">[</span><span class="s1">&#39;cluster_flag&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cluster_flag</span>

        <span class="c1"># Merge masks if possible</span>
        <span class="n">ProcStartTime</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Clustering: Merging Start&#39;</span><span class="p">)</span>
        <span class="c1"># RealSignal should have all row&#39;s as its key</span>
        <span class="n">tmp_index</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">vrow</span> <span class="ow">in</span> <span class="n">index_list</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">vrow</span> <span class="ow">in</span> <span class="n">RealSignal</span><span class="p">:</span>
                <span class="n">signal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__merge_lines</span><span class="p">(</span><span class="n">RealSignal</span><span class="p">[</span><span class="n">vrow</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">nchan</span><span class="p">)</span>
                <span class="n">signal</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">manual_range</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">signal</span> <span class="o">=</span> <span class="n">manual_range</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">signal</span> <span class="o">=</span> <span class="p">[[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
                <span class="c1">#RealSignal[row] = [PosList[0][tmp_index], PosList[1][tmp_index], signal]</span>
            <span class="n">tmp_index</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="n">origin_vis</span><span class="p">,</span> <span class="n">row</span> <span class="o">=</span> <span class="n">indexer</span><span class="o">.</span><span class="n">serial2perms</span><span class="p">(</span><span class="n">vrow</span><span class="p">)</span>
            <span class="n">datatable</span> <span class="o">=</span> <span class="n">datatable_dict</span><span class="p">[</span><span class="n">origin_vis</span><span class="p">]</span>

            <span class="c1"># In the following code, access to MASKLIST and NOCHANGE columns</span>
            <span class="c1"># is direct to underlying table object instead of access via</span>
            <span class="c1"># datatable object&#39;s method since direct access is faster.</span>
            <span class="c1"># Note that MASKLIST [[-1,-1]] represents that no masks are</span>
            <span class="c1"># available, while NOCHANGE -1 indicates NOCHANGE is False.</span>
            <span class="c1">#tMASKLIST = datatable.getcell(&#39;MASKLIST&#39;,row)</span>
            <span class="c1">#tNOCHANGE = datatable.getcell(&#39;NOCHANGE&#39;,row)</span>
            <span class="n">tMASKLIST</span> <span class="o">=</span> <span class="n">datatable</span><span class="o">.</span><span class="n">getcell</span><span class="p">(</span><span class="s1">&#39;MASKLIST&#39;</span><span class="p">,</span> <span class="n">row</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tMASKLIST</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">tMASKLIST</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">tMASKLIST</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tMASKLIST</span> <span class="o">=</span> <span class="n">tMASKLIST</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>  <span class="c1"># list(tMASKLIST)</span>
            <span class="n">tNOCHANGE</span> <span class="o">=</span> <span class="n">datatable</span><span class="o">.</span><span class="n">getcell</span><span class="p">(</span><span class="s1">&#39;NOCHANGE&#39;</span><span class="p">,</span> <span class="n">row</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">tMASKLIST</span> <span class="o">==</span> <span class="n">signal</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">tNOCHANGE</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># 2013/05/17 TN</span>
                    <span class="c1"># Put iteration itself instead to subtract 1 since iteration</span>
                    <span class="c1"># counter is incremented *after* baseline subtraction</span>
                    <span class="c1"># in refactorred code.</span>
                    <span class="n">datatable</span><span class="o">.</span><span class="n">putcell</span><span class="p">(</span><span class="s1">&#39;NOCHANGE&#39;</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">iteration</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">datatable</span><span class="o">.</span><span class="n">putcell</span><span class="p">(</span><span class="s1">&#39;MASKLIST&#39;</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">signal</span><span class="p">)</span>
                <span class="n">datatable</span><span class="o">.</span><span class="n">putcell</span><span class="p">(</span><span class="s1">&#39;NOCHANGE&#39;</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">del</span> <span class="n">RealSignal</span>
        <span class="n">ProcEndTime</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Clustering: Merging End: Elapsed time = </span><span class="si">%s</span><span class="s1"> sec&#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">ProcEndTime</span> <span class="o">-</span> <span class="n">ProcStartTime</span><span class="p">))</span>

        <span class="n">lines</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">manual_window</span><span class="p">)</span>
        <span class="n">channelmap_range</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">manual_window</span><span class="p">)</span>

        <span class="n">outcome</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;lines&#39;</span><span class="p">:</span> <span class="n">lines</span><span class="p">,</span>
                   <span class="s1">&#39;channelmap_range&#39;</span><span class="p">:</span> <span class="n">channelmap_range</span><span class="p">,</span>
                   <span class="s1">&#39;cluster_info&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">cluster_info</span><span class="p">,</span>
                   <span class="s1">&#39;flag_digits&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">flag_digits</span> <span class="p">}</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">ValidateLineResults</span><span class="p">(</span><span class="n">task</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span>
                                     <span class="n">success</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                     <span class="n">outcome</span><span class="o">=</span><span class="n">outcome</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="ValidateLineRaster.analyse">
<a class="viewcode-back" href="../../../../../_autosummary/pipeline.hsd.tasks.baseline.validation.ValidateLineRaster.html#pipeline.hsd.tasks.baseline.validation.ValidateLineRaster.analyse">[docs]</a>
    <span class="k">def</span> <span class="nf">analyse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="p">:</span> <span class="n">ValidateLineResults</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ValidateLineResults</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Analyse results instance generated by prepare.</span>

<span class="sd">        Do nothing.</span>

<span class="sd">        Returns:</span>
<span class="sd">            ValidateLineResutls instance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">result</span></div>


    <span class="k">def</span> <span class="nf">_merge_cluster_info</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">algorithm</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">cluster_score</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
        <span class="n">detected_lines</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">cluster_property</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]]],</span>
        <span class="n">cluster_scale</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Merge information on clustering analysis into &quot;cluster_info&quot; attribute.</span>

<span class="sd">        Merges args into &quot;cluster_info&quot; attribute according to the following rule:</span>

<span class="sd">            - cluster_score for kmean takes priority over the one for hierarchy</span>
<span class="sd">            - detected_lines is registered only once (since detected_lines is an</span>
<span class="sd">              input for clustering analysis and should be the same among clustering</span>
<span class="sd">              algorithm)</span>
<span class="sd">            - cluster_property is accumulated</span>
<span class="sd">            - cluster_scale is registered only once (since the value is shared</span>
<span class="sd">              among clustering algorithm)</span>

<span class="sd">        Args:</span>
<span class="sd">            algorithm: Clustering algorithm. Either &#39;kmean&#39; or &#39;hierarchy&#39;.</span>
<span class="sd">            cluster_score: Cluster score vs number of clusters</span>
<span class="sd">            detected_lines: List of line properties per grid position</span>
<span class="sd">            cluster_property: List of properties (line width, line center) for</span>
<span class="sd">                              each detected clusters</span>
<span class="sd">            cluster_scale: Scaling factor</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">actions</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;cluster_score&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;kmean&#39;</span><span class="p">,</span> <span class="n">cluster_score</span><span class="p">),</span>
            <span class="s1">&#39;detected_lines&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;skip&#39;</span><span class="p">,</span> <span class="n">detected_lines</span><span class="p">),</span>
            <span class="s1">&#39;cluster_property&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;append&#39;</span><span class="p">,</span> <span class="n">cluster_property</span><span class="p">),</span>
            <span class="s1">&#39;cluster_scale&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;skip&#39;</span><span class="p">,</span> <span class="n">cluster_scale</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="p">(</span><span class="n">action</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="ow">in</span> <span class="n">actions</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cluster_info</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cluster_info</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">elif</span> <span class="n">action</span> <span class="o">==</span> <span class="s1">&#39;append&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cluster_info</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">action</span> <span class="o">==</span> <span class="n">algorithm</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cluster_info</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">_merge_cluster_result</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">result_list</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">dict</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]]],</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]]],</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">dict</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]]],</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]]],</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Merge multiple clustering analysis results into one.</span>

<span class="sd">        Take union on detected clusters. If length of result_list is 1, simply return</span>
<span class="sd">        the first item.</span>

<span class="sd">        Args:</span>
<span class="sd">            result_list: List of clustering analysis result</span>

<span class="sd">        Returns:</span>
<span class="sd">            Merged result</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">result_list</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">result_list</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="n">merged_RealSignal</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="p">[]])</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">result_list</span><span class="p">:</span>
            <span class="n">RealSignal</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">RealSignal</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">merged_RealSignal</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">merged_lines</span> <span class="o">=</span> <span class="p">[</span><span class="n">l</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">result_list</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
        <span class="n">merged_channelmap_ranges</span> <span class="o">=</span> <span class="p">[</span><span class="n">l</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">result_list</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">r</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
        <span class="n">merged_flag</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">r</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">result_list</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">merged_RealSignal</span><span class="p">,</span> <span class="n">merged_lines</span><span class="p">,</span> <span class="n">merged_channelmap_ranges</span><span class="p">,</span> <span class="n">merged_flag</span>

<div class="viewcode-block" id="ValidateLineRaster.clean_detect_signal">
<a class="viewcode-back" href="../../../../../_autosummary/pipeline.hsd.tasks.baseline.validation.ValidateLineRaster.html#pipeline.hsd.tasks.baseline.validation.ValidateLineRaster.clean_detect_signal">[docs]</a>
    <span class="k">def</span> <span class="nf">clean_detect_signal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">detect_signal</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Exclude false detections based on the detection rate.</span>

<span class="sd">        Spectra in each grid positions are splitted into 3 groups along time series.</span>
<span class="sd">        Group of spectra is then combined to 1 spectrum. So, one grid position has</span>
<span class="sd">        3 combined spectra.</span>
<span class="sd">        Suppose that the real signal is correlated but the error is not, we can</span>
<span class="sd">        clean false signals (not correlated) in advance of the validation stage.</span>

<span class="sd">        Args:</span>
<span class="sd">            detect_signal: List of detected lines per spatial position. Its format is</span>
<span class="sd">                           as follows.</span>

<span class="sd">                detect_signal = {</span>
<span class="sd">                    ID1: [RA, DEC, [[LineStartChannel1, LineEndChannel1],</span>
<span class="sd">                                    [LineStartChannel2, LineEndChannel2],</span>
<span class="sd">                                    ...,</span>
<span class="sd">                                    [LineStartChannelN, LineEndChannelN]]],</span>
<span class="sd">                    IDn: [RA, DEC, [[LineStartChannel1, LineEndChannel1],</span>
<span class="sd">                                    ...,</span>
<span class="sd">                                    [LineStartChannelN, LineEndChannelN]]]</span>
<span class="sd">                }</span>

<span class="sd">        Returns:</span>
<span class="sd">            detect_signal after cleaning</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># grouping by position</span>
        <span class="n">Gthreshold</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="mf">3600.</span>
        <span class="c1"># TODO: review whether the following relies on a specific order of keys.</span>
        <span class="n">DSkey</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">detect_signal</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">PosGroup</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># PosGroup: [[ID,ID,ID],[ID,ID,ID],...,[ID,ID,ID]]</span>
        <span class="k">for</span> <span class="n">ID</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">detect_signal</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="k">if</span> <span class="n">ID</span> <span class="ow">in</span> <span class="n">DSkey</span><span class="p">:</span>
                <span class="k">del</span> <span class="n">DSkey</span><span class="p">[</span><span class="n">DSkey</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">ID</span><span class="p">)]</span>
                <span class="n">DStmp</span> <span class="o">=</span> <span class="n">DSkey</span><span class="p">[:]</span>
                <span class="n">PosGroup</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">ID</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">nID</span> <span class="ow">in</span> <span class="n">DStmp</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">detect_signal</span><span class="p">[</span><span class="n">ID</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">detect_signal</span><span class="p">[</span><span class="n">nID</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">Gthreshold</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">detect_signal</span><span class="p">[</span><span class="n">ID</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">detect_signal</span><span class="p">[</span><span class="n">nID</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">Gthreshold</span><span class="p">:</span>
                        <span class="k">del</span> <span class="n">DSkey</span><span class="p">[</span><span class="n">DSkey</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">nID</span><span class="p">)]</span>
                        <span class="n">PosGroup</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nID</span><span class="p">)</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;clean_detect_signal: PosGroup = </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">PosGroup</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">PList</span> <span class="ow">in</span> <span class="n">PosGroup</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">PList</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">PList</span><span class="p">:</span>
                    <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">detect_signal</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>
                <span class="c1"># threshold 0.7: identical line is detected in all 3 data: strict checking</span>
                <span class="c1"># threshold 0.6: identical line is detected in 2 data out of 3</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">clean_detect_line</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">0.7</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">PList</span><span class="p">:</span>
                    <span class="n">detect_signal</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">ret</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">detect_signal</span></div>


<div class="viewcode-block" id="ValidateLineRaster.clean_detect_line">
<a class="viewcode-back" href="../../../../../_autosummary/pipeline.hsd.tasks.baseline.validation.ValidateLineRaster.html#pipeline.hsd.tasks.baseline.validation.ValidateLineRaster.clean_detect_line">[docs]</a>
    <span class="k">def</span> <span class="nf">clean_detect_line</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">,</span> <span class="n">threshold</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.6</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Exclude false detection by comparing three signals.</span>

<span class="sd">        Select only line candidates with good possibility by checking all spectra</span>
<span class="sd">        taken at the same position. If list of detected signals per spectrum, data,</span>
<span class="sd">        is given, this method evaluates detection rate of each signal where identity</span>
<span class="sd">        of signals is checked by CheckLineIdentity method. If the rate exceeds threshold,</span>
<span class="sd">        the signal is marked as &quot;true signal&quot;. Default threshold for &quot;true signal&quot; is</span>
<span class="sd">        0.6 (60%).</span>

<span class="sd">        Meaning of default value is interpreted as follows. Suppose we have three sets</span>
<span class="sd">        of signals. If identical lines are found in two out of three signals, detection</span>
<span class="sd">        rate is 2/3 or 0.66666.... Therefore, default value corresponds to the condition</span>
<span class="sd">        that the signal is true detection if it is found in two out of three signals.</span>
<span class="sd">        Larger threshold such as 0.7 is more strict check, which effectively requires</span>
<span class="sd">        that the signal must be found in all three.</span>

<span class="sd">        Args:</span>
<span class="sd">            data: List of properties of detected lines to be examined. Format is</span>
<span class="sd">                  as follows</span>

<span class="sd">                      {ID1: [[LineStart, LineEnd, Binning],,,],</span>
<span class="sd">                       ID2: [[LineStart, LineEnd, Binning],,,],</span>
<span class="sd">                       ...</span>
<span class="sd">                       IDn: [[LineStart, LineEnd, Binning],,,]}</span>
<span class="sd">            threshold: threshold for the exclusion. Ranges between 0 and 1.</span>
<span class="sd">                       Defalts to 0.6.</span>

<span class="sd">        Returns:</span>
<span class="sd">            List of lines that are regarded as &quot;true detection&quot;. For false</span>
<span class="sd">            detection, dict value will be [-1, -1, 1].</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">NSP</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">ID</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="n">ret</span><span class="p">[</span><span class="n">ID</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ID</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">ID</span><span class="p">])):</span>
                <span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="n">ID</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">ref</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">ID</span><span class="p">][</span><span class="n">i</span><span class="p">][:]</span>
                    <span class="n">tmp</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="c1"># if binning &gt; 1: expected number of lines in the grid doubles, i.e., two different offsets</span>
                    <span class="k">for</span> <span class="n">nID</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                        <span class="n">Lines</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]</span>
                        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">nID</span><span class="p">])):</span>
                            <span class="c1"># check binning is the same, and overlap</span>
                            <span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="n">nID</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">ref</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">CheckLineIdentity</span><span class="p">(</span><span class="n">ref</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="n">nID</span><span class="p">][</span><span class="n">j</span><span class="p">],</span> <span class="n">overlap</span><span class="o">=</span><span class="mf">0.7</span><span class="p">):</span>
                                <span class="n">Lines</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">data</span><span class="p">[</span><span class="n">nID</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                                <span class="n">Lines</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">data</span><span class="p">[</span><span class="n">nID</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                                <span class="n">Lines</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+=</span> <span class="mf">1.0</span>
                                <span class="c1"># clear identical line</span>
                                <span class="n">data</span><span class="p">[</span><span class="n">nID</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">Lines</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">tmp</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">nID</span><span class="p">,</span> <span class="p">[</span><span class="n">Lines</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">Lines</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">Lines</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">Lines</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">ref</span><span class="p">[</span><span class="mi">2</span><span class="p">]]])</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span> <span class="o">/</span> <span class="n">NSP</span> <span class="o">&gt;=</span> <span class="n">threshold</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">nID</span><span class="p">,</span> <span class="n">ref</span> <span class="ow">in</span> <span class="n">tmp</span><span class="p">:</span>
                            <span class="n">ret</span><span class="p">[</span><span class="n">nID</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ref</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ID</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ret</span><span class="p">[</span><span class="n">ID</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">ret</span><span class="p">[</span><span class="n">ID</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">ret</span></div>


<div class="viewcode-block" id="ValidateLineRaster.CheckLineIdentity">
<a class="viewcode-back" href="../../../../../_autosummary/pipeline.hsd.tasks.baseline.validation.ValidateLineRaster.html#pipeline.hsd.tasks.baseline.validation.ValidateLineRaster.CheckLineIdentity">[docs]</a>
    <span class="k">def</span> <span class="nf">CheckLineIdentity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">old</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">new</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">overlap</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.7</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check if the given set of line ranges overlap.</span>

<span class="sd">        True if the overlap of two lines is greater than the threshold.</span>

<span class="sd">        1L          1R          1L         1R          1L        1R       1L       1R</span>
<span class="sd">         [          ]           [          ]            [         ]       [         ]</span>
<span class="sd">         xxxxxxxxxxxx           xxxxxxxxxxxx            xxxxxxxxxxx       xxxxxxxxxxx</span>
<span class="sd">        oooooooooooooo           oooooooooooo          ooooooooooo         ooooooooo</span>
<span class="sd">        [            ]           [          ]          [         ]         [       ]</span>
<span class="sd">        2L          2R          2L         2R          2L        2R       2L       2R</span>

<span class="sd">        True if Num(x) / Num(o) &gt;= overlap</span>

<span class="sd">        Args:</span>
<span class="sd">            old: Reference line range. [left, right, binning]</span>
<span class="sd">            new: Comparing line range. [left, right, binning]</span>
<span class="sd">            overlap: Threshold for overlap. Ranges between 0 and 1. Defaults to 0.7.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Whether or not two lines overlap.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">old</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">new</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">old</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">or</span> \
           <span class="n">old</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">new</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">old</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">or</span> \
           <span class="n">new</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">old</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">new</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">or</span> \
           <span class="n">new</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">old</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">new</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> \
           <span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">old</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">new</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="nb">max</span><span class="p">(</span><span class="n">old</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">new</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="nb">max</span><span class="p">((</span><span class="n">old</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">old</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="n">new</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">new</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span> <span class="o">&gt;=</span> <span class="n">overlap</span><span class="p">:</span>
            <span class="c1">#print &#39;Identical&#39;, old, new</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="ValidateLineRaster.clustering_kmean">
<a class="viewcode-back" href="../../../../../_autosummary/pipeline.hsd.tasks.baseline.validation.ValidateLineRaster.html#pipeline.hsd.tasks.baseline.validation.ValidateLineRaster.clustering_kmean">[docs]</a>
    <span class="k">def</span> <span class="nf">clustering_kmean</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Region</span><span class="p">:</span> <span class="n">DetectedLineList</span><span class="p">,</span> <span class="n">Region2</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ClusteringResult</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Perform k-mean clustering analysis on detected lines.</span>

<span class="sd">        Perform k-mean clustering analysis on detected lines with various</span>
<span class="sd">        pre-defined number of clusters. Best number of clusters are</span>
<span class="sd">        determined by the scoring scheme based on the distance between</span>
<span class="sd">        origin of the cluster and the data regarded as a member of the</span>
<span class="sd">        cluster.</span>

<span class="sd">        Args:</span>
<span class="sd">            Region: List of line properties with associated spatial coordinate.</span>
<span class="sd">                    Format is as follows.</span>

<span class="sd">                [[row, chan0, chan1, RA, DEC, flag, Binning],[],[],,,[]]</span>

<span class="sd">            Region2: List of line properties (line width and line center)</span>
<span class="sd">                     for each data. Format is as follows.</span>

<span class="sd">                [[Width, Center],[],[],,,[]]</span>

<span class="sd">        Returns:</span>
<span class="sd">            4-tuple representing clustering results, number of clusters,</span>
<span class="sd">            list of cluster properties (Center, Width/WHITEN, T/F, ClusterRadius),</span>
<span class="sd">            List of category indices indicating which lines belong to what</span>
<span class="sd">            cluster, and list of line properties with associated spatial</span>
<span class="sd">            coordinate (which is same format as Region).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Region = [[row, chan0, chan1, RA, DEC, flag, Binning],[],[],,,[]]</span>
        <span class="c1"># Region2 = [[Width, Center],[],[],,,[]]</span>
        <span class="n">MedianWidth</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">Region2</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;MedianWidth = </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">MedianWidth</span><span class="p">)</span>

        <span class="n">MaxCluster</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">rules</span><span class="o">.</span><span class="n">ClusterRule</span><span class="p">[</span><span class="s1">&#39;MaxCluster&#39;</span><span class="p">])</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Maximum number of clusters (MaxCluster) = </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">MaxCluster</span><span class="p">)</span>

        <span class="c1"># Determin the optimum number of clusters</span>
        <span class="n">BestScore</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span>
        <span class="c1"># 2010/6/15 Plot the score along the number of the clusters</span>
        <span class="n">ListNcluster</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">ListScore</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">ListBestScore</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">converged</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1">#</span>
        <span class="n">elapsed</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">DebugOutVer</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">Ncluster</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">MaxCluster</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">index0</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">ListScore</span><span class="p">)</span>
            <span class="c1"># Fix the random seed 2008/5/23</span>
            <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">((</span><span class="mi">1234</span><span class="p">,</span> <span class="mi">567</span><span class="p">))</span>
            <span class="c1"># Try multiple times to supress random selection effect 2007/09/04</span>
            <span class="k">for</span> <span class="n">Multi</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">Ncluster</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">)):</span>
                <span class="n">codebook</span><span class="p">,</span> <span class="n">diff</span> <span class="o">=</span> <span class="n">VQ</span><span class="o">.</span><span class="n">kmeans</span><span class="p">(</span><span class="n">Region2</span><span class="p">,</span> <span class="n">Ncluster</span><span class="p">,</span> <span class="nb">iter</span><span class="o">=</span><span class="mi">50</span><span class="p">)</span>
                <span class="c1"># codebook = [[clstCentX, clstCentY],[clstCentX,clstCentY],,[]] len=Ncluster</span>
                <span class="c1"># diff &lt;= distortion</span>
                <span class="n">NclusterNew</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;codebook=</span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">codebook</span><span class="p">)</span>
                <span class="c1"># Do iteration until no merging of clusters to be found</span>
                <span class="k">while</span><span class="p">(</span><span class="n">NclusterNew</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">codebook</span><span class="p">)):</span>
                    <span class="n">category</span><span class="p">,</span> <span class="n">distance</span> <span class="o">=</span> <span class="n">VQ</span><span class="o">.</span><span class="n">vq</span><span class="p">(</span><span class="n">Region2</span><span class="p">,</span> <span class="n">codebook</span><span class="p">)</span>
                    <span class="c1"># category = [c0, c0, c1, c2, c0,,,] c0,c1,c2,,, are clusters which each element belongs to</span>
                    <span class="c1"># category starts with 0</span>
                    <span class="c1"># distance = [d1, d2, d3,,,,,] distance from belonging cluster center</span>
                    <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;Cluster Category&amp;Distance </span><span class="si">%s</span><span class="s1">, distance = </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">category</span><span class="p">,</span> <span class="n">distance</span><span class="p">)</span>

                    <span class="c1"># remove empty line in codebook</span>
                    <span class="n">codebook</span> <span class="o">=</span> <span class="n">codebook</span><span class="o">.</span><span class="n">take</span><span class="p">([</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">codebook</span><span class="p">))</span> <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">category</span><span class="o">==</span><span class="n">x</span><span class="p">)],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">NclusterNew</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">codebook</span><span class="p">)</span>

                    <span class="c1"># Clear Flag</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Region</span><span class="p">)):</span>
                        <span class="n">Region</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

                    <span class="n">Outlier</span> <span class="o">=</span> <span class="mf">0.0</span>
                    <span class="n">lines</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">Nc</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">NclusterNew</span><span class="p">):</span>
                        <span class="c1">### 2011/05/17 Strict the threshold, clean-up each cluster by nsigma clipping/flagging</span>
                        <span class="n">ValueList</span> <span class="o">=</span> <span class="n">distance</span><span class="p">[(</span><span class="n">category</span> <span class="o">==</span> <span class="n">Nc</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]]</span>
                        <span class="n">Stddev</span> <span class="o">=</span> <span class="n">ValueList</span><span class="o">.</span><span class="n">std</span><span class="p">()</span>
                        <span class="n">Threshold</span> <span class="o">=</span> <span class="n">ValueList</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span> <span class="o">+</span> <span class="n">Stddev</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsigma</span>
                        <span class="k">del</span> <span class="n">ValueList</span>
                        <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;Cluster Clipping Threshold = </span><span class="si">%s</span><span class="s1">, Stddev = </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">Threshold</span><span class="p">,</span> <span class="n">Stddev</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">((</span><span class="n">distance</span> <span class="o">*</span> <span class="p">(</span><span class="n">category</span> <span class="o">==</span> <span class="n">Nc</span><span class="p">))</span> <span class="o">&gt;</span> <span class="n">Threshold</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]:</span>
                            <span class="n">Region</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># set flag to 0</span>
                            <span class="n">Outlier</span> <span class="o">+=</span> <span class="mf">1.0</span>
                        <span class="c1"># Calculate Cluster Characteristics</span>
                        <span class="n">MaxDistance</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">distance</span> <span class="o">*</span> <span class="p">((</span><span class="n">distance</span> <span class="o">&lt;</span> <span class="n">Threshold</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">category</span> <span class="o">==</span> <span class="n">Nc</span><span class="p">)))</span>
                        <span class="n">indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">category</span><span class="p">))</span> <span class="k">if</span> <span class="n">category</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">==</span> <span class="n">Nc</span> <span class="ow">and</span> <span class="n">Region</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="mi">5</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span>
                        <span class="n">properties</span> <span class="o">=</span> <span class="n">Region2</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                        <span class="n">median_props</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">properties</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                        <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">median_props</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">median_props</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="kc">True</span><span class="p">,</span> <span class="n">MaxDistance</span><span class="p">])</span>
                    <span class="n">MemberRate</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Region</span><span class="p">)</span> <span class="o">-</span> <span class="n">Outlier</span><span class="p">)</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Region</span><span class="p">))</span>
                    <span class="n">MeanDistance</span> <span class="o">=</span> <span class="p">(</span><span class="n">distance</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Region</span><span class="p">))[</span><span class="mi">5</span><span class="p">])</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
                    <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;lines = </span><span class="si">%s</span><span class="s1">, MemberRate = </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">lines</span><span class="p">,</span> <span class="n">MemberRate</span><span class="p">)</span>

                    <span class="c1"># 2010/6/15 Plot the score along the number of the clusters</span>
                    <span class="n">ListNcluster</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Ncluster</span><span class="p">)</span>
                    <span class="n">Score</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">clustering_kmean_score</span><span class="p">(</span><span class="n">MeanDistance</span><span class="p">,</span> <span class="n">MedianWidth</span><span class="p">,</span> <span class="n">NclusterNew</span><span class="p">,</span> <span class="n">MemberRate</span><span class="p">)</span>
                    <span class="n">ListScore</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Score</span><span class="p">)</span>
                    <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;NclusterNew = </span><span class="si">%s</span><span class="s1">, Score = </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">NclusterNew</span><span class="p">,</span> <span class="n">Score</span><span class="p">)</span>

                    <span class="c1">### 2017/07/06 save Score to file for test</span>
                    <span class="k">if</span> <span class="n">infrastructure</span><span class="o">.</span><span class="n">logging</span><span class="o">.</span><span class="n">logging_level</span> <span class="o">==</span> <span class="n">infrastructure</span><span class="o">.</span><span class="n">logging</span><span class="o">.</span><span class="n">LOGGING_LEVELS</span><span class="p">[</span><span class="s1">&#39;trace&#39;</span><span class="p">]</span> <span class="ow">or</span> \
                       <span class="n">infrastructure</span><span class="o">.</span><span class="n">logging</span><span class="o">.</span><span class="n">logging_level</span> <span class="o">==</span> <span class="n">infrastructure</span><span class="o">.</span><span class="n">logging</span><span class="o">.</span><span class="n">LOGGING_LEVELS</span><span class="p">[</span><span class="s1">&#39;debug&#39;</span><span class="p">]:</span>
                        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;ClstProp.</span><span class="si">%s</span><span class="s1">.</span><span class="si">%02d</span><span class="s1">.txt&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">DebugOutName</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">DebugOutVer</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="s2">&quot;wa&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
                            <span class="n">fp</span><span class="o">.</span><span class="n">writelines</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%d</span><span class="s1">,</span><span class="si">%f</span><span class="s1">,</span><span class="si">%f</span><span class="s1">,</span><span class="si">%f</span><span class="s1">,</span><span class="si">%f</span><span class="s1">,</span><span class="si">%s</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">NclusterNew</span><span class="p">,</span> <span class="n">Score</span><span class="p">,</span> <span class="n">MeanDistance</span><span class="p">,</span> <span class="n">MedianWidth</span><span class="p">,</span>
                                                                   <span class="n">MemberRate</span><span class="p">,</span> <span class="n">lines</span><span class="p">))</span>

                    <span class="k">if</span> <span class="n">BestScore</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">Score</span> <span class="o">&lt;</span> <span class="n">BestScore</span><span class="p">:</span>
                        <span class="n">BestNcluster</span> <span class="o">=</span> <span class="n">NclusterNew</span>
                        <span class="n">BestScore</span> <span class="o">=</span> <span class="n">Score</span>
                        <span class="n">BestCategory</span> <span class="o">=</span> <span class="n">category</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                        <span class="n">BestCodebook</span> <span class="o">=</span> <span class="n">codebook</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                        <span class="n">BestRegion</span> <span class="o">=</span> <span class="n">Region</span><span class="p">[:]</span>
                        <span class="n">Bestlines</span> <span class="o">=</span> <span class="n">lines</span><span class="p">[:]</span>

            <span class="n">ListBestScore</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">ListScore</span><span class="p">[</span><span class="n">index0</span><span class="p">:]))</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Ncluster = </span><span class="si">%s</span><span class="s1">, BestScore = </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">NclusterNew</span><span class="p">,</span> <span class="n">ListBestScore</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="c1"># iteration end if Score(N) &lt; Score(N+1),Score(N+2),Score(N+3)</span>
            <span class="c1">#if len(ListBestScore) &gt; 3 and \</span>
            <span class="c1">#   ListBestScore[-4] &lt;= ListBestScore[-3] and \</span>
            <span class="c1">#   ListBestScore[-4] &lt;= ListBestScore[-2] and \</span>
            <span class="c1">#   ListBestScore[-4] &lt;= ListBestScore[-1]:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ListBestScore</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">10</span><span class="p">:</span>
                <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Determined the Number of Clusters to be </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">BestNcluster</span><span class="p">)</span>
                <span class="n">converged</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">break</span>

        <span class="k">if</span> <span class="n">converged</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Clustering analysis not converged. Number of clusters may be greater than upper limit&#39;</span>
                        <span class="s1">&#39; (MaxCluster=</span><span class="si">%s</span><span class="s1">)&#39;</span><span class="p">,</span> <span class="n">MaxCluster</span><span class="p">)</span>

        <span class="n">cluster_info</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;algorithm&#39;</span><span class="p">:</span> <span class="s1">&#39;kmean&#39;</span><span class="p">,</span>
            <span class="s1">&#39;cluster_score&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">ListNcluster</span><span class="p">,</span> <span class="n">ListScore</span><span class="p">],</span>
            <span class="s1">&#39;detected_lines&#39;</span><span class="p">:</span> <span class="n">Region2</span><span class="p">,</span>
            <span class="s1">&#39;cluster_property&#39;</span><span class="p">:</span> <span class="n">Bestlines</span><span class="p">,</span>  <span class="c1"># [[Center, Width/WHITEN, T/F, ClusterRadius],[],,,[]]</span>
            <span class="s1">&#39;cluster_scale&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">CLUSTER_WHITEN</span>
        <span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_merge_cluster_info</span><span class="p">(</span><span class="o">**</span><span class="n">cluster_info</span><span class="p">)</span>
        <span class="c1">#SDP.ShowClusterScore(ListNcluster, ListScore, ShowPlot, FigFileDir, FigFileRoot)</span>
        <span class="c1">#SDP.ShowClusterInchannelSpace(Region2, Bestlines, self.CLUSTER_WHITEN, ShowPlot, FigFileDir, FigFileRoot)</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Final: Ncluster = </span><span class="si">%s</span><span class="s1">, Score = </span><span class="si">%s</span><span class="s1">, lines = </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">BestNcluster</span><span class="p">,</span> <span class="n">BestScore</span><span class="p">,</span> <span class="n">Bestlines</span><span class="p">)</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Category = </span><span class="si">%s</span><span class="s1">, CodeBook = </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">category</span><span class="p">,</span> <span class="n">BestCodebook</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">BestNcluster</span><span class="p">,</span> <span class="n">Bestlines</span><span class="p">,</span> <span class="n">BestCategory</span><span class="p">,</span> <span class="n">BestRegion</span><span class="p">)</span></div>


<div class="viewcode-block" id="ValidateLineRaster.clustering_hierarchy">
<a class="viewcode-back" href="../../../../../_autosummary/pipeline.hsd.tasks.baseline.validation.ValidateLineRaster.html#pipeline.hsd.tasks.baseline.validation.ValidateLineRaster.clustering_hierarchy">[docs]</a>
    <span class="k">def</span> <span class="nf">clustering_hierarchy</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">Region</span><span class="p">:</span> <span class="n">DetectedLineList</span><span class="p">,</span>
        <span class="n">Region2</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">nThreshold</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">3.0</span><span class="p">,</span>
        <span class="n">nThreshold2</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">4.5</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;single&#39;</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ClusteringResult</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Perform hierarchical clustering analysis on detected lines.</span>

<span class="sd">        Perform hierarchical clustering analysis that is a &quot;bottom-up&quot;</span>
<span class="sd">        approach to configure the clusters that best represents the</span>
<span class="sd">        distribution of the detected line properties. It starts with</span>
<span class="sd">        the small clusters and combine them until certain condition</span>
<span class="sd">        is met.</span>

<span class="sd">        method = &#39;ward&#39;    : Ward&#39;s linkage method</span>
<span class="sd">                 &#39;single&#39;  : nearest point linkage method</span>
<span class="sd">                 &#39;complete&#39;: farthest point linkage method</span>
<span class="sd">                 &#39;average&#39; : average linkage method</span>
<span class="sd">                 &#39;centroid&#39;: centroid/UPGMC linkage method</span>
<span class="sd">                 &#39;median&#39;  : median/WPGMC linkage method</span>
<span class="sd">        1st threshold is set to nThreshold x stddev(distance matrix)</span>
<span class="sd">        2nd threshold is set to nThreshold2 x stddev of sub-cluster distance matrix</span>
<span class="sd">        in:</span>
<span class="sd">            self.Data -&gt; Region2</span>
<span class="sd">            self.Ndata</span>
<span class="sd">        out:</span>
<span class="sd">            self.Threshold</span>
<span class="sd">            self.Nthreshold</span>
<span class="sd">            self.Category</span>
<span class="sd">            self.Ncluster</span>

<span class="sd">        Args:</span>
<span class="sd">            Region: List of line properties with associated spatial coordinate.</span>
<span class="sd">                    Format is as follows.</span>

<span class="sd">                [[row, chan0, chan1, RA, DEC, flag, Binning],[],[],,,[]]</span>

<span class="sd">            Region2: List of line properties (line width and line center)</span>
<span class="sd">                     for each data. Format is as follows.</span>

<span class="sd">                [[Width, Center],[],[],,,[]]</span>
<span class="sd">            nThreshold: Threshold factor for the hierarchical clustering analysis.</span>
<span class="sd">                        It is used as a multiplicative factor for stddev of</span>
<span class="sd">                        initial distance matrix.</span>
<span class="sd">            nThreshold2: Another threshold factor for the hierarchical clustering analysis.</span>
<span class="sd">                        It is used as a multiplicative factor for stddev of</span>
<span class="sd">                        sub-cluster distance matrix.</span>
<span class="sd">            method: Method name for linkage method of the hierarchical clustering analysis.</span>

<span class="sd">        Returns:</span>
<span class="sd">            4-tuple representing clustering results, number of clusters,</span>
<span class="sd">            list of cluster properties (Center, Width/WHITEN, T/F, ClusterRadius),</span>
<span class="sd">            List of category indices indicating which lines belong to what</span>
<span class="sd">            cluster, and list of line properties with associated spatial</span>
<span class="sd">            coordinate (which is same format as Region).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_data</span><span class="p">(</span><span class="n">Region2</span><span class="p">,</span> <span class="n">ordering</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>  <span class="c1"># Data: numpy[[width, center],[w,c],,,]</span>
        <span class="n">Repeat</span> <span class="o">=</span> <span class="mi">3</span>  <span class="c1"># Number of artificial detection points to normalize the cluster distance</span>
        <span class="c1"># Calculate LinkMatrix from given data set</span>
        <span class="k">if</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;single&#39;</span><span class="p">:</span> <span class="c1"># nearest point linkage method</span>
            <span class="n">H_Clustering</span> <span class="o">=</span> <span class="n">HIERARCHY</span><span class="o">.</span><span class="n">single</span>
        <span class="k">elif</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;complete&#39;</span><span class="p">:</span> <span class="c1"># farthest point linkage method</span>
            <span class="n">H_Clustering</span> <span class="o">=</span> <span class="n">HIERARCHY</span><span class="o">.</span><span class="n">complete</span>
        <span class="k">elif</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;average&#39;</span><span class="p">:</span> <span class="c1"># average linkage method</span>
            <span class="n">H_Clustering</span> <span class="o">=</span> <span class="n">HIERARCHY</span><span class="o">.</span><span class="n">average</span>
        <span class="k">elif</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;centroid&#39;</span><span class="p">:</span> <span class="c1"># centroid/UPGMC linkage method</span>
            <span class="n">H_Clustering</span> <span class="o">=</span> <span class="n">HIERARCHY</span><span class="o">.</span><span class="n">centroid</span>
        <span class="k">elif</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;median&#39;</span><span class="p">:</span> <span class="c1"># median/WPGMC linkage method</span>
            <span class="n">H_Clustering</span> <span class="o">=</span> <span class="n">HIERARCHY</span><span class="o">.</span><span class="n">median</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1"># Ward&#39;s linkage method: default</span>
            <span class="n">H_Clustering</span> <span class="o">=</span> <span class="n">HIERARCHY</span><span class="o">.</span><span class="n">ward</span>
        <span class="c1"># temporaly add artificial detection points to normalize the cluster distance</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">Data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">Repeat</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="n">Data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="nb">float</span><span class="p">)</span>
        <span class="n">tmp</span><span class="p">[</span><span class="n">Repeat</span><span class="o">*</span><span class="mi">2</span><span class="p">:]</span> <span class="o">=</span> <span class="n">Data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Repeat</span><span class="p">):</span>
            <span class="n">tmp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">nchan</span><span class="o">//</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">tmp</span><span class="p">[</span><span class="n">Repeat</span><span class="o">+</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">nchan</span><span class="o">//</span><span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nchan</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1">#LOG.debug(&#39;tmp[:10] = {}&#39;, tmp[:10])</span>
        <span class="n">tmpLinkMatrix</span> <span class="o">=</span> <span class="n">H_Clustering</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>
        <span class="n">MedianDistance</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">tmpLinkMatrix</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">MeanDistance</span> <span class="o">=</span> <span class="n">tmpLinkMatrix</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="n">Stddev</span> <span class="o">=</span> <span class="n">tmpLinkMatrix</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">std</span><span class="p">()</span>
        <span class="k">del</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">tmpLinkMatrix</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;MedianDistance = </span><span class="si">%s</span><span class="s1">, MeanDistance = </span><span class="si">%s</span><span class="s1">, Stddev = </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">MedianDistance</span><span class="p">,</span> <span class="n">MeanDistance</span><span class="p">,</span> <span class="n">Stddev</span><span class="p">)</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Ndata = </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">Data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="c1"># Divide data set into several clusters</span>
        <span class="c1"># LinkMatrix[n][2]: distance between two data/clusters</span>
        <span class="c1"># 1st classification</span>
        <span class="n">LinkMatrix</span> <span class="o">=</span> <span class="n">H_Clustering</span><span class="p">(</span><span class="n">Data</span><span class="p">)</span>
        <span class="c1">#MedianDistance = numpy.median(LinkMatrix.T[2])</span>
        <span class="c1">#Stddev = LinkMatrix.T[2].std()</span>
        <span class="n">Nthreshold</span> <span class="o">=</span> <span class="n">nThreshold</span>
        <span class="c1">#Threshold = MedianDistance + Nthreshold * Stddev</span>
        <span class="n">Threshold</span> <span class="o">=</span> <span class="n">MeanDistance</span> <span class="o">+</span> <span class="n">Nthreshold</span> <span class="o">*</span> <span class="n">Stddev</span>
        <span class="n">Category</span> <span class="o">=</span> <span class="n">HIERARCHY</span><span class="o">.</span><span class="n">fcluster</span><span class="p">(</span><span class="n">LinkMatrix</span><span class="p">,</span> <span class="n">Threshold</span><span class="p">,</span> <span class="n">criterion</span><span class="o">=</span><span class="s1">&#39;distance&#39;</span><span class="p">)</span>
        <span class="n">Ncluster</span> <span class="o">=</span> <span class="n">Category</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;nThreshold = </span><span class="si">%s</span><span class="s1">, nThreshold2 = </span><span class="si">%s</span><span class="s1">, method = </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">nThreshold</span><span class="p">,</span> <span class="n">nThreshold2</span><span class="p">,</span> <span class="n">method</span><span class="p">)</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Init Threshold = </span><span class="si">%s</span><span class="s1">, Init Ncluster = </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">Threshold</span><span class="p">,</span> <span class="n">Ncluster</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Init Threshold: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">Threshold</span><span class="p">),</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">Init Ncluster: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">Ncluster</span><span class="p">))</span>

        <span class="n">IDX</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Data</span><span class="p">))])</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Ncluster</span><span class="p">):</span>
            <span class="n">C</span> <span class="o">=</span> <span class="n">Category</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
            <span class="n">NewData</span> <span class="o">=</span> <span class="n">Data</span><span class="p">[</span><span class="n">Category</span><span class="o">==</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span> <span class="c1"># Category starts with 1 (not 0)</span>
            <span class="k">if</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">NewData</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;skip(</span><span class="si">%d</span><span class="s1">): </span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">NewData</span><span class="p">)))</span>
                <span class="k">continue</span> <span class="c1"># LinkMatrix = ()</span>
            <span class="n">NewIDX</span> <span class="o">=</span> <span class="n">IDX</span><span class="p">[</span><span class="n">Category</span><span class="o">==</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
            <span class="n">LinkMatrix</span> <span class="o">=</span> <span class="n">H_Clustering</span><span class="p">(</span><span class="n">NewData</span><span class="p">)</span> <span class="c1"># selected linkage method</span>
            <span class="c1">#print LinkMatrix</span>
            <span class="n">MedianDistance</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">LinkMatrix</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">MeanDistance</span> <span class="o">=</span> <span class="n">LinkMatrix</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
            <span class="c1">#print &#39;MedianD&#39;, MedianDistance</span>
            <span class="n">Stddev</span> <span class="o">=</span> <span class="n">LinkMatrix</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">std</span><span class="p">()</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;MedianDistance = </span><span class="si">%s</span><span class="s1">, MeanDistance = </span><span class="si">%s</span><span class="s1">, Stddev = </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">MedianDistance</span><span class="p">,</span> <span class="n">MeanDistance</span><span class="p">,</span> <span class="n">Stddev</span><span class="p">)</span>
            <span class="n">NewThreshold</span> <span class="o">=</span> <span class="n">MeanDistance</span> <span class="o">+</span> <span class="n">nThreshold2</span> <span class="o">*</span> <span class="n">Stddev</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Threshold(</span><span class="si">%s</span><span class="s1">): </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">NewThreshold</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Threshold(</span><span class="si">%d</span><span class="s1">): </span><span class="si">%.1f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">NewThreshold</span><span class="p">),</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
            <span class="n">NewCategory</span> <span class="o">=</span> <span class="n">HIERARCHY</span><span class="o">.</span><span class="n">fcluster</span><span class="p">(</span><span class="n">LinkMatrix</span><span class="p">,</span> <span class="n">NewThreshold</span><span class="p">,</span> <span class="n">criterion</span><span class="o">=</span><span class="s1">&#39;distance&#39;</span><span class="p">)</span>
            <span class="n">NewNcluster</span> <span class="o">=</span> <span class="n">NewCategory</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;NewCluster(</span><span class="si">%s</span><span class="s1">): </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">NewNcluster</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">NewNcluster(</span><span class="si">%d</span><span class="s1">): </span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">NewNcluster</span><span class="p">),</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1"># of Members(</span><span class="si">%d</span><span class="s1">): </span><span class="si">%d</span><span class="s1">: &#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="p">((</span><span class="n">Category</span> <span class="o">==</span> <span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()),</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">kk</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">NewNcluster</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(((</span><span class="n">NewCategory</span> <span class="o">==</span> <span class="n">kk</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">NewNcluster</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">NewData</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="n">NewCategory</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">Category</span><span class="p">[</span><span class="n">NewIDX</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">C</span> <span class="o">+</span> <span class="n">NewCategory</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">Ncluster</span> <span class="o">=</span> <span class="n">Category</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="c1"># update Ncluster</span>

        <span class="p">(</span><span class="n">Region</span><span class="p">,</span> <span class="n">Range</span><span class="p">,</span> <span class="n">Stdev</span><span class="p">,</span> <span class="n">Category</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">clean_cluster</span><span class="p">(</span><span class="n">Data</span><span class="p">,</span> <span class="n">Category</span><span class="p">,</span> <span class="n">Region</span><span class="p">,</span> <span class="n">nThreshold2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="c1"># nThreshold, NumParam</span>
        <span class="c1"># 2017/7/25 ReNumbering is done in clean_cluster</span>
        <span class="c1">#for i in range(len(Category)):</span>
        <span class="c1">#    #if Category[i] &gt; Ncluster: Region[i][5] = 0 # flag out cleaned data</span>
        <span class="c1">#    Category[i] -= 1 # Category starts with 1 -&gt; starts with 0 (to align kmean)</span>
        <span class="n">Bestlines</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">Ncluster</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Range</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Ncluster</span><span class="p">):</span>
            <span class="n">Bestlines</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">Range</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">Range</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="kc">True</span><span class="p">,</span> <span class="n">Range</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">4</span><span class="p">]])</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Final: Ncluster = </span><span class="si">%s</span><span class="s1">, lines = </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">Ncluster</span><span class="p">,</span> <span class="n">Bestlines</span><span class="p">)</span>

        <span class="n">cluster_info</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;algorithm&#39;</span><span class="p">:</span> <span class="s1">&#39;hierarchy&#39;</span><span class="p">,</span>
            <span class="s1">&#39;cluster_score&#39;</span><span class="p">:</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]],</span>
            <span class="s1">&#39;detected_lines&#39;</span><span class="p">:</span> <span class="n">Region2</span><span class="p">,</span>
            <span class="s1">&#39;cluster_property&#39;</span><span class="p">:</span> <span class="n">Bestlines</span><span class="p">,</span>  <span class="c1"># [[Center, Width, T/F, ClusterRadius],[],,,[]]</span>
            <span class="s1">&#39;cluster_scale&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">CLUSTER_WHITEN</span>
        <span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_merge_cluster_info</span><span class="p">(</span><span class="o">**</span><span class="n">cluster_info</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">Ncluster</span><span class="p">,</span> <span class="n">Bestlines</span><span class="p">,</span> <span class="n">Category</span><span class="p">,</span> <span class="n">Region</span><span class="p">)</span></div>


<div class="viewcode-block" id="ValidateLineRaster.set_data">
<a class="viewcode-back" href="../../../../../_autosummary/pipeline.hsd.tasks.baseline.validation.ValidateLineRaster.html#pipeline.hsd.tasks.baseline.validation.ValidateLineRaster.set_data">[docs]</a>
    <span class="k">def</span> <span class="nf">set_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Observation</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">ordering</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="s1">&#39;none&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Transpose axes of two-dimensional array data.</span>

<span class="sd">        Observation: numpy.array([[val1, val2, val3,..,valN],</span>
<span class="sd">                                  [val1, val2, val3,..,valN],</span>
<span class="sd">                                   ........................</span>
<span class="sd">                                  [val1, val2, val3,..,valN]], float)</span>
<span class="sd">        where N is a max dimensions of parameter space</span>
<span class="sd">            ordering: &#39;none&#39; or list of ordering of columns</span>
<span class="sd">              e.g., ordering=[2,3,1,0] =&gt; [col3,col2,col0,col1]</span>

<span class="sd">        self.Data: Observation data</span>
<span class="sd">        self.NumParam: Number of dimensions to be used for Clustering Analysis</span>
<span class="sd">        self.Factor: Set default Whitening factor (to be 1.0)</span>

<span class="sd">        Args:</span>
<span class="sd">            Observation: Two-dimensional array data</span>
<span class="sd">            ordering: Axis order for output array</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: Given array is not two-dimensional</span>

<span class="sd">        Returns:</span>
<span class="sd">            Transposed array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ordering</span> <span class="o">!=</span> <span class="s1">&#39;none&#39;</span><span class="p">:</span>
            <span class="n">NumParam</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ordering</span><span class="p">)</span>
            <span class="n">OrderList</span> <span class="o">=</span> <span class="n">ordering</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">NumParam</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Observation</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">OrderList</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">NumParam</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">Observation</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">Obs</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Observation</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Obs</span> <span class="o">=</span> <span class="n">Observation</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">Obs</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">Data</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">Obs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">NumParam</span><span class="p">),</span> <span class="nb">float</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Obs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">NumParam</span><span class="p">):</span>
                    <span class="n">Data</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">Obs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">OrderList</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span>
            <span class="n">Factor</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">NumParam</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
            <span class="n">Ndata</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Data</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Data should be 2-dimensional. </span><span class="si">{}</span><span class="s2">-dimensional data was given&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Obs</span><span class="o">.</span><span class="n">shape</span><span class="p">)))</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Data should be 2-dimensional!&#39;</span><span class="p">)</span>
        <span class="k">del</span> <span class="n">Obs</span><span class="p">,</span> <span class="n">OrderList</span>
        <span class="k">return</span> <span class="n">Data</span></div>


<div class="viewcode-block" id="ValidateLineRaster.clean_cluster">
<a class="viewcode-back" href="../../../../../_autosummary/pipeline.hsd.tasks.baseline.validation.ValidateLineRaster.html#pipeline.hsd.tasks.baseline.validation.ValidateLineRaster.clean_cluster">[docs]</a>
    <span class="k">def</span> <span class="nf">clean_cluster</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                      <span class="n">Data</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                      <span class="n">Category</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
                      <span class="n">Region</span><span class="p">:</span> <span class="n">DetectedLineList</span><span class="p">,</span>
                      <span class="n">Nthreshold</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
                      <span class="n">NumParam</span><span class="p">:</span> <span class="nb">int</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]],</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Clean-up cluster by eliminating outliers.</span>

<span class="sd">         Radius = StandardDeviation * nThreshold (circle/sphere)</span>

<span class="sd">        Args:</span>
<span class="sd">            Data: List of cluster properties with associated spatial coordinate.</span>
<span class="sd">            Category: Input category list representing membership information</span>
<span class="sd">            Region: List of line properties with associated spatial coordinate.</span>
<span class="sd">                    Format is as follows.</span>

<span class="sd">                [[row, chan0, chan1, RA, DEC, flag, Binning],[],[],,,[]]</span>

<span class="sd">            Nthreshold: Threshold factor for detecting outlier</span>
<span class="sd">            NumParam: Number of cluster properties</span>

<span class="sd">        Returns:</span>
<span class="sd">            4-tuple of the following values.</span>
<span class="sd">                Region: flag information is added</span>
<span class="sd">                Range: Range[Ncluster][5]: [ClusterCenterX, ClusterCenterY, 0, 0, Threshold]</span>
<span class="sd">                Stdev: Stdev[Ncluster][5]: [ClusterStddevX, ClusterStddevY, 0, 0, 0]</span>
<span class="sd">                Category: renumbered category</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">IDX</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Data</span><span class="p">))])</span>
        <span class="n">Ncluster</span> <span class="o">=</span> <span class="n">Category</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="n">C</span> <span class="o">=</span> <span class="n">Ncluster</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">ValidClusterID</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">ValidRange</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">ValidStdev</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">ReNumber</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">Range</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">C</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="nb">float</span><span class="p">)</span>
        <span class="n">Stdev</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">C</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="nb">float</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Ncluster</span><span class="p">):</span>
            <span class="n">NewData</span> <span class="o">=</span> <span class="n">Data</span><span class="p">[</span><span class="n">Category</span> <span class="o">==</span> <span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>
            <span class="n">NewIDX</span> <span class="o">=</span> <span class="n">IDX</span><span class="p">[</span><span class="n">Category</span> <span class="o">==</span> <span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">NumParam</span><span class="p">):</span>
                <span class="n">Range</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">NewData</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
                <span class="n">Stdev</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">NewData</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">std</span><span class="p">()</span>
            <span class="k">if</span><span class="p">(</span><span class="n">NumParam</span> <span class="o">==</span> <span class="mi">4</span><span class="p">):</span>
                <span class="n">Tmp</span> <span class="o">=</span> <span class="p">((</span><span class="n">NewData</span> <span class="o">-</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">Range</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="mi">0</span><span class="p">]],</span> <span class="p">[</span><span class="n">Range</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="mi">1</span><span class="p">]],</span> <span class="p">[</span><span class="n">Range</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="mi">2</span><span class="p">]],</span> <span class="p">[</span><span class="n">Range</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="mi">3</span><span class="p">]]]))</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span>
            <span class="k">elif</span><span class="p">(</span><span class="n">NumParam</span> <span class="o">==</span> <span class="mi">3</span><span class="p">):</span>
                <span class="n">Tmp</span> <span class="o">=</span> <span class="p">((</span><span class="n">NewData</span> <span class="o">-</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">Range</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="mi">0</span><span class="p">]],</span> <span class="p">[</span><span class="n">Range</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="mi">1</span><span class="p">]],</span> <span class="p">[</span><span class="n">Range</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="mi">2</span><span class="p">]]]))</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span>
            <span class="k">else</span><span class="p">:</span> <span class="c1"># NumParam == 2</span>
                <span class="n">Tmp</span> <span class="o">=</span> <span class="p">((</span><span class="n">NewData</span> <span class="o">-</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">Range</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="mi">0</span><span class="p">]],</span> <span class="p">[</span><span class="n">Range</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="mi">1</span><span class="p">]]]))</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span>
            <span class="n">Threshold</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">Tmp</span><span class="p">)</span> <span class="o">+</span> <span class="n">Tmp</span><span class="o">.</span><span class="n">std</span><span class="p">()</span> <span class="o">*</span> <span class="n">Nthreshold</span>
            <span class="c1">#Threshold = Tmp.mean() + Tmp.std() * Nthreshold</span>
            <span class="n">Range</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">Threshold</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;Threshold(</span><span class="si">%s</span><span class="s1">) = </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">Threshold</span><span class="p">)</span>
            <span class="n">Out</span> <span class="o">=</span> <span class="n">NewIDX</span><span class="p">[</span><span class="n">Tmp</span> <span class="o">&gt;</span> <span class="n">Threshold</span><span class="p">]</span>
            <span class="c1">#if (len(NewIDX) - len(Out)) &lt; 6: # max 3 detections for each binning: detected in two binning pattern</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">NewIDX</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">Out</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span> <span class="c1"># max 3 detections for each binning: detected in at least one binning pattern: sensitive to very narrow lines</span>
                <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;Non Cluster: </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">NewIDX</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">NewIDX</span><span class="p">:</span>
                    <span class="c1">#self.Category[i] = C</span>
                    <span class="n">Region</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">ReNumber</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">continue</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;Out Of Cluster (</span><span class="si">%s</span><span class="s1">): </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">Out</span><span class="p">))</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">Out</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">Out</span><span class="p">:</span>
                    <span class="c1">#Category[i] = C</span>
                    <span class="n">Region</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">ReNumber</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ValidClusterID</span><span class="p">)</span>
            <span class="n">ValidClusterID</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">ValidClusterID</span><span class="p">:</span>
            <span class="n">ValidRange</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Range</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
            <span class="n">ValidStdev</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Stdev</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;ReNumbering Table: </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">ReNumber</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Category</span><span class="p">)):</span> <span class="n">Category</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">ReNumber</span><span class="p">[</span><span class="n">Category</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span>
        <span class="c1">#return (Region, Range, Stdev)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">Region</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ValidRange</span><span class="p">),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ValidStdev</span><span class="p">),</span> <span class="n">Category</span><span class="p">)</span></div>


<div class="viewcode-block" id="ValidateLineRaster.clustering_kmean_score">
<a class="viewcode-back" href="../../../../../_autosummary/pipeline.hsd.tasks.baseline.validation.ValidateLineRaster.html#pipeline.hsd.tasks.baseline.validation.ValidateLineRaster.clustering_kmean_score">[docs]</a>
    <span class="k">def</span> <span class="nf">clustering_kmean_score</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">MeanDistance</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">MedianWidth</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">Ncluster</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">MemberRate</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute score of the clusters.</span>

<span class="sd">        Args:</span>
<span class="sd">            MeanDistance: Mean distance from the center of the cluster</span>
<span class="sd">            MedianWidth: Median value of the line width</span>
<span class="sd">            Ncluster: Number of clusters</span>
<span class="sd">            MemberRate: Fraction of the members that belong to any cluster</span>

<span class="sd">        Returns:</span>
<span class="sd">            Score of the cluster</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Rating</span>
        <span class="c1">### 2011/05/12 modified for (distance==0)</span>
        <span class="c1">### 2014/11/28 further modified for (distance==0)</span>
        <span class="c1">### 2017/07/05 modified to be sensitive to MemberRate</span>
        <span class="c1"># (distance * numpy.transpose(Region[5])).mean(): average distance from each cluster center</span>
        <span class="k">return</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">MeanDistance</span><span class="o">**</span><span class="mf">2.0</span> <span class="o">+</span> <span class="p">(</span><span class="n">MedianWidth</span><span class="o">/</span><span class="mf">2.0</span><span class="p">)</span><span class="o">**</span><span class="mf">2.0</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">Ncluster</span><span class="o">+</span> <span class="mf">1.0</span><span class="o">/</span><span class="n">Ncluster</span><span class="p">)</span> <span class="o">*</span> <span class="p">((</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">MemberRate</span><span class="p">)</span> <span class="o">*</span> <span class="mf">100.0</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">))</span></div>


<div class="viewcode-block" id="ValidateLineRaster.detection_stage">
<a class="viewcode-back" href="../../../../../_autosummary/pipeline.hsd.tasks.baseline.validation.ValidateLineRaster.html#pipeline.hsd.tasks.baseline.validation.ValidateLineRaster.detection_stage">[docs]</a>
    <span class="k">def</span> <span class="nf">detection_stage</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">Ncluster</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">nra</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">ndec</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">ra0</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">dec0</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">grid_ra</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">grid_dec</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">category</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
        <span class="n">Region</span><span class="p">:</span> <span class="n">DetectedLineList</span><span class="p">,</span>
        <span class="n">detect_signal</span><span class="p">:</span> <span class="nb">dict</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Classify cluster members by their location on celestial coordinate.</span>

<span class="sd">        This method implements the first phase of cluster validation process,</span>
<span class="sd">        and is so-called &quot;Detection Stage&quot;. It combines clustering analysis</span>
<span class="sd">        result with spatial information of each detected line, and classify</span>
<span class="sd">        cluster members by their location on celestial coordinate.</span>

<span class="sd">        Args:</span>
<span class="sd">            Ncluster: Number of clusters</span>
<span class="sd">            nra: Number of horizontal grids on the sky</span>
<span class="sd">            ndec: Number of vertical grids on the sky</span>
<span class="sd">            grid_ra: Physical size of the horizontal grid in degree</span>
<span class="sd">            grid_dec: Physical size of the vertical grid in degree</span>
<span class="sd">            category: List of cluster membership indices</span>
<span class="sd">            Region: List of line properties with associated spatial coordinate.</span>
<span class="sd">                    Format is as follows.</span>

<span class="sd">                [[row, chan0, chan1, RA, DEC, flag, Binning],[],[],,,[]]</span>

<span class="sd">            detect_signal: List of detected lines per spatial position. Its format is</span>
<span class="sd">                           as follows.</span>

<span class="sd">                detect_signal = {</span>
<span class="sd">                    ID1: [RA, DEC, [[LineStartChannel1, LineEndChannel1],</span>
<span class="sd">                                    [LineStartChannel2, LineEndChannel2],</span>
<span class="sd">                                    ...,</span>
<span class="sd">                                    [LineStartChannelN, LineEndChannelN]]],</span>
<span class="sd">                    IDn: [RA, DEC, [[LineStartChannel1, LineEndChannel1],</span>
<span class="sd">                                    ...,</span>
<span class="sd">                                    [LineStartChannelN, LineEndChannelN]]]</span>
<span class="sd">                }</span>

<span class="sd">        Returns:</span>
<span class="sd">            3-tuple of the following numpy arrays.</span>

<span class="sd">                - Three dimensional array representing spatial distribution of</span>
<span class="sd">                  each cluster detected by the clustering analysis.</span>
<span class="sd">                - Number of spectra at each grid position. Value of the array ranges</span>
<span class="sd">                  from 0 to 3 (either of 0, 1, 2, 3) but usually it is 3.</span>
<span class="sd">                - array data for plotting clustering analysis results for detection stage</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Create Grid Parameter Space (Ncluster * nra * ndec)</span>
        <span class="n">MinChanBinSp</span> <span class="o">=</span> <span class="mf">50.0</span>
        <span class="n">BinningVariation</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nchan</span><span class="o">/</span><span class="n">MinChanBinSp</span><span class="p">)</span><span class="o">/</span><span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">4</span><span class="p">)))</span>
        <span class="n">GridClusterWithBinning</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">Ncluster</span><span class="p">,</span> <span class="n">BinningVariation</span><span class="p">,</span> <span class="n">nra</span><span class="p">,</span> <span class="n">ndec</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="c1">#GridCluster = numpy.zeros((Ncluster, nra, ndec), dtype=numpy.float32)</span>
        <span class="n">GridMember</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nra</span><span class="p">,</span> <span class="n">ndec</span><span class="p">))</span>

        <span class="c1"># Set the number of spectra belong to each gridding positions</span>
        <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">detect_signal</span><span class="p">)):</span>
            <span class="n">GridMember</span><span class="p">[</span><span class="nb">int</span><span class="p">((</span><span class="n">detect_signal</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">ra0</span><span class="p">)</span><span class="o">/</span><span class="n">grid_ra</span><span class="p">)][</span><span class="nb">int</span><span class="p">((</span><span class="n">detect_signal</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">dec0</span><span class="p">)</span><span class="o">/</span><span class="n">grid_dec</span><span class="p">)]</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">category</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">Region</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">5</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="c1"># valid spectrum</span>
                <span class="c1"># binning = 4**n</span>
                <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">Region</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">6</span><span class="p">])</span><span class="o">/</span><span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">4.</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.1</span><span class="p">)</span>
                <span class="c1"># if binning larger than 1, detection is done twice: m=&gt;0.5</span>
                <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="n">m</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="c1"># case binning=1</span>
                <span class="k">else</span><span class="p">:</span> <span class="n">m</span> <span class="o">=</span> <span class="mf">0.5</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="c1">#2014/11/28 Counting is done for each binning separately</span>
                    <span class="n">GridClusterWithBinning</span><span class="p">[</span><span class="n">category</span><span class="p">[</span><span class="n">i</span><span class="p">]][</span><span class="n">n</span><span class="p">][</span><span class="nb">int</span><span class="p">((</span><span class="n">Region</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="n">ra0</span><span class="p">)</span><span class="o">/</span><span class="n">grid_ra</span><span class="p">)][</span><span class="nb">int</span><span class="p">((</span><span class="n">Region</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">4</span><span class="p">]</span> <span class="o">-</span> <span class="n">dec0</span><span class="p">)</span><span class="o">/</span><span class="n">grid_dec</span><span class="p">)]</span> <span class="o">+=</span> <span class="n">m</span>
                    <span class="c1">#GridCluster[category[i]][int((Region[i][3] - ra0)/grid_ra)][int((Region[i][4] - dec0)/grid_dec)] += 1.0</span>
                <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                    <span class="k">pass</span>
        <span class="n">GridCluster</span> <span class="o">=</span> <span class="n">GridClusterWithBinning</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;GridClusterWithBinning = </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">GridClusterWithBinning</span><span class="p">)</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;GridCluster = </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">GridCluster</span><span class="p">)</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;GridMember = </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">GridMember</span><span class="p">)</span>
        <span class="k">del</span> <span class="n">GridClusterWithBinning</span>
        <span class="c1"># 2013/05/29 TN</span>
        <span class="c1"># cluster_flag is data for plotting clustering analysis results.</span>
        <span class="c1"># It stores GridCluster quantized by given thresholds.</span>
        <span class="c1"># it is defined as integer array and one digit is assigned to</span>
        <span class="c1"># one clustering stage in each integer value:</span>
        <span class="c1">#</span>
        <span class="c1">#     1st digit: detection</span>
        <span class="c1">#     2nd digit: validation</span>
        <span class="c1">#     3rd digit: smoothing</span>
        <span class="c1">#     4th digit: final</span>
        <span class="c1">#</span>
        <span class="c1"># If GridCluster value exceeds any threshold, corresponding</span>
        <span class="c1"># digit is incremented. For example, flag 3210 stands for,</span>
        <span class="c1">#</span>
        <span class="c1">#     value didn&#39;t exceed any thresholds in detection, and</span>
        <span class="c1">#     exceeded one (out of three) threshold in validation, and</span>
        <span class="c1">#     exceeded two (out of three) thresholds in smoothing, and</span>
        <span class="c1">#     exceeded three (out of four) thresholds in final.</span>
        <span class="c1">#</span>
        <span class="c1">#self.cluster_info[&#39;cluster_flag&#39;] = numpy.zeros(GridCluster.shape, dtype=numpy.uint16)</span>
        <span class="n">threshold</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">]</span>
        <span class="n">cluster_flag</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">GridCluster</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">uint16</span><span class="p">)</span>
        <span class="n">flag_digit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flag_digits</span><span class="p">[</span><span class="s1">&#39;detection&#39;</span><span class="p">]</span>
        <span class="n">cluster_flag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__update_cluster_flag</span><span class="p">(</span><span class="n">cluster_flag</span><span class="p">,</span> <span class="s1">&#39;detection&#39;</span><span class="p">,</span> <span class="n">GridCluster</span><span class="p">,</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">flag_digit</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">GridCluster</span><span class="p">,</span> <span class="n">GridMember</span><span class="p">,</span> <span class="n">cluster_flag</span><span class="p">)</span></div>


<div class="viewcode-block" id="ValidateLineRaster.validation_stage">
<a class="viewcode-back" href="../../../../../_autosummary/pipeline.hsd.tasks.baseline.validation.ValidateLineRaster.html#pipeline.hsd.tasks.baseline.validation.ValidateLineRaster.validation_stage">[docs]</a>
    <span class="k">def</span> <span class="nf">validation_stage</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">GridCluster</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">GridMember</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">lines</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]]],</span>
        <span class="n">cluster_flag</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]]],</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Validate clusters by their detection fraction on each grid.</span>

<span class="sd">        This method implements the second phase of cluster validation process,</span>
<span class="sd">        and is so-called &quot;Validation Stage&quot;. It sets validation flag based on</span>
<span class="sd">        the detection fraction on each grid.</span>

<span class="sd">        Cluster is validated if number of spectrum which contains feature belongs</span>
<span class="sd">        to the cluster is greater or equal to the half number of spectrum in the Grid.</span>
<span class="sd">        Normally, 3 spectra are created for each grid positions, therefore,</span>
<span class="sd">        GridMember[ra][dec] = 3 for most of the cases.</span>

<span class="sd">        Normalized validity can be</span>

<span class="sd">            - 1/3 (0.2&lt;V) -&gt; only one detection -&gt; Qestionable</span>
<span class="sd">            - 2/3 (0.5&lt;V)-&gt; two detections -&gt; Marginal</span>
<span class="sd">            - 3/3 (0.7&lt;V)-&gt; detected for all spectra -&gt; Valid</span>

<span class="sd">        Questionable lines are flagged.</span>

<span class="sd">        Args:</span>
<span class="sd">            GridCluster: Three dimensional array representing spatial distribution of</span>
<span class="sd">                         each cluster detected by the clustering analysis</span>
<span class="sd">            GridMember: Number of spectra at each grid position</span>
<span class="sd">            lines: List of line properties with validity flag</span>
<span class="sd">            cluster_flag: array data for plotting clustering analysis results</span>

<span class="sd">        Returns:</span>
<span class="sd">            4-tuple of the following arrays.</span>

<span class="sd">                - Updated GridCluster normalized by GridMember</span>
<span class="sd">                - Number of lines detected at each grid position (return GridMember as is)</span>
<span class="sd">                - List of line properties with updated validity flag (Questionable lines are</span>
<span class="sd">                  flagged out)</span>
<span class="sd">                - array data for plotting clustering analysis results for validation stage</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Validated if number of spectrum which contains feature belongs to the cluster is greater or equal to</span>
        <span class="c1"># the half number of spectrum in the Grid</span>
        <span class="c1"># Normally, 3 spectra are created for each grid positions,</span>
        <span class="c1"># therefore, gridmember[ra][dec] = 3 for most of the cases.</span>
        <span class="c1"># Normalized validity can be</span>
        <span class="c1"># 1/3 (0.2&lt;V) -&gt; only one detection -&gt; Qestionable</span>
        <span class="c1"># 2/3 (0.5&lt;V)-&gt; two detections -&gt; Marginal</span>
        <span class="c1"># 3/3 (0.7&lt;V)-&gt; detected for all spectra -&gt; Valid</span>
        <span class="c1"># ThresholdValid should be 0.5 -&gt; 0.7 in the future</span>

        <span class="p">(</span><span class="n">Ncluster</span><span class="p">,</span> <span class="n">nra</span><span class="p">,</span> <span class="n">ndec</span><span class="p">)</span> <span class="o">=</span> <span class="n">GridCluster</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">MinChanBinSp</span> <span class="o">=</span> <span class="mf">50.0</span>
        <span class="n">BinningVariation</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nchan</span><span class="o">/</span><span class="n">MinChanBinSp</span><span class="p">)</span><span class="o">/</span><span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">4</span><span class="p">)))</span>

        <span class="k">for</span> <span class="n">Nc</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Ncluster</span><span class="p">):</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;GridCluster[Nc]: </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">GridCluster</span><span class="p">[</span><span class="n">Nc</span><span class="p">])</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;Gridmember: </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">GridMember</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nra</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ndec</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">GridMember</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="n">GridCluster</span><span class="p">[</span><span class="n">Nc</span><span class="p">][</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
                    <span class="k">elif</span> <span class="n">GridMember</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">GridCluster</span><span class="p">[</span><span class="n">Nc</span><span class="p">][</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">0.9</span><span class="p">:</span>
                        <span class="n">GridCluster</span><span class="p">[</span><span class="n">Nc</span><span class="p">][</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
                    <span class="c1">### 2014/11/28 Binning valiation is taken into account in the previous stage</span>
                    <span class="c1"># normarize validity</span>
                    <span class="c1">#else: GridCluster[Nc][x][y] /= float(GridMember[x][y])</span>
                    <span class="k">else</span><span class="p">:</span> <span class="n">GridCluster</span><span class="p">[</span><span class="n">Nc</span><span class="p">][</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">GridCluster</span><span class="p">[</span><span class="n">Nc</span><span class="p">][</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">GridMember</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]),</span> <span class="mf">1.0</span><span class="p">)</span>

            <span class="k">if</span> <span class="p">((</span><span class="n">GridCluster</span><span class="p">[</span><span class="n">Nc</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">Questionable</span><span class="p">)</span><span class="o">*</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="n">lines</span><span class="p">[</span><span class="n">Nc</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="n">threshold</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">Valid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Marginal</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Questionable</span><span class="p">]</span>
        <span class="n">flag_digit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flag_digits</span><span class="p">[</span><span class="s1">&#39;validation&#39;</span><span class="p">]</span>
        <span class="n">cluster_flag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__update_cluster_flag</span><span class="p">(</span><span class="n">cluster_flag</span><span class="p">,</span> <span class="s1">&#39;validation&#39;</span><span class="p">,</span> <span class="n">GridCluster</span><span class="p">,</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">flag_digit</span><span class="p">)</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;GridCluster </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">GridCluster</span><span class="p">)</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;GridMember </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">GridMember</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">GridClusterValidation</span> <span class="o">=</span> <span class="n">GridCluster</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">GridCluster</span><span class="p">,</span> <span class="n">GridMember</span><span class="p">,</span> <span class="n">lines</span><span class="p">,</span> <span class="n">cluster_flag</span><span class="p">)</span></div>


<div class="viewcode-block" id="ValidateLineRaster.smoothing_stage">
<a class="viewcode-back" href="../../../../../_autosummary/pipeline.hsd.tasks.baseline.validation.ValidateLineRaster.html#pipeline.hsd.tasks.baseline.validation.ValidateLineRaster.smoothing_stage">[docs]</a>
    <span class="k">def</span> <span class="nf">smoothing_stage</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">GridCluster</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">lines</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]]],</span>
        <span class="n">cluster_flag</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]]],</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Smooth cluster distribution.</span>

<span class="sd">        This method implements the third phase of cluster validation process,</span>
<span class="sd">        and is so-called &quot;Smoothing Stage&quot;. It applies smoothing to spatial</span>
<span class="sd">        cluster distribution and update validity flag of detected lines</span>
<span class="sd">        according to the smoothed cluster distribution.</span>

<span class="sd">        Smoothing kernel is given by,</span>

<span class="sd">            6.0 if Dx=0 and Dy=0,</span>
<span class="sd">            1.0 / (Dx**2 + Dy**2) if abs(Dx) + abs(Dy) &lt; 4, and</span>
<span class="sd">            0 otherwise</span>

<span class="sd">        where Dx and Dy is distance from the center pixel. It looks like below.</span>

<span class="sd">            [ 0.0,  0.2, 0.25,  0.2,  0.0]</span>
<span class="sd">            [ 0.2,  0.5,  0.1,  0.5,  0.2]</span>
<span class="sd">            [0.25,  0.1,  6.0,  0.1, 0.25]</span>
<span class="sd">            [ 0.2,  0.5,  0.1,  0.5,  0.2]</span>
<span class="sd">            [ 0.0,  0.2, 0.25,  0.2,  0.0]</span>

<span class="sd">        Lines with too low detection value is flagged.</span>

<span class="sd">        Args:</span>
<span class="sd">            GridCluster: Three dimensional array representing spatial distribution of</span>
<span class="sd">                         each cluster detected by the clustering analysis</span>
<span class="sd">            lines: List of line properties with validity flag</span>
<span class="sd">            cluster_flag: array data for plotting clustering analysis results</span>

<span class="sd">        Returns:</span>
<span class="sd">            3-tuple of updated cluster information.</span>

<span class="sd">              - Smoothed GridCluster</span>
<span class="sd">              - List of line properties with updated validity flag</span>
<span class="sd">              - Updated cluster_flag (flags for smoothing stage is appended)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Rating:  [0.0, 0.4, 0.5, 0.4, 0.0]</span>
        <span class="c1">#          [0.4, 0.7, 1.0, 0.7, 0.4]</span>
        <span class="c1">#          [0.5, 1.0, 6.0, 1.0, 0.5]</span>
        <span class="c1">#          [0.4, 0.7, 1.0, 0.7, 0.4]</span>
        <span class="c1">#          [0.0, 0.4, 0.5, 0.4, 0.0]</span>
        <span class="c1"># Rating = 1.0 / (Dx**2 + Dy**2)**(0.5) : if (Dx, Dy) == (0, 0) rating = 6.0</span>
        <span class="c1"># NewRating[0.0, 0.2, 0.3, 0.2, 0.0]</span>
        <span class="c1">#          [0.2, 0.5, 1.0, 0.5, 0.2]</span>
        <span class="c1">#          [0.3, 1.0, 6.0, 1.0, 0.3]</span>
        <span class="c1">#          [0.2, 0.5, 1.0, 0.5, 0.2]</span>
        <span class="c1">#          [0.0, 0.2, 0.3, 0.2, 0.0]</span>
        <span class="c1"># NewRating = 1.0 / (Dx**2 + Dy**2) : if (Dx, Dy) == (0, 0) rating = 6.0</span>
        <span class="p">(</span><span class="n">Ncluster</span><span class="p">,</span> <span class="n">nra</span><span class="p">,</span> <span class="n">ndec</span><span class="p">)</span> <span class="o">=</span> <span class="n">GridCluster</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">GridScore</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="n">nra</span><span class="p">,</span> <span class="n">ndec</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;GridCluster = </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">GridCluster</span><span class="p">)</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;lines = </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">lines</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">Nc</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Ncluster</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">lines</span><span class="p">[</span><span class="n">Nc</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">!=</span> <span class="kc">False</span><span class="p">:</span>
                <span class="n">GridScore</span><span class="p">[:]</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nra</span><span class="p">):</span>
                    <span class="n">range_x</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="nb">min</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span> <span class="mi">0</span><span class="p">))</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">nra</span><span class="o">-</span><span class="n">x</span><span class="p">)))</span>
                    <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ndec</span><span class="p">):</span>
                        <span class="n">range_y</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="nb">min</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="mi">0</span><span class="p">))</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">ndec</span><span class="o">-</span><span class="n">y</span><span class="p">)))</span>
                        <span class="c1"># TN refactoring</span>
                        <span class="c1"># split smoothing loop</span>
                        <span class="c1"># dx = 0 and dy = 0</span>
                        <span class="n">GridScore</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">+=</span> <span class="mf">6.0</span> <span class="o">*</span> <span class="n">GridCluster</span><span class="p">[</span><span class="n">Nc</span><span class="p">][</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span>
                        <span class="n">GridScore</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">+=</span> <span class="mf">6.0</span>
                        <span class="c1"># dx = 0</span>
                        <span class="k">for</span> <span class="n">dy</span> <span class="ow">in</span> <span class="n">range_y</span><span class="p">:</span>
                            <span class="n">ny</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="n">dy</span>
                            <span class="c1">#Rating = 1.0 / abs(dy)</span>
                            <span class="n">Rating</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dy</span><span class="o">*</span><span class="n">dy</span><span class="p">)</span>
                            <span class="n">GridScore</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">+=</span> <span class="n">Rating</span> <span class="o">*</span> <span class="n">GridCluster</span><span class="p">[</span><span class="n">Nc</span><span class="p">][</span><span class="n">x</span><span class="p">][</span><span class="n">ny</span><span class="p">]</span>
                            <span class="n">GridScore</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">+=</span> <span class="n">Rating</span>
                        <span class="c1"># dy = 0</span>
                        <span class="k">for</span> <span class="n">dx</span> <span class="ow">in</span> <span class="n">range_x</span><span class="p">:</span>
                            <span class="n">nx</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">dx</span>
                            <span class="c1">#Rating = 1.0 / abs(dx)</span>
                            <span class="n">Rating</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dx</span><span class="o">*</span><span class="n">dx</span><span class="p">)</span>
                            <span class="n">GridScore</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">+=</span> <span class="n">Rating</span> <span class="o">*</span> <span class="n">GridCluster</span><span class="p">[</span><span class="n">Nc</span><span class="p">][</span><span class="n">nx</span><span class="p">][</span><span class="n">y</span><span class="p">]</span>
                            <span class="n">GridScore</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">+=</span> <span class="n">Rating</span>
                        <span class="c1"># dx != 0 and dy != 0</span>
                        <span class="k">for</span> <span class="n">dx</span> <span class="ow">in</span> <span class="n">range_x</span><span class="p">:</span>
                            <span class="k">for</span> <span class="n">dy</span> <span class="ow">in</span> <span class="n">range_y</span><span class="p">:</span>
                                <span class="k">if</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">dx</span><span class="p">)</span> <span class="o">+</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dy</span><span class="p">))</span> <span class="o">&lt;=</span> <span class="mi">3</span><span class="p">:</span>
                                    <span class="p">(</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">dx</span><span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="n">dy</span><span class="p">)</span>
                                    <span class="c1">#Rating = 1.0 / sqrt(dx*dx + dy*dy)</span>
                                    <span class="n">Rating</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">dx</span><span class="o">*</span><span class="n">dx</span> <span class="o">+</span> <span class="n">dy</span><span class="o">*</span><span class="n">dy</span><span class="p">)</span>
                                    <span class="n">GridScore</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">+=</span> <span class="n">Rating</span> <span class="o">*</span> <span class="n">GridCluster</span><span class="p">[</span><span class="n">Nc</span><span class="p">][</span><span class="n">nx</span><span class="p">][</span><span class="n">ny</span><span class="p">]</span>
                                    <span class="n">GridScore</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">+=</span> <span class="n">Rating</span>
                <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;Score :  GridScore[</span><span class="si">%s</span><span class="s1">][0] = </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">Nc</span><span class="p">,</span> <span class="n">GridScore</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;Rating:  GridScore[</span><span class="si">%s</span><span class="s1">][1] = </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">Nc</span><span class="p">,</span> <span class="n">GridScore</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="c1">#GridCluster[Nc] = GridScore[0] / GridScore[1]</span>
                <span class="n">GridCluster</span><span class="p">[</span><span class="n">Nc</span><span class="p">]</span> <span class="o">=</span> <span class="n">GridScore</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">GridScore</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="mf">2.0</span> <span class="c1"># for single valid detection</span>
            <span class="k">if</span> <span class="p">((</span><span class="n">GridCluster</span><span class="p">[</span><span class="n">Nc</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">Questionable</span><span class="p">)</span><span class="o">*</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mf">0.1</span><span class="p">:</span> <span class="n">lines</span><span class="p">[</span><span class="n">Nc</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="n">threshold</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">Valid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Marginal</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Questionable</span><span class="p">]</span>
        <span class="n">flag_digit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flag_digits</span><span class="p">[</span><span class="s1">&#39;smoothing&#39;</span><span class="p">]</span>
        <span class="n">cluster_flag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__update_cluster_flag</span><span class="p">(</span><span class="n">cluster_flag</span><span class="p">,</span> <span class="s1">&#39;smoothing&#39;</span><span class="p">,</span> <span class="n">GridCluster</span><span class="p">,</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">flag_digit</span><span class="p">)</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;threshold = </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">threshold</span><span class="p">)</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;GridCluster = </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">GridCluster</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">GridCluster</span><span class="p">,</span> <span class="n">lines</span><span class="p">,</span> <span class="n">cluster_flag</span><span class="p">)</span></div>


<div class="viewcode-block" id="ValidateLineRaster.final_stage">
<a class="viewcode-back" href="../../../../../_autosummary/pipeline.hsd.tasks.baseline.validation.ValidateLineRaster.html#pipeline.hsd.tasks.baseline.validation.ValidateLineRaster.final_stage">[docs]</a>
    <span class="k">def</span> <span class="nf">final_stage</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">GridCluster</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">GridMember</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">Region</span><span class="p">:</span> <span class="n">DetectedLineList</span><span class="p">,</span>
        <span class="n">Region2</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">lines</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]]],</span>
        <span class="n">category</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
        <span class="n">grid_ra</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">grid_dec</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">broad_component</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
        <span class="n">xorder</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">yorder</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">x0</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">y0</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">Grid2SpectrumID</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
        <span class="n">index_list</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
        <span class="n">PosList</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">cluster_flag</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]]],</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]]],</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Distribute validated lines to each observed spectra.</span>

<span class="sd">        This method implements the final phase of cluster validation process,</span>
<span class="sd">        and is so-called &quot;Final Stage&quot;. It performs two-dimensional least-square</span>
<span class="sd">        fitting of line properties (center, width) on the grid configured onto</span>
<span class="sd">        the celestial plane, and distribute those properties to each observed</span>
<span class="sd">        spectra using least-square solution at their associated position.</span>

<span class="sd">        Args:</span>
<span class="sd">            GridCluster: Three dimensional array representing spatial distribution of</span>
<span class="sd">                         each cluster detected by the clustering analysis</span>
<span class="sd">            GridMember: Number of spectra at each grid position</span>
<span class="sd">            Region: List of line properties with associated spatial coordinate.</span>
<span class="sd">                    Format is as follows.</span>

<span class="sd">                [[row, chan0, chan1, RA, DEC, flag, Binning],[],[],,,[]]</span>

<span class="sd">            Region2: List of line properties (line width and line center)</span>
<span class="sd">                     for each data</span>
<span class="sd">            lines: List of line properties with validity flag</span>
<span class="sd">            category: List of cluster membership indices</span>
<span class="sd">            grid_ra: Horizontal (longitudinal) spacing of spatial grids.</span>
<span class="sd">                     The value should be the one with declination correction.</span>
<span class="sd">            grid_dec: Vertical (latitudinal) spacing of spatial grids.</span>
<span class="sd">            broad_component: Process broad component or not. Not used.</span>
<span class="sd">            xorder: Order of the polynomial for horizontal fitting.</span>
<span class="sd">                    If it is -1, order is automatically determined inside</span>
<span class="sd">                    the method (max 5).</span>
<span class="sd">            yorder: Order of the polynomial for vertical fitting.</span>
<span class="sd">                    If it is -1, order is automatically determined inside</span>
<span class="sd">                    the method (max 5).</span>
<span class="sd">            x0: Horizontal position of the bottom left corner</span>
<span class="sd">            y0: Vertical position of the bottom left corner</span>
<span class="sd">            Grid2SpectrumID: Index mapping between serial list of gridded</span>
<span class="sd">                             spectra and two-dimensional grid positions</span>
<span class="sd">            index_list: List of consecutive datatable row numbers.</span>
<span class="sd">            PosList: List of pointings (RA and Dec) of ON_SOURCE data</span>
<span class="sd">            cluster_flag: array data for plotting clustering analysis results</span>

<span class="sd">        Returns:</span>
<span class="sd">            4-tuple of the following data.</span>

<span class="sd">              - List of validated line ranges distributed to each observed spectrum</span>
<span class="sd">                using the least-square fitting of line parameters</span>
<span class="sd">              - List of line properties with updated validity flag</span>
<span class="sd">              - List of line properties dedicated to plotting</span>
<span class="sd">              - Updated cluster_flag (flags for smoothing stage is appended)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="p">(</span><span class="n">Ncluster</span><span class="p">,</span> <span class="n">nra</span><span class="p">,</span> <span class="n">ndec</span><span class="p">)</span> <span class="o">=</span> <span class="n">GridCluster</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">xorder0</span> <span class="o">=</span> <span class="n">xorder</span>
        <span class="n">yorder0</span> <span class="o">=</span> <span class="n">yorder</span>

        <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;GridCluster = </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">GridCluster</span><span class="p">)</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;GridMember = </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">GridMember</span><span class="p">)</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;lines = </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">lines</span><span class="p">)</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Ncluster=</span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">Ncluster</span><span class="p">)</span>

        <span class="c1"># Dictionary for final output</span>
        <span class="n">RealSignal</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">()</span>

        <span class="n">HalfGrid</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">grid_ra</span><span class="o">*</span><span class="n">grid_ra</span> <span class="o">+</span> <span class="n">grid_dec</span><span class="o">*</span><span class="n">grid_dec</span><span class="p">)</span>

        <span class="n">MinFWHM</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">MinFWHM</span>
        <span class="n">MaxFWHM</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">MaxFWHM</span>

        <span class="c1"># for Channel Map velocity range determination 2014/1/12</span>
        <span class="n">channelmap_range</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lines</span><span class="p">)):</span>
            <span class="n">channelmap_range</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lines</span><span class="p">[</span><span class="n">i</span><span class="p">][:])</span>

        <span class="k">for</span> <span class="n">Nc</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Ncluster</span><span class="p">):</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;------00------ Exec for Nth Cluster: Nc=</span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">Nc</span><span class="p">)</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;lines[Nc] = </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">lines</span><span class="p">[</span><span class="n">Nc</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">lines</span><span class="p">[</span><span class="n">Nc</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span> <span class="k">continue</span>
            <span class="n">Plane</span> <span class="o">=</span> <span class="p">(</span><span class="n">GridCluster</span><span class="p">[</span><span class="n">Nc</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">Marginal</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">Plane</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">lines</span><span class="p">[</span><span class="n">Nc</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">channelmap_range</span><span class="p">[</span><span class="n">Nc</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">continue</span>
            <span class="n">Original</span> <span class="o">=</span> <span class="n">GridCluster</span><span class="p">[</span><span class="n">Nc</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="c1"># Clear GridCluster Nc-th plane</span>
            <span class="n">GridCluster</span><span class="p">[</span><span class="n">Nc</span><span class="p">]</span> <span class="o">*=</span> <span class="mf">0.0</span>

            <span class="c1"># Clean isolated grids</span>
            <span class="n">MemberList</span><span class="p">,</span> <span class="n">Realmember</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">CleanIsolation</span><span class="p">(</span><span class="n">nra</span><span class="p">,</span> <span class="n">ndec</span><span class="p">,</span> <span class="n">Original</span><span class="p">,</span> <span class="n">Plane</span><span class="p">,</span> <span class="n">GridMember</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">MemberList</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">continue</span>

            <span class="c1"># Blur each SubCluster with the radius of sqrt(Nmember/Pi) * ratio</span>
            <span class="n">ratio</span> <span class="o">=</span> <span class="n">rules</span><span class="o">.</span><span class="n">ClusterRule</span><span class="p">[</span><span class="s1">&#39;BlurRatio&#39;</span><span class="p">]</span>
            <span class="c1"># Set-up SubCluster</span>
            <span class="k">for</span> <span class="n">Ns</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">MemberList</span><span class="p">)):</span>  <span class="c1"># Ns: SubCluster number</span>
                <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;------01------ Ns=</span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">Ns</span><span class="p">)</span>
                <span class="n">SubPlane</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nra</span><span class="p">,</span> <span class="n">ndec</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="ow">in</span> <span class="n">MemberList</span><span class="p">[</span><span class="n">Ns</span><span class="p">]:</span> <span class="n">SubPlane</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="n">Original</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span>
                <span class="n">ValidPlane</span><span class="p">,</span> <span class="n">BlurPlane</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">DoBlur</span><span class="p">(</span><span class="n">Realmember</span><span class="p">[</span><span class="n">Ns</span><span class="p">],</span> <span class="n">nra</span><span class="p">,</span> <span class="n">ndec</span><span class="p">,</span> <span class="n">SubPlane</span><span class="p">,</span> <span class="n">ratio</span><span class="p">)</span>

                <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;GridCluster.shape = </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">GridCluster</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
                <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;Original </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">Original</span><span class="p">)</span>
                <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;SubPlane.shape = </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">SubPlane</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
                <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;SubPlane </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">SubPlane</span><span class="p">)</span>
                <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;BlurPlane.shape = </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">BlurPlane</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
                <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;BlurPlane </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">BlurPlane</span><span class="p">)</span>
                <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;ValidPlane </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">ValidPlane</span><span class="p">)</span>
                <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;GridClusterV </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">GridClusterValidation</span><span class="p">[</span><span class="n">Nc</span><span class="p">])</span>

                <span class="c1"># 2D fit for each Plane</span>
                <span class="c1"># Use the data for fit if GridCluster[Nc][x][y] &gt; self.Valid</span>
                <span class="c1"># Not use for fit but apply the value at the border if GridCluster[Nc][x][y] &gt; self.Marginal</span>

                <span class="p">(</span><span class="n">ylen</span><span class="p">,</span> <span class="n">xlen</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">GridClusterValidation</span><span class="p">[</span><span class="n">Nc</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
                <span class="c1"># 2017/9/21 GridClusterValidation should not be used for order determination</span>
                <span class="c1"># 0 &lt;= xorder0,yorder0 &lt;= 5, swap xorder0 and yorder0</span>
                <span class="k">if</span> <span class="n">xorder</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span> <span class="n">xorder0</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ValidPlane</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">yorder</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span> <span class="n">yorder0</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ValidPlane</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;(X,Y)order, order0 = (</span><span class="si">%s</span><span class="s1">, </span><span class="si">%s</span><span class="s1">) (</span><span class="si">%s</span><span class="s1">, </span><span class="si">%s</span><span class="s1">)&#39;</span><span class="p">,</span> <span class="n">xorder</span><span class="p">,</span> <span class="n">yorder</span><span class="p">,</span> <span class="n">xorder0</span><span class="p">,</span> <span class="n">yorder0</span><span class="p">)</span>

                <span class="c1"># clear Flag</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">category</span><span class="p">)):</span>
                    <span class="n">Region</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

                <span class="c1">#while ExceptionLinAlg:</span>
                <span class="n">FitData</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;------02-1---- category=</span><span class="si">%s</span><span class="s1">, len(category)=</span><span class="si">%s</span><span class="s1">, ClusterNumber(Nc)=</span><span class="si">%s</span><span class="s1">, SubClusterNumber(Ns)=</span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">category</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">category</span><span class="p">),</span> <span class="n">Nc</span><span class="p">,</span> <span class="n">Ns</span><span class="p">)</span>
                <span class="c1">#Region format:([row, line[0], line[1], RA, DEC, flag])</span>
                <span class="n">dummy</span> <span class="o">=</span> <span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">Region</span><span class="p">[</span><span class="n">i</span><span class="p">][:</span><span class="mi">5</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">category</span><span class="p">))</span>
                         <span class="k">if</span> <span class="n">category</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">Nc</span> <span class="ow">and</span> <span class="n">Region</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">5</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span>
                         <span class="n">SubPlane</span><span class="p">[</span><span class="nb">int</span><span class="p">((</span><span class="n">Region</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="n">x0</span><span class="p">)</span><span class="o">/</span><span class="n">grid_ra</span><span class="p">)][</span><span class="nb">int</span><span class="p">((</span><span class="n">Region</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">4</span><span class="p">]</span> <span class="o">-</span> <span class="n">y0</span><span class="p">)</span><span class="o">/</span><span class="n">grid_dec</span><span class="p">)]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">Valid</span><span class="p">]</span>
                <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;------02-2----- len(dummy)=</span><span class="si">%s</span><span class="s1">, dummy=</span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">dummy</span><span class="p">),</span> <span class="n">dummy</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dummy</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">continue</span>

                <span class="c1"># same signal can be detected in a single row with multiple binning</span>
                <span class="c1"># in that case, take maximum width as a representative width (Lmax-Lmin)</span>
                <span class="p">(</span><span class="n">Lrow</span><span class="p">,</span> <span class="n">Lmin</span><span class="p">,</span> <span class="n">Lmax</span><span class="p">,</span> <span class="n">LRA</span><span class="p">,</span> <span class="n">LDEC</span><span class="p">)</span> <span class="o">=</span> <span class="n">dummy</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">dummy</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="n">Lrow</span> <span class="o">==</span> <span class="n">dummy</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span>
                        <span class="n">Lmin</span><span class="p">,</span> <span class="n">Lmax</span> <span class="o">=</span> <span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">Lmin</span><span class="p">,</span> <span class="n">dummy</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]),</span> <span class="nb">max</span><span class="p">(</span><span class="n">Lmax</span><span class="p">,</span> <span class="n">dummy</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">]))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">FitData</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">Lmin</span><span class="p">,</span> <span class="n">Lmax</span><span class="p">,</span> <span class="n">LRA</span><span class="p">,</span> <span class="n">LDEC</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
                        <span class="p">(</span><span class="n">Lrow</span><span class="p">,</span> <span class="n">Lmin</span><span class="p">,</span> <span class="n">Lmax</span><span class="p">,</span> <span class="n">LRA</span><span class="p">,</span> <span class="n">LDEC</span><span class="p">)</span> <span class="o">=</span> <span class="n">dummy</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">FitData</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">Lmin</span><span class="p">,</span> <span class="n">Lmax</span><span class="p">,</span> <span class="n">LRA</span><span class="p">,</span> <span class="n">LDEC</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
                <span class="k">del</span> <span class="n">dummy</span>
                <span class="c1"># FitData format: [Chan0, Chan1, RA, DEC, flag]</span>
                <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;FitData = </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">FitData</span><span class="p">)</span>

                <span class="c1"># TN refactoring</span>
                <span class="c1"># Comment out the following if statement since</span>
                <span class="c1"># 1) len(FitData) is always greater than 0.</span>
                <span class="c1">#    Lee the code just above start of iteration.</span>
                <span class="c1"># 2) SingularMatrix is always False in this</span>
                <span class="c1">#    loop. Exit the loop whenever SingularMatrix</span>
                <span class="c1">#    is set to False. See code below.</span>
                <span class="c1">#if len(FitData) == 0 or SingularMatrix: break</span>

                <span class="n">SingularMatrix</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">for</span> <span class="n">iteration</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>  <span class="c1"># iteration loop for 2D fit sigma flagging</span>
                    <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;------03------ iteration=</span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">iteration</span><span class="p">)</span>
                    <span class="c1"># effective components of FitData</span>
                    <span class="n">effective</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">FitData</span><span class="p">))</span> <span class="k">if</span> <span class="n">FitData</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">4</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span>

                    <span class="c1"># assertion</span>
                    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">effective</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>

                    <span class="c1"># prepare data for SVD fit</span>
                    <span class="c1"># 2017/9/26 Repeat solver.find_good_solution until not through exception by reducing xorder and yorder</span>
                    <span class="n">SVDsolver</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">):</span>
                        <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;2D Fit Order: xorder0=</span><span class="si">%s</span><span class="s1"> yorder0=</span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">xorder0</span><span class="p">,</span> <span class="n">yorder0</span><span class="p">)</span>
                        <span class="k">if</span><span class="p">(</span><span class="n">SVDsolver</span><span class="p">):</span>
                            <span class="c1"># Instantiate SVD solver</span>
                            <span class="n">solver</span> <span class="o">=</span> <span class="n">SVDSolver2D</span><span class="p">(</span><span class="n">xorder0</span><span class="p">,</span> <span class="n">yorder0</span><span class="p">)</span>
                            <span class="c1"># prepare data for SVD fit</span>
                            <span class="n">xdata</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">FitData</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">effective</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
                            <span class="n">ydata</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">FitData</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">effective</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
                            <span class="n">lmindata</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">FitData</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">effective</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
                            <span class="n">lmaxdata</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">FitData</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">effective</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="c1"># 2017/9/28 old code is incerted for validation purpose</span>
                            <span class="c1"># make arrays for coefficient calculation</span>
                            <span class="c1"># Matrix    MM x A = B  -&gt;  A = MM^-1 x B</span>
                            <span class="n">M0</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">xorder0</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">yorder0</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
                            <span class="n">M1</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">xorder0</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">yorder0</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
                            <span class="n">B0</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">xorder0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">yorder0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
                            <span class="n">B1</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">xorder0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">yorder0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
                            <span class="n">MM0</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">([(</span><span class="n">xorder0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">yorder0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="n">xorder0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">yorder0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
                            <span class="n">MM1</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">([(</span><span class="n">xorder0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">yorder0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="n">xorder0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">yorder0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
                            <span class="k">for</span> <span class="p">(</span><span class="n">Width</span><span class="p">,</span> <span class="n">Center</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">flag</span><span class="p">)</span> <span class="ow">in</span> <span class="n">FitData</span><span class="p">:</span>
                                <span class="k">if</span> <span class="n">flag</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">yorder0</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                                        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">xorder0</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                                            <span class="n">M0</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="n">k</span> <span class="o">*</span> <span class="p">(</span><span class="n">xorder0</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">+=</span> <span class="n">math</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
                                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">yorder0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                                        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">xorder0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                                            <span class="n">B0</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="n">k</span> <span class="o">*</span> <span class="p">(</span><span class="n">xorder0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">+=</span> <span class="n">math</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="o">*</span> <span class="n">Center</span>
                                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">yorder0</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                                        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">xorder0</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                                            <span class="n">M1</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="n">k</span> <span class="o">*</span> <span class="p">(</span><span class="n">xorder0</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">+=</span> <span class="n">math</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
                                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">yorder0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                                        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">xorder0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                                            <span class="n">B1</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="n">k</span> <span class="o">*</span> <span class="p">(</span><span class="n">xorder0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">+=</span> <span class="n">math</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="o">*</span> <span class="n">Width</span>
                            <span class="c1"># make Matrix MM0,MM1 and calculate A0,A1</span>
                            <span class="k">for</span> <span class="n">K</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">((</span><span class="n">xorder0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">yorder0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)):</span>
                                <span class="n">k0</span> <span class="o">=</span> <span class="n">K</span> <span class="o">%</span> <span class="p">(</span><span class="n">xorder0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                                <span class="n">k1</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">K</span> <span class="o">//</span> <span class="p">(</span><span class="n">xorder0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
                                <span class="k">for</span> <span class="n">J</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">((</span><span class="n">xorder0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">yorder0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)):</span>
                                    <span class="n">j0</span> <span class="o">=</span> <span class="n">J</span> <span class="o">%</span> <span class="p">(</span><span class="n">xorder0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                                    <span class="n">j1</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">J</span> <span class="o">//</span> <span class="p">(</span><span class="n">xorder0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
                                    <span class="n">MM0</span><span class="p">[</span><span class="n">J</span><span class="p">,</span> <span class="n">K</span><span class="p">]</span> <span class="o">=</span> <span class="n">M0</span><span class="p">[</span><span class="n">j0</span> <span class="o">+</span> <span class="n">k0</span> <span class="o">+</span> <span class="p">(</span><span class="n">j1</span> <span class="o">+</span> <span class="n">k1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">xorder0</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
                                    <span class="n">MM1</span><span class="p">[</span><span class="n">J</span><span class="p">,</span> <span class="n">K</span><span class="p">]</span> <span class="o">=</span> <span class="n">M1</span><span class="p">[</span><span class="n">j0</span> <span class="o">+</span> <span class="n">k0</span> <span class="o">+</span> <span class="p">(</span><span class="n">j1</span> <span class="o">+</span> <span class="n">k1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">xorder0</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
                            <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;OLD:MM0 = </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">MM0</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
                            <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;OLD:B0 = </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">B0</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>

                        <span class="k">try</span><span class="p">:</span>
                            <span class="k">if</span><span class="p">(</span><span class="n">SVDsolver</span><span class="p">):</span>
                                <span class="n">solver</span><span class="o">.</span><span class="n">set_data_points</span><span class="p">(</span><span class="n">xdata</span><span class="p">,</span> <span class="n">ydata</span><span class="p">)</span>
                                <span class="n">A0</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">find_good_solution</span><span class="p">(</span><span class="n">lmaxdata</span><span class="p">)</span>
                                <span class="n">A1</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">find_good_solution</span><span class="p">(</span><span class="n">lmindata</span><span class="p">)</span>
                                <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;SVD: A0=</span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">A0</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
                                <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;SVD: A1=</span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">A1</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
                                <span class="k">break</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">A0</span> <span class="o">=</span> <span class="n">LA</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">MM0</span><span class="p">,</span> <span class="n">B0</span><span class="p">)</span>
                                <span class="n">A1</span> <span class="o">=</span> <span class="n">LA</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">MM1</span><span class="p">,</span> <span class="n">B1</span><span class="p">)</span>
                                <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;OLD: A0=</span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">A0</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
                                <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;OLD: A1=</span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">A1</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
                                <span class="k">del</span> <span class="n">MM0</span><span class="p">,</span> <span class="n">MM1</span><span class="p">,</span> <span class="n">B0</span><span class="p">,</span> <span class="n">B1</span><span class="p">,</span> <span class="n">M0</span><span class="p">,</span> <span class="n">M1</span>
                                <span class="k">break</span>

                        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                            <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;------04------ in exception loop SingularMatrix=</span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">SingularMatrix</span><span class="p">)</span>
                            <span class="kn">import</span> <span class="nn">traceback</span>
                            <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">traceback</span><span class="o">.</span><span class="n">format_exc</span><span class="p">())</span>
                            <span class="k">if</span> <span class="n">xorder0</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">yorder0</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                                <span class="n">xorder0</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">xorder0</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                                <span class="n">yorder0</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">yorder0</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                                <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Fit failed. Trying lower order (</span><span class="si">%s</span><span class="s1">, </span><span class="si">%s</span><span class="s1">)&#39;</span><span class="p">,</span> <span class="n">xorder0</span><span class="p">,</span> <span class="n">yorder0</span><span class="p">)</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">SingularMatrix</span> <span class="o">=</span> <span class="kc">True</span>
                                <span class="k">break</span>
                    <span class="k">if</span> <span class="n">SingularMatrix</span><span class="p">:</span> <span class="k">break</span>

                    <span class="c1"># Calculate Sigma</span>
                    <span class="c1"># Sigma should be calculated in the upper stage</span>
                    <span class="c1"># Fit0: Center or Lmax, Fit1: Width or Lmin</span>
                    <span class="n">Diff</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="c1"># TN refactoring</span>
                    <span class="c1"># Calculation of Diff is duplicated here and</span>
                    <span class="c1"># following clipping stage. So, evalueate Diff</span>
                    <span class="c1"># only once here and reuse it in clipping.</span>
                    <span class="k">for</span> <span class="p">(</span><span class="n">Width</span><span class="p">,</span> <span class="n">Center</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">flag</span><span class="p">)</span> <span class="ow">in</span> <span class="n">FitData</span><span class="p">:</span>
                        <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> </span><span class="si">%s</span><span class="s1"> </span><span class="si">%s</span><span class="s1"> </span><span class="si">%s</span><span class="s1"> </span><span class="si">%s</span><span class="s1"> </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">xorder0</span><span class="p">,</span> <span class="n">yorder0</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">A0</span><span class="p">,</span> <span class="n">A1</span><span class="p">)</span>
                        <span class="p">(</span><span class="n">Fit0</span><span class="p">,</span> <span class="n">Fit1</span><span class="p">)</span> <span class="o">=</span> <span class="n">_eval_poly</span><span class="p">(</span><span class="n">xorder0</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">yorder0</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">A0</span><span class="p">,</span> <span class="n">A1</span><span class="p">)</span>
                        <span class="n">Fit0</span> <span class="o">-=</span> <span class="n">Center</span>
                        <span class="n">Fit1</span> <span class="o">-=</span> <span class="n">Width</span>
                        <span class="n">Diff</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Fit0</span><span class="o">*</span><span class="n">Fit0</span> <span class="o">+</span> <span class="n">Fit1</span><span class="o">*</span><span class="n">Fit1</span><span class="p">))</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">effective</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">npdiff</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Diff</span><span class="p">)[</span><span class="n">effective</span><span class="p">]</span>
                        <span class="n">Threshold</span> <span class="o">=</span> <span class="n">npdiff</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
                        <span class="n">Threshold</span> <span class="o">+=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">npdiff</span> <span class="o">-</span> <span class="n">Threshold</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">())</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsigma</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">Threshold</span> <span class="o">=</span> <span class="n">Diff</span><span class="p">[</span><span class="n">effective</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">*</span> <span class="mf">2.0</span>
                    <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;Diff = </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">Diff</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">effective</span><span class="p">])</span>
                    <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;2D Fit Threshold = </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">Threshold</span><span class="p">)</span>

                    <span class="c1"># Sigma Clip</span>
                    <span class="n">NFlagged</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">Number</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">FitData</span><span class="p">)</span>
                    <span class="c1">### 2011/05/15</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Number</span><span class="p">):</span>
                        <span class="c1"># Reuse Diff</span>
                        <span class="k">if</span> <span class="n">Diff</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">Threshold</span><span class="p">:</span>
                            <span class="n">FitData</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">FitData</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                            <span class="n">NFlagged</span> <span class="o">+=</span> <span class="mi">1</span>

                    <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;2D Fit Flagged/All = (</span><span class="si">%s</span><span class="s1">, </span><span class="si">%s</span><span class="s1">)&#39;</span><span class="p">,</span> <span class="n">NFlagged</span><span class="p">,</span> <span class="n">Number</span><span class="p">)</span>
                    <span class="c1">#2009/10/15 compare the number of the remainder and fitting order</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">Number</span> <span class="o">-</span> <span class="n">NFlagged</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nb">max</span><span class="p">(</span><span class="n">xorder0</span><span class="p">,</span> <span class="n">yorder0</span><span class="p">)</span> <span class="ow">or</span> <span class="n">Number</span> <span class="o">==</span> <span class="n">NFlagged</span><span class="p">:</span>
                        <span class="n">SingularMatrix</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">break</span>
                    <span class="c1">#2017/9/27 exit if there is update (no flag, or flag number is the same to the previous iteration)</span>
                    <span class="k">if</span> <span class="n">NFlagged</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">break</span>
                    <span class="k">if</span> <span class="n">iteration</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="n">NFlagOrg</span> <span class="o">=</span> <span class="n">NFlagged</span>
                    <span class="k">elif</span> <span class="n">NFlagOrg</span> <span class="o">==</span> <span class="n">NFlagged</span><span class="p">:</span> <span class="k">break</span>
                <span class="c1"># Iteration End</span>

                <span class="c1">### 2011/05/15 Fitting is no longer (Width, Center) but (minchan, maxChan)</span>
                <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;------06------ End of Iteration: SingularMatrix=</span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">SingularMatrix</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">SingularMatrix</span><span class="p">:</span> <span class="c1"># skip for next Ns (SubCluster)</span>
                    <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;------06b----- Skip for the next SubCluster&#39;</span><span class="p">)</span>
                    <span class="k">continue</span>

                <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;------07------ SingularMatrix=False&#39;</span><span class="p">)</span>
                <span class="c1"># Clear FitData and restore all relevant data</span>
                <span class="c1"># FitData: [(Chan0, Chan1, RA, DEC, Flag)]</span>
                <span class="n">FitData</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">category</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="n">category</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">Nc</span> <span class="ow">and</span> <span class="n">Region</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">5</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">SubPlane</span><span class="p">[</span><span class="nb">int</span><span class="p">((</span><span class="n">Region</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="n">x0</span><span class="p">)</span><span class="o">/</span><span class="n">grid_ra</span><span class="p">)][</span><span class="nb">int</span><span class="p">((</span><span class="n">Region</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">4</span><span class="p">]</span> <span class="o">-</span> <span class="n">y0</span><span class="p">)</span><span class="o">/</span><span class="n">grid_dec</span><span class="p">)]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">Valid</span><span class="p">:</span>
                        <span class="n">FitData</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">Region2</span><span class="p">[</span><span class="n">i</span><span class="p">][:</span><span class="mi">5</span><span class="p">]))</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">FitData</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">continue</span>

                <span class="c1"># for Channel Map velocity range determination 2014/1/12</span>
                <span class="p">(</span><span class="n">MaskMin</span><span class="p">,</span> <span class="n">MaskMax</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="mf">10000.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
                <span class="c1"># Calculate Fit for each position</span>
                <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;------08------ Calc Fit for each pos&#39;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nra</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ndec</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">ValidPlane</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;------09------ in ValidPlane x=</span><span class="si">%s</span><span class="s1"> y=</span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
                            <span class="k">for</span> <span class="n">PID</span> <span class="ow">in</span> <span class="n">Grid2SpectrumID</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]:</span>
                                <span class="n">ID</span> <span class="o">=</span> <span class="n">index_list</span><span class="p">[</span><span class="n">PID</span><span class="p">]</span>
                                <span class="c1">### 2011/05/15 (Width, Center) -&gt; (minchan, maxChan)</span>
                                <span class="p">(</span><span class="n">Chan1</span><span class="p">,</span> <span class="n">Chan0</span><span class="p">)</span> <span class="o">=</span> <span class="n">_eval_poly</span><span class="p">(</span><span class="n">xorder0</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">yorder0</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">PosList</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">PID</span><span class="p">],</span> <span class="n">PosList</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">PID</span><span class="p">],</span> <span class="n">A0</span><span class="p">,</span> <span class="n">A1</span><span class="p">)</span>
                                <span class="n">Fit0</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">Chan0</span> <span class="o">+</span> <span class="n">Chan1</span><span class="p">)</span>
                                <span class="n">Fit1</span> <span class="o">=</span> <span class="p">(</span><span class="n">Chan1</span> <span class="o">-</span> <span class="n">Chan0</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1.0</span>
                                <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;Fit0, Fit1 = </span><span class="si">%s</span><span class="s1">, </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">Fit0</span><span class="p">,</span> <span class="n">Fit1</span><span class="p">)</span>
                                <span class="c1"># 2015/04/23 remove MaxFWHM check</span>
                                <span class="k">if</span> <span class="p">(</span><span class="n">Fit1</span> <span class="o">&gt;=</span> <span class="n">MinFWHM</span><span class="p">):</span> <span class="c1"># and (Fit1 &lt;= MaxFWHM):</span>
                                    <span class="n">ProtectMask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_ProtectMask</span><span class="p">(</span><span class="n">Fit0</span><span class="p">,</span> <span class="n">Fit1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nchan</span><span class="p">,</span> <span class="n">MinFWHM</span><span class="p">,</span> <span class="n">MaxFWHM</span><span class="p">)</span>
                                    <span class="c1"># for Channel map velocity range determination 2014/1/12</span>
                                    <span class="n">MaskCen</span> <span class="o">=</span> <span class="p">(</span><span class="n">ProtectMask</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">ProtectMask</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="mf">2.0</span>
                                    <span class="k">if</span> <span class="n">MaskMin</span> <span class="o">&gt;</span> <span class="n">MaskCen</span><span class="p">:</span>
                                        <span class="n">MaskMin</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">MaskCen</span><span class="p">)</span>
                                    <span class="k">if</span> <span class="n">MaskMax</span> <span class="o">&lt;</span> <span class="n">MaskCen</span><span class="p">:</span>
                                        <span class="n">MaskMax</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nchan</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">MaskCen</span><span class="p">)</span>

                                    <span class="k">if</span> <span class="n">ID</span> <span class="ow">in</span> <span class="n">RealSignal</span><span class="p">:</span>
                                        <span class="n">RealSignal</span><span class="p">[</span><span class="n">ID</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ProtectMask</span><span class="p">)</span>
                                    <span class="k">else</span><span class="p">:</span>
                                        <span class="n">RealSignal</span><span class="p">[</span><span class="n">ID</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">PosList</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">PID</span><span class="p">],</span> <span class="n">PosList</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">PID</span><span class="p">],</span> <span class="p">[</span><span class="n">ProtectMask</span><span class="p">]]</span>
                                <span class="k">else</span><span class="p">:</span>
                                    <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;------10------ out of range Fit0=</span><span class="si">%s</span><span class="s1"> Fit1=</span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">Fit0</span><span class="p">,</span> <span class="n">Fit1</span><span class="p">)</span>
                        <span class="k">elif</span> <span class="n">BlurPlane</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;------11------ in BlurPlane x=</span><span class="si">%s</span><span class="s1"> y=</span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
                            <span class="c1"># in Blur Plane, Fit is not extrapolated,</span>
                            <span class="c1"># but use the nearest value in Valid Plane</span>
                            <span class="c1"># Search the nearest Valid Grid</span>
                            <span class="n">Nearest</span> <span class="o">=</span> <span class="p">[]</span>
                            <span class="n">square_aspect</span> <span class="o">=</span> <span class="n">grid_ra</span> <span class="o">/</span> <span class="n">grid_dec</span>
                            <span class="n">square_aspect</span> <span class="o">*=</span> <span class="n">square_aspect</span>
                            <span class="n">Dist2</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">inf</span>
                            <span class="k">for</span> <span class="n">xx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nra</span><span class="p">):</span>
                                <span class="k">for</span> <span class="n">yy</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ndec</span><span class="p">):</span>
                                    <span class="k">if</span> <span class="n">ValidPlane</span><span class="p">[</span><span class="n">xx</span><span class="p">][</span><span class="n">yy</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                                        <span class="n">Dist3</span> <span class="o">=</span> <span class="p">(</span><span class="n">xx</span><span class="o">-</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">xx</span><span class="o">-</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">square_aspect</span> <span class="o">+</span> <span class="p">(</span><span class="n">yy</span><span class="o">-</span><span class="n">y</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">yy</span><span class="o">-</span><span class="n">y</span><span class="p">)</span>
                                        <span class="k">if</span> <span class="n">Dist2</span> <span class="o">&gt;</span> <span class="n">Dist3</span><span class="p">:</span>
                                            <span class="n">Nearest</span> <span class="o">=</span> <span class="p">[</span><span class="n">xx</span><span class="p">,</span> <span class="n">yy</span><span class="p">]</span>
                                            <span class="n">Dist2</span> <span class="o">=</span> <span class="n">Dist3</span>
                            <span class="p">(</span><span class="n">RA0</span><span class="p">,</span> <span class="n">DEC0</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">x0</span> <span class="o">+</span> <span class="n">grid_ra</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">),</span> <span class="n">y0</span> <span class="o">+</span> <span class="n">grid_dec</span> <span class="o">*</span> <span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">))</span>
                            <span class="p">(</span><span class="n">RA1</span><span class="p">,</span> <span class="n">DEC1</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">x0</span> <span class="o">+</span> <span class="n">grid_ra</span> <span class="o">*</span> <span class="p">(</span><span class="n">Nearest</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">),</span> <span class="n">y0</span> <span class="o">+</span> <span class="n">grid_dec</span> <span class="o">*</span> <span class="p">(</span><span class="n">Nearest</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">))</span>

                            <span class="c1"># Setup the position near the border</span>
                            <span class="n">RA2</span> <span class="o">=</span> <span class="n">RA1</span> <span class="o">-</span> <span class="p">(</span><span class="n">RA1</span> <span class="o">-</span> <span class="n">RA0</span><span class="p">)</span> <span class="o">*</span> <span class="n">HalfGrid</span> <span class="o">/</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">Dist2</span><span class="p">)</span>
                            <span class="n">DEC2</span> <span class="o">=</span> <span class="n">DEC1</span> <span class="o">-</span> <span class="p">(</span><span class="n">DEC1</span> <span class="o">-</span> <span class="n">DEC0</span><span class="p">)</span> <span class="o">*</span> <span class="n">HalfGrid</span> <span class="o">/</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">Dist2</span><span class="p">)</span>
                            <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;[X,Y],[XX,YY] = [</span><span class="si">%s</span><span class="s1">,</span><span class="si">%s</span><span class="s1">],</span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">Nearest</span><span class="p">)</span>
                            <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;(RA0,DEC0),(RA1,DEC1),(RA2,DEC2) = (</span><span class="si">%.5f</span><span class="s1">,</span><span class="si">%.5f</span><span class="s1">),(</span><span class="si">%.5f</span><span class="s1">,</span><span class="si">%.5f</span><span class="s1">),(</span><span class="si">%.5f</span><span class="s1">,</span><span class="si">%.5f</span><span class="s1">)&#39;</span><span class="p">,</span>
                                      <span class="n">RA0</span><span class="p">,</span> <span class="n">DEC0</span><span class="p">,</span> <span class="n">RA1</span><span class="p">,</span> <span class="n">DEC1</span><span class="p">,</span> <span class="n">RA2</span><span class="p">,</span> <span class="n">DEC2</span><span class="p">)</span>
                            <span class="c1"># Calculate Fit and apply same value to all the spectra in the Blur Grid</span>
                            <span class="c1">### 2011/05/15 (Width, Center) -&gt; (minchan, maxChan)</span>
                            <span class="c1"># Border case</span>
                            <span class="c1">#(Chan0, Chan1) = _eval_poly(xorder0+1, yorder0+1, RA2, DEC2, A0, A1)</span>
                            <span class="c1"># Center case</span>
                            <span class="p">(</span><span class="n">Chan1</span><span class="p">,</span> <span class="n">Chan0</span><span class="p">)</span> <span class="o">=</span> <span class="n">_eval_poly</span><span class="p">(</span><span class="n">xorder0</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">yorder0</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">RA1</span><span class="p">,</span> <span class="n">DEC1</span><span class="p">,</span> <span class="n">A0</span><span class="p">,</span> <span class="n">A1</span><span class="p">)</span>
                            <span class="n">Fit0</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">Chan0</span> <span class="o">+</span> <span class="n">Chan1</span><span class="p">)</span>
                            <span class="n">Fit1</span> <span class="o">=</span> <span class="p">(</span><span class="n">Chan1</span> <span class="o">-</span> <span class="n">Chan0</span><span class="p">)</span>
                            <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;Fit0, Fit1 = </span><span class="si">%s</span><span class="s1">, </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">Fit0</span><span class="p">,</span> <span class="n">Fit1</span><span class="p">)</span>
                            <span class="c1"># 2015/04/23 remove MaxFWHM check</span>
                            <span class="k">if</span> <span class="p">(</span><span class="n">Fit1</span> <span class="o">&gt;=</span> <span class="n">MinFWHM</span><span class="p">):</span> <span class="c1"># and (Fit1 &lt;= MaxFWHM):</span>
                                <span class="n">ProtectMask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_ProtectMask</span><span class="p">(</span><span class="n">Fit0</span><span class="p">,</span> <span class="n">Fit1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nchan</span><span class="p">,</span> <span class="n">MinFWHM</span><span class="p">,</span> <span class="n">MaxFWHM</span><span class="p">)</span>

                                <span class="k">for</span> <span class="n">PID</span> <span class="ow">in</span> <span class="n">Grid2SpectrumID</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]:</span>
                                    <span class="n">ID</span> <span class="o">=</span> <span class="n">index_list</span><span class="p">[</span><span class="n">PID</span><span class="p">]</span>
                                    <span class="k">if</span> <span class="n">ID</span> <span class="ow">in</span> <span class="n">RealSignal</span><span class="p">:</span>
                                        <span class="n">RealSignal</span><span class="p">[</span><span class="n">ID</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ProtectMask</span><span class="p">)</span>
                                    <span class="k">else</span><span class="p">:</span>
                                        <span class="n">RealSignal</span><span class="p">[</span><span class="n">ID</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">PosList</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">PID</span><span class="p">],</span> <span class="n">PosList</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">PID</span><span class="p">],</span> <span class="p">[</span><span class="n">ProtectMask</span><span class="p">]]</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;------12------ out of range Fit0=</span><span class="si">%s</span><span class="s1"> Fit1=</span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">Fit0</span><span class="p">,</span> <span class="n">Fit1</span><span class="p">)</span>
                                <span class="k">continue</span>

                <span class="c1"># Add every SubClusters to GridCluster just for Plot</span>
                <span class="n">GridCluster</span><span class="p">[</span><span class="n">Nc</span><span class="p">]</span> <span class="o">+=</span> <span class="n">BlurPlane</span>
                <span class="c1">#if not SingularMatrix: GridCluster[Nc] += BlurPlane</span>

            <span class="k">if</span> <span class="p">((</span><span class="n">GridCluster</span><span class="p">[</span><span class="n">Nc</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">0.5</span><span class="p">)</span><span class="o">*</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">Questionable</span> <span class="ow">or</span> <span class="n">MaskMax</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="n">lines</span><span class="p">[</span><span class="n">Nc</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">channelmap_range</span><span class="p">[</span><span class="n">Nc</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># for Channel map velocity range determination 2014/1/12 arbitrary factor 0.8</span>
                <span class="c1">#channelmap_range[Nc][1] = (MaskMax - MaskMin - 10) * 0.8</span>
                <span class="c1">#channelmap_range[Nc][1] = MaskMax - MaskMin + lines[Nc][1] / 2.0</span>
                <span class="c1"># MaskMax-MaskMin is an maximum offset of line center</span>
                <span class="n">channelmap_range</span><span class="p">[</span><span class="n">Nc</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">MaskMax</span> <span class="o">-</span> <span class="n">MaskMin</span> <span class="o">+</span> <span class="n">lines</span><span class="p">[</span><span class="n">Nc</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Nc, MaskMax, Min: </span><span class="si">%s</span><span class="s1">, </span><span class="si">%s</span><span class="s1">, </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">Nc</span><span class="p">,</span> <span class="n">MaskMax</span><span class="p">,</span> <span class="n">MaskMin</span><span class="p">)</span>
                <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;channelmap_range[Nc]: </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">channelmap_range</span><span class="p">[</span><span class="n">Nc</span><span class="p">])</span>
                <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;lines[Nc]: </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">lines</span><span class="p">[</span><span class="n">Nc</span><span class="p">])</span>

            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nra</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ndec</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">Original</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">Valid</span><span class="p">:</span> <span class="n">GridCluster</span><span class="p">[</span><span class="n">Nc</span><span class="p">][</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="mf">2.0</span>
                    <span class="k">elif</span> <span class="n">GridCluster</span><span class="p">[</span><span class="n">Nc</span><span class="p">][</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">0.5</span><span class="p">:</span> <span class="n">GridCluster</span><span class="p">[</span><span class="n">Nc</span><span class="p">][</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>

        <span class="n">threshold</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">]</span>
        <span class="n">flag_digit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flag_digits</span><span class="p">[</span><span class="s1">&#39;final&#39;</span><span class="p">]</span>
        <span class="n">cluster_flag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__update_cluster_flag</span><span class="p">(</span><span class="n">cluster_flag</span><span class="p">,</span> <span class="s1">&#39;final&#39;</span><span class="p">,</span> <span class="n">GridCluster</span><span class="p">,</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">flag_digit</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">RealSignal</span><span class="p">,</span> <span class="n">lines</span><span class="p">,</span> <span class="n">channelmap_range</span><span class="p">,</span> <span class="n">cluster_flag</span><span class="p">)</span></div>


<div class="viewcode-block" id="ValidateLineRaster.CleanIsolation">
<a class="viewcode-back" href="../../../../../_autosummary/pipeline.hsd.tasks.baseline.validation.ValidateLineRaster.html#pipeline.hsd.tasks.baseline.validation.ValidateLineRaster.CleanIsolation">[docs]</a>
    <span class="k">def</span> <span class="nf">CleanIsolation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nra</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">ndec</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">Original</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">Plane</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">GridMember</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Clean spatially isolated cluster.</span>

<span class="sd">        Pick up only Valid detections, and check if there are enough</span>
<span class="sd">        surrounding pixels with Valid detection. Create subplane of the</span>
<span class="sd">        cluster by collecting contiguous cluster members.</span>

<span class="sd">        Args:</span>
<span class="sd">            nra: Number of horizontal grids</span>
<span class="sd">            ndec: Number of vertical grids</span>
<span class="sd">            Original: Spatial distribution of Marginal+Valid detections.</span>
<span class="sd">                      Value ranges from 0 to 1.</span>
<span class="sd">            Plane: Integer binary flag, 0 (False) or 1 (True), indicating whether</span>
<span class="sd">                   or not any cluster member exists in the grid.</span>
<span class="sd">            GridMember: Number of spectra at each grid position. Value ranges</span>
<span class="sd">                        from 0 to 3.</span>

<span class="sd">        Returns:</span>
<span class="sd">            2-tuple of cleaned clusters, MemberList and RealMember. If no cluster is</span>
<span class="sd">            left after the cleaning, empty lists are returned.</span>
<span class="sd">            MemberList contains positions of cluster member with Marginal+Valid detection</span>
<span class="sd">            MemberList[n]: [[(x00,y00),(x01,y01),........,(x0k-1,y0k-1)],</span>
<span class="sd">                            [(x10,y10),(x11,y11),..,(x1i-1,y1i-1)],</span>
<span class="sd">                                    ...</span>
<span class="sd">                            [(xn-10,yn-10),(xn-11,yn-11),..,(xn-1i-1,yn-1i-1)]]</span>
<span class="sd">            Realmember contains number of cluster members with only Valid detection</span>
<span class="sd">            RealMember: [Nvalid_00, Nvalid_01, ..., Nvalid_n-1i-1]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Nmember</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># number of positions where value &gt; self.Marginal in each SubCluster</span>
        <span class="n">Realmember</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># number of positions where value &gt; self.Valid in each SubCluster</span>
        <span class="n">MemberList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">NsubCluster</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># Separate cluster members into several SubClusters by spacial connection</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nra</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ndec</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">Plane</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">Plane</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
                    <span class="n">SearchList</span> <span class="o">=</span> <span class="p">[(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)]</span>
                    <span class="n">M</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="k">if</span> <span class="n">Original</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">Valid</span><span class="p">:</span>
                        <span class="n">MM</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">MM</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">MemberList</span><span class="o">.</span><span class="n">append</span><span class="p">([(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)])</span>
                    <span class="k">while</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">SearchList</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">):</span>
                        <span class="n">cx</span><span class="p">,</span> <span class="n">cy</span> <span class="o">=</span> <span class="n">SearchList</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="c1">#for dx in [-1, 0, 1]:</span>
                        <span class="k">for</span> <span class="n">dx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="nb">min</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">cx</span><span class="p">),</span> <span class="nb">min</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">nra</span><span class="o">-</span><span class="n">cx</span><span class="p">)):</span>
                            <span class="c1">#for dy in [-1, 0, 1]:</span>
                            <span class="k">for</span> <span class="n">dy</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="nb">min</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">cy</span><span class="p">),</span> <span class="nb">min</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">ndec</span><span class="o">-</span><span class="n">cy</span><span class="p">)):</span>
                                <span class="p">(</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">cx</span> <span class="o">+</span> <span class="n">dx</span><span class="p">,</span> <span class="n">cy</span> <span class="o">+</span> <span class="n">dy</span><span class="p">)</span>
                                <span class="c1">#if 0 &lt;= nx &lt; nra and 0 &lt;= ny &lt; ndec and Plane[nx][ny] == 1:</span>
                                <span class="k">if</span> <span class="n">Plane</span><span class="p">[</span><span class="n">nx</span><span class="p">][</span><span class="n">ny</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                                    <span class="n">Plane</span><span class="p">[</span><span class="n">nx</span><span class="p">][</span><span class="n">ny</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
                                    <span class="n">SearchList</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">))</span>
                                    <span class="n">M</span> <span class="o">+=</span> <span class="mi">1</span>
                                    <span class="k">if</span> <span class="n">Original</span><span class="p">[</span><span class="n">nx</span><span class="p">][</span><span class="n">ny</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">Valid</span><span class="p">:</span>
                                        <span class="n">MM</span> <span class="o">+=</span> <span class="mi">1</span>
                                    <span class="n">MemberList</span><span class="p">[</span><span class="n">NsubCluster</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">))</span>
                        <span class="k">del</span> <span class="n">SearchList</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">Nmember</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
                    <span class="n">Realmember</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">MM</span><span class="p">)</span>
                    <span class="n">NsubCluster</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">Nmember</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">Threshold</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="nb">max</span><span class="p">(</span><span class="n">Realmember</span><span class="p">),</span> <span class="mi">3</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">NsubCluster</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="c1"># isolated cluster made from single spectrum should be omitted</span>
                <span class="k">if</span> <span class="n">Nmember</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="n">MemberList</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">GridMember</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">Nmember</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="c1"># Sub-Cluster whose member below the threshold is cleaned</span>
                <span class="k">if</span> <span class="n">Nmember</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">Threshold</span><span class="p">:</span>
                    <span class="k">for</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="ow">in</span> <span class="n">MemberList</span><span class="p">[</span><span class="n">n</span><span class="p">]:</span>
                        <span class="n">Plane</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span>
                    <span class="k">del</span> <span class="n">Nmember</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">Realmember</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">MemberList</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">MemberList</span><span class="p">,</span> <span class="n">Realmember</span></div>


<div class="viewcode-block" id="ValidateLineRaster.DoBlur">
<a class="viewcode-back" href="../../../../../_autosummary/pipeline.hsd.tasks.baseline.validation.ValidateLineRaster.html#pipeline.hsd.tasks.baseline.validation.ValidateLineRaster.DoBlur">[docs]</a>
    <span class="k">def</span> <span class="nf">DoBlur</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
               <span class="n">Realmember</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
               <span class="n">nra</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
               <span class="n">ndec</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
               <span class="n">SubPlane</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
               <span class="n">ratio</span><span class="p">:</span> <span class="n">Integral</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Blur cluster subplane.</span>

<span class="sd">        Convolve subplane data with two-dimensional boxcar kernal whose</span>
<span class="sd">        radius depends on Realmember and ratio.</span>

<span class="sd">            R_blur = sqrt(Realmember / pi) * ratio + 1.5</span>

<span class="sd">        Args:</span>
<span class="sd">            Realmember: Number of valid cluster members in the subplane</span>
<span class="sd">            nra: Number of horizontal grids</span>
<span class="sd">            ndec: Number of vertical grids</span>
<span class="sd">            SubPlane: Spatial distribution of Valid detections.</span>
<span class="sd">            ratio: Factor for blur radius</span>

<span class="sd">        Returns:</span>
<span class="sd">            2-tuple of numpy arrays. First one is an integer binary array</span>
<span class="sd">            of whether original (pre-blur) pixels are Valid detection</span>
<span class="sd">            while the second array is also an integer binary array</span>
<span class="sd">            of whether blurred pixels are Valid or Marginal detection</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Calculate Blur radius</span>
        <span class="n">BlurF</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">Realmember</span> <span class="o">/</span> <span class="mf">3.141592653</span><span class="p">)</span> <span class="o">*</span> <span class="n">ratio</span> <span class="o">+</span> <span class="mf">1.5</span>
        <span class="n">Blur</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">BlurF</span><span class="p">)</span>
        <span class="c1"># Set-up kernel for convolution</span>
        <span class="c1"># caution: if nra &lt; (Blur*2+1) and ndec &lt; (Blur*2+1)</span>
        <span class="c1">#  =&gt; dimension of SPC.convolve2d(Sub,kernel) gets not (nra,ndec) but (Blur*2+1,Blur*2+1)</span>
        <span class="k">if</span> <span class="n">nra</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">Blur</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="n">ndec</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">Blur</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span> <span class="n">Blur</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="nb">max</span><span class="p">(</span><span class="n">nra</span><span class="p">,</span> <span class="n">ndec</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">kernel</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">Blur</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">Blur</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Blur</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">dx</span> <span class="o">=</span> <span class="n">Blur</span> <span class="o">-</span> <span class="n">x</span>
            <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Blur</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">dy</span> <span class="o">=</span> <span class="n">Blur</span> <span class="o">-</span> <span class="n">y</span>
                <span class="k">if</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">dx</span><span class="o">*</span><span class="n">dx</span> <span class="o">+</span> <span class="n">dy</span><span class="o">*</span><span class="n">dy</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">BlurF</span><span class="p">:</span>
                    <span class="n">kernel</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="c1"># ValidPlane is used for fitting parameters</span>
        <span class="c1"># BlurPlane is not used for fitting but just extend the parameter determined in ValidPlane</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">SubPlane</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">Valid</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">convolve2d</span><span class="p">(</span><span class="n">SubPlane</span><span class="p">,</span> <span class="n">kernel</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">Marginal</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1</span></div>


<div class="viewcode-block" id="ValidateLineRaster.calc_ProtectMask">
<a class="viewcode-back" href="../../../../../_autosummary/pipeline.hsd.tasks.baseline.validation.ValidateLineRaster.html#pipeline.hsd.tasks.baseline.validation.ValidateLineRaster.calc_ProtectMask">[docs]</a>
    <span class="k">def</span> <span class="nf">calc_ProtectMask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Center</span><span class="p">:</span> <span class="n">Integral</span><span class="p">,</span> <span class="n">Width</span><span class="p">:</span> <span class="n">Integral</span><span class="p">,</span> <span class="n">nchan</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">MinFWHM</span><span class="p">:</span> <span class="n">Integral</span><span class="p">,</span> <span class="n">MaxFWHM</span><span class="p">:</span> <span class="n">Integral</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return ProtectMask according to Center and Width.</span>

<span class="sd">        Return ProtectMask: [MaskL, MaskR]</span>

<span class="sd">        This method translates a range of protected range given as (center, width) value</span>
<span class="sd">        into (start, end) style. Effective width of the translated range is calculated</span>
<span class="sd">        from the original with and the input parameters.</span>

<span class="sd">        Args:</span>
<span class="sd">            Center: Center of the range</span>
<span class="sd">            Width: Width of the range</span>
<span class="sd">            nchan: Number of channels of the spectrum</span>
<span class="sd">            MinFWHM: Minimum FWHM</span>
<span class="sd">            MaxFTHM: Maximum FWHM</span>

<span class="sd">        Returns:</span>
<span class="sd">            Range of protected range as (start, end) value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># To keep broad line region, make allowance larger</span>
        <span class="c1">### 2015/04/23 Allowance=MaxFWHM at x=MaxFWHM, Allowance=2xMinFWHM+10 at x=MinFWHM</span>
        <span class="n">Allowance</span> <span class="o">=</span> <span class="p">((</span><span class="n">MaxFWHM</span><span class="o">-</span><span class="n">Width</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">MinFWHM</span><span class="o">+</span><span class="mf">10.0</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">Width</span><span class="o">-</span><span class="n">MinFWHM</span><span class="p">)</span><span class="o">*</span><span class="n">MaxFWHM</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">MaxFWHM</span><span class="o">-</span><span class="n">MinFWHM</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="c1">### 2011/10/21 left side mask exceeded nchan</span>
        <span class="n">ProtectMask</span> <span class="o">=</span> <span class="p">[</span><span class="nb">min</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">Center</span> <span class="o">-</span> <span class="n">Allowance</span><span class="p">),</span> <span class="mi">0</span><span class="p">),</span> <span class="n">nchan</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="nb">min</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">Center</span> <span class="o">+</span> <span class="n">Allowance</span><span class="p">),</span> <span class="n">nchan</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;Allowance = </span><span class="si">%s</span><span class="s1"> ProtectMask = </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">Allowance</span><span class="p">,</span> <span class="n">ProtectMask</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">ProtectMask</span></div>


    <span class="k">def</span> <span class="nf">__merge_lines</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lines</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Integral</span><span class="p">]],</span> <span class="n">nchan</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Integral</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Merge overlapping lines.</span>

<span class="sd">        Args:</span>
<span class="sd">            lines: List of lines as (start, end) list</span>
<span class="sd">            nchan: Number of channels</span>

<span class="sd">        Returns:</span>
<span class="sd">            Merged list of lines</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nlines</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">nlines</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="k">elif</span> <span class="n">nlines</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">lines</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># TN refactoring</span>
            <span class="c1"># New line merge algorithm that doesn&#39;t require 1-d array with</span>
            <span class="c1"># length of nchan+2. It will be faster if nchan is large while</span>
            <span class="c1"># it would be slow when number of lines is (extremely) large.</span>
            <span class="n">nlines</span> <span class="o">*=</span> <span class="mi">2</span>
            <span class="n">flat_lines</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">nlines</span><span class="p">))</span>
            <span class="n">sorted_index</span> <span class="o">=</span> <span class="n">flat_lines</span><span class="o">.</span><span class="n">argsort</span><span class="p">()</span>
            <span class="n">flag</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">left_edge</span> <span class="o">=</span> <span class="n">flat_lines</span><span class="p">[</span><span class="n">sorted_index</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="n">nedges</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nlines</span><span class="o">-</span><span class="mi">2</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">sorted_index</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">flag</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1">#flag = min(0, flag + 1)</span>
                    <span class="n">flag</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">flag</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">flat_lines</span><span class="p">[</span><span class="n">sorted_index</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">!=</span> <span class="n">flat_lines</span><span class="p">[</span><span class="n">sorted_index</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]]:</span>
                    <span class="n">sorted_index</span><span class="p">[</span><span class="n">nedges</span><span class="p">]</span> <span class="o">=</span> <span class="n">left_edge</span>
                    <span class="n">sorted_index</span><span class="p">[</span><span class="n">nedges</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">flat_lines</span><span class="p">[</span><span class="n">sorted_index</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
                    <span class="n">nedges</span> <span class="o">+=</span> <span class="mi">2</span>
                    <span class="n">left_edge</span> <span class="o">=</span> <span class="n">flat_lines</span><span class="p">[</span><span class="n">sorted_index</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]]</span>
            <span class="n">sorted_index</span><span class="p">[</span><span class="n">nedges</span><span class="p">]</span> <span class="o">=</span> <span class="n">left_edge</span>
            <span class="n">sorted_index</span><span class="p">[</span><span class="n">nedges</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">flat_lines</span><span class="p">[</span><span class="n">sorted_index</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
            <span class="n">nedges</span> <span class="o">+=</span> <span class="mi">2</span>
            <span class="k">return</span> <span class="n">sorted_index</span><span class="p">[:</span><span class="n">nedges</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">nedges</span><span class="o">//</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__update_cluster_flag</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">cluster_flag</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">stage</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">GridCluster</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">threshold</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Integral</span><span class="p">],</span>
        <span class="n">factor</span><span class="p">:</span> <span class="nb">int</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Update cluster flag array.</span>

<span class="sd">        Set integer flag to cluster flag array (cluster_flag) according</span>
<span class="sd">        to the detection rate and its threshold. Flag values are set to</span>
<span class="sd">        the digit specified by the factor.</span>

<span class="sd">        cluster_flag is data for plotting clustering analysis results.</span>
<span class="sd">        It stores GridCluster quantized by given thresholds.</span>
<span class="sd">        it is defined as integer array and one digit is assigned to</span>
<span class="sd">        one clustering stage in each integer value:</span>

<span class="sd">            1st digit: detection</span>
<span class="sd">            2nd digit: validation</span>
<span class="sd">            3rd digit: smoothing</span>
<span class="sd">            4th digit: final</span>

<span class="sd">        If GridCluster value exceeds any threshold, corresponding</span>
<span class="sd">        digit is incremented. For example, flag 3210 stands for,</span>

<span class="sd">            value didn&#39;t exceed any thresholds in detection, and</span>
<span class="sd">            exceeded one (out of three) threshold in validation, and</span>
<span class="sd">            exceeded two (out of three) thresholds in smoothing, and</span>
<span class="sd">            exceeded three (out of four) thresholds in final.</span>

<span class="sd">        Args:</span>
<span class="sd">            cluster_flag: Two-dimensional array holding flag information</span>
<span class="sd">            stage: Name of the cluster validation stage</span>
<span class="sd">            GridCluster: Number of clusters detected in each spatial position.</span>
<span class="sd">                         Each array element ranges from 0 (no cluster in the</span>
<span class="sd">                         position) to 3 (detected cluster in all spectra in</span>
<span class="sd">                         the position).</span>
<span class="sd">            threshold: Threshold for cluster flag. This specifies the threshold</span>
<span class="sd">                       for the detection rate, which ranges from 0 to 1. Important</span>
<span class="sd">                       values for threshold is 0.333 (1/3), and 0.666 (2/3).</span>
<span class="sd">            factor: Digit control factor</span>

<span class="sd">        Returns:</span>
<span class="sd">            Updated cluster flag array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#cluster_flag = self.cluster_info[&#39;cluster_flag&#39;]</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">threshold</span><span class="p">:</span>
            <span class="n">cluster_flag</span> <span class="o">=</span> <span class="n">cluster_flag</span> <span class="o">+</span> <span class="n">factor</span> <span class="o">*</span> <span class="p">(</span><span class="n">GridCluster</span> <span class="o">&gt;</span> <span class="n">t</span><span class="p">)</span>
        <span class="c1">#self.cluster_info[&#39;cluster_flag&#39;] = cluster_flag</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cluster_info</span><span class="p">[</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">_threshold&#39;</span><span class="o">%</span><span class="p">(</span><span class="n">stage</span><span class="p">)]</span> <span class="o">=</span> <span class="n">threshold</span>
        <span class="c1">#LOG.trace(&#39;cluster_flag = {}&#39;, cluster_flag)</span>
        <span class="k">return</span> <span class="n">cluster_flag</span></div>



<div class="viewcode-block" id="convolve2d">
<a class="viewcode-back" href="../../../../../_autosummary/pipeline.hsd.tasks.baseline.validation.convolve2d.html#pipeline.hsd.tasks.baseline.validation.convolve2d">[docs]</a>
<span class="k">def</span> <span class="nf">convolve2d</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">kernel</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;nearest&#39;</span><span class="p">,</span> <span class="n">cval</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Perform two-dimensional convolution.</span>

<span class="sd">    Perform two-dimensional convolution. This implements direct convolution</span>
<span class="sd">    rather than FFT based one. Returne array has the same shape as the input.</span>

<span class="sd">    Args:</span>
<span class="sd">        data: Two-dimensional array to be convolved</span>
<span class="sd">        kernel: Convolution kernel as two-dimensional array</span>
<span class="sd">        mode: Mode to handle edge values. Two options are available.</span>

<span class="sd">                - &#39;nearest&#39;  use nearest pixel value for pixels beyond the edge</span>
<span class="sd">                - &#39;constant&#39; use cval for pixels beyond the edge</span>

<span class="sd">              Defaults to &#39;nearest&#39;.</span>
<span class="sd">        cval: Constant value used when mode is &#39;constant&#39;</span>

<span class="sd">    Returns:</span>
<span class="sd">        Colvolved data array with the same shape as input data array</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="p">(</span><span class="n">ndx</span><span class="p">,</span> <span class="n">ndy</span><span class="p">)</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span>
    <span class="p">(</span><span class="n">nkx</span><span class="p">,</span> <span class="n">nky</span><span class="p">)</span> <span class="o">=</span> <span class="n">kernel</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">edgex</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">nkx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">edgey</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">nky</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">dummy</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">ndx</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">edgex</span><span class="p">,</span> <span class="n">ndy</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">edgey</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span> <span class="o">*</span> <span class="n">cval</span>
    <span class="n">dummy</span><span class="p">[</span><span class="n">edgex</span><span class="p">:</span><span class="n">ndx</span><span class="o">+</span><span class="n">edgex</span><span class="p">,</span> <span class="n">edgey</span><span class="p">:</span><span class="n">ndy</span><span class="o">+</span><span class="n">edgey</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span>
    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;nearest&#39;</span><span class="p">:</span>
        <span class="n">dummy</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">edgex</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">edgey</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">dummy</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">edgex</span><span class="p">,</span> <span class="n">edgey</span><span class="o">+</span><span class="n">ndy</span><span class="p">:]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">ndy</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">dummy</span><span class="p">[</span><span class="n">edgex</span><span class="o">+</span><span class="n">ndx</span><span class="p">:,</span> <span class="mi">0</span><span class="p">:</span><span class="n">edgey</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">ndx</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">dummy</span><span class="p">[</span><span class="n">edgex</span><span class="o">+</span><span class="n">ndx</span><span class="p">:,</span> <span class="n">edgey</span><span class="o">+</span><span class="n">ndy</span><span class="p">:]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">ndx</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">ndy</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ndx</span><span class="p">):</span>
            <span class="n">dummy</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">edgex</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">edgey</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">dummy</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">edgex</span><span class="p">,</span> <span class="n">edgey</span><span class="o">+</span><span class="n">ndy</span><span class="p">:]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">ndy</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ndy</span><span class="p">):</span>
            <span class="n">dummy</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">edgex</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="n">edgey</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
            <span class="n">dummy</span><span class="p">[</span><span class="n">edgex</span><span class="o">+</span><span class="n">ndx</span><span class="p">:,</span> <span class="n">i</span><span class="o">+</span><span class="n">edgey</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">ndx</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
    <span class="n">cdata</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ndx</span><span class="p">,</span> <span class="n">ndy</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">ix</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ndx</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">iy</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ndy</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">jx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nkx</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">jy</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nky</span><span class="p">):</span>
                    <span class="n">idx</span> <span class="o">=</span> <span class="n">ix</span> <span class="o">+</span> <span class="n">jx</span>
                    <span class="n">idy</span> <span class="o">=</span> <span class="n">iy</span> <span class="o">+</span> <span class="n">jy</span>
                    <span class="n">val</span> <span class="o">=</span> <span class="n">dummy</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="n">idy</span><span class="p">]</span>
                    <span class="n">cdata</span><span class="p">[</span><span class="n">ix</span><span class="p">][</span><span class="n">iy</span><span class="p">]</span> <span class="o">+=</span> <span class="n">kernel</span><span class="p">[</span><span class="n">jx</span><span class="p">][</span><span class="n">jy</span><span class="p">]</span> <span class="o">*</span> <span class="n">val</span>
    <span class="k">return</span> <span class="n">cdata</span></div>



<span class="k">def</span> <span class="nf">_eval_poly</span><span class="p">(</span>
    <span class="n">xorder</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">yorder</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Integral</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">Integral</span><span class="p">,</span>
    <span class="n">xcoeff</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Integral</span><span class="p">],</span> <span class="n">ycoeff</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Integral</span><span class="p">]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Integral</span><span class="p">,</span> <span class="n">Integral</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Evaluate sum of the polynomial terms.</span>

<span class="sd">    It computes sum of two-dimensional polynomial terms</span>
<span class="sd">    provided by xorder, yorder, xcoeff, and ycoeff.</span>
<span class="sd">    While xorder and yorder indicates maximum order of</span>
<span class="sd">    the polynomial, xcoeff and ycoeff provides coefficients</span>
<span class="sd">    of each polynomial term.</span>

<span class="sd">    Args:</span>
<span class="sd">        xorder: Maximum polynomial order for x</span>
<span class="sd">        yorder: Maximum polynomial order for y</span>
<span class="sd">        x: x value</span>
<span class="sd">        y: y value</span>
<span class="sd">        xcoeff: Coefficients for polynomial</span>
<span class="sd">        ycoeff: Coefficients for polynomial</span>

<span class="sd">    Returns:</span>
<span class="sd">        Sum of the polynomials</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">xpoly</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">ypoly</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">yk</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">yorder</span><span class="p">):</span>
        <span class="n">xjyk</span> <span class="o">=</span> <span class="n">yk</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">xorder</span><span class="p">):</span>
            <span class="n">xpoly</span> <span class="o">+=</span> <span class="n">xjyk</span> <span class="o">*</span> <span class="n">xcoeff</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
            <span class="n">ypoly</span> <span class="o">+=</span> <span class="n">xjyk</span> <span class="o">*</span> <span class="n">ycoeff</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
            <span class="n">xjyk</span> <span class="o">*=</span> <span class="n">x</span>
            <span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">yk</span> <span class="o">*=</span> <span class="n">y</span>
    <span class="k">return</span> <span class="n">xpoly</span><span class="p">,</span> <span class="n">ypoly</span>


<span class="k">def</span> <span class="nf">_to_validated_lines</span><span class="p">(</span><span class="n">detect_lines</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert list of detected lines into list with flags.</span>

<span class="sd">    In addition to the conversion from dict to list, it also converts</span>
<span class="sd">    [chmin, chmax] style line information into [center, width] style</span>
<span class="sd">    and adds flag information (initially all True).</span>

<span class="sd">    Args:</span>
<span class="sd">        detect_lines: List of detected lines</span>

<span class="sd">    Returns:</span>
<span class="sd">        Converted list of detected lines with flag</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># conversion from [chmin, chmax] to [center, width, T/F]</span>
    <span class="n">lines</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">line_prop</span> <span class="ow">in</span> <span class="n">detect_lines</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">line_prop</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">line</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">:</span>
                <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
    <span class="n">lines_withflag</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">0.5</span><span class="o">*</span><span class="nb">sum</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="kc">True</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">lines_withflag</span>


<div class="viewcode-block" id="SVDSolver2D">
<a class="viewcode-back" href="../../../../../_autosummary/pipeline.hsd.tasks.baseline.validation.SVDSolver2D.html#pipeline.hsd.tasks.baseline.validation.SVDSolver2D">[docs]</a>
<span class="k">class</span> <span class="nc">SVDSolver2D</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Least-square solver based on singular value decomposition (SVD).</span>

<span class="sd">    The singular value decomposition (SVD) is a factorization of a</span>
<span class="sd">    matrix, which has many practical mathematical application.</span>
<span class="sd">    This class determines the best coefficients of two-dimensional</span>
<span class="sd">    polynomials in a least-square sense using SVD.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">CONDITION_NUMBER_LIMIT</span> <span class="o">=</span> <span class="mf">1.0e-12</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xorder</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">yorder</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Construct SVDSolver2D instance.</span>

<span class="sd">        Args:</span>
<span class="sd">            xorder: Maximum order of x-polynomial. Must be 0 or positive.</span>
<span class="sd">            yorder: Maximum order of y-polynomial. Must be 0 or positive.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xorder</span> <span class="o">=</span> <span class="n">xorder</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">yorder</span> <span class="o">=</span> <span class="n">yorder</span>

        <span class="k">assert</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xorder</span>
        <span class="k">assert</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">yorder</span>

        <span class="c1"># internal storage for solver</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">L</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xorder</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">yorder</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># design matrix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">storage</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">G</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># for SVD</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Vs</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">B</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">U</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="SVDSolver2D.set_data_points">
<a class="viewcode-back" href="../../../../../_autosummary/pipeline.hsd.tasks.baseline.validation.SVDSolver2D.html#pipeline.hsd.tasks.baseline.validation.SVDSolver2D.set_data_points">[docs]</a>
    <span class="k">def</span> <span class="nf">set_data_points</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Integral</span><span class="p">],</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">y</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Integral</span><span class="p">],</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set data array.</span>

<span class="sd">        Configure design matrix from the input data arrays.</span>

<span class="sd">        Args:</span>
<span class="sd">            x: One-dimensional data array</span>
<span class="sd">            y: One-dimensional data array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">ny</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;nx, ny = </span><span class="si">%s</span><span class="s1">, </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">nx</span> <span class="o">==</span> <span class="n">ny</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">&lt;</span> <span class="n">nx</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">storage</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">storage</span><span class="p">,</span> <span class="n">nx</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">=</span> <span class="n">nx</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">G</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">storage</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">))</span>

        <span class="c1"># matrix operation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_design_matrix</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span></div>

        <span class="c1">#self._svd()</span>

    <span class="k">def</span> <span class="nf">_set_design_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Integral</span><span class="p">],</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">y</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Integral</span><span class="p">],</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Configure design matrix.</span>

<span class="sd">        The design matrix G is a basis array that stores gj(xi)</span>
<span class="sd">        where</span>

<span class="sd">            g0  = 1,   g1  = x,     g2  = x^2      g3  = x^3,</span>
<span class="sd">            g4  = y,   g5  = x y,   g6  = x^2 y,   g7  = x^3 y</span>
<span class="sd">            g8  = y^2, g9  = x y^2, g10 = x^2 y^2, g11 = x^3 y^2</span>
<span class="sd">            g12 = y^3, g13 = x y^3, g14 = x^2 y^3, g15 = x^3 y^3</span>

<span class="sd">        when xorder = 3 and yorder = 3</span>

<span class="sd">        Args:</span>
<span class="sd">            x: One-dimensional data array</span>
<span class="sd">            y: One-dimensional data array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">):</span>
            <span class="n">yp</span> <span class="o">=</span> <span class="mf">1.0</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">yorder</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">xp</span> <span class="o">=</span> <span class="mf">1.0</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xorder</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="n">l</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xorder</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">i</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">xp</span> <span class="o">*</span> <span class="n">yp</span>
                    <span class="n">xp</span> <span class="o">*=</span> <span class="n">x</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                <span class="n">yp</span> <span class="o">*=</span> <span class="n">y</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_do_svd</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Perform singular value decomposition (SVD).&quot;&quot;&quot;</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;G.shape=</span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Vh</span> <span class="o">=</span> <span class="n">LA</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">,</span> <span class="n">full_matrices</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;U.shape=</span><span class="si">%s</span><span class="s1"> (N,L)=(</span><span class="si">%s</span><span class="s1">,</span><span class="si">%s</span><span class="s1">)&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">)</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;s.shape=</span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;Vh.shape=</span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Vh</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;s = </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="p">)</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">Vh</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_svd_with_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nmask</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute intermediate matrix for SVD least-square problem.</span>

<span class="sd">        Args:</span>
<span class="sd">            nmask: Number of singular values to be masked. Defaults to 0.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;s&#39;</span><span class="p">):</span>
            <span class="c1"># do SVD</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_do_svd</span><span class="p">()</span>

        <span class="k">assert</span> <span class="n">nmask</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span>

        <span class="k">for</span> <span class="n">icol</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">icol</span> <span class="o">&lt;</span> <span class="n">nmask</span><span class="p">:</span>
                <span class="n">sinv</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sinv</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="p">[</span><span class="n">icol</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">irow</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">Vs</span><span class="p">[</span><span class="n">irow</span><span class="p">,</span> <span class="n">icol</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Vh</span><span class="p">[</span><span class="n">icol</span><span class="p">,</span> <span class="n">irow</span><span class="p">]</span> <span class="o">*</span> <span class="n">sinv</span>

    <span class="k">def</span> <span class="nf">_svd_with_eps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">eps</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0e-7</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute intermediate matrix for SVD least-square problem.</span>

<span class="sd">        Args:</span>
<span class="sd">            eps: Threshold for masking singular values. Defaults to 1.0e-7.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;s&#39;</span><span class="p">):</span>
            <span class="c1"># do SVD</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_do_svd</span><span class="p">()</span>

        <span class="k">assert</span> <span class="mf">0.0</span> <span class="o">&lt;</span> <span class="n">eps</span>

        <span class="c1"># max value of s is always s[0] since it is sorted</span>
        <span class="c1"># in descendent order</span>
        <span class="c1">#threshold = self.s.max() * eps</span>
        <span class="n">threshold</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">eps</span>
        <span class="k">for</span> <span class="n">icol</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="p">[</span><span class="n">icol</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">threshold</span><span class="p">:</span>
                <span class="n">sinv</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sinv</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="p">[</span><span class="n">icol</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">irow</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">Vs</span><span class="p">[</span><span class="n">irow</span><span class="p">,</span> <span class="n">icol</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Vh</span><span class="p">[</span><span class="n">icol</span><span class="p">,</span> <span class="n">irow</span><span class="p">]</span> <span class="o">*</span> <span class="n">sinv</span>

    <span class="k">def</span> <span class="nf">_svd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">eps</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Perform singular value decomposition (SVD).</span>

<span class="sd">        After SVD, singular values are compared with the threshold</span>
<span class="sd">        determined by the max singular value with threshold factor,</span>
<span class="sd">        eps, and values less than threshold are masked.</span>

<span class="sd">        Args:</span>
<span class="sd">            eps: Threshold factor for masking singular value</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;G.shape=</span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">Vh</span> <span class="o">=</span> <span class="n">LA</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">,</span> <span class="n">full_matrices</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;U.shape=</span><span class="si">%s</span><span class="s1"> (N,L)=(</span><span class="si">%s</span><span class="s1">,</span><span class="si">%s</span><span class="s1">)&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">)</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;s.shape=</span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;Vh.shape=</span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">Vh</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span>
        <span class="k">assert</span> <span class="n">Vh</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">)</span>
        <span class="k">assert</span> <span class="mf">0.0</span> <span class="o">&lt;</span> <span class="n">eps</span>

        <span class="n">threshold</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">*</span> <span class="n">eps</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">threshold</span><span class="p">:</span>
                <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">icol</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">irow</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">Vs</span><span class="p">[</span><span class="n">irow</span><span class="p">,</span> <span class="n">icol</span><span class="p">]</span> <span class="o">=</span> <span class="n">Vh</span><span class="p">[</span><span class="n">icol</span><span class="p">,</span> <span class="n">irow</span><span class="p">]</span> <span class="o">*</span> <span class="n">s</span><span class="p">[</span><span class="n">icol</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_eval_poly_from_G</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">row</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">coeff</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Evaluate polynomial with given coefficients.</span>

<span class="sd">        Args:</span>
<span class="sd">            row: Row id for the matrix</span>
<span class="sd">            coeff: Polynomial coefficient. Least-square solution.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Resulting value</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">poly</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">yorder</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xorder</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">poly</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">[</span><span class="n">row</span><span class="p">,</span> <span class="n">idx</span><span class="p">]</span> <span class="o">*</span> <span class="n">coeff</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
                <span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">poly</span>

<div class="viewcode-block" id="SVDSolver2D.solve_with_mask">
<a class="viewcode-back" href="../../../../../_autosummary/pipeline.hsd.tasks.baseline.validation.SVDSolver2D.html#pipeline.hsd.tasks.baseline.validation.SVDSolver2D.solve_with_mask">[docs]</a>
    <span class="k">def</span> <span class="nf">solve_with_mask</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">z</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Integral</span><span class="p">],</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
        <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">nmask</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Solve least-square problem with SVD.</span>

<span class="sd">        Find x which minimizes ||A x - b||^2 where A is design matrix and</span>
<span class="sd">        b is a vector given as arg (denoted to z).</span>

<span class="sd">        With this method, one can specify number of singular values to</span>
<span class="sd">        be masked to obtain stable solution.</span>

<span class="sd">        Args:</span>
<span class="sd">            z: right hand side vector</span>
<span class="sd">            out: Storage for output solution. This is used when memory for the</span>
<span class="sd">                 solution is allocated externally. Defaults to None.</span>
<span class="sd">            nmask: Number of singular values to be masked. Defaults to 0.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Least-square solution</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nz</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">nz</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_svd_with_mask</span><span class="p">(</span><span class="n">nmask</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">A</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">A</span> <span class="o">=</span> <span class="n">out</span>
            <span class="n">A</span><span class="p">[:]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">B</span><span class="p">[:]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">z</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">):</span>
                <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Vs</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">B</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">A</span></div>


<div class="viewcode-block" id="SVDSolver2D.solve_with_eps">
<a class="viewcode-back" href="../../../../../_autosummary/pipeline.hsd.tasks.baseline.validation.SVDSolver2D.html#pipeline.hsd.tasks.baseline.validation.SVDSolver2D.solve_with_eps">[docs]</a>
    <span class="k">def</span> <span class="nf">solve_with_eps</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">z</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Integral</span><span class="p">],</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
        <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">eps</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0e-7</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Solve least-square problem with SVD.</span>

<span class="sd">        Find x which minimizes ||A x - b||^2 where A is design matrix and</span>
<span class="sd">        b is a vector given as arg (denoted to z).</span>

<span class="sd">        With this method, one can specify the threshold for singular values</span>
<span class="sd">        to be masked to obtain stable solution.</span>

<span class="sd">        Args:</span>
<span class="sd">            z: right hand side vector</span>
<span class="sd">            out: Storage for output solution. Defaults to None.</span>
<span class="sd">            eps: Threshold factor for masking singular values. Defaults to 1.0e-7.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Least-square solution</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="mf">0.0</span> <span class="o">&lt;=</span> <span class="n">eps</span>

        <span class="n">nz</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">nz</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_svd_with_eps</span><span class="p">(</span><span class="n">eps</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">A</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">A</span> <span class="o">=</span> <span class="n">out</span>
            <span class="n">A</span><span class="p">[:]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">B</span><span class="p">[:]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">z</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">):</span>
                <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Vs</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">B</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">A</span></div>


<div class="viewcode-block" id="SVDSolver2D.solve_for">
<a class="viewcode-back" href="../../../../../_autosummary/pipeline.hsd.tasks.baseline.validation.SVDSolver2D.html#pipeline.hsd.tasks.baseline.validation.SVDSolver2D.solve_for">[docs]</a>
    <span class="k">def</span> <span class="nf">solve_for</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">z</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Integral</span><span class="p">],</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
        <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">eps</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0e-7</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Solve least-square problem with SVD.</span>

<span class="sd">        Find x which minimizes ||A x - b||^2 where A is design matrix and</span>
<span class="sd">        b is a vector given as arg (denoted to z).</span>

<span class="sd">        With this method, one can specify the threshold for singular values</span>
<span class="sd">        to be masked to obtain stable solution.</span>

<span class="sd">        Args:</span>
<span class="sd">            z: right hand side vector</span>
<span class="sd">            out: Storage for output solution. Defaults to None.</span>
<span class="sd">            eps: Threshold factor for masking singular values. Defaults to 1.0e-7.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Least-square solution</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="mf">0.0</span> <span class="o">&lt;=</span> <span class="n">eps</span>

        <span class="n">nz</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">nz</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_svd</span><span class="p">(</span><span class="n">eps</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">A</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">A</span> <span class="o">=</span> <span class="n">out</span>
            <span class="n">A</span><span class="p">[:]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">B</span><span class="p">[:]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">z</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">):</span>
                <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Vs</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">B</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">A</span></div>


<div class="viewcode-block" id="SVDSolver2D.find_good_solution">
<a class="viewcode-back" href="../../../../../_autosummary/pipeline.hsd.tasks.baseline.validation.SVDSolver2D.html#pipeline.hsd.tasks.baseline.validation.SVDSolver2D.find_good_solution">[docs]</a>
    <span class="k">def</span> <span class="nf">find_good_solution</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">z</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Integral</span><span class="p">],</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
        <span class="n">threshold</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.05</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Find the best least-square solution from candidate SVD solutions.</span>

<span class="sd">        Find x which minimizes ||A x - b||^2 where A is design matrix and</span>
<span class="sd">        b is a vector given as arg (denoted to z).</span>

<span class="sd">        This method examines the solution with various masking threshold</span>
<span class="sd">        for singular value, and find the best solution among them.</span>
<span class="sd">        Range of masking threshold value is chosen empirically. Currently,</span>
<span class="sd">        the values ranging from 10^-11 to 10^-3 are examined.</span>

<span class="sd">        Solutions are scored based on the mean fractional deviation from</span>
<span class="sd">        actual data. If fractional deviaion exceeds threshold given as</span>
<span class="sd">        an argument, that will be noticed via the log message.</span>
<span class="sd">        If fractional deviation exceeds 1.0, exception will be thrown.</span>

<span class="sd">        Args:</span>
<span class="sd">            z: right hand side vector</span>
<span class="sd">            threshold: Threshold for score. Should be 0 or positive value.</span>
<span class="sd">                       Defaults to 0.05.</span>

<span class="sd">        Raises:</span>
<span class="sd">            RuntimeError: No good least-square solution is found</span>

<span class="sd">        Returns:</span>
<span class="sd">            The best least-square solution</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="mf">0.0</span> <span class="o">&lt;=</span> <span class="n">threshold</span>
        <span class="n">eps_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="o">**</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="mi">11</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">)]</span>

        <span class="n">best_score</span> <span class="o">=</span> <span class="mf">1e30</span>
        <span class="n">best_eps</span> <span class="o">=</span> <span class="n">eps_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">intlog</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">best_ans</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="c1"># do SVD</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_do_svd</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">eps</span> <span class="ow">in</span> <span class="n">eps_list</span><span class="p">:</span>
            <span class="n">ans</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solve_with_eps</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">ans</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="n">eps</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">):</span>
                <span class="n">fit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_poly_from_G</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">ans</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">diff</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">((</span><span class="n">fit</span> <span class="o">-</span> <span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">/</span> <span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">diff</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">fit</span>
            <span class="n">score</span> <span class="o">=</span> <span class="n">diff</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;eps=</span><span class="si">%s</span><span class="s1">, score=</span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">intlog</span><span class="p">(</span><span class="n">eps</span><span class="p">),</span> <span class="n">score</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">best_ans</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">score</span> <span class="o">&lt;</span> <span class="n">best_score</span><span class="p">:</span>
                <span class="n">best_ans</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">ans</span>
                <span class="n">best_score</span> <span class="o">=</span> <span class="n">score</span>
                <span class="n">best_eps</span> <span class="o">=</span> <span class="n">eps</span>
        <span class="k">if</span> <span class="mf">1.0</span> <span class="o">&lt;=</span> <span class="n">best_score</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;No good solution is found.&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">threshold</span> <span class="o">&lt;</span> <span class="n">best_score</span><span class="p">:</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;Score is higher than given threshold (threshold </span><span class="si">%s</span><span class="s1">, score </span><span class="si">%s</span><span class="s1">)&#39;</span><span class="p">,</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">best_score</span><span class="p">)</span>

        <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;best eps: </span><span class="si">%s</span><span class="s1"> (score </span><span class="si">%s</span><span class="s1">)&#39;</span><span class="p">,</span> <span class="n">intlog</span><span class="p">(</span><span class="n">best_eps</span><span class="p">),</span> <span class="n">best_score</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">best_ans</span></div>
</div>



<div class="viewcode-block" id="ValidationFactory">
<a class="viewcode-back" href="../../../../../_autosummary/pipeline.hsd.tasks.baseline.validation.ValidationFactory.html#pipeline.hsd.tasks.baseline.validation.ValidationFactory">[docs]</a>
<span class="k">def</span> <span class="nf">ValidationFactory</span><span class="p">(</span><span class="n">pattern</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Type</span><span class="p">[</span><span class="n">ValidateLineRaster</span><span class="p">],</span><span class="n">Type</span><span class="p">[</span><span class="n">ValidateLineSinglePointing</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return appropriate task class according to observing pattern.</span>

<span class="sd">    The pattern string must be in uppercase letters.</span>

<span class="sd">    Args:</span>
<span class="sd">        pattern: Observing pattern</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: Invalid observing pattern</span>

<span class="sd">    Returns:</span>
<span class="sd">        Task class. Either ValidateLineRaster or ValidateLineSinglePointing.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">pattern</span> <span class="o">==</span> <span class="s1">&#39;RASTER&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ValidateLineRaster</span>
    <span class="k">elif</span> <span class="n">pattern</span> <span class="o">==</span> <span class="s1">&#39;SINGLE-POINT&#39;</span> <span class="ow">or</span> <span class="n">pattern</span> <span class="o">==</span> <span class="s1">&#39;MULTI-POINT&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ValidateLineSinglePointing</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid observing pattern&#39;</span><span class="p">)</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020–2024, Pipeline Dev. Team.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>