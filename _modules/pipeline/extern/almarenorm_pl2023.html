

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>pipeline.extern.almarenorm_pl2023 &mdash; Pipeline unknown documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css?v=4ae1632d" />
      <link rel="stylesheet" type="text/css" href="../../../_static/sphinx_astrorefs.css?v=4d4a2fdb" />
      <link rel="stylesheet" type="text/css" href="../../../_static/custom_theme.css?v=678032d9" />

  
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=3f1b9271"></script>
      <script src="../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            Pipeline
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Releases etc.</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../releases.html">Past Releases</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../dependencies.html">Dependencies of <code class="docutils literal notranslate"><span class="pre">Pipeline</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../modular.html">Run the Pipeline in a Conda environment</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../apisummary.html">Pipeline Tasks (from autosummary)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../apisummary.html#full-list">Full List</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">TaskRef (create_docs.py)</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../_taskdocs/taskdocs.html">List of Heuristics Tasks (Pipeline 2023)</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Pipeline Heuristics</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../heuristics/field_parameter.html">Field parameter</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../heuristics/FlaggingTasks.html">Pipeline Flagging Tasks</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Developer Notes</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../develdocmd/ways_to_run_the_pipeline.html">Ways to run the Pipeline</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../develdocmd/comparing_pipeline_executions.html">Comparing pipeline executions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../develdocmd/building_the_pipeline.html">Building the pipeline</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../develdocmd/ALMA-Imaging-Workflow.html">ALMA interferometry imaging workflow</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../develdocmd/VLA-Imaging-Workflow.html">VLA interferometry imaging workflow</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../develdocmd/VLASS-SE-CONT-Imaging-Workflow.html">VLASS-SE-CONT imaging workflow</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../develdocmd/VLASS-SE-CUBE-Imaging-Workflow.html">VLASS-SE-CUBE imaging workflow</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../develdocmd/selfcal_workflow.html">VLASS Selfcal &amp; Restore workflows</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../develdocmd/pipeline_tests.html">Pipeline testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../develdocmd/DataType_Testing.html">DataType Testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../develdocmd/QA_scores.html">Pipeline Quality Assurance (QA) Score Class Design</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../develdocmd/DeveloperDocumentation.html">Pipeline developer documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../develdocmd/python3_conversion_notes.html">Python 3 conversion notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../develdocmd/recipes.html">Pipeline Recipes</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Pipeline Domain/Context/etc. (automodapi)</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../basics.html"><code class="docutils literal notranslate"><span class="pre">pipeline.domain</span></code> module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../basics.html#module-pipeline.infrastructure.launcher"><code class="docutils literal notranslate"><span class="pre">pipeline.infrastructure.launcher</span></code> module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../basics.html#module-pipeline.infrastructure.callibrary"><code class="docutils literal notranslate"><span class="pre">pipeline.infrastructure.project</span></code> module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../basics.html#pipeline-infrastructure-callibrary-module"><code class="docutils literal notranslate"><span class="pre">pipeline.infrastructure.callibrary</span></code> module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../basics.html#pipeline-infrastructure-imagelibrary-module"><code class="docutils literal notranslate"><span class="pre">pipeline.infrastructure.imagelibrary</span></code> module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../basics.html#module-pipeline.infrastructure.vdp"><code class="docutils literal notranslate"><span class="pre">pipeline.infrastructure.vdp</span></code> module</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Pipeline Domain/Context (autosummary)</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../_autosummary/pipeline.domain.html">pipeline.domain</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../_autosummary/pipeline.infrastructure.launcher.html">pipeline.infrastructure.launcher</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Pipeline Task/Inputs/Results Classes</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../classes.html">Classes in <code class="docutils literal notranslate"><span class="pre">pipeline.h*.tasks</span></code> modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../classes.html#inheritance-diagrams">Inheritance Diagrams</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Notebooks</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../notebooks/context.html">Pipeline Context</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notebooks/tier0dask.html">“Tier0” Parallelization with Dask/Futures</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Examples Notes (from Jupyter Notebooks)</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/test1.html">test</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Example Notes (from .rst)</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/test2.html">Example 1</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">Pipeline</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
          <li class="breadcrumb-item"><a href="../../pipeline.html">pipeline</a></li>
      <li class="breadcrumb-item active">pipeline.extern.almarenorm_pl2023</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for pipeline.extern.almarenorm_pl2023</h1><div class="highlight"><pre>
<span></span><span class="c1">########################################################################</span>
<span class="c1"># almarenorm.py</span>
<span class="c1">#</span>
<span class="c1">#  Script to calculate and optionally apply spectrally-resolved</span>
<span class="c1">#  normalization correction for ALMA in the strong-line case.  This is</span>
<span class="c1">#  needed when Tsys measurements inadequately recover these lines</span>
<span class="c1">#  either because Tsys is measured off-source (12m array and ACA)</span>
<span class="c1">#  and/or at insufficient spectral resolution (12m array only).</span>
<span class="c1">#</span>
<span class="c1"># Usage (from CASA 5.x or CASA 6.1.1-15):</span>
<span class="c1">#</span>
<span class="c1">#  (assumes this python file exists in the current working directory) </span>
<span class="c1">#  </span>
<span class="c1">#  sys.path.append(os.getcwd())  </span>
<span class="c1">#  from almarenorm import *    # import </span>
<span class="c1">#  RN=ACreNorm(&lt;msname&gt;)       # create ACreNorm tool </span>
<span class="c1">#</span>
<span class="c1">### To examine Tsys spectra for spurious lines - BY EYE:</span>
<span class="c1">#</span>
<span class="c1">#  RN.plotRelTsysSpectra(fthresh=0.01) - Luke&#39;s default 0.01 (1%) </span>
<span class="c1">#                                        old default 0.002 is a very </span>
<span class="c1">#                                        low trigger theshold 0.2% level</span>
<span class="c1">#</span>
<span class="c1">#  this will also write a Tsys template file but it should always be checked</span>
<span class="c1">#  as TDM (12m) Tsys are hard to fit and sometime diverage at edges suggesting</span>
<span class="c1">#  to incorrectly flag a broad range of Tsys channel </span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1">### To evaluate the need for the correction on all FDM science spws </span>
<span class="c1">#   and scans (excluding spws as specified), but making NO change in</span>
<span class="c1">#   MS:</span>
<span class="c1">#</span>
<span class="c1">#  RN.renormalize(docorr=False)</span>
<span class="c1">#</span>
<span class="c1"># (The renormalize function will nominally auto-detect all FDM and</span>
<span class="c1">#  science scans to evaluate - without extra options runs default paramaters)</span>
<span class="c1">#</span>
<span class="c1">### To make plots (if hardcopy=True, unique names constructed from &lt;msname&gt;</span>
<span class="c1">#   will be generated for each plot):</span>
<span class="c1">#</span>
<span class="c1">#  RN.plotSpectra(hardcopy=True)     # Scan-averaged Renorm spectra</span>
<span class="c1">#  RN.plotSpwStats(hardcopy=True)    # Scan/Ant-averaged peak stats</span>
<span class="c1">#  RN.plotScanStats(hardcopy=True)   # Scan-dep peak stats</span>
<span class="c1">#</span>
<span class="c1">## To apply the correction to fully-calibrated data (this scales the</span>
<span class="c1">#  CORRECTED_DATA by default, applies the renormalization correction and writes</span>
<span class="c1">#  it back (plot* commands can also be run after this):</span>
<span class="c1">#</span>
<span class="c1">#  RN.renormalize(docorr=True)</span>
<span class="c1">#  </span>
<span class="c1">## Close the ACreNorm tool (detaches from MS, etc.)</span>
<span class="c1">#</span>
<span class="c1">#  RN.close()</span>
<span class="c1">#</span>
<span class="c1">########################################################################</span>
<span class="c1">#</span>
<span class="c1">#  Notes for future development - from some discussion with PLWG </span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1"># - PLWG might want some information to store in MS keywords</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1"># - the plotSpwStats and plotScanStats coded by George I did not use </span>
<span class="c1">#   very much - the way these stats are currently built is that</span>
<span class="c1">#   they only pass the last field of a scan, i.e. the values are </span>
<span class="c1">#   stored in the RN.rnstat dictionary which never had &#39;field&#39; </span>
<span class="c1">#   coded in. plotSpectra I have modified to do the correct </span>
<span class="c1">#   cumulative average and takes all fields - even this could be </span>
<span class="c1">#   split out into a per field basis</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1">#########################################################################</span>

<span class="kn">import</span> <span class="nn">warnings</span>
<span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="n">action</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="ne">FutureWarning</span><span class="p">)</span>

<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Dict</span>
<span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">datetime</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">signal</span>
<span class="kn">import</span> <span class="nn">copy</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">taskinit</span> <span class="kn">import</span> <span class="n">tbtool</span><span class="p">,</span><span class="n">msmdtool</span><span class="p">,</span><span class="n">qatool</span><span class="p">,</span><span class="n">attool</span><span class="p">,</span> <span class="n">mstool</span><span class="p">,</span> <span class="n">casalog</span><span class="p">,</span> <span class="n">metool</span>
<span class="k">except</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">casatools</span> <span class="kn">import</span> <span class="n">table</span> <span class="k">as</span> <span class="n">tbtool</span>
    <span class="kn">from</span> <span class="nn">casatools</span> <span class="kn">import</span> <span class="n">msmetadata</span> <span class="k">as</span> <span class="n">msmdtool</span>
    <span class="kn">from</span> <span class="nn">casatools</span> <span class="kn">import</span> <span class="n">quanta</span> <span class="k">as</span> <span class="n">qatool</span>
    <span class="kn">from</span> <span class="nn">casatools</span> <span class="kn">import</span> <span class="n">atmosphere</span> <span class="k">as</span> <span class="n">attool</span>
    <span class="kn">from</span> <span class="nn">casatools</span> <span class="kn">import</span> <span class="n">ms</span> <span class="k">as</span> <span class="n">mstool</span>
    <span class="kn">from</span> <span class="nn">casatasks</span> <span class="kn">import</span> <span class="n">casalog</span> 
    <span class="kn">from</span> <span class="nn">casatools</span> <span class="kn">import</span> <span class="n">measures</span> <span class="k">as</span> <span class="n">metool</span>

<span class="n">mytb</span><span class="o">=</span><span class="n">tbtool</span><span class="p">()</span>
<span class="n">myms</span><span class="o">=</span><span class="n">mstool</span><span class="p">()</span>


<span class="c1"># Interface function for use by ALMA Pipeline renormalization task (PIPE-1687).</span>
<div class="viewcode-block" id="alma_renorm">
<a class="viewcode-back" href="../../../_autosummary/pipeline.h.tasks.restoredata.restoredata.alma_renorm.html#pipeline.h.tasks.restoredata.restoredata.alma_renorm">[docs]</a>
<span class="k">def</span> <span class="nf">alma_renorm</span><span class="p">(</span><span class="n">vis</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">spw</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">apply</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">threshold</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span> <span class="n">excludechan</span><span class="p">:</span> <span class="n">Dict</span><span class="p">,</span>
                <span class="n">correct_atm</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">atm_auto_exclude</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">bwthreshspw</span><span class="p">:</span> <span class="n">Dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>   <span class="c1">## PIPE-1469 for bwthreshspw</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Interface function for ALMA Pipeline: this runs the ALMA renormalization</span>
<span class="sd">    heuristic for input vis, and returns statistics and metadata required by</span>
<span class="sd">    the Pipeline renormalization task.</span>

<span class="sd">    Args:</span>
<span class="sd">        vis: path to the measurement set to renormalize.</span>
<span class="sd">        spw: Spectral Window IDs to process.</span>
<span class="sd">        apply: apply the correction or not.</span>
<span class="sd">        threshold: the threshold above which the scaling must exceed for the</span>
<span class="sd">            renormalization correction to be applied. If set to None, then use</span>
<span class="sd">            a pre-defined threshold appropriate for the ALMA Band.</span>
<span class="sd">        excludechan: dictionary with keys set to SpW IDs (as string), and</span>
<span class="sd">            values set to channels to exclude for that SpW.</span>
<span class="sd">        correct_atm: this will get the transmission profiles for the SPW</span>
<span class="sd">            bandpass (or phase) and target(s) because the BP (or phase) and</span>
<span class="sd">            target(s) autocorr are compared in establishing the scaling in</span>
<span class="sd">            cases spectra, there can be issues where transmission is low and</span>
<span class="sd">            the source elevations are tens of degrees different. Often the ATM</span>
<span class="sd">            is not divided out well and leads to incorrect scaling in ATM</span>
<span class="sd">            regions. This option acts to fix this discrepancy so ATM are</span>
<span class="sd">            handled correctly.</span>
<span class="sd">        atm_auto_exclude: if True, then spectral regions found during the</span>
<span class="sd">            &quot;check for false positives&quot; algorithm will be excluded from the</span>
<span class="sd">             spectrum.</span>
<span class="sd">        bwthreshspw: disctionary with keys set to SpW IDs (as string), </span>
<span class="sd">            and values set to a bandwidth (in Hz) to use for dividing </span>
<span class="sd">            up the SpWs, e.g. 120e6 </span>

<span class="sd">    Returns: 8-tuple containing:</span>
<span class="sd">        - boolean declaring whether data are all TDM</span>
<span class="sd">        - ATM exclusion command</span>
<span class="sd">        - ATM warning</span>
<span class="sd">        - boolean declaring whether the renormalization correction was found</span>
<span class="sd">          to have already been applied.</span>
<span class="sd">        - boolean declaring whether a corrected data column was found.</span>
<span class="sd">        - boolean declaring whether the renormalization correction was applied.</span>
<span class="sd">        - dictionary containing factors for Pipeline QA.</span>
<span class="sd">        - dictionary containing renormalization statistics indexed by source</span>
<span class="sd">          and SpW.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Initialize the renormalization object for input vis.</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; Doing the initialize in ALMARENORM itself</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">rn</span> <span class="o">=</span> <span class="n">ACreNorm</span><span class="p">(</span><span class="n">vis</span><span class="p">)</span>

    <span class="c1"># Initialize return variables.</span>
    <span class="n">stats</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">rnstats</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">atmWarning</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">atmExcludeCmd</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">renorm_applied</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="c1"># Store &quot;all TDM&quot; information before trying the renormalization so</span>
    <span class="c1"># that the weblog is rendered properly.</span>
    <span class="n">alltdm</span> <span class="o">=</span> <span class="n">rn</span><span class="o">.</span><span class="n">tdm_only</span>

    <span class="c1"># Check if the correction has already been applied.</span>
    <span class="n">corrApplied</span> <span class="o">=</span> <span class="n">rn</span><span class="o">.</span><span class="n">checkApply</span><span class="p">()</span>

    <span class="c1"># Check whether the dataset has a corrected data column.</span>
    <span class="n">corrColExists</span> <span class="o">=</span> <span class="n">rn</span><span class="o">.</span><span class="n">correxists</span>

    <span class="c1"># Only attempt the correction if the data are not all TDM.</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">alltdm</span><span class="p">:</span>
        <span class="c1"># Run the renormalisation.</span>
        <span class="n">rn</span><span class="o">.</span><span class="n">renormalize</span><span class="p">(</span><span class="n">docorr</span><span class="o">=</span><span class="n">apply</span><span class="p">,</span> <span class="n">docorrThresh</span><span class="o">=</span><span class="n">threshold</span><span class="p">,</span> <span class="n">correctATM</span><span class="o">=</span><span class="n">correct_atm</span><span class="p">,</span> <span class="n">spws</span><span class="o">=</span><span class="n">spw</span><span class="p">,</span> <span class="n">excludechan</span><span class="o">=</span><span class="n">excludechan</span><span class="p">,</span>
                       <span class="n">atmAutoExclude</span><span class="o">=</span><span class="n">atm_auto_exclude</span><span class="p">,</span> <span class="n">bwthreshspw</span><span class="o">=</span><span class="n">bwthreshspw</span><span class="p">)</span> <span class="c1"># add bwthreshspw</span>

        <span class="c1"># Create spectra plots.</span>
        <span class="n">rn</span><span class="o">.</span><span class="n">plotSpectra</span><span class="p">(</span><span class="n">includeSummary</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Check if the renormalisation has been applied. This flag will be</span>
        <span class="c1"># passed back to caller, for future export to the manifest and use</span>
        <span class="c1"># during restore.</span>
        <span class="k">if</span> <span class="n">apply</span> <span class="ow">and</span> <span class="n">rn</span><span class="o">.</span><span class="n">checkApply</span><span class="p">():</span>
            <span class="n">renorm_applied</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># Only populate the following variables used for QA and to populate the</span>
        <span class="c1"># weblog if this was run in a &#39;valid&#39; way: on data which has not</span>
        <span class="c1"># already been corrected (not corrApplied) and on data which has a</span>
        <span class="c1"># corrected column. If apply=False, it doesn&#39;t matter if the corrected</span>
        <span class="c1"># column exists or if the data has already been corrected, because the</span>
        <span class="c1"># correction isn&#39;t actually done.</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">corrColExists</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">apply</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">corrApplied</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">apply</span><span class="p">):</span>
            <span class="c1"># Get stats (dictionary) indexed by source, spw</span>
            <span class="n">stats</span> <span class="o">=</span> <span class="n">rn</span><span class="o">.</span><span class="n">rnpipestats</span>
            <span class="c1"># Get all factors for QA</span>
            <span class="n">rnstats</span> <span class="o">=</span> <span class="n">rn</span><span class="o">.</span><span class="n">stats</span><span class="p">()</span>
            <span class="c1"># get information related to detecting false positives caused by</span>
            <span class="c1"># atmospheric features, also needed for QA.</span>
            <span class="n">atmWarning</span> <span class="o">=</span> <span class="n">rn</span><span class="o">.</span><span class="n">atmWarning</span>
            <span class="n">atmExcludeCmd</span> <span class="o">=</span> <span class="n">rn</span><span class="o">.</span><span class="n">atmExcludeCmd</span>

    <span class="c1"># Clean up.</span>
    <span class="n">rn</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">alltdm</span><span class="p">,</span> <span class="n">atmExcludeCmd</span><span class="p">,</span> <span class="n">atmWarning</span><span class="p">,</span> <span class="n">corrApplied</span><span class="p">,</span> <span class="n">corrColExists</span><span class="p">,</span> <span class="n">renorm_applied</span><span class="p">,</span> <span class="n">rnstats</span><span class="p">,</span> <span class="n">stats</span>  </div>




<div class="viewcode-block" id="ACreNorm">
<a class="viewcode-back" href="../../../_autosummary/pipeline.extern.almarenorm_pl2023.ACreNorm.html#pipeline.h.tasks.restoredata.restoredata.ACreNorm">[docs]</a>
<span class="k">class</span> <span class="nc">ACreNorm</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>


    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">msname</span><span class="p">):</span>

        <span class="c1"># Version</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">RNversion</span><span class="o">=</span><span class="s1">&#39;v1.6.1-2023/08/09-PLWG&#39;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">msname</span><span class="o">=</span><span class="n">msname</span>
        <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;Opening ms: &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">msname</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">msmeta</span><span class="o">=</span><span class="n">msmdtool</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">msmeta</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">msname</span><span class="p">)</span>

        <span class="n">mytb</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">msname</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">correxists</span><span class="o">=</span><span class="n">mytb</span><span class="o">.</span><span class="n">colnames</span><span class="p">()</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s1">&#39;CORRECTED_DATA&#39;</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">wtspexists</span><span class="o">=</span><span class="kc">False</span>    
        <span class="c1"># George&#39;s code was already commented - with forward look to figuing out weights....</span>
        <span class="c1"># mytb.colnames().count(&#39;WEIGHT_SPECTRUM&#39;)&gt;0</span>
        <span class="c1"># Need to check it is initialized (contains values!)!</span>
        <span class="c1">#try:</span>
        <span class="c1">#    # Try to extract value from first row</span>
        <span class="c1">#    wtsp=mytb.getcol(&#39;WEIGHT_SPECTRUM&#39;,0,1,1)</span>
        <span class="c1">#except:</span>
        <span class="c1">#    self.wtspexists=False</span>
        <span class="c1">#    pass</span>

        <span class="n">mytb</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;CORRECTED_DATA exists = &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">correxists</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">AntName</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">msmeta</span><span class="o">.</span><span class="n">antennanames</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nAnt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">msmeta</span><span class="o">.</span><span class="n">nantennas</span><span class="p">()</span>
        <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;Found &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nAnt</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39; antennas&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">AntOut</span><span class="o">=</span><span class="p">{}</span> <span class="c1"># LM Added initiate for outlier antennas channels</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">replacedCorr</span><span class="o">=</span><span class="p">{}</span> <span class="c1"># LM added </span>
        <span class="c1"># for tracking of outlier ants per spw, scan, field </span>
        <span class="c1"># that were deemed to need more than 10 channels correcting</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">birdiechan</span><span class="o">=</span><span class="p">{}</span> <span class="c1"># LM added - actually is set but not assessed - was for testing </span>
        <span class="bp">self</span><span class="o">.</span><span class="n">atmtrans</span><span class="o">=</span> <span class="p">{}</span>  <span class="c1"># LM added initiated for atmopsheric transmission regions</span>
                           <span class="c1"># options in main code to exclude or &quot;fit out&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">corrATM</span> <span class="o">=</span> <span class="kc">False</span> <span class="c1"># global variable as if we set to True but then cannot find</span>
                           <span class="c1"># the PWV value (for whatever reason)</span>
                           <span class="c1"># correctATM is input in renormalize function</span>

        <span class="c1"># ALMA Bands     0       1     2    3    4     5     6     7     8    9    10</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">usePWV</span> <span class="o">=</span>  <span class="p">[</span><span class="mf">99.0</span><span class="p">,</span> <span class="mf">5.186</span><span class="p">,</span><span class="mf">5.186</span><span class="p">,</span><span class="mf">2.748</span><span class="p">,</span><span class="mf">2.748</span><span class="p">,</span><span class="mf">1.796</span><span class="p">,</span><span class="mf">1.262</span><span class="p">,</span><span class="mf">0.913</span><span class="p">,</span><span class="mf">0.658</span><span class="p">,</span><span class="mf">0.472</span><span class="p">,</span><span class="mf">0.472</span><span class="p">]</span> 

        <span class="bp">self</span><span class="o">.</span><span class="n">scalingValues</span><span class="o">=</span><span class="p">{}</span>  <span class="c1"># for PL to read the levels at SPW, Scan, Field - max scaling value </span>

        <span class="bp">self</span><span class="o">.</span><span class="n">TsysReturn</span><span class="o">=</span><span class="p">{}</span>  <span class="c1"># LM added so Tsys flag channel are already passed and stored</span>
        <span class="c1"># useful for ALMA production </span>

        <span class="c1"># ALMA Bands        0    1   2    3    4    5    6    7    8    9    10</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bandThresh</span><span class="o">=</span><span class="p">[</span><span class="mf">99.0</span><span class="p">,</span> <span class="mf">1.02</span><span class="p">,</span><span class="mf">1.02</span><span class="p">,</span><span class="mf">1.02</span><span class="p">,</span><span class="mf">1.02</span><span class="p">,</span><span class="mf">1.02</span><span class="p">,</span><span class="mf">1.02</span><span class="p">,</span><span class="mf">1.02</span><span class="p">,</span><span class="mf">1.02</span><span class="p">,</span><span class="mf">1.02</span><span class="p">,</span><span class="mf">1.02</span><span class="p">]</span> 
        <span class="c1"># B9/B10 set high now to now correct</span>
        <span class="c1"># set a B0 as its way easier just to then index this array with Band</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">docorrApply</span><span class="o">=</span><span class="p">{}</span> <span class="c1"># - this is to record if the field in a given SPW is</span>
        <span class="c1"># above the threshold for application, in which case that field in that</span>
        <span class="c1"># SPW will always be corrected and a boolean can be stored in this dictionary</span>
        <span class="c1"># one caveat is what about boarderline data around the threshold</span>
        <span class="c1"># and some scans are above, and some are below? Do we add a buffer? - it would be wrong</span>
        <span class="c1"># to scale e.g. only half the scans for a field. Code is iterative, so doesn&#39;t</span>
        <span class="c1"># know about later scans in advanced..so must be based on first scan assessment of the field only</span>
        <span class="c1"># usually scalng per scan for same fields is roughtly similar/constant </span>
        
 
        <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="o">=</span><span class="p">[]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">nfit</span><span class="o">=</span><span class="mi">5</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fthresh</span><span class="o">=</span><span class="mf">0.001</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="o">=</span><span class="p">{}</span>
        <span class="n">myms</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">msname</span><span class="p">)</span>
        <span class="n">spwInfo</span> <span class="o">=</span> <span class="n">myms</span><span class="o">.</span><span class="n">getspectralwindowinfo</span><span class="p">()</span>
        <span class="n">myms</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">fdmspws</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">msmeta</span><span class="o">.</span><span class="n">fdmspws</span><span class="p">()</span>
        <span class="c1"># Make sure there are FDM windows, if not, work around that.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fdmspws</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tdm_only</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">bandFreq</span> <span class="o">=</span> <span class="n">spwInfo</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fdmspws</span><span class="p">[</span><span class="mi">0</span><span class="p">])][</span><span class="s1">&#39;Chan1Freq&#39;</span><span class="p">]</span>
            <span class="c1"># Maybe a better way?</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">num_corrs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">msmeta</span><span class="o">.</span><span class="n">ncorrforpol</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">msmeta</span><span class="o">.</span><span class="n">polidfordatadesc</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">msmeta</span><span class="o">.</span><span class="n">datadescids</span><span class="p">(</span><span class="n">spw</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">fdmspws</span><span class="p">[</span><span class="mi">0</span><span class="p">])[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="c1"># AC data will only use the parallel hands, so if 4 correlations are detected in the FDM</span>
            <span class="c1"># window, we set the full_pol flag to True and reset num_corrs to 2.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_corrs</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">full_pol</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">num_corrs</span> <span class="o">=</span> <span class="mi">2</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">full_pol</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="c1">#mytb.open(self.msname+&#39;/SPECTRAL_WINDOW&#39;)</span>
            <span class="c1"># try to get the reference frequency directly but REF_FREQUENCY doesn&#39;t exist for</span>
            <span class="c1"># older data so in those cases we just take the mean of the spw. </span>
            <span class="c1">#try: </span>
            <span class="c1">#    bandFreq = mytb.getcol(&#39;REF_FREQUENCY&#39;)[self.fdmspws[0]]</span>
            <span class="c1">#except RuntimeError:</span>
            <span class="c1">#    bandFreq = np.mean(mytb.getcell(&#39;CHAN_FREQ&#39;,[self.fdmswps[0]]))</span>
            <span class="c1">#mytb.close()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;No FDM windows found! Renormalization unnecessary.&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tdm_only</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">bandFreq</span> <span class="o">=</span> <span class="n">spwInfo</span><span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">][</span><span class="s1">&#39;Chan1Freq&#39;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">num_corrs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">msmeta</span><span class="o">.</span><span class="n">ncorrforpol</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">msmeta</span><span class="o">.</span><span class="n">polidfordatadesc</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">msmeta</span><span class="o">.</span><span class="n">datadescids</span><span class="p">(</span><span class="n">spw</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">msmeta</span><span class="o">.</span><span class="n">tdmspws</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">])[</span><span class="mi">0</span><span class="p">]))</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">Band</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getband</span><span class="p">(</span><span class="n">bandFreq</span><span class="p">))</span>

        <span class="c1"># warnings that give nan slice back or empty mean</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span><span class="n">action</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="s1">&#39;All-NaN slice encountered&#39;</span><span class="p">)</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span><span class="n">action</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="s1">&#39;Mean of empty slice&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;Closing msmd tool.&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="mi">13</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="mi">14</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="mi">15</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">msmeta</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="o">=</span><span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="fm">__del__</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">chanfreqs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">ispw</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">msmeta</span><span class="o">.</span><span class="n">chanfreqs</span><span class="p">(</span><span class="n">ispw</span><span class="p">)</span>
        
    <span class="k">def</span> <span class="nf">getBscan</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">spw</span><span class="p">,</span><span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">Bspw</span><span class="o">=</span><span class="p">[]</span>
        <span class="n">Bscans</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">msmeta</span><span class="o">.</span><span class="n">scansforintent</span><span class="p">(</span><span class="s1">&#39;*BANDPASS*&#39;</span><span class="p">)</span>
        <span class="n">Spwscans</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">msmeta</span><span class="o">.</span><span class="n">scansforspw</span><span class="p">(</span><span class="n">spw</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">iB</span> <span class="ow">in</span> <span class="n">Bscans</span><span class="p">:</span>
            <span class="n">mask</span><span class="o">=</span><span class="n">Spwscans</span><span class="o">==</span><span class="n">iB</span>
            <span class="k">for</span> <span class="n">iS</span> <span class="ow">in</span> <span class="n">Spwscans</span><span class="p">[</span><span class="n">mask</span><span class="p">]:</span>
                <span class="n">Bspw</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">iS</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s2">&quot; Bandpass scan(s): &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">Bspw</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">Bspw</span>


    <span class="k">def</span> <span class="nf">getPhscan</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">spw</span><span class="p">,</span><span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">PHscan</span><span class="o">=</span><span class="p">[]</span>
        <span class="n">Phscans</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">msmeta</span><span class="o">.</span><span class="n">scansforintent</span><span class="p">(</span><span class="s1">&#39;*PHASE*&#39;</span><span class="p">)</span>
        <span class="n">Spwscans</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">msmeta</span><span class="o">.</span><span class="n">scansforspw</span><span class="p">(</span><span class="n">spw</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">iPh</span> <span class="ow">in</span> <span class="n">Phscans</span><span class="p">:</span>
            <span class="n">mask</span><span class="o">=</span><span class="n">Spwscans</span><span class="o">==</span><span class="n">iPh</span>
            <span class="k">for</span> <span class="n">iS</span> <span class="ow">in</span> <span class="n">Spwscans</span><span class="p">[</span><span class="n">mask</span><span class="p">]:</span>
                <span class="n">PHscan</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">iS</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s2">&quot; Phase calibrator scan(s): &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">PHscan</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">PHscan</span>
        
    <span class="k">def</span> <span class="nf">getStateIdsForIntent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">intent</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">mytb</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">msname</span><span class="o">+</span><span class="s1">&#39;/STATE&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="o">=</span><span class="n">mytb</span><span class="o">.</span><span class="n">getcol</span><span class="p">(</span><span class="s1">&#39;OBS_MODE&#39;</span><span class="p">)</span>
            <span class="n">mytb</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">)))[</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">([</span><span class="n">intent</span> <span class="ow">in</span> <span class="n">y</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">])])</span>


    <span class="k">def</span> <span class="nf">getBtsysscan</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">spw</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span> 
        
        <span class="n">Bflds</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">msmeta</span><span class="o">.</span><span class="n">fieldsforintent</span><span class="p">(</span><span class="s1">&#39;*BANDPASS*&#39;</span><span class="p">))</span>  <span class="c1"># Bandpass field(s)</span>
        <span class="n">Bscans</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">for</span> <span class="n">iBfld</span> <span class="ow">in</span> <span class="n">Bflds</span><span class="p">:</span>   <span class="c1"># handle multiple B calibrators (needed?)</span>
            <span class="n">Bscans</span><span class="o">=</span><span class="n">Bscans</span><span class="o">+</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">msmeta</span><span class="o">.</span><span class="n">scansforfield</span><span class="p">(</span><span class="n">iBfld</span><span class="p">))</span>     <span class="c1"># Scans on Bandpass field(s)</span>
        <span class="n">TsysScans</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">msmeta</span><span class="o">.</span><span class="n">scansforintent</span><span class="p">(</span><span class="s1">&#39;*ATM*&#39;</span><span class="p">))</span>  <span class="c1"># all Tsys scans</span>
        <span class="n">SpwScans</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">msmeta</span><span class="o">.</span><span class="n">scansforspw</span><span class="p">(</span><span class="n">spw</span><span class="p">))</span> <span class="c1"># Scans in specified spw</span>
        
        <span class="c1"># [scan in [scans on Bfld among Tsys scans] among spw scans]</span>
        <span class="n">BTsysScans</span><span class="o">=</span><span class="p">[</span><span class="n">iscan</span> <span class="k">for</span> <span class="n">iscan</span> <span class="ow">in</span> <span class="p">[</span><span class="n">iscan1</span> <span class="k">for</span> <span class="n">iscan1</span> <span class="ow">in</span> <span class="n">TsysScans</span> <span class="k">if</span> <span class="n">iscan1</span> <span class="ow">in</span> <span class="n">Bscans</span><span class="p">]</span> <span class="k">if</span> <span class="n">iscan</span> <span class="ow">in</span> <span class="n">SpwScans</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">BTsysScans</span><span class="p">)</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;Could not find Tsys scan on B calibrator in spw=&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">spw</span><span class="p">))</span>
            <span class="k">return</span> <span class="kc">None</span>  
        
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;Tsys scan(s) for bandpass calibrator(s) </span><span class="si">{0}</span><span class="s1"> in spw=</span><span class="si">{1}</span><span class="s1"> are: </span><span class="si">{2}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">Bflds</span><span class="p">,</span> <span class="n">spw</span><span class="p">,</span> <span class="n">BTsysScans</span><span class="p">))</span>

        <span class="c1"># already a list</span>
        <span class="k">return</span> <span class="n">BTsysScans</span>

    <span class="k">def</span> <span class="nf">getACdata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">scan</span><span class="p">,</span><span class="n">spw</span><span class="p">,</span><span class="n">field</span><span class="p">,</span><span class="n">rowave</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">stateid</span><span class="o">=</span><span class="p">[]):</span>
        <span class="n">sortlist</span><span class="o">=</span><span class="s1">&#39;&#39;</span>
        <span class="k">if</span> <span class="n">rowave</span><span class="p">:</span>
            <span class="n">sortlist</span><span class="o">=</span><span class="s1">&#39;ANTENNA1&#39;</span>

        <span class="n">mytb</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">msname</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">scan</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
            <span class="n">scans</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">scan</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">scans</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">scan</span><span class="p">)</span>
        <span class="n">ddid</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">msmeta</span><span class="o">.</span><span class="n">datadescids</span><span class="p">(</span><span class="n">spw</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">field</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># i.e. science data</span>
            <span class="n">quer</span><span class="o">=</span><span class="s1">&#39;SCAN_NUMBER IN [&#39;</span><span class="o">+</span><span class="n">scans</span><span class="o">+</span><span class="s1">&#39;] &amp;&amp; DATA_DESC_ID IN &#39;</span><span class="o">+</span><span class="n">ddid</span><span class="o">+</span><span class="s1">&#39; &amp;&amp; ANTENNA1==ANTENNA2 &amp;&amp; FIELD_ID==&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">field</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># because the getTsysSpectra passes scans but wont pass the field or Bandpass doesn&#39;t pass field actually</span>
            <span class="n">quer</span><span class="o">=</span><span class="s1">&#39;SCAN_NUMBER IN [&#39;</span><span class="o">+</span><span class="n">scans</span><span class="o">+</span><span class="s1">&#39;] &amp;&amp; DATA_DESC_ID IN &#39;</span><span class="o">+</span><span class="n">ddid</span><span class="o">+</span><span class="s1">&#39; &amp;&amp; ANTENNA1==ANTENNA2&#39;</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">stateid</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">quer</span><span class="o">=</span><span class="n">quer</span><span class="o">+</span><span class="s1">&#39;&amp;&amp; STATE_ID IN &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">stateid</span><span class="p">)</span>
        <span class="n">st</span><span class="o">=</span><span class="n">mytb</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">quer</span><span class="p">,</span><span class="n">sortlist</span><span class="o">=</span><span class="n">sortlist</span><span class="p">)</span>

        <span class="n">d</span><span class="o">=</span><span class="n">st</span><span class="o">.</span><span class="n">getcol</span><span class="p">(</span><span class="s1">&#39;DATA&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">real</span>
        <span class="c1"># If we want to incorporate the XML flags then need to grab them</span>
        <span class="c1">#f=st.getcol(&#39;FLAG&#39;)</span>

        <span class="c1"># need a check here for failed data read - happens for aborted data (e.g. in Mosaics ALMA-IMF)</span>
        <span class="c1"># aborted means in a given scan the &#39;last&#39; fiels is not necessarily recorded</span>
        <span class="c1"># simply</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                <span class="n">d</span><span class="o">=</span><span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">::(</span><span class="n">d</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">),:,:]</span>   <span class="c1">#  parallel hands only for full pol data</span>
            <span class="n">a1</span><span class="o">=</span><span class="n">st</span><span class="o">.</span><span class="n">getcol</span><span class="p">(</span><span class="s1">&#39;ANTENNA1&#39;</span><span class="p">)</span>  <span class="c1">## WARNING will CASA 6.2 obey row ordering if getcol ANT is not called with DATA ??</span>
            <span class="n">st</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="n">mytb</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

            <span class="n">dsh</span><span class="o">=</span><span class="n">d</span><span class="o">.</span><span class="n">shape</span>
            <span class="k">if</span> <span class="n">rowave</span> <span class="ow">and</span> <span class="n">dsh</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="n">nAnt</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">dsh2</span><span class="o">=</span><span class="p">(</span><span class="n">dsh</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">dsh</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">nAnt</span><span class="p">,</span><span class="nb">int</span><span class="p">(</span><span class="n">dsh</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">nAnt</span><span class="p">))</span> 
                <span class="n">d</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">dsh2</span><span class="p">),</span><span class="mi">3</span><span class="p">)</span>
                <span class="n">a1</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">a1</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">dsh2</span><span class="p">[</span><span class="mi">2</span><span class="p">:]),</span><span class="mi">1</span><span class="p">)</span><span class="o">//</span><span class="n">dsh2</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>

                <span class="c1">## Some details for how to incorporate flagging if that was wanted in the future:</span>
                <span class="c1"># if (f == True).any(): #if there are no flags then just do as above</span>
                <span class="c1"># d = d.reshape(dsh2)</span>
                <span class="c1"># f = f.reshape(dsh2)</span>
                <span class="c1"># d = np.ma.array(d, mask=f, fill_value=np.nan)</span>
                <span class="c1"># d = np.nanmean(d,3)</span>
                <span class="c1"># </span>
                <span class="c1"># Note that if this is run after the PL flagging (stage 2) then EVERYTHING is</span>
                <span class="c1"># flagged because the PL flags autocorrs. </span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="kc">None</span> <span class="c1"># new return which is analysed in the renorm code now </span>
            <span class="n">mytb</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">d</span>

    <span class="k">def</span> <span class="nf">getXCdata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">scan</span><span class="p">,</span><span class="n">spw</span><span class="p">,</span><span class="n">field</span><span class="p">,</span><span class="n">datacolumn</span><span class="o">=</span><span class="s1">&#39;CORRECTED_DATA&#39;</span><span class="p">):</span>
        <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;  Extracting CROSS-correlation data from spw=&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">spw</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39; and scan=&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">scan</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39; and field=&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">field</span><span class="p">))</span>

        <span class="n">mytb</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">msname</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">mytb</span><span class="o">.</span><span class="n">colnames</span><span class="p">()</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">datacolumn</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">mytb</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;ERROR: &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">datacolumn</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39; does NOT exist!&#39;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">datacolumn</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39; does not exist.&#39;</span><span class="p">)</span>

        <span class="n">ddid</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">msmeta</span><span class="o">.</span><span class="n">datadescids</span><span class="p">(</span><span class="n">spw</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">scan</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
            <span class="n">scans</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">scan</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">scans</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">scan</span><span class="p">)</span>
        <span class="n">st</span><span class="o">=</span><span class="n">mytb</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="s1">&#39;SCAN_NUMBER IN [&#39;</span><span class="o">+</span><span class="n">scans</span><span class="o">+</span><span class="s1">&#39;] &amp;&amp; DATA_DESC_ID IN &#39;</span><span class="o">+</span><span class="n">ddid</span><span class="o">+</span><span class="s1">&#39; &amp;&amp; ANTENNA1!=ANTENNA2 &amp;&amp; FIELD_ID ==&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">field</span><span class="p">))</span>
        <span class="n">cd</span><span class="o">=</span><span class="n">st</span><span class="o">.</span><span class="n">getcol</span><span class="p">(</span><span class="n">datacolumn</span><span class="p">)</span>  <span class="c1">## WARNING CASA6.2 might not obey row order</span>
        <span class="n">a1</span><span class="o">=</span><span class="n">st</span><span class="o">.</span><span class="n">getcol</span><span class="p">(</span><span class="s1">&#39;ANTENNA1&#39;</span><span class="p">)</span>
        <span class="n">a2</span><span class="o">=</span><span class="n">st</span><span class="o">.</span><span class="n">getcol</span><span class="p">(</span><span class="s1">&#39;ANTENNA2&#39;</span><span class="p">)</span>
        <span class="n">st</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="n">mytb</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">a1</span><span class="p">,</span><span class="n">a2</span><span class="p">,</span><span class="n">cd</span><span class="p">)</span>

    <span class="c1"># Mimics part of getXCdata, but gets the FLAG column</span>
    <span class="k">def</span> <span class="nf">getXCflags</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">scan</span><span class="p">,</span><span class="n">spw</span><span class="p">,</span><span class="n">field</span><span class="p">,</span><span class="n">datacolumn</span><span class="o">=</span><span class="s1">&#39;FLAG&#39;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;  Extracting CROSS-correlation flags from spw=&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">spw</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39; and scan=&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">scan</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39; and field=&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">field</span><span class="p">))</span>
            
        <span class="n">mytb</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">msname</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">mytb</span><span class="o">.</span><span class="n">colnames</span><span class="p">()</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">datacolumn</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">mytb</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;ERROR: &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">datacolumn</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39; does NOT exist!&#39;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">datacolumn</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39; does not exist.&#39;</span><span class="p">)</span>

        <span class="n">ddid</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">msmeta</span><span class="o">.</span><span class="n">datadescids</span><span class="p">(</span><span class="n">spw</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">scan</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
            <span class="n">scans</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">scan</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">scans</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">scan</span><span class="p">)</span>
        <span class="n">st</span><span class="o">=</span><span class="n">mytb</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="s1">&#39;SCAN_NUMBER IN [&#39;</span><span class="o">+</span><span class="n">scans</span><span class="o">+</span><span class="s1">&#39;] &amp;&amp; DATA_DESC_ID IN &#39;</span><span class="o">+</span><span class="n">ddid</span><span class="o">+</span><span class="s1">&#39; &amp;&amp; ANTENNA1!=ANTENNA2 &amp;&amp; FIELD_ID ==&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">field</span><span class="p">))</span>
        <span class="n">cd</span><span class="o">=</span><span class="n">st</span><span class="o">.</span><span class="n">getcol</span><span class="p">(</span><span class="n">datacolumn</span><span class="p">)</span>
        <span class="n">a1</span><span class="o">=</span><span class="n">st</span><span class="o">.</span><span class="n">getcol</span><span class="p">(</span><span class="s1">&#39;ANTENNA1&#39;</span><span class="p">)</span>
        <span class="n">a2</span><span class="o">=</span><span class="n">st</span><span class="o">.</span><span class="n">getcol</span><span class="p">(</span><span class="s1">&#39;ANTENNA2&#39;</span><span class="p">)</span>
        <span class="n">st</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="n">mytb</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="c1"># idea is actually to return a list of fully flagged antennas</span>

        <span class="c1"># each row in the XC flags is a unique antenna pair</span>
        <span class="c1"># loop the rows and make a list of those that are NOT fully flagged, then use exclusion </span>
        <span class="c1"># comparing to the list of all antennas</span>

        <span class="n">gdants</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">for</span> <span class="n">irow</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cd</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">cd</span><span class="p">[:,:,</span><span class="n">irow</span><span class="p">])</span> <span class="o">!=</span> <span class="n">cd</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">cd</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span> <span class="c1"># i.e here we are summing all corrs and the spectral axis</span>
                <span class="n">gdants</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a1</span><span class="p">[</span><span class="n">irow</span><span class="p">])</span>
                <span class="n">gdants</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a2</span><span class="p">[</span><span class="n">irow</span><span class="p">])</span>

        <span class="c1"># now make an exclusion cause</span>
        <span class="n">aout</span> <span class="o">=</span> <span class="p">[</span><span class="n">iant</span> <span class="k">for</span> <span class="n">iant</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nAnt</span><span class="p">)</span> <span class="k">if</span> <span class="n">iant</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">gdants</span><span class="p">]</span>

        <span class="c1"># probably this could be coded better - instead of the loop??? - but is relatively fast as robust </span>

        <span class="k">return</span> <span class="p">(</span><span class="n">aout</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">putXCdata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">scan</span><span class="p">,</span><span class="n">spw</span><span class="p">,</span><span class="n">field</span><span class="p">,</span><span class="n">cd</span><span class="p">,</span><span class="n">datacolumn</span><span class="o">=</span><span class="s1">&#39;CORRECTED_DATA&#39;</span><span class="p">):</span>
        <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;  Writing CROSS-correlation data to spw=&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">spw</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39; and scan=&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">scan</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39; and field=&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">field</span><span class="p">))</span>

        <span class="n">mytb</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">msname</span><span class="p">,</span><span class="n">nomodify</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">ddid</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">msmeta</span><span class="o">.</span><span class="n">datadescids</span><span class="p">(</span><span class="n">spw</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">scan</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
            <span class="n">scans</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">scan</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">scans</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">scan</span><span class="p">)</span>
        <span class="n">st</span><span class="o">=</span><span class="n">mytb</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="s1">&#39;SCAN_NUMBER IN [&#39;</span><span class="o">+</span><span class="n">scans</span><span class="o">+</span><span class="s1">&#39;] &amp;&amp; DATA_DESC_ID IN &#39;</span><span class="o">+</span><span class="n">ddid</span><span class="o">+</span><span class="s1">&#39; &amp;&amp; ANTENNA1!=ANTENNA2 &amp;&amp; FIELD_ID ==&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">field</span><span class="p">))</span>
        <span class="n">d</span><span class="o">=</span><span class="n">st</span><span class="o">.</span><span class="n">putcol</span><span class="p">(</span><span class="n">datacolumn</span><span class="p">,</span><span class="n">cd</span><span class="p">)</span>
        <span class="n">st</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="n">mytb</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>


    <span class="k">def</span> <span class="nf">getTsysSpectra</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">scan</span><span class="p">,</span><span class="n">spw</span><span class="p">):</span>

        <span class="c1"># get the sky</span>
        <span class="n">atmoff</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getACdata</span><span class="p">(</span><span class="n">scan</span><span class="p">,</span><span class="n">spw</span><span class="p">,</span><span class="kc">None</span><span class="p">,</span><span class="kc">True</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">getStateIdsForIntent</span><span class="p">(</span><span class="s1">&#39;ATMOSPHERE#OFF&#39;</span><span class="p">))</span>

        <span class="c1"># get hot</span>
        <span class="n">atmhot</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getACdata</span><span class="p">(</span><span class="n">scan</span><span class="p">,</span><span class="n">spw</span><span class="p">,</span><span class="kc">None</span><span class="p">,</span><span class="kc">True</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">getStateIdsForIntent</span><span class="p">(</span><span class="s1">&#39;ATMOSPHERE#HOT&#39;</span><span class="p">))</span>

        <span class="c1"># divide sky by hot (removes bandpass, etc.)</span>
        <span class="n">Tatm</span><span class="o">=</span><span class="n">atmoff</span><span class="o">/</span><span class="n">atmhot</span>

        <span class="c1"># norm on Chan axis:</span>
        <span class="n">Tatm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">normChanAxis</span><span class="p">(</span><span class="n">Tatm</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">Tatm</span>


    <span class="k">def</span> <span class="nf">normChanAxis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">A</span><span class="p">):</span>
        <span class="c1"># this is for the Tsys checking part/plotting </span>
        <span class="p">(</span><span class="n">n0</span><span class="p">,</span><span class="n">n1</span><span class="p">,</span><span class="n">n2</span><span class="p">)</span><span class="o">=</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span>

        <span class="c1"># Normalize each spectrum by median</span>
        <span class="k">for</span> <span class="n">i2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n2</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i0</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n0</span><span class="p">):</span>
                <span class="n">A</span><span class="p">[</span><span class="n">i0</span><span class="p">,:,</span><span class="n">i2</span><span class="p">]</span><span class="o">/=</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">i0</span><span class="p">,:,</span><span class="n">i2</span><span class="p">])</span>
                
        <span class="k">return</span> <span class="n">A</span>


    <span class="k">def</span> <span class="nf">xyplots</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">N</span><span class="p">):</span>
        <span class="n">nY</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">floor</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="o">+</span><span class="mf">0.5</span><span class="p">))</span>
        <span class="n">nX</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">ceil</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="o">/</span><span class="n">nY</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">nX</span><span class="p">,</span><span class="n">nY</span>

        
    <span class="k">def</span> <span class="nf">plotSpws</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">hardcopy</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>  <span class="c1"># unchanged George&#39;s code (expect figure output name nad hardcopy=True -- I&#39;ve not really used (L.Maud)</span>

        <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;Discerning spw intents...&#39;</span><span class="p">)</span>

        <span class="n">specspws</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">msmeta</span><span class="o">.</span><span class="n">almaspws</span><span class="p">(</span><span class="n">tdm</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">fdm</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>

        <span class="n">scispws</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">msmeta</span><span class="o">.</span><span class="n">spwsforintent</span><span class="p">(</span><span class="s1">&#39;*TARGET*&#39;</span><span class="p">))</span>
        <span class="n">scispecspws</span><span class="o">=</span><span class="p">[</span><span class="n">ispw</span> <span class="k">for</span> <span class="n">ispw</span> <span class="ow">in</span> <span class="n">scispws</span> <span class="k">if</span> <span class="n">ispw</span> <span class="ow">in</span> <span class="n">specspws</span> <span class="p">]</span>
        <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;Found resolved Science spws: &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">scispecspws</span><span class="p">))</span>

        <span class="n">tsysspws</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">msmeta</span><span class="o">.</span><span class="n">spwsforintent</span><span class="p">(</span><span class="s1">&#39;*ATM*&#39;</span><span class="p">))</span>
        <span class="n">tsysspecspws</span><span class="o">=</span><span class="p">[</span><span class="n">ispw</span> <span class="k">for</span> <span class="n">ispw</span> <span class="ow">in</span> <span class="n">tsysspws</span> <span class="k">if</span> <span class="n">ispw</span> <span class="ow">in</span> <span class="n">specspws</span> <span class="p">]</span>
        <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;Found resolved Tsys spws = &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">tsysspecspws</span><span class="p">))</span>
        
        <span class="n">nSpw</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">tsysspecspws</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ioff</span><span class="p">()</span>
        <span class="n">pfig</span><span class="o">=</span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">14</span><span class="p">,</span><span class="mi">9</span><span class="p">))</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ioff</span><span class="p">()</span>
        <span class="n">pfig</span><span class="o">.</span><span class="n">clf</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">ispw</span> <span class="ow">in</span> <span class="n">scispecspws</span><span class="p">:</span>
            <span class="n">f</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">msmeta</span><span class="o">.</span><span class="n">chanfreqs</span><span class="p">(</span><span class="n">ispw</span><span class="p">,</span><span class="s1">&#39;GHz&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="o">*</span><span class="p">[</span><span class="n">ispw</span><span class="o">+</span><span class="mf">0.01</span><span class="p">],</span><span class="s1">&#39;r-&#39;</span><span class="p">,</span><span class="n">lw</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">f</span><span class="p">),</span><span class="n">ispw</span><span class="o">+</span><span class="mf">0.01</span><span class="p">,</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">),</span><span class="n">fontsize</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">ispw</span> <span class="ow">in</span> <span class="n">tsysspecspws</span><span class="p">:</span>
            <span class="n">f</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">msmeta</span><span class="o">.</span><span class="n">chanfreqs</span><span class="p">(</span><span class="n">ispw</span><span class="p">,</span><span class="s1">&#39;GHz&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="o">*</span><span class="p">[</span><span class="n">ispw</span><span class="p">])</span><span class="o">-</span><span class="mf">0.1</span><span class="p">,</span><span class="s1">&#39;b-&#39;</span><span class="p">,</span><span class="n">lw</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">f</span><span class="p">),</span><span class="n">ispw</span><span class="o">-</span><span class="mf">0.1</span><span class="p">,</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;-Tsys&#39;</span><span class="p">,</span><span class="n">ha</span><span class="o">=</span><span class="s1">&#39;right&#39;</span><span class="p">,</span><span class="n">va</span><span class="o">=</span><span class="s1">&#39;top&#39;</span><span class="p">,</span><span class="n">fontsize</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
            <span class="c1">#plt.text(min(f),ispw,&#39;Tsys&#39;,ha=&#39;right&#39;,va=&#39;center&#39;,fontsize=10)</span>


        <span class="n">flo</span><span class="p">,</span><span class="n">fhi</span><span class="p">,</span><span class="n">spwlo</span><span class="p">,</span><span class="n">spwhi</span><span class="o">=</span><span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">()</span>

        <span class="n">tdmspws</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">msmeta</span><span class="o">.</span><span class="n">almaspws</span><span class="p">(</span><span class="n">tdm</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ispw</span> <span class="ow">in</span> <span class="n">tsysspecspws</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ispw</span> <span class="ow">in</span> <span class="n">tdmspws</span><span class="p">:</span>
                <span class="n">f</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">msmeta</span><span class="o">.</span><span class="n">chanfreqs</span><span class="p">(</span><span class="n">ispw</span><span class="p">,</span><span class="s1">&#39;GHz&#39;</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">*</span><span class="mi">2</span><span class="p">,[</span><span class="n">spwlo</span><span class="p">,</span><span class="n">spwhi</span><span class="p">],</span><span class="s1">&#39;b:&#39;</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">f</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span><span class="o">*</span><span class="mi">2</span><span class="p">,[</span><span class="n">spwlo</span><span class="p">,</span><span class="n">spwhi</span><span class="p">],</span><span class="s1">&#39;b:&#39;</span><span class="p">)</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Frequency (GHz)&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Spw Id&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">msname</span><span class="p">,{</span><span class="s1">&#39;horizontalalignment&#39;</span><span class="p">:</span> <span class="s1">&#39;left&#39;</span><span class="p">,</span> <span class="s1">&#39;fontsize&#39;</span><span class="p">:</span> <span class="s1">&#39;medium&#39;</span><span class="p">,</span><span class="s1">&#39;verticalalignment&#39;</span><span class="p">:</span> <span class="s1">&#39;bottom&#39;</span><span class="p">})</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ticklabel_format</span><span class="p">(</span><span class="n">style</span><span class="o">=</span><span class="s1">&#39;plain&#39;</span><span class="p">,</span> <span class="n">useOffset</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">hardcopy</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="s1">&#39;RN_plots&#39;</span><span class="p">):</span>
                <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="s1">&#39;RN_plots&#39;</span><span class="p">)</span>
            <span class="n">fname</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">msname</span><span class="o">+</span><span class="s1">&#39;_ReNormSpwVsFreq.png&#39;</span>
            <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;Saving hardcopy plot: &#39;</span><span class="o">+</span><span class="n">fname</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;./RN_plots/&#39;</span><span class="o">+</span><span class="n">fname</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

                   
    <span class="k">def</span> <span class="nf">plotRelTsysSpectra</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">spws</span><span class="o">=</span><span class="p">[],</span><span class="n">scans</span><span class="o">=</span><span class="p">[],</span><span class="n">normByB</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">fthresh</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span><span class="n">bwthresh</span><span class="o">=</span><span class="mf">64e6</span><span class="p">,</span><span class="n">bwdiv</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">nfit</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span><span class="n">edge</span><span class="o">=</span><span class="mf">0.025</span><span class="p">,</span><span class="n">hardcopy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">retflchan</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">plotATM</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="c1"># LM edited:</span>
        <span class="c1">#         made log message </span>
        <span class="c1">#         CASA 6 fix</span>
        <span class="c1">#         default alarm/trigger changed to 0.01, i.e. 1% trigger not 0.002 (0.2%) as before</span>
        <span class="c1">#         output channels are saved as class value - for later tsys template </span>
        <span class="c1">#         verbose option</span>
        <span class="c1">#         plotATM - will also show ATM transmission profile on the Tsys spectra to help DRs</span>
        <span class="c1">#         REMOVED fitTDM  - tired to fit TDM spws in chunks, but this diverges at breaks and just is a mess - don&#39;t use</span>
    

        <span class="c1"># LM Note - the bwthresh, bwdiv etc all work similarly to those for the main renorm code, but are not shared</span>
        <span class="c1">#           so the default here is usually kept are per George&#39;s setup</span>
        <span class="c1">#           this is probably ok, as anyway this is used only to identify possible channels</span>
        <span class="c1">#           that need flagging. IF we are to rely on this code later and automate the channels to </span>
        <span class="c1">#           flag in the Tsys, we need very careful testing as the fitting can really diverge at the edges and</span>
        <span class="c1">#           causes upswings in the returned profile at the edges of TDM SPWs which are then triggering flags</span>

        <span class="n">usefthresh</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">fthresh</span>
        <span class="k">if</span> <span class="n">fthresh</span><span class="o">&gt;</span><span class="mf">0.0</span><span class="p">:</span>
            <span class="n">usefthresh</span><span class="o">=</span><span class="n">fthresh</span>

        <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
        <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;Using fractional alarm threshold for Tsys Spectra=&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">usefthresh</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">nfit</span><span class="o">=</span><span class="n">nfit</span>

        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">spws</span><span class="p">)</span><span class="o">!=</span><span class="nb">list</span><span class="p">:</span>
            <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;Please specify spws as a list.&#39;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;input parameter &quot;spws&quot; must be a list&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">scans</span><span class="p">)</span><span class="o">!=</span><span class="nb">list</span><span class="p">:</span>
            <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;Please specify scans as a list.&#39;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;input parameter &quot;scans&quot; must be a list&#39;</span><span class="p">)</span>

        <span class="c1"># the spws to process (Tsys spws)</span>
        <span class="n">tsysspecspws</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">spws</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">specspws</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">msmeta</span><span class="o">.</span><span class="n">almaspws</span><span class="p">(</span><span class="n">tdm</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">fdm</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
            <span class="n">tsysspws</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">msmeta</span><span class="o">.</span><span class="n">spwsforintent</span><span class="p">(</span><span class="s1">&#39;*ATM*&#39;</span><span class="p">))</span>
            <span class="n">tsysspecspws</span><span class="o">=</span><span class="p">[</span><span class="n">ispw</span> <span class="k">for</span> <span class="n">ispw</span> <span class="ow">in</span> <span class="n">tsysspws</span> <span class="k">if</span> <span class="n">ispw</span> <span class="ow">in</span> <span class="n">specspws</span> <span class="p">]</span>
            <span class="c1">#spws=list(self.msmeta.almaspws(fdm=True))</span>
            <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;Found Resolved Tsys spws = &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">tsysspecspws</span><span class="p">))</span>
        
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tsysspecspws</span><span class="o">=</span><span class="n">spws</span>
            <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;User supplied Tsys spws = &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">tsysspecspws</span><span class="p">))</span>

        <span class="c1"># global list of target scans</span>
        <span class="n">targtsysscans</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">scans</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">tsysscans</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">msmeta</span><span class="o">.</span><span class="n">scansforintent</span><span class="p">(</span><span class="s1">&#39;*ATM*&#39;</span><span class="p">))</span>
            <span class="n">bandpassfields</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">msmeta</span><span class="o">.</span><span class="n">fieldsforintent</span><span class="p">(</span><span class="s1">&#39;*BAND*&#39;</span><span class="p">))</span>
            <span class="n">fldforscans</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">msmeta</span><span class="o">.</span><span class="n">fieldsforscans</span><span class="p">(</span><span class="n">tsysscans</span><span class="p">,</span><span class="kc">False</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">asmap</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">targtsysscans</span> <span class="o">=</span> <span class="p">[</span><span class="n">iscan</span> <span class="k">for</span> <span class="n">iscan</span> <span class="ow">in</span> <span class="n">tsysscans</span> <span class="k">if</span> <span class="n">fldforscans</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">iscan</span><span class="p">)][</span><span class="mi">0</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">bandpassfields</span> <span class="p">]</span>
            <span class="c1">#targscans=list(self.msmeta.scansforintent(&#39;*TARGET*&#39;))</span>
            <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;Found science Tsys scans = &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">targtsysscans</span><span class="p">))</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">targtsysscans</span><span class="o">=</span><span class="n">scans</span>
            <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;User supplied Tsys scans = &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">targtsysscans</span><span class="p">))</span>

        <span class="n">nSpw</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">tsysspecspws</span><span class="p">)</span>

        <span class="n">nXspw</span><span class="p">,</span><span class="n">nYspw</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyplots</span><span class="p">(</span><span class="n">nSpw</span><span class="p">)</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">ioff</span><span class="p">()</span>
        <span class="n">pfig</span><span class="o">=</span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="mi">14</span><span class="p">,</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">14</span><span class="p">,</span><span class="mi">9</span><span class="p">))</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ioff</span><span class="p">()</span>
        <span class="n">pfig</span><span class="o">.</span><span class="n">clf</span><span class="p">()</span>

        <span class="n">cols</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;g&#39;</span><span class="p">,</span><span class="s1">&#39;r&#39;</span><span class="p">,</span><span class="s1">&#39;c&#39;</span><span class="p">,</span><span class="s1">&#39;m&#39;</span><span class="p">]</span>
        <span class="n">ncol</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">cols</span><span class="p">)</span>
        <span class="n">k</span><span class="o">=</span><span class="mi">1</span>

        <span class="n">flch</span><span class="o">=</span><span class="p">{}</span>

        <span class="k">for</span> <span class="n">ispw</span> <span class="ow">in</span> <span class="n">tsysspecspws</span><span class="p">:</span>

            <span class="k">if</span> <span class="n">normByB</span><span class="p">:</span>
                <span class="c1"># discern the B TSYS scan</span>
                <span class="n">Bscan</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getBtsysscan</span><span class="p">(</span><span class="n">ispw</span><span class="p">,</span><span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">Bscan</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">return</span>
                <span class="c1"># and get corr- and ant-dep B, time-averaged </span>
                <span class="n">Btsys</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getTsysSpectra</span><span class="p">(</span><span class="n">scan</span><span class="o">=</span><span class="n">Bscan</span><span class="p">,</span><span class="n">spw</span><span class="o">=</span><span class="n">ispw</span><span class="p">)</span>
        
            <span class="c1"># Calculate channel chunks                </span>
            <span class="p">(</span><span class="n">nseg</span><span class="p">,</span><span class="n">dNchan</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calcChanRanges</span><span class="p">(</span><span class="n">ispw</span><span class="p">,</span><span class="n">bwthresh</span><span class="p">,</span><span class="n">bwdiv</span><span class="p">,</span><span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="c1"># not an option for Tsys (yet - April 2)</span>

            <span class="c1"># George&#39;s code for chan range - comes later in plots and Tsys edges are masked too </span>
            <span class="n">nCha</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">msmeta</span><span class="o">.</span><span class="n">nchan</span><span class="p">(</span><span class="n">ispw</span><span class="p">)</span>    <span class="c1"># Btsys.shape[1]</span>
            <span class="n">chlo</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">ceil</span><span class="p">(</span><span class="n">edge</span><span class="o">*</span><span class="n">nCha</span><span class="p">))</span>
            <span class="n">chhi</span><span class="o">=</span><span class="n">nCha</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">chlo</span>
            <span class="n">chans</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="n">chlo</span><span class="p">,</span><span class="n">nCha</span><span class="o">-</span><span class="n">chlo</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">plotATM</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">Bscan</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">:</span>
                    <span class="n">Bscanatm</span><span class="o">=</span><span class="n">Bscan</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">Bscanatm</span><span class="o">=</span><span class="n">Bscan</span>
                <span class="n">ATMprof</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ATMtrans</span><span class="p">(</span><span class="n">Bscanatm</span><span class="p">,</span> <span class="n">ispw</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
                <span class="c1"># mask edges same as the Tsys below,i.e. TDM coes from 128 to 120 channels</span>
                <span class="n">ATMprof</span><span class="o">=</span><span class="n">ATMprof</span><span class="p">[</span><span class="n">chlo</span><span class="p">:(</span><span class="n">nCha</span><span class="o">-</span><span class="n">chlo</span><span class="p">)]</span>

            <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="n">nYspw</span><span class="p">,</span><span class="n">nXspw</span><span class="p">,</span><span class="n">k</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">ioff</span><span class="p">()</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">ticklabel_format</span><span class="p">(</span><span class="n">style</span><span class="o">=</span><span class="s1">&#39;plain&#39;</span><span class="p">,</span> <span class="n">useOffset</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="n">nXspw</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Relative Tsys&#39;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">k</span><span class="o">&gt;</span><span class="p">(</span><span class="n">nSpw</span><span class="o">-</span><span class="n">nXspw</span><span class="p">):</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Channel&#39;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">k</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">msname</span><span class="o">+</span><span class="s1">&#39; &lt;Nant=&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nAnt</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;&gt; Nscan=&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">targtsysscans</span><span class="p">)),{</span><span class="s1">&#39;horizontalalignment&#39;</span><span class="p">:</span> <span class="s1">&#39;left&#39;</span><span class="p">,</span> <span class="s1">&#39;fontsize&#39;</span><span class="p">:</span> <span class="s1">&#39;medium&#39;</span><span class="p">,</span><span class="s1">&#39;verticalalignment&#39;</span><span class="p">:</span> <span class="s1">&#39;bottom&#39;</span><span class="p">})</span>
            <span class="n">k</span><span class="o">+=</span><span class="mi">1</span>

            <span class="n">c</span><span class="o">=-</span><span class="mi">1</span>

            <span class="k">for</span> <span class="n">iscan</span> <span class="ow">in</span> <span class="n">targtsysscans</span><span class="p">:</span>
                <span class="n">c</span><span class="o">+=</span><span class="mi">1</span>  <span class="c1"># new color each scan</span>

                <span class="c1"># this scan&#39;s Tsys</span>
                <span class="n">Tsys</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getTsysSpectra</span><span class="p">(</span><span class="n">iscan</span><span class="p">,</span><span class="n">ispw</span><span class="p">)</span>

                <span class="c1"># Divid by Btsys to remove atm, mostly</span>
                <span class="k">if</span> <span class="n">normByB</span><span class="p">:</span>
                    <span class="n">Tsys</span><span class="o">/=</span><span class="n">Btsys</span>
                
                <span class="c1"># normalize on channel axis</span>
                <span class="n">Tsys</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">normChanAxis</span><span class="p">(</span><span class="n">Tsys</span><span class="p">)</span>
                
                <span class="c1"># average over corrs, antennas</span>
                <span class="n">Tsys</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">Tsys</span><span class="p">,(</span><span class="mi">0</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">num_corrs</span><span class="p">))</span>

                <span class="c1"># mask edges</span>
                <span class="n">Tsys</span><span class="o">=</span><span class="n">Tsys</span><span class="p">[</span><span class="n">chlo</span><span class="p">:(</span><span class="n">nCha</span><span class="o">-</span><span class="n">chlo</span><span class="p">)]</span>

                <span class="c1"># remove broad non-linearity (usually atm) -- this does not trigger for TDM at present  </span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nfit</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                    
                    <span class="k">for</span> <span class="n">iseg</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nseg</span><span class="p">):</span>
                        <span class="c1"># Tsys was masked so rubbish edges are not fitted </span>
                        <span class="n">lochan</span><span class="o">=</span><span class="nb">max</span><span class="p">(</span><span class="n">iseg</span><span class="o">*</span><span class="n">dNchan</span><span class="o">-</span><span class="n">chlo</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
                        <span class="n">hichan</span><span class="o">=</span><span class="nb">min</span><span class="p">((</span><span class="n">iseg</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">dNchan</span><span class="o">-</span><span class="n">chlo</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">Tsys</span><span class="p">))</span>
                        <span class="k">if</span> <span class="n">lochan</span><span class="o">&lt;</span><span class="n">hichan</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">calcReNorm1</span><span class="p">(</span><span class="n">Tsys</span><span class="p">[</span><span class="n">lochan</span><span class="p">:</span><span class="n">hichan</span><span class="p">],</span><span class="kc">False</span><span class="p">)</span>

                <span class="c1">#for iant in range(Tsys.shape[1]):</span>
                <span class="c1">#    plt.plot(Tsys[:,iant])</span>

                <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">chans</span><span class="p">,</span><span class="n">Tsys</span><span class="p">,</span><span class="n">cols</span><span class="p">[</span><span class="n">c</span><span class="o">%</span><span class="n">ncol</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39;-&#39;</span><span class="p">)</span>


                <span class="n">TsysMax</span><span class="o">=</span><span class="n">Tsys</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
                <span class="n">TsysMedDev</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">Tsys</span><span class="o">-</span><span class="mf">1.0</span><span class="p">))</span>
                <span class="n">TsysSfrac</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">Tsys</span><span class="p">)</span><span class="o">-</span><span class="mf">1.0</span>
                <span class="n">alarm</span><span class="o">=</span><span class="s1">&#39;   &#39;</span>
                <span class="n">flchans</span><span class="o">=</span><span class="p">[]</span>
                <span class="n">flchanstr</span><span class="o">=</span><span class="s1">&#39;&#39;</span>
                <span class="k">if</span> <span class="n">TsysMax</span><span class="o">&gt;=</span><span class="p">(</span><span class="mf">1.0</span><span class="o">+</span><span class="n">usefthresh</span><span class="p">):</span>
                    <span class="n">flchans</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">Tsys</span><span class="o">&gt;</span><span class="p">(</span><span class="mf">1.0</span><span class="o">+</span><span class="n">usefthresh</span><span class="p">))[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="n">nflchan</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">flchans</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">nflchan</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                        <span class="n">flchans</span><span class="o">+=</span><span class="n">chlo</span>
                        <span class="n">spwkey</span><span class="o">=</span><span class="s1">&#39;spw=&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)</span>
                        <span class="c1">#if not flch.has_key(spwkey):  ## HAS_KEY IS NOT IN CASA6 - PYTHON3</span>
                        <span class="c1">#    flch[spwkey]={}</span>

                        <span class="k">if</span> <span class="ow">not</span> <span class="n">spwkey</span> <span class="ow">in</span> <span class="n">flch</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                            <span class="n">flch</span><span class="p">[</span><span class="n">spwkey</span><span class="p">]</span><span class="o">=</span><span class="p">{}</span>

                        <span class="n">scankey</span><span class="o">=</span><span class="s1">&#39;scan=&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">iscan</span><span class="p">)</span>
                        <span class="n">flch</span><span class="p">[</span><span class="n">spwkey</span><span class="p">][</span><span class="n">scankey</span><span class="p">]</span><span class="o">=</span><span class="n">flchans</span>
                        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                            <span class="n">flchanstr</span><span class="o">=</span><span class="s1">&#39; Found &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">nflchan</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39; channels in SPW &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39; execeeding fractional threshold (&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">usefthresh</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;)&#39;</span> 
                        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">flchans</span><span class="p">,[</span><span class="mf">0.999</span><span class="p">]</span><span class="o">*</span><span class="n">nflchan</span><span class="p">,</span><span class="s1">&#39;ks&#39;</span><span class="p">,</span><span class="n">markersize</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
                    <span class="n">alarm</span><span class="o">=</span><span class="s1">&#39; ***&#39;</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="mi">3</span><span class="o">*</span><span class="n">nCha</span><span class="o">/</span><span class="mi">8</span><span class="p">,</span><span class="mi">5</span><span class="o">*</span><span class="n">nCha</span><span class="o">/</span><span class="mi">8</span><span class="p">],[</span><span class="n">TsysMax</span><span class="p">]</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="n">cols</span><span class="p">[</span><span class="n">c</span><span class="o">%</span><span class="n">ncol</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39;-&#39;</span><span class="p">)</span>
                    <span class="n">note1</span><span class="o">=</span><span class="s1">&#39;Peak=&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">floor</span><span class="p">(</span><span class="n">TsysMax</span><span class="o">*</span><span class="mf">10000.0</span><span class="p">)</span><span class="o">/</span><span class="mf">10000.0</span><span class="p">)</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">nCha</span><span class="o">/</span><span class="mi">8</span><span class="p">,</span><span class="n">TsysMax</span><span class="p">,</span><span class="n">note1</span><span class="p">,</span><span class="n">ha</span><span class="o">=</span><span class="s1">&#39;right&#39;</span><span class="p">,</span><span class="n">va</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">,</span><span class="n">color</span><span class="o">=</span><span class="n">cols</span><span class="p">[</span><span class="n">c</span><span class="o">%</span><span class="n">ncol</span><span class="p">],</span><span class="n">size</span><span class="o">=</span><span class="s1">&#39;x-small&#39;</span><span class="p">)</span>
                    <span class="n">note2</span><span class="o">=</span><span class="s1">&#39;Intg~&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">floor</span><span class="p">(</span><span class="n">TsysSfrac</span><span class="o">*</span><span class="mf">10000.0</span><span class="p">)</span><span class="o">/</span><span class="mf">10000.0</span><span class="p">)</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="mi">5</span><span class="o">*</span><span class="n">nCha</span><span class="o">/</span><span class="mi">8</span><span class="p">,</span><span class="n">TsysMax</span><span class="p">,</span><span class="n">note2</span><span class="p">,</span><span class="n">ha</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">,</span><span class="n">va</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">,</span><span class="n">color</span><span class="o">=</span><span class="n">cols</span><span class="p">[</span><span class="n">c</span><span class="o">%</span><span class="n">ncol</span><span class="p">],</span><span class="n">size</span><span class="o">=</span><span class="s1">&#39;x-small&#39;</span><span class="p">)</span>
                

    
                <span class="n">pstr</span><span class="o">=</span><span class="s2">&quot; Science Tsys(spw=</span><span class="si">{0:2d}</span><span class="s2">,scan=</span><span class="si">{1:3d}</span><span class="s2">): PEAK Frac Line Contrib=</span><span class="si">{2:.4f}{3}</span><span class="s2">  INTEGRATED Frac Line Contrib=</span><span class="si">{4:.4f}</span><span class="s2">&quot;</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="n">pstr</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ispw</span><span class="p">,</span><span class="n">iscan</span><span class="p">,</span><span class="n">TsysMax</span><span class="p">,</span><span class="n">alarm</span><span class="p">,</span><span class="n">TsysSfrac</span><span class="p">))</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">flchanstr</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                    <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="n">flchanstr</span><span class="p">)</span>
                    
            <span class="n">lims</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">())</span>
            <span class="n">lims</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="n">chlo</span><span class="o">-</span><span class="mi">1</span>
            <span class="n">lims</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">nCha</span><span class="o">-</span><span class="n">chlo</span>
            <span class="n">lims</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">=</span><span class="nb">min</span><span class="p">(</span><span class="mf">0.9985</span><span class="p">,</span><span class="n">lims</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">lims</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">=</span><span class="nb">max</span><span class="p">(</span><span class="mf">1.15</span><span class="o">*</span><span class="n">lims</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">-</span><span class="mf">0.15</span><span class="o">*</span><span class="n">lims</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="mf">1.02</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="n">lims</span><span class="p">)</span>

            <span class="n">dy</span><span class="o">=</span><span class="n">lims</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="mf">0.1</span><span class="o">+</span><span class="n">lims</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">*</span><span class="mf">0.9</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">nCha</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="n">dy</span><span class="p">,</span><span class="s1">&#39;Spw=&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">),</span><span class="n">ha</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">)</span>

            <span class="c1"># want second axis for ATM line </span>
            <span class="c1"># this is to aid DR in understading there is not a problem here</span>
            <span class="c1"># similar to pipeline Tsys plots with transmission shown</span>
            <span class="c1"># but keep simple with 0 to 100% shown only</span>
            <span class="c1"># and plot only once (while looping Target fields) - BP ATM profile is show</span>
            <span class="c1"># as the way Geogre coded the plots we can just called plt.twin and </span>
            <span class="c1"># thus &#39;shifts&#39; to only registering about the new ATM &#39;axis&#39;</span>
            <span class="k">if</span> <span class="n">plotATM</span><span class="p">:</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">twinx</span><span class="p">()</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">chans</span><span class="p">,</span><span class="mf">100.</span><span class="o">*</span><span class="n">ATMprof</span><span class="p">,</span><span class="n">c</span><span class="o">=</span><span class="s1">&#39;m&#39;</span><span class="p">,</span><span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;-&#39;</span><span class="p">,</span><span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">100</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="n">nXspw</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span> 
                    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;ATM transmission (%)&#39;</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">nXspw</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">subplots_adjust</span><span class="p">(</span><span class="n">wspace</span><span class="o">=</span><span class="mf">0.35</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">subplots_adjust</span><span class="p">(</span><span class="n">wspace</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">hardcopy</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="s1">&#39;RN_plots&#39;</span><span class="p">):</span>
                <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="s1">&#39;RN_plots&#39;</span><span class="p">)</span>
            <span class="n">fname</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">msname</span><span class="o">+</span><span class="s1">&#39;_RelTsysSpectra.png&#39;</span>
            <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;Saving hardcopy plot: &#39;</span><span class="o">+</span><span class="n">fname</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;./RN_plots/&#39;</span><span class="o">+</span><span class="n">fname</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

        <span class="c1"># keep the channels in a dictionary </span>
        <span class="bp">self</span><span class="o">.</span><span class="n">TsysReturn</span> <span class="o">=</span> <span class="n">flch</span>

        <span class="k">if</span> <span class="n">retflchan</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">flch</span>



    <span class="c1"># LM added / edited lots</span>
<div class="viewcode-block" id="ACreNorm.renormalize">
<a class="viewcode-back" href="../../../_autosummary/pipeline.extern.almarenorm_pl2023.ACreNorm.html#pipeline.h.tasks.restoredata.restoredata.ACreNorm.renormalize">[docs]</a>
    <span class="k">def</span> <span class="nf">renormalize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spws</span><span class="o">=</span><span class="p">[],</span> <span class="n">excludespws</span><span class="o">=</span><span class="p">[],</span> <span class="n">targscans</span><span class="o">=</span><span class="p">[],</span> 
            <span class="n">excludeants</span><span class="o">=</span><span class="p">[],</span> <span class="n">excludechan</span><span class="o">=</span><span class="p">{},</span> <span class="n">excflagged</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fixOutliers</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">mededge</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span>  
            <span class="n">atmAutoExclude</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">checkFalsePositives</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">correctATM</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">limATM</span><span class="o">=</span><span class="mf">0.85</span><span class="p">,</span> <span class="n">plotATM</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> 
            <span class="n">bwdiv</span><span class="o">=</span><span class="s1">&#39;odd&#39;</span><span class="p">,</span> <span class="n">bwthresh</span><span class="o">=</span><span class="mf">120e6</span><span class="p">,</span> <span class="n">bwthreshspw</span><span class="o">=</span><span class="p">{},</span> <span class="n">checkLineForest</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">nfit</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">useDynamicSegments</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">datacolumn</span><span class="o">=</span><span class="s1">&#39;CORRECTED_DATA&#39;</span><span class="p">,</span> <span class="n">docorr</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">docorrThresh</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">usePhaseAC</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">antHeuristicsSpectra</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">diagSpectra</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fthresh</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> 
            <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Purpose:</span>
<span class="sd">            This is the main function of the ACreNorm class. It takes the </span>
<span class="sd">            autocorrelations and evaluates them to see if a rescaling of the</span>
<span class="sd">            crosscorrelation data is necessary. It does this by looping over</span>
<span class="sd">            the science targets on a per spw, per scan, per field, per antenna,</span>
<span class="sd">            per correlation basis. It takes the autocorrelations of the target</span>
<span class="sd">            and divides them by a calibrator&#39;s autocorrelations (by default the</span>
<span class="sd">            bandpass) and any peaks above 2% in the resultant spectrum are </span>
<span class="sd">            caused by actual detections of the science target and therefore </span>
<span class="sd">            need to be corrected in the crosscorrelation data. </span>

<span class="sd">        Inputs:</span>
<span class="sd">            This function has many options for evaluating the autocorrelations</span>
<span class="sd">            and applying solutions if necessary but no inputs are necessary</span>
<span class="sd">            for operation. Some options are highly experimental and not </span>
<span class="sd">            recommended for blind usage, they have been noted below.</span>

<span class="sd">            --------------</span>
<span class="sd">            Data Selection</span>
<span class="sd">            --------------</span>

<span class="sd">            excludespws : list of integers</span>
<span class="sd">                If not empty, any spw specified will be removed from analysis</span>
<span class="sd">                if that spw is one of the science spws. </span>
<span class="sd">                Example: excludespws = [21]</span>
<span class="sd">                Default: excludespws = []</span>

<span class="sd">             spws : list of integers</span>
<span class="sd">                If not empty, only perform renormalization on the spws that</span>
<span class="sd">                are specified. Note that these must be science spws or they</span>
<span class="sd">                will be ignored.</span>
<span class="sd">                Example: spws = [21,23]</span>
<span class="sd">                Default: spws = []</span>

<span class="sd">            targscans : list of integers</span>
<span class="sd">                If not empty, only perform renormalization on the target scans</span>
<span class="sd">                that are specified. Note that these scans must contain science</span>
<span class="sd">                data or they will be ignored. </span>
<span class="sd">                Example: targscans = [18,21,24,27]</span>
<span class="sd">                Default: targscans = []</span>

<span class="sd">            --------------</span>
<span class="sd">            Data Reduction</span>
<span class="sd">            --------------</span>

<span class="sd">            excludeants : list of integers</span>
<span class="sd">                Specified antennas will be ignored in all analysis and </span>
<span class="sd">                application. This is intended to be used if any antenna are </span>
<span class="sd">                problematic in the interferometric data or need manually </span>
<span class="sd">                flagging. This is normally done via the excflagged option but </span>
<span class="sd">                if the data were just imported then flags are not available </span>
<span class="sd">                and this can be used instead. Excluded antennas have their</span>
<span class="sd">                scaling spectra set to 1.0.</span>
<span class="sd">                Example: excludeants = [10,32]</span>
<span class="sd">                Default: excludeants = []</span>

<span class="sd">            excludechan : dictionary </span>
<span class="sd">                If problematic data is found across a series of channels (often</span>
<span class="sd">                from atmospheric features) then the spw and channel ranges can</span>
<span class="sd">                be specified in either channel or frequency space (TOPO, GHz).</span>
<span class="sd">                Excluded channels have their scaling spectra set to 1.0.</span>
<span class="sd">                Example: excludechan={&#39;22&#39;:&#39;100~150;800~850&#39;, &#39;24&#39;:&#39;100~200&#39;}</span>
<span class="sd">                         excludechan={&#39;22&#39;:&#39;230.1GHz~230.2GHz&#39;}</span>
<span class="sd">                Default: excludechan={}</span>

<span class="sd">            excflagged : boolean</span>
<span class="sd">                Excluded flagged antenna by reading the crosscorrelation flag</span>
<span class="sd">                tables per spw, per scan, and per field. Antennas are excluded</span>
<span class="sd">                if fully flagged. Only useful after the data are fully </span>
<span class="sd">                calibrated. Fully flagged antenna will have thier scaling </span>
<span class="sd">                spectra set to 1.0.</span>
<span class="sd">                Default: excflagged = True</span>

<span class="sd">            fixOutliers : boolean</span>
<span class="sd">                Check antennas individually per scan, field, and correlation</span>
<span class="sd">                for outlier data compared to the median spectrum across all </span>
<span class="sd">                antennas for that correlation on a channel-by-channel basis. </span>
<span class="sd">                Outlier data is set to the median spectrum value of the </span>
<span class="sd">                corresponding correlation.</span>
<span class="sd">                Default: fixOutliers = True</span>

<span class="sd">            mededge : float</span>
<span class="sd">                Percentage of edge channels to set to the median spectrum </span>
<span class="sd">                value to prevent edge effects from influencing results.</span>
<span class="sd">                Default: mededge = 0.01     (i.e. 1%)</span>

<span class="sd">            ---------------------</span>
<span class="sd">            Atmosphere Mitigation</span>
<span class="sd">            ---------------------</span>

<span class="sd">            atmAutoExclude : boolean</span>
<span class="sd">                This option works in conjunction with the checkFalsePositives</span>
<span class="sd">                option to identify problematic sections of the spectrum where</span>
<span class="sd">                the atmosphere may be causing issues. If set to True, this will</span>
<span class="sd">                automatically exclude those sections of the spectrum where </span>
<span class="sd">                there are atmospheric features using the same method as the</span>
<span class="sd">                excludechan option.</span>
<span class="sd">                Default: atmAutoExclude = True</span>
<span class="sd">            </span>
<span class="sd">            checkFalsePositives : boolean</span>
<span class="sd">                This will automatically find atmospheric lines in the spectrum </span>
<span class="sd">                and check those regions to see if there is a renorm signal </span>
<span class="sd">                above the threshold. If there is, it is assumed to be a &quot;false </span>
<span class="sd">                positive&quot; signal caused by the ATM feature and will trigger a</span>
<span class="sd">                warning as well as a suggested region to exclude from analysis.</span>
<span class="sd">                Default: checkFalsePositives = True</span>

<span class="sd">            correctATM : boolean : EXPERIMENTAL - NOT RECOMMENDED</span>
<span class="sd">                This will get the transmission profiles for the bandpass (or</span>
<span class="sd">                phase) and target(s) and create a ratio of those profiles and</span>
<span class="sd">                apply it to the scaling spectrum. Becuase the bandpass (or</span>
<span class="sd">                phase) and target(s) autocorrelations are compared in </span>
<span class="sd">                establishing the scaling spectra, there can be issues where </span>
<span class="sd">                transmission is low and/or the source elevations are different </span>
<span class="sd">                by a significant amount resulting in very different atmospheric </span>
<span class="sd">                effects. This option acts to fix this discrpancy so that </span>
<span class="sd">                atmospheric features are handled correction. </span>
<span class="sd">                NOTE: Although a good idea, in practice it appears to have </span>
<span class="sd">                little effect and sometimes does more harm.</span>
<span class="sd">                Default: correctATM = False</span>

<span class="sd">            limATM : float</span>
<span class="sd">                Set the transmission limit for atmospheric features so that</span>
<span class="sd">                only when features are below the set limit are they mitigated.</span>
<span class="sd">                This helps with computation time as there are diminishing </span>
<span class="sd">                returns on dealing with minor atmospheric features.</span>
<span class="sd">                Default: limATM = 0.85</span>

<span class="sd">            plotATM : boolean</span>
<span class="sd">                If set to True, plot the atmospheric transmission curve on a</span>
<span class="sd">                secondary y-axis.</span>
<span class="sd">                Default: plotATM = True</span>

<span class="sd">            ----------</span>
<span class="sd">            Baselining</span>
<span class="sd">            ----------</span>

<span class="sd">            bwdiv : None, &#39;odd&#39;, int</span>
<span class="sd">                If a spw needs to be broken up into chunks (see bwthresh), this</span>
<span class="sd">                option determines the behavior of the division process. The </span>
<span class="sd">                input here will be applied to all spws. There are three input</span>
<span class="sd">                options available: </span>
<span class="sd">                    1. None - This will use powers of 2 based on taking the </span>
<span class="sd">                        full spw bandwidth and dividing by bwthresh option.</span>
<span class="sd">                    2. &#39;odd&#39; - This follows the process of (1) but attempts to</span>
<span class="sd">                        force an odd number of segments of equal size.</span>
<span class="sd">                    3. int - This will divide the spw bandwidth by the input </span>
<span class="sd">                        integer to create segments of equal size. </span>

<span class="sd">                NOTE: For options (2) and (3) there is a possiblity that the</span>
<span class="sd">                total number of channels does not evenly divide into an </span>
<span class="sd">                integer number of channels. For example, 2048 channels divided</span>
<span class="sd">                by 3 segments is 682 channels per segment with a remainder of 2</span>
<span class="sd">                channels. In these cases, the mededge option is considered as</span>
<span class="sd">                this will flag a number of edge channels anyway. If the number</span>
<span class="sd">                of channels in the remainder is smaller than the flagged region</span>
<span class="sd">                then the solution is kept, otherwise the solution defaults to</span>
<span class="sd">                option (1). </span>

<span class="sd">                NOTE: The total number of segments is capped at 7 which will</span>
<span class="sd">                override any input here.</span>

<span class="sd">                Examples: bwdiv = None</span>
<span class="sd">                          bwdiv = &#39;odd&#39;</span>
<span class="sd">                          bwdiv = 4</span>
<span class="sd">                Default: bwdiv = &#39;odd&#39;</span>


<span class="sd">            bwthresh : float</span>
<span class="sd">                The maximum bandwidth (in Hz) to fit a baseline to, beyond this</span>
<span class="sd">                limit the spw will be broken into chunks to fit separately.</span>
<span class="sd">                NOTE: The maximum number of segments is capped at 7. This will</span>
<span class="sd">                override this setting for wide spws. </span>
<span class="sd">                Default: bwthresh = 120e6</span>

<span class="sd">            bwthreshspw : dictionary</span>
<span class="sd">                This allows the user to input specific settings of the bwthresh</span>
<span class="sd">                option on a per spw basis, spws not specifed here will default </span>
<span class="sd">                to the bwthresh option setting.</span>
<span class="sd">                Example: bwthreshspw = {&#39;22&#39;:&#39;250e6&#39;, &#39;24&#39;:&#39;500e6&#39;}</span>
<span class="sd">                Default: {}</span>

<span class="sd">            checkLineForest : boolean</span>
<span class="sd">                Each segment goes through a process of masking to find and </span>
<span class="sd">                ignore potential lines. Atmospheric features are also ignored. </span>
<span class="sd">                After this masking, this option will enable to a check to make</span>
<span class="sd">                sure that &gt;50% of the remaining segment bandwidth is available</span>
<span class="sd">                for fitting a baseline to. If not, then a warning is issued and</span>
<span class="sd">                if useDynamicSegments is also set to True, then the segment </span>
<span class="sd">                size will be increased to include more bandwidth.</span>
<span class="sd">                NOTE: This only works if useDynamicSegments is also True.</span>
<span class="sd">                Default: True</span>

<span class="sd">            nfit : int</span>
<span class="sd">                This is the order of the polynomial that is used to fit the</span>
<span class="sd">                scaling spectrum in order to flatten or baseline it.</span>
<span class="sd">                Default: nfit = 5</span>

<span class="sd">            useDynamicSegments : boolean</span>
<span class="sd">                If set to True, then after fitting the scaling spectrum, check</span>
<span class="sd">                for issues at the segment boundaries by looking for values </span>
<span class="sd">                &gt;1.05 in the resultant scaling spectrum that are within 10 </span>
<span class="sd">                channels or 10 MHz (whichever is larger). If any values are </span>
<span class="sd">                found, then decrease the number of segments by 2 and try again.</span>
<span class="sd">                This process is repeated until a good solution is found or</span>
<span class="sd">                only 1 segment remains.</span>
<span class="sd">                Default: True</span>

<span class="sd">            ---------------</span>
<span class="sd">            Data Correction</span>
<span class="sd">            ---------------</span>

<span class="sd">            datacolumn : string</span>
<span class="sd">                Specify the data column of the MS to apply the corrections to.</span>
<span class="sd">                If this is run post-calibration, then the CORRECTED_DATA column</span>
<span class="sd">                will exist and will need to be corrected by the scaling </span>
<span class="sd">                spectrum calculated here. This is preferred as the code will be</span>
<span class="sd">                able to take advantage of any flagging performed during </span>
<span class="sd">                calibration (if the excflagged option is set to True). </span>
<span class="sd">                Alternatively, if this is run pre-calibration, then the DATA</span>
<span class="sd">                column of the MS can be selected, this however will modify the</span>
<span class="sd">                raw data directly so it is not recommended. </span>
<span class="sd">                Default: datacolumn = &#39;CORRECTED_DATA&#39;</span>

<span class="sd">            docorr : boolean</span>
<span class="sd">                Specify whether or not to apply the calculated scaling spectrum</span>
<span class="sd">                to the MS. If a correction is applied, a history note is </span>
<span class="sd">                written into the MS indicating application, this is checked for</span>
<span class="sd">                before application to prevent double application. </span>
<span class="sd">                Default: docorr=False</span>

<span class="sd">            docorrThresh : None or float</span>
<span class="sd">                The threshold above which to apply the scaling spectrum to the </span>
<span class="sd">                data. It has been determined by ALMA that datasets that do not</span>
<span class="sd">                have any residuals in their scaling spectra above 2% do not </span>
<span class="sd">                need to be corrected. As such, the default is set to 1.02 </span>
<span class="sd">                across all Bands.</span>
<span class="sd">                Example: docorrThresh = 1.01</span>
<span class="sd">                Default: docorrThresh = None   (this results in 1.02 being set)</span>

<span class="sd">            usePhaseAC : boolean : EXPERIMENTAL - USE WITH CAUTION</span>
<span class="sd">                The bandpass calibrator is used by default to create the </span>
<span class="sd">                scaling spectrum as it, by definition, should have no spectral</span>
<span class="sd">                features. However, because it can be very far away in elevation</span>
<span class="sd">                it can cause significant residuals due to atmospheric effects.</span>
<span class="sd">                In those cases, it may be useful to use the Phase calibrator</span>
<span class="sd">                instead as it must be within 3 degrees of the target. Note </span>
<span class="sd">                however that the phase calibrator is not guaranteed to be free</span>
<span class="sd">                of line emission or be free of wide-spread emission from the</span>
<span class="sd">                target itself for cases like Orion where CO is pervasive. </span>
<span class="sd">                If this option is set to True, then the phase calibrator will</span>
<span class="sd">                be used to create the scaling spectra instead of the bandpass.</span>
<span class="sd">                Default: False</span>

<span class="sd">            -------------</span>
<span class="sd">            Data Analysis</span>
<span class="sd">            -------------</span>

<span class="sd">            antHeuristicsSpectra : boolean</span>
<span class="sd">                Create additional heuristics plots per antenna for diagnosing</span>
<span class="sd">                and fixing bad autocorrelation data as described by the</span>
<span class="sd">                fixOutliers option.</span>
<span class="sd">                Default: True</span>

<span class="sd">            diagSpectra : boolean</span>
<span class="sd">                Create additional diagnostic spectra for each spw, scan, and </span>
<span class="sd">                field with both X and Y correlations and all antennas on the </span>
<span class="sd">                same plot along with the median spectra per correlation. These</span>
<span class="sd">                plots show the actual correction that is applied per antenna.</span>
<span class="sd">                Defualt: True</span>

<span class="sd">            fthresh : float</span>
<span class="sd">                This is the threshold above which to show an alarm trigger in</span>
<span class="sd">                print statements and logs as &quot;***&quot;. Stands for &quot;fractional</span>
<span class="sd">                alarm&quot; threshold.</span>
<span class="sd">                Default: 0.01   (i.e. 1%)</span>

<span class="sd">            -----</span>
<span class="sd">            Misc.</span>
<span class="sd">            -----</span>

<span class="sd">            verbose : boolean</span>
<span class="sd">                Print additional messages to the terminal that normally only go</span>
<span class="sd">                into the log file along with some &quot;debug&quot; type statements.</span>
<span class="sd">                Default: False</span>
<span class="sd">        </span>
<span class="sd">        Outputs:</span>
<span class="sd">            Varies by the options selected above but at minimum the scaling </span>
<span class="sd">            spectra are calculated and optionally applied directly to the data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Starting CASA logger message</span>
        <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;*** ALMA almarenorm.py ***&#39;</span><span class="p">,</span> <span class="s1">&#39;INFO&#39;</span><span class="p">,</span> <span class="s1">&#39;ReNormalize&#39;</span><span class="p">)</span>   
        <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;*** &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">RNversion</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39; ***&#39;</span><span class="p">,</span> <span class="s1">&#39;INFO&#39;</span><span class="p">,</span> <span class="s1">&#39;ReNormalize&#39;</span><span class="p">)</span>   
        <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;*** Beginning renormalization run ***&#39;</span><span class="p">,</span> <span class="s1">&#39;INFO&#39;</span><span class="p">,</span> <span class="s1">&#39;ReNormalize&#39;</span><span class="p">)</span>   

        <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
        <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;*** ALMA almarenorm.py renormalize &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">RNversion</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39; ***&#39;</span><span class="p">)</span>

        <span class="n">usefthresh</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">fthresh</span>
        <span class="k">if</span> <span class="n">fthresh</span><span class="o">&gt;</span><span class="mf">0.0</span><span class="p">:</span>
            <span class="n">usefthresh</span><span class="o">=</span><span class="n">fthresh</span>

        <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
        <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;Using fractional alarm indication threshold for ReNorm = &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">usefthresh</span><span class="o">*</span><span class="mi">100</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;%&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">correctATM</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">corrATM</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;Will account for any ATM lines within the SPWs&#39;</span><span class="p">)</span>

        <span class="c1"># Handle correction request</span>
        <span class="k">if</span> <span class="n">docorr</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">datacolumn</span><span class="o">==</span><span class="s1">&#39;CORRECTED_DATA&#39;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">correxists</span><span class="p">:</span>
                <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;Correction of CORRECTED_DATA requested, but column does not exist! Cannot procede.&#39;</span><span class="p">)</span>
                <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;*** Terminating renormalization run ***&#39;</span><span class="p">,</span> <span class="s1">&#39;INFO&#39;</span><span class="p">,</span> <span class="s1">&#39;ReNormalize&#39;</span><span class="p">)</span>   
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Correction of CORRECTED_DATA requested but column does not exist.&#39;</span><span class="p">)</span>

            <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;The &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">datacolumn</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39; column will be corrected!&#39;</span><span class="p">)</span>

            <span class="c1"># Check of the MS history as the renorm code now writes in that application was made</span>
            <span class="n">alreadyApp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">checkApply</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">alreadyApp</span><span class="p">:</span>
                <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
                <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;Correction requested, but these data have already been ReNormalized! Cannot procede&#39;</span><span class="p">)</span>
                <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;                      set docorr=False for plots only&#39;</span><span class="p">)</span>
                <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
                <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;*** Terminating renormalization run ***&#39;</span><span class="p">,</span> <span class="s1">&#39;INFO&#39;</span><span class="p">,</span> <span class="s1">&#39;ReNormalize&#39;</span><span class="p">)</span>   
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Correction requested but these data have already been renormalized.&#39;</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;No corrections will be applied (docorr=False)!&#39;</span><span class="p">)</span>

        <span class="c1"># Check if docorrThresh is set correctly</span>
        <span class="k">if</span> <span class="n">docorrThresh</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">docorrThresh</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">float</span><span class="p">:</span>
                <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;Correction of CORRECTED_DATA requested, but docorrThresh is set incorrectly! Cannot procede.&#39;</span><span class="p">)</span>
                <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39; set to None for automatic thresholding during apply, or input a float to use&#39;</span><span class="p">)</span> 
                <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;*** Terminating renormalization run ***&#39;</span><span class="p">,</span> <span class="s1">&#39;INFO&#39;</span><span class="p">,</span> <span class="s1">&#39;ReNormalize&#39;</span><span class="p">)</span>   
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Correction of CORRECTED_DATA requested, but docorrThresh is set incorrectly. Use None or float.&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">docorrThresh</span> <span class="o">&gt;</span> <span class="mf">1.5</span><span class="p">:</span>
                <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;WARNING: Correction of CORRECTED_DATA requested, but docorrThresh is set very high&#39;</span><span class="p">)</span>
                <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;         docorrThresh is a factor above which to apply the ReNormalization&#39;</span><span class="p">)</span>
                <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;         &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">docorrThresh</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39; is very high and it is likely that no data will pass that limit&#39;</span><span class="p">)</span> 
                <span class="n">hardLim</span> <span class="o">=</span> <span class="n">docorrThresh</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">hardLim</span> <span class="o">=</span> <span class="n">docorrThresh</span>
        <span class="k">else</span><span class="p">:</span>  
            <span class="n">hardLim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bandThresh</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">Band</span><span class="p">]</span>
        
        <span class="k">if</span> <span class="n">docorr</span><span class="p">:</span>
            <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;####################&#39;</span><span class="p">)</span>
            <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;Using Application threshold for ReNorm =&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">hardLim</span><span class="p">))</span>
            <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;Only spws where fields exceed this will be corrected&#39;</span><span class="p">)</span>
            <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;####################&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;Using threshold limit of &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">hardLim</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39; for renormalization determination&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">nfit</span><span class="o">=</span><span class="n">nfit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fthresh</span><span class="o">=</span><span class="n">fthresh</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="o">=</span><span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;inputs&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;inputs&#39;</span><span class="p">][</span><span class="s1">&#39;bwthresh&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">bwthresh</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;inputs&#39;</span><span class="p">][</span><span class="s1">&#39;bwdiv&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">bwdiv</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;inputs&#39;</span><span class="p">][</span><span class="s1">&#39;bwthreshspw&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">bwthreshspw</span>

        <span class="c1"># the spws to process (FDM only)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">spws</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">spws</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">msmeta</span><span class="o">.</span><span class="n">almaspws</span><span class="p">(</span><span class="n">fdm</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span> 
            <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;Found FDM spws = &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">spws</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Force input list to be of type int</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">spws</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">str</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">spws</span><span class="p">)):</span>
                    <span class="n">spws</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">spws</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;User supplied spws = &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">spws</span><span class="p">))</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">uspw</span> <span class="ow">in</span> <span class="n">spws</span> <span class="k">for</span> <span class="n">uspw</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fdmspws</span><span class="p">)):</span>
                <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;User supplied spw(s) are not in the list of FDM spws =&gt; &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fdmspws</span><span class="p">))</span>
                <span class="k">raise</span> <span class="ne">SyntaxError</span><span class="p">(</span><span class="s1">&#39;User supplied spw(s) are not in the list of FDM spws =&gt; &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fdmspws</span><span class="p">))</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">excludespws</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;Will exclude spws=&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">excludespws</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">espw</span> <span class="ow">in</span> <span class="n">excludespws</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">spws</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">espw</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                    <span class="n">spws</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">espw</span><span class="p">)</span>

        <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;Will process spws = &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">spws</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;spws&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">spws</span>

        <span class="c1"># List of target scans if user didn&#39;t input any</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">targscans</span><span class="p">:</span>
            <span class="n">targscans</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">msmeta</span><span class="o">.</span><span class="n">scansforintent</span><span class="p">(</span><span class="s1">&#39;*TARGET*&#39;</span><span class="p">))</span>
        
        <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;Will process science target scans=&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">targscans</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">nScan</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">targscans</span><span class="p">)</span>
        
        <span class="c1"># This sets up rnstats for later summary plots</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;scans&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">targscans</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;rNmax&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">num_corrs</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nAnt</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">spws</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">targscans</span><span class="p">)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;rNmdev&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">num_corrs</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nAnt</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">spws</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">targscans</span><span class="p">)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;N&#39;</span><span class="p">]</span><span class="o">=</span><span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;N_atm&#39;</span><span class="p">]</span><span class="o">=</span><span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;N_thresh&#39;</span><span class="p">]</span><span class="o">=</span><span class="p">{}</span> <span class="c1"># same as N except only populated when the hardLim is reached</span>

        <span class="c1"># Excludeants function</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">excludeants</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># check type</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">excludeants</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">str</span><span class="p">:</span>
                <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39; excludeants requires a list of antenna ID(s) or antenna Name(s)&#39;</span><span class="p">)</span>
                <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39; e.g. [0,1] or [&quot;DA44&quot;,&quot;DA45&quot;]&#39;</span><span class="p">)</span>
                <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;*** Terminating renormalization run ***&#39;</span><span class="p">,</span> <span class="s1">&#39;INFO&#39;</span><span class="p">,</span> <span class="s1">&#39;ReNormalize&#39;</span><span class="p">)</span>   
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;excludeants requires a list of antenna ID(s) or antenna name(s) (e.g. [0,1] or [&quot;DA44&quot;, &quot;DA55&quot;]&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># note this does not check if the Antenna is actually in the Antenna Names list</span>
                <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">excludeants</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">str</span><span class="p">:</span>
                    <span class="c1"># convert to antenna ID</span>
                    <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;Will exclude antennas = &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">((</span><span class="s1">&#39;,&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">excludeants</span><span class="p">)))</span>
                    <span class="n">excludeants</span><span class="o">=</span><span class="p">[</span><span class="n">excn</span> <span class="k">for</span> <span class="n">excn</span><span class="p">,</span><span class="n">exca</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">AntName</span><span class="p">)</span> <span class="k">if</span> <span class="n">exca</span> <span class="ow">in</span> <span class="n">excludeants</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;Will exclude antennas = &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">((</span><span class="s1">&#39;,&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">AntName</span><span class="p">[[</span><span class="n">excludeants</span><span class="p">]]))))</span>

        <span class="k">if</span> <span class="n">excflagged</span><span class="p">:</span>
            <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;For each spw, scan, field will exclude fully flagged antennas&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">diagSpectra</span><span class="p">:</span>
            <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;Will plot diagnostic spectra per spw, scan, field&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">checkFalsePositives</span><span class="p">:</span>
            <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;Will check for false positive renormalization triggers from atmospheric features.&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">atmMask</span><span class="o">=</span><span class="p">{}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">atmWarning</span><span class="o">=</span><span class="p">{}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">atmExcludeCmd</span><span class="o">=</span><span class="p">{}</span>

        <span class="k">if</span> <span class="n">atmAutoExclude</span><span class="p">:</span>
            <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;Regions of the spectrum where atmospheric lines are found will be excluded.&#39;</span><span class="p">)</span>
            <span class="n">checkFalsePositives</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="n">excludechan</span><span class="p">:</span>
            <span class="c1"># checkformats sucessively for fail modes</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">excludechan</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">dict</span><span class="p">:</span>
                <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39; excludechan requires a string dict input&#39;</span><span class="p">)</span>
                <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39; e.g. {&quot;22&quot;:&quot;100~150&quot;}&#39;</span><span class="p">)</span>
                <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;*** Terminating renormalization run ***&#39;</span><span class="p">,</span> <span class="s1">&#39;INFO&#39;</span><span class="p">,</span> <span class="s1">&#39;ReNormalize&#39;</span><span class="p">)</span>   
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;excludechan parameter requires a string dict input.&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">excch</span> <span class="ow">in</span> <span class="n">excludechan</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">excch</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">str</span><span class="p">:</span>
                    <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39; excludechan requires a string dict input&#39;</span><span class="p">)</span>
                    <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39; e.g. {&quot;22&quot;:&quot;100~150&quot;}&#39;</span><span class="p">)</span>
                    <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;*** Terminating renormalization run ***&#39;</span><span class="p">,</span> <span class="s1">&#39;INFO&#39;</span><span class="p">,</span> <span class="s1">&#39;ReNormalize&#39;</span><span class="p">)</span>   
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;excludechan parameter requires a string dict input&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="n">excch</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">spws</span><span class="p">:</span>
                    <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39; excludechan specified SPW &#39;</span><span class="o">+</span><span class="n">excch</span><span class="o">+</span><span class="s1">&#39; is not a SPW of this dataset&#39;</span><span class="p">)</span>
                    <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;*** Terminating renormalization run ***&#39;</span><span class="p">,</span> <span class="s1">&#39;INFO&#39;</span><span class="p">,</span> <span class="s1">&#39;ReNormalize&#39;</span><span class="p">)</span>   
                    <span class="k">raise</span> <span class="ne">SyntaxError</span><span class="p">(</span><span class="s1">&#39;Inconsistent input parameters: excludechan contains spws not in spw parameter&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">excludechan</span><span class="p">[</span><span class="n">excch</span><span class="p">])</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">str</span><span class="p">:</span>
                    <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39; excludechan requires a string dict input for channels&#39;</span><span class="p">)</span>
                    <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39; e.g. {&quot;22&quot;:&quot;100~150&quot;}&#39;</span><span class="p">)</span>
                    <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;*** Terminating renormalization run ***&#39;</span><span class="p">,</span> <span class="s1">&#39;INFO&#39;</span><span class="p">,</span> <span class="s1">&#39;ReNormalize&#39;</span><span class="p">)</span>   
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;excludechan requires a stringdict input for channels&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="s1">&#39;~&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">excludechan</span><span class="p">[</span><span class="n">excch</span><span class="p">]:</span>
                    <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39; excludechan requires a channel range separator of &quot;~&quot;&#39;</span><span class="p">)</span>
                    <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39; e.g. {&quot;22&quot;:&quot;100~150&quot;}&#39;</span><span class="p">)</span>
                    <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;*** Terminating renormalization run ***&#39;</span><span class="p">,</span> <span class="s1">&#39;INFO&#39;</span><span class="p">,</span> <span class="s1">&#39;ReNormalize&#39;</span><span class="p">)</span>   
                    <span class="k">raise</span> <span class="ne">SyntaxError</span><span class="p">(</span><span class="s1">&#39;excludechan requires a channel range separator of &quot;~&quot; (tilde)&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">excludechan</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">excludechan</span><span class="o">=</span><span class="p">{}</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">excludechan</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">str</span><span class="p">:</span>
            <span class="n">excludechan</span><span class="o">=</span><span class="p">{}</span>
        <span class="c1"># PIPE-1612: make a copy of the excludechan input so that it&#39;s not modified in the upstream code</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;inputs&#39;</span><span class="p">][</span><span class="s1">&#39;excludechan&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">excludechan</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">useDynamicSegments</span><span class="p">:</span>
            <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;Will examine segment boundaries for possible issues and automatically resize.&#39;</span><span class="p">)</span>

        <span class="c1"># Bwthreshspw (dictionary)</span>
        <span class="k">if</span> <span class="n">bwthreshspw</span><span class="p">:</span>
            <span class="c1"># check formats sucessively for fail modes</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">bwthreshspw</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">dict</span><span class="p">:</span>
                <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39; bwthreshspw requires a string dict input&#39;</span><span class="p">)</span>
                <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39; e.g. {&quot;22&quot;:120e6}&#39;</span><span class="p">)</span>
                <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;*** Terminating renormalization run ***&#39;</span><span class="p">,</span> <span class="s1">&#39;INFO&#39;</span><span class="p">,</span> <span class="s1">&#39;ReNormalize&#39;</span><span class="p">)</span>   
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;bwthreshspw requires a string dict input&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">spwth</span> <span class="ow">in</span> <span class="n">bwthreshspw</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">spwth</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">str</span><span class="p">:</span>
                    <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39; bwthreshspw requires the spw as a string input&#39;</span><span class="p">)</span>
                    <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39; e.g. {&quot;22&quot;:120e6}&#39;</span><span class="p">)</span>
                    <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;*** Terminating renormalization run ***&#39;</span><span class="p">,</span> <span class="s1">&#39;INFO&#39;</span><span class="p">,</span> <span class="s1">&#39;ReNormalize&#39;</span><span class="p">)</span>   
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;bwthreshspw requires the spw as a string input&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="n">spwth</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">spws</span><span class="p">:</span>
                    <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39; bwthreshspw SPW specified is not a SPW of this dataset&#39;</span><span class="p">)</span>
                    <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;*** Terminating renormalization run ***&#39;</span><span class="p">,</span> <span class="s1">&#39;INFO&#39;</span><span class="p">,</span> <span class="s1">&#39;ReNormalize&#39;</span><span class="p">)</span>   
                    <span class="k">raise</span> <span class="ne">SyntaxError</span><span class="p">(</span><span class="s1">&#39;bwthreshspw SPW specified is not a SPW of this dataset&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">bwthreshspw</span><span class="p">[</span><span class="n">spwth</span><span class="p">])</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">float</span><span class="p">:</span>
                    <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39; bwthreshspw requires a float for the bw-threshold&#39;</span><span class="p">)</span>
                    <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39; e.g. {&quot;22&quot;:120e6}&#39;</span><span class="p">)</span>
                    <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;*** Terminating renormalization run ***&#39;</span><span class="p">,</span> <span class="s1">&#39;INFO&#39;</span><span class="p">,</span> <span class="s1">&#39;ReNormalize&#39;</span><span class="p">)</span>   
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;bwthreshspw requires a float for the bw threshold&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">useDynamicSegments</span><span class="p">:</span>
                <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39; bwthreshspw specified but useDynamicSegments was also specified.&#39;</span><span class="p">)</span>
                <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39; I will use the user input and turn off dynamic segmentation for specified spws.&#39;</span><span class="p">)</span>

        <span class="c1"># Send all input options to the log file so it&#39;s clear what has been entered</span>
        <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;Equivalent manual input:&#39;</span><span class="p">)</span>
        <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">self.renormalize(excludespws=&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">excludespws</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;, spws=&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">spws</span><span class="p">)</span> \
                <span class="o">+</span> <span class="s1">&#39;, targscans=&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">targscans</span><span class="p">))</span>
        <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;    excludeants=&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">excludeants</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;, excludechan=&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">excludechan</span><span class="p">)</span>\
                <span class="o">+</span><span class="s1">&#39;, excflagged=&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">excflagged</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;, fixOutliers=&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">fixOutliers</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;, mededge=&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">mededge</span><span class="p">))</span>
        <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;    atmAutoExclude=&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">atmAutoExclude</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;, checkFalsePositives=&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">checkFalsePositives</span><span class="p">)</span> \
                <span class="o">+</span><span class="s1">&#39;, correctATM=&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">correctATM</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;, limATM=&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">limATM</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;, plotATM=&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">plotATM</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;,&#39;</span><span class="p">)</span>
        <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;    bwdiv=&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">bwdiv</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;, bwthresh=&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">bwthresh</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;, bwthreshspw=&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">bwthreshspw</span><span class="p">)</span> \
                <span class="o">+</span><span class="s1">&#39;, checkLineForest=&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">checkLineForest</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;, nfit=&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">nfit</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;, useDynamicSegments=&#39;</span> \
                <span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">useDynamicSegments</span><span class="p">))</span>
        <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;    datacolumn=&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">datacolumn</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;, docorr=&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">docorr</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;, docorrThresh=&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">docorrThresh</span><span class="p">)</span> \
                <span class="o">+</span><span class="s1">&#39;, usePhaseAC=&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">usePhaseAC</span><span class="p">))</span>
        <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;    antHeuristicsSpectra=&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">antHeuristicsSpectra</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;, diagSpectra=&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">diagSpectra</span><span class="p">)</span> \
                <span class="o">+</span><span class="s1">&#39;, fthresh=&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">fthresh</span><span class="p">))</span>
        <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;    verbose=&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">verbose</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;)&#39;</span><span class="p">)</span>

        <span class="c1"># Want to loop over sources so we can disentangle fields and sources and better plot what is happening</span>
        <span class="c1"># for mosaics and multi-target observations. </span>
        <span class="n">target_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">msmeta</span><span class="o">.</span><span class="n">namesforfields</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">msmeta</span><span class="o">.</span><span class="n">fieldsforintent</span><span class="p">(</span><span class="s1">&#39;*TARGET*&#39;</span><span class="p">)))</span>
        <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Found targets: &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">target_list</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">target_list</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;N&#39;</span><span class="p">][</span><span class="n">target</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;N_atm&#39;</span><span class="p">][</span><span class="n">target</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;N_thresh&#39;</span><span class="p">][</span><span class="n">target</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;inputs&#39;</span><span class="p">][</span><span class="n">target</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">docorrApply</span><span class="p">[</span><span class="n">target</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span> 

            <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1"> Processing Target=&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">target</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39; ******************************&#39;</span><span class="p">)</span>
      
            <span class="c1"># process each spw</span>
            <span class="n">dospws</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">spws</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">msmeta</span><span class="o">.</span><span class="n">spwsforfield</span><span class="p">(</span><span class="n">target</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">ispw</span> <span class="ow">in</span> <span class="n">dospws</span><span class="p">:</span>
                <span class="c1"># Not all targets are in all scans, we need to iterate over only those scans containing the target</span>
                <span class="n">target_scans</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">msmeta</span><span class="o">.</span><span class="n">scansforintent</span><span class="p">(</span><span class="s1">&#39;*TARGET*&#39;</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">msmeta</span><span class="o">.</span><span class="n">scansforfield</span><span class="p">(</span><span class="n">target</span><span class="p">))</span>

                <span class="c1"># Make an additional cut to catch only those scans which contain the current spw (usually only relevant</span>
                <span class="c1"># for spectral scan datasets)</span>
                <span class="n">target_scans</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">target_scans</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">msmeta</span><span class="o">.</span><span class="n">scansforspw</span><span class="p">(</span><span class="n">ispw</span><span class="p">))</span>

                <span class="c1"># If user input list of scans to use, cross check those with the list of all scans on targets to make</span>
                <span class="c1"># sure it&#39;s necessary to perform this loop. </span>
                <span class="n">target_scans</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">target_scans</span><span class="p">,</span> <span class="n">targscans</span><span class="p">)</span>
                
                <span class="c1"># if there is no intersection of the input scan list and the list of scans with this target, break </span>
                <span class="c1"># out of the spw loop and continue on to the next target.</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">target_scans</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1"> Target &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">target</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39; is not contained in the input scan list &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">targscans</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;. Moving to next target.</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
                    <span class="k">break</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">docorrApply</span><span class="p">[</span><span class="n">target</span><span class="p">][</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)]</span> <span class="o">=</span> <span class="kc">None</span> <span class="c1"># instantiating the spw dictionary for this target</span>

                <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1"> Processing spw=&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39; (nchan=&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">msmeta</span><span class="o">.</span><span class="n">nchan</span><span class="p">(</span><span class="n">ispw</span><span class="p">))</span><span class="o">+</span><span class="s1">&#39;) ******************************&#39;</span><span class="p">)</span>

                <span class="c1"># Setup for phase cal AC rather than Bandpass AC</span>
                <span class="k">if</span> <span class="n">usePhaseAC</span><span class="p">:</span>
                    <span class="c1"># just pick up the full list of phase cal scans</span>
                    <span class="c1"># later work out which one we get the AC from within the loop over the target scans</span>
                    <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;Will use PHASE calibrator AutoCorr for comparisons&#39;</span><span class="p">)</span>
                    <span class="n">Phscan</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getPhscan</span><span class="p">(</span><span class="n">ispw</span><span class="p">,</span><span class="n">verbose</span><span class="p">)</span>
                    <span class="c1"># still need Bandpass scan for any ATM plots - these are only for illustration</span>
                    <span class="n">Bscan</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getBscan</span><span class="p">(</span><span class="n">ispw</span><span class="p">,</span><span class="n">verbose</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># discern the B scan(s) which will be used - otherwise for using the phase AC we get it later</span>
                    <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;Will use BANDPASS source AutoCorr for comparisons&#39;</span><span class="p">)</span> 
                    <span class="n">Bscan</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getBscan</span><span class="p">(</span><span class="n">ispw</span><span class="p">,</span><span class="n">verbose</span><span class="p">)</span>
                    <span class="c1"># and get corr- and ant-dep B, time-averaged </span>
                    <span class="n">B</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getACdata</span><span class="p">(</span><span class="n">Bscan</span><span class="p">,</span><span class="n">ispw</span><span class="p">,</span><span class="kc">None</span><span class="p">,</span><span class="kc">True</span><span class="p">)</span>

                <span class="c1"># If correctATM then we need to get the ATM transmission for the bandpass</span>
                <span class="c1"># this can happen outside the scan loop below where we get for the target</span>
                <span class="c1"># and optionally for the phase cal</span>
                <span class="k">if</span> <span class="n">correctATM</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">Bscan</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">:</span>
                        <span class="n">Bscanatm</span> <span class="o">=</span> <span class="n">Bscan</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">Bscanatm</span> <span class="o">=</span> <span class="n">Bscan</span>
                    <span class="k">if</span> <span class="s1">&#39;BandPass&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">atmtrans</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                        <span class="c1"># make initiation check as we loop spw then</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">atmtrans</span><span class="p">[</span><span class="s1">&#39;BandPass&#39;</span><span class="p">]</span><span class="o">=</span><span class="p">{}</span>
                    <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">Bscanatm</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">atmtrans</span><span class="p">[</span><span class="s1">&#39;BandPass&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">atmtrans</span><span class="p">[</span><span class="s1">&#39;BandPass&#39;</span><span class="p">][</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)]</span><span class="o">=</span><span class="p">{}</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">atmtrans</span><span class="p">[</span><span class="s1">&#39;BandPass&#39;</span><span class="p">][</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)][</span><span class="nb">str</span><span class="p">(</span><span class="n">Bscanatm</span><span class="p">)]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ATMtrans</span><span class="p">(</span><span class="n">Bscanatm</span><span class="p">,</span><span class="n">ispw</span><span class="p">,</span><span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="c1"># here will make first call to ATMtrans, which can access resetting the correctATM</span>
                    <span class="c1"># global variable in case the PWV cannot be found for the data</span>

                <span class="c1"># global list of scans with the current spw</span>
                <span class="n">spwscans</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">msmeta</span><span class="o">.</span><span class="n">scansforspw</span><span class="p">(</span><span class="n">ispw</span><span class="p">))</span>

                <span class="k">if</span> <span class="n">bwthreshspw</span><span class="p">:</span>
                    <span class="c1"># check if the spw is ispw and use different bwthreshold</span>
                    <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)</span> <span class="ow">in</span> <span class="n">bwthreshspw</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                        <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39; Using SPW specific bwthresh of &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">bwthreshspw</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)])</span><span class="o">+</span><span class="s1">&#39; for &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">))</span> 
                        <span class="p">(</span><span class="n">nseg</span><span class="p">,</span><span class="n">dNchan</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calcChanRanges</span><span class="p">(</span><span class="n">ispw</span><span class="p">,</span><span class="n">bwthreshspw</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)],</span><span class="n">bwdiv</span><span class="p">,</span><span class="n">edge</span><span class="o">=</span><span class="n">mededge</span><span class="p">,</span><span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># spw not in the bwthreshspw keys list - calculate channel chunks with defaults</span>
                        <span class="p">(</span><span class="n">nseg</span><span class="p">,</span><span class="n">dNchan</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calcChanRanges</span><span class="p">(</span><span class="n">ispw</span><span class="p">,</span><span class="n">bwthresh</span><span class="p">,</span><span class="n">bwdiv</span><span class="p">,</span><span class="n">edge</span><span class="o">=</span><span class="n">mededge</span><span class="p">,</span><span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># no bwthreshspw option - calculate channel chunks with defaults as normal</span>
                    <span class="p">(</span><span class="n">nseg</span><span class="p">,</span><span class="n">dNchan</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calcChanRanges</span><span class="p">(</span><span class="n">ispw</span><span class="p">,</span><span class="n">bwthresh</span><span class="p">,</span><span class="n">bwdiv</span><span class="p">,</span><span class="n">edge</span><span class="o">=</span><span class="n">mededge</span><span class="p">,</span><span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
                
                <span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;inputs&#39;</span><span class="p">][</span><span class="n">target</span><span class="p">][</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)]</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;inputs&#39;</span><span class="p">][</span><span class="n">target</span><span class="p">][</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)][</span><span class="s1">&#39;num_segments&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;inputs&#39;</span><span class="p">][</span><span class="n">target</span><span class="p">][</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)][</span><span class="s1">&#39;dNchan&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

                <span class="c1"># init Norm spectra for this spw</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;N&#39;</span><span class="p">][</span><span class="n">target</span><span class="p">][</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)]</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">num_corrs</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">msmeta</span><span class="o">.</span><span class="n">nchan</span><span class="p">(</span><span class="n">ispw</span><span class="p">),</span><span class="bp">self</span><span class="o">.</span><span class="n">nAnt</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;N_thresh&#39;</span><span class="p">][</span><span class="n">target</span><span class="p">][</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">num_corrs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">msmeta</span><span class="o">.</span><span class="n">nchan</span><span class="p">(</span><span class="n">ispw</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">nAnt</span><span class="p">))</span>

                <span class="c1"># process each target scan</span>
                <span class="n">ngoodscan</span><span class="o">=</span><span class="mi">0</span>
                <span class="n">ngoodscan_thresh</span><span class="o">=</span><span class="mi">0</span>

                <span class="k">if</span> <span class="n">fixOutliers</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">AntOut</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)]</span><span class="o">=</span><span class="p">{}</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">replacedCorr</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)]</span><span class="o">=</span><span class="p">[]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">birdiechan</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)]</span><span class="o">=</span><span class="p">[]</span>
                    <span class="c1"># sets for list of known ants with channel outliers </span>
                
                <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;Target is in the following scans: &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">target_scans</span><span class="p">))</span>

                <span class="c1"># We want to apply over all fields even if only one field of a mosaic is over the limit. </span>
                <span class="c1"># This will also catch anything that wobbles around the limit and make sure it is applied.</span>
                <span class="k">if</span> <span class="n">docorr</span><span class="p">:</span> 
                    <span class="n">num_passes</span> <span class="o">=</span> <span class="mi">2</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">num_passes</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">second_pass</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">second_pass_required</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">for</span> <span class="n">npass</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_passes</span><span class="p">):</span>
                    <span class="c1"># if num_passes = 2, then npass will be set to 0 on first loop and 1 on second loop (then stops when 2 is reached).</span>
                    <span class="c1"># So, if npass == 1, it&#39;s the second loop and if second_pass was *not* set to True at the end of the loop, we don&#39;t</span>
                    <span class="c1"># need to go through the loop again.</span>
                    <span class="k">if</span> <span class="n">npass</span><span class="o">==</span><span class="mi">1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">second_pass_required</span><span class="p">:</span>
                        <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;Threshold limit not reached for any field/scan of spw &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39; of target &#39;</span><span class="o">+</span><span class="n">target</span><span class="o">+</span><span class="s1">&#39;.&#39;</span><span class="p">)</span>
                        <span class="k">continue</span>
                    <span class="c1"># Same as previous but if second_pass_required is set to True, we need to apply the correction and run through the scan loop again.</span>
                    <span class="k">elif</span> <span class="n">npass</span><span class="o">==</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">second_pass_required</span><span class="p">:</span>
                        <span class="n">second_pass</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Threshold limit was reached for one or more fields/scans of spw &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39; of target &#39;</span><span class="o">+</span><span class="n">target</span><span class="o">+</span><span class="s1">&#39;. Applying renormalization correction to all scans, fields, and polarizations.&#39;</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">pass</span>

                    <span class="k">for</span> <span class="n">iscan</span> <span class="ow">in</span> <span class="n">target_scans</span><span class="p">:</span>
                        <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39; Processing scan=&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">iscan</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;------------------------------&#39;</span><span class="p">)</span>

                        <span class="c1"># LM added</span>
                        <span class="c1"># here we will get the Phasecal AC if requested</span>
                        <span class="c1"># this will be from the scan preceeding the target scan</span>
                        <span class="c1"># get the existing phase cal scan numerically lower than the target scan &#39;iscan&#39;</span>
                        <span class="k">if</span> <span class="n">usePhaseAC</span><span class="p">:</span>
                            <span class="n">scanIdx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Phscan</span><span class="p">)</span><span class="o">&lt;</span><span class="n">iscan</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                            <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;**************** using the phase cal scan &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">Phscan</span><span class="p">[</span><span class="n">scanIdx</span><span class="p">])</span><span class="o">+</span><span class="s1">&#39; *************************&#39;</span><span class="p">)</span>
                            <span class="n">B</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getACdata</span><span class="p">(</span><span class="n">Phscan</span><span class="p">[</span><span class="n">scanIdx</span><span class="p">],</span><span class="n">ispw</span><span class="p">,</span><span class="kc">None</span><span class="p">,</span><span class="kc">True</span><span class="p">)</span>
                            <span class="k">if</span> <span class="n">correctATM</span><span class="p">:</span> 
                                <span class="k">if</span> <span class="s1">&#39;PhaseCal&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">atmtrans</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">atmtrans</span><span class="p">[</span><span class="s1">&#39;PhaseCal&#39;</span><span class="p">]</span><span class="o">=</span><span class="p">{}</span>
                                <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">atmtrans</span><span class="p">[</span><span class="s1">&#39;PhaseCal&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">atmtrans</span><span class="p">[</span><span class="s1">&#39;PhaseCal&#39;</span><span class="p">][</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)]</span><span class="o">=</span><span class="p">{}</span>
                                <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">iscan</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">atmtrans</span><span class="p">[</span><span class="s1">&#39;PhaseCal&#39;</span><span class="p">][</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                                    <span class="c1"># now we know this field, spw and scan is not filled and we will calc it</span>
                                    <span class="c1"># otherwise we just use what&#39;s there - i.e for a mosaic it doesn&#39;t redo for each ifld</span>
                                    <span class="c1"># because the atm trans model reads scan level only</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">atmtrans</span><span class="p">[</span><span class="s1">&#39;PhaseCal&#39;</span><span class="p">][</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)][</span><span class="nb">str</span><span class="p">(</span><span class="n">Phscan</span><span class="p">[</span><span class="n">scanIdx</span><span class="p">])]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ATMtrans</span><span class="p">(</span><span class="n">Phscan</span><span class="p">[</span><span class="n">scanIdx</span><span class="p">],</span><span class="n">ispw</span><span class="p">,</span><span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

                        <span class="c1"># get the fields to process in this scan - i.e. mosaics have many fields per scan</span>
                        <span class="n">Tarfld</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">msmeta</span><span class="o">.</span><span class="n">fieldsforscan</span><span class="p">(</span><span class="n">iscan</span><span class="p">))</span>
                        <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39; Will process science target field(s) &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">Tarfld</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39; within this scan&#39;</span><span class="p">)</span>

                        <span class="c1"># holder for a max value per scan to print out </span>
                        <span class="n">scanNmax</span><span class="o">=</span><span class="p">[]</span>

                        <span class="c1"># Now loop over the target fields</span>
                        <span class="k">for</span> <span class="n">ifld</span> <span class="ow">in</span> <span class="n">Tarfld</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                                <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39; Processing field=&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">ifld</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;-----------------------------&#39;</span><span class="p">)</span>

                            <span class="c1"># step over target scans that don&#39;t have the current spw</span>
                            <span class="k">if</span> <span class="n">spwscans</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">iscan</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                                    <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;Scan=&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">iscan</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39; is not a target scan in spw=&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">))</span>
                                <span class="k">continue</span>

                            <span class="c1"># initiate the self.scalingValues dictionary</span>
                            <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">scalingValues</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">scalingValues</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)]</span><span class="o">=</span><span class="p">{}</span>
                            <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">iscan</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">scalingValues</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">scalingValues</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)][</span><span class="nb">str</span><span class="p">(</span><span class="n">iscan</span><span class="p">)]</span><span class="o">=</span><span class="p">{}</span>
                            <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">ifld</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">scalingValues</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)][</span><span class="nb">str</span><span class="p">(</span><span class="n">iscan</span><span class="p">)]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">scalingValues</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)][</span><span class="nb">str</span><span class="p">(</span><span class="n">iscan</span><span class="p">)][</span><span class="nb">str</span><span class="p">(</span><span class="n">ifld</span><span class="p">)]</span><span class="o">=</span><span class="mf">1.0</span> <span class="c1"># default no scaling</span>

                            <span class="c1"># AutoCorr is divided by B (can be BANDPASS or PHASE cal AutoCorr) </span>
                            <span class="c1"># make if statement as getACdata can now return None if data was not filled</span>
                            <span class="n">ToB</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getACdata</span><span class="p">(</span><span class="n">iscan</span><span class="p">,</span><span class="n">ispw</span><span class="p">,</span><span class="n">ifld</span><span class="p">,</span><span class="kc">True</span><span class="p">)</span>
                            <span class="k">if</span> <span class="n">ToB</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> 
                                <span class="n">ToB</span><span class="o">/=</span><span class="n">B</span>

                                <span class="c1"># Renorm function will be Nb0 divided by a fit</span>
                                <span class="n">N</span><span class="o">=</span><span class="n">ToB</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

                                <span class="c1"># get the ATM transmission here for target - above for BP and Phase already</span>
                                <span class="c1"># and fix the data - should we do per scan or bulk - bulk should be enough</span>
                                <span class="c1"># to get rid of the main defect so fitting will work close enough (one hopes)</span>
                                <span class="k">if</span> <span class="n">correctATM</span> <span class="ow">or</span> <span class="n">checkFalsePositives</span><span class="p">:</span>
                                    <span class="c1"># we are in iscan, ispw  and ifld</span>
                                    <span class="c1"># in a mosaic we are safe to use one field as representative</span>
                                    <span class="c1"># because these differences are &#39;negligable&#39; </span>
                                    <span class="c1"># compared to possibly large ones we are trying to fix between the BP and target</span>
                                    <span class="n">fldname</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">msmeta</span><span class="o">.</span><span class="n">namesforfields</span><span class="p">(</span><span class="n">ifld</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>  

                                    <span class="c1"># need per scan, per spw - if we are just doing a bulk correction we miss any scan variations ??? </span>
                                
                                    <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">fldname</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">atmtrans</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">atmtrans</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">fldname</span><span class="p">)]</span><span class="o">=</span><span class="p">{}</span>
                                        <span class="k">if</span> <span class="n">checkFalsePositives</span><span class="p">:</span>
                                            <span class="bp">self</span><span class="o">.</span><span class="n">atmMask</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">fldname</span><span class="p">)]</span><span class="o">=</span><span class="p">{}</span>
                                            <span class="bp">self</span><span class="o">.</span><span class="n">atmWarning</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">fldname</span><span class="p">)]</span><span class="o">=</span><span class="p">{}</span>
                                            <span class="bp">self</span><span class="o">.</span><span class="n">atmExcludeCmd</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">fldname</span><span class="p">)]</span> <span class="o">=</span> <span class="p">{}</span>
                                    <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">atmtrans</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">fldname</span><span class="p">)]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">atmtrans</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">fldname</span><span class="p">)][</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)]</span><span class="o">=</span><span class="p">{}</span>
                                        <span class="k">if</span> <span class="n">checkFalsePositives</span><span class="p">:</span>
                                            <span class="bp">self</span><span class="o">.</span><span class="n">atmMask</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">fldname</span><span class="p">)][</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)]</span><span class="o">=</span><span class="p">{}</span>
                                            <span class="bp">self</span><span class="o">.</span><span class="n">atmWarning</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">fldname</span><span class="p">)][</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)]</span> <span class="o">=</span> <span class="kc">None</span>
                                            <span class="bp">self</span><span class="o">.</span><span class="n">atmExcludeCmd</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">fldname</span><span class="p">)][</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)]</span> <span class="o">=</span> <span class="kc">None</span>
                                    <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">iscan</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">atmtrans</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">fldname</span><span class="p">)][</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                                        <span class="c1"># now we know this field, spw and scan is not filled and we will calc it</span>
                                        <span class="c1"># otherwise we just use what&#39;s there - i.e for a mosaic it doesn&#39;t redo for each ifld</span>
                                        <span class="c1"># because the atm trans model reads scan level only</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">atmtrans</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">fldname</span><span class="p">)][</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)][</span><span class="nb">str</span><span class="p">(</span><span class="n">iscan</span><span class="p">)]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ATMtrans</span><span class="p">(</span><span class="n">iscan</span><span class="p">,</span><span class="n">ispw</span><span class="p">,</span><span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
                                        
                                        <span class="c1"># If desired, keep track of where ATM lines are so we can know if they are causing issues</span>
                                        <span class="k">if</span> <span class="n">checkFalsePositives</span><span class="p">:</span>
                                            <span class="n">atm_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">N</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">bool</span><span class="p">)</span><span class="o">*</span><span class="kc">False</span>
                                            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">Band</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">]:</span>
                                                <span class="n">atm_centers</span><span class="p">,</span> <span class="n">atm_gammas</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fitAtmLines</span><span class="p">(</span>
                                                        <span class="bp">self</span><span class="o">.</span><span class="n">atmtrans</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">fldname</span><span class="p">)][</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)][</span><span class="nb">str</span><span class="p">(</span><span class="n">iscan</span><span class="p">)][</span><span class="mi">0</span><span class="p">],</span> <span class="nb">int</span><span class="p">(</span><span class="n">ispw</span><span class="p">)</span>
                                                        <span class="p">)</span>
                                                <span class="n">atm_centers_SB</span><span class="p">,</span> <span class="n">atm_gammas_SB</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fitAtmLines</span><span class="p">(</span>
                                                        <span class="bp">self</span><span class="o">.</span><span class="n">atmtrans</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">fldname</span><span class="p">)][</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)][</span><span class="nb">str</span><span class="p">(</span><span class="n">iscan</span><span class="p">)][</span><span class="mi">1</span><span class="p">],</span> <span class="nb">int</span><span class="p">(</span><span class="n">ispw</span><span class="p">)</span>
                                                        <span class="p">)</span>
                                                <span class="n">atm_centers</span> <span class="o">+=</span> <span class="n">atm_centers_SB</span>
                                                <span class="n">atm_gammas</span> <span class="o">+=</span> <span class="n">atm_gammas_SB</span>
                                            <span class="k">else</span><span class="p">:</span>
                                                <span class="n">atm_centers</span><span class="p">,</span> <span class="n">atm_gammas</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fitAtmLines</span><span class="p">(</span>
                                                        <span class="bp">self</span><span class="o">.</span><span class="n">atmtrans</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">fldname</span><span class="p">)][</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)][</span><span class="nb">str</span><span class="p">(</span><span class="n">iscan</span><span class="p">)],</span> <span class="nb">int</span><span class="p">(</span><span class="n">ispw</span><span class="p">)</span>
                                                        <span class="p">)</span>
                                            <span class="k">for</span> <span class="n">cen</span><span class="p">,</span> <span class="n">gam</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">atm_centers</span><span class="p">,</span> <span class="n">atm_gammas</span><span class="p">):</span>
                                                <span class="n">atm_mask</span><span class="p">[</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">floor</span><span class="p">(</span><span class="n">cen</span><span class="o">-</span><span class="mf">1.3</span><span class="o">*</span><span class="n">gam</span><span class="p">)):</span><span class="nb">min</span><span class="p">(</span><span class="n">N</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">ceil</span><span class="p">(</span><span class="n">cen</span><span class="o">+</span><span class="mf">1.3</span><span class="o">*</span><span class="n">gam</span><span class="p">))]</span> <span class="o">=</span> <span class="kc">True</span>
                                            <span class="bp">self</span><span class="o">.</span><span class="n">atmMask</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">fldname</span><span class="p">)][</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)][</span><span class="nb">str</span><span class="p">(</span><span class="n">iscan</span><span class="p">)]</span> <span class="o">=</span> <span class="n">atm_mask</span>
                                            <span class="k">if</span> <span class="n">atm_mask</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                                                <span class="bp">self</span><span class="o">.</span><span class="n">atmExcludeCmd</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">fldname</span><span class="p">)][</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">suggestAtmExclude</span><span class="p">(</span>
                                                        <span class="n">target</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">),</span> <span class="n">return_command</span><span class="o">=</span><span class="kc">True</span>
                                                        <span class="p">)</span>                                                
                                                <span class="k">if</span> <span class="n">atmAutoExclude</span><span class="p">:</span>
                                                    <span class="c1"># Get a dictionary returned of regions to exclude due to ATM lines</span>
                                                    <span class="n">atm_exchan</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">suggestAtmExclude</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">),</span> <span class="n">return_dict</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                                                    <span class="c1"># Merge ATM results with user input and update our accounting</span>
                                                    <span class="n">excludechan</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">merge_dicts</span><span class="p">(</span><span class="n">excludechan</span><span class="p">,</span> <span class="n">atm_exchan</span><span class="p">)</span>
                                                    <span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;inputs&#39;</span><span class="p">][</span><span class="s1">&#39;excludechan&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">excludechan</span><span class="p">)</span>

                                <span class="n">skipAtmCorr</span><span class="o">=</span><span class="kc">True</span>
                                <span class="k">if</span> <span class="n">correctATM</span><span class="p">:</span>
                                    <span class="c1"># check if we want to do the fix, if the ATM line is not strong</span>
                                    <span class="c1"># it&#39;s a pointless calculation to work out the are differences</span>
                                    <span class="c1"># between the BandPass and Target pointings</span>
                                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atmtrans</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">fldname</span><span class="p">)][</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)][</span><span class="nb">str</span><span class="p">(</span><span class="n">iscan</span><span class="p">)])</span><span class="o">&lt;</span><span class="n">limATM</span><span class="p">:</span>
                                        <span class="c1"># * check now the global as if the ATM code previously didn&#39;t</span>
                                        <span class="c1"># * find the correct PWV, only nominal values were input</span>
                                        <span class="c1"># * and we probably don&#39;t want to use those for ATM correction</span>
                                        <span class="c1"># * as it could make ATM residuals worse</span>
                                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">corrATM</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                                            <span class="c1"># statement that is won&#39;t do the correction</span>
                                            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                                                <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;WARNING will not account for any ATM lines as requested as PWV not found&#39;</span><span class="p">)</span>
                                        <span class="k">else</span><span class="p">:</span>
                                            <span class="n">skipAtmCorr</span> <span class="o">=</span> <span class="kc">False</span>
                                            <span class="c1"># Want to keep a &quot;clean&quot; copy of the data so we can plot</span>
                                            <span class="c1"># the original data and see the improvement.</span>
                                            <span class="n">N_atm</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                                            <span class="c1"># now we pass to a function to do the correction</span>
                                            <span class="k">if</span> <span class="n">usePhaseAC</span><span class="p">:</span>
                                                <span class="bp">self</span><span class="o">.</span><span class="n">ATMcorrection</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="n">iscan</span><span class="p">,</span><span class="n">ispw</span><span class="p">,</span><span class="n">ifld</span><span class="p">,</span><span class="nb">str</span><span class="p">(</span><span class="n">Phscan</span><span class="p">[</span><span class="n">scanIdx</span><span class="p">]),</span><span class="s1">&#39;PhaseCal&#39;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span> 
                                                <span class="c1"># just edits the N in place - i.e. should flattens out the ATM region </span>
                                                <span class="c1"># - could pass fldname also but re-gets this in ATM correction function</span>
                                            <span class="k">else</span><span class="p">:</span>
                                                <span class="c1"># bscanatm already specified above </span>
                                                <span class="bp">self</span><span class="o">.</span><span class="n">ATMcorrection</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="n">iscan</span><span class="p">,</span><span class="n">ispw</span><span class="p">,</span><span class="n">ifld</span><span class="p">,</span><span class="nb">str</span><span class="p">(</span><span class="n">Bscanatm</span><span class="p">),</span><span class="s1">&#39;BandPass&#39;</span><span class="p">,</span><span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> 
                                                <span class="c1"># just edits the N in place - i.e. should flattens out the ATM region </span>
                                    <span class="k">else</span><span class="p">:</span>
                                        <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;No ATM features found below set limATM limit of &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">limATM</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;. Skipping computation of ATM correction.&#39;</span><span class="p">)</span>
                                        <span class="n">skipAtmCorr</span> <span class="o">=</span> <span class="kc">True</span>


                                <span class="k">if</span> <span class="n">excludechan</span><span class="p">:</span>
                                    <span class="c1"># First check to make sure we have defined the N_atm variable as it holds the </span>
                                    <span class="c1"># &quot;original&quot; copy of the spectrum before any ATM fixing.</span>
                                    <span class="k">if</span> <span class="s1">&#39;N_atm&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">locals</span><span class="p">():</span>
                                        <span class="n">N_atm</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

                                    <span class="c1"># Now, what if N_atm exists due to an earlier spw but none of the above settings</span>
                                    <span class="c1"># have updated it yet?</span>
                                    <span class="c1">#</span>
                                    <span class="c1"># If we are skipping explicit ATM correction but N_atm already exists, it needs </span>
                                    <span class="c1"># to be updated.</span>
                                    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">corrATM</span> <span class="ow">and</span> <span class="n">skipAtmCorr</span><span class="p">:</span>
                                        <span class="n">N_atm</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

                                    <span class="c1"># Now if this spw is in the list of spws that include exclusion, find the ranges</span>
                                    <span class="c1"># and apply the exclusion (set data in channel ranges = 1.0)</span>
                                    <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)</span> <span class="ow">in</span> <span class="n">excludechan</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                                        <span class="n">ranges</span> <span class="o">=</span> <span class="p">[</span><span class="n">rng</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">rng</span> <span class="ow">in</span> <span class="n">excludechan</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;;&#39;</span><span class="p">)]</span>
                                        <span class="n">exloch</span><span class="p">,</span> <span class="n">exhich</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interpretExcludechan</span><span class="p">(</span><span class="n">ranges</span><span class="p">,</span> <span class="n">ispw</span><span class="p">)</span>
                                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">exloch</span><span class="p">)):</span>
                                            <span class="n">N</span><span class="p">[:,</span><span class="n">exloch</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span><span class="n">exhich</span><span class="p">[</span><span class="n">i</span><span class="p">],:]</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span>

                                <span class="c1"># ants and corrs to calculate:</span>
                                <span class="p">(</span><span class="n">nCor</span><span class="p">,</span><span class="n">nCha</span><span class="p">,</span><span class="n">nAnt</span><span class="p">)</span><span class="o">=</span><span class="n">N</span><span class="o">.</span><span class="n">shape</span>

                                <span class="c1"># If we want renorm to resize segments on-the-fly due to possible issues with the </span>
                                <span class="c1"># boundary choice, we need to loop over each fitting and check.</span>
                                <span class="k">if</span> <span class="n">useDynamicSegments</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">bwthreshspw</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                                    <span class="c1"># We may have to loop several times over our fitting process to ensure that we</span>
                                    <span class="c1"># don&#39;t have a line that needs to be corrected falling on a segment boundary.</span>
                                    <span class="c1"># Therefore, we set these to temporary values so we can adjust them freely.</span>
                                    <span class="n">nseg_tmp</span> <span class="o">=</span> <span class="n">nseg</span>
                                    <span class="n">dNchan_tmp</span> <span class="o">=</span> <span class="n">dNchan</span>
                                    
                                    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
                                    <span class="c1"># We will only loop down to 1 segment.</span>
                                    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">floor</span><span class="p">(</span><span class="n">nseg</span><span class="o">/</span><span class="mi">2</span><span class="p">):</span>
                                        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                                            <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">Attempting fitting with nseg=&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">nseg_tmp</span><span class="p">))</span>
                                        <span class="c1"># N is edited in place by self.calcReNorm1() so we make a clean copy to play </span>
                                        <span class="c1"># with while figuring out if the segmenting is working well.</span>
                                        <span class="n">N_tmp</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                                        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">corrATM</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">skipAtmCorr</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)</span> <span class="ow">in</span> <span class="n">excludechan</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                                            <span class="n">N_atm_tmp</span> <span class="o">=</span> <span class="n">N_atm</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                                        <span class="c1"># Initialize a redo variable for redoing the while loop</span>
                                        <span class="n">redo</span> <span class="o">=</span> <span class="kc">False</span>
                                        <span class="c1"># Loop over antennas, segments, and correlations</span>
                                        <span class="k">for</span> <span class="n">iant</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nAnt</span><span class="p">):</span>
                                            <span class="k">for</span> <span class="n">iseg</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nseg_tmp</span><span class="p">):</span>
                                                <span class="n">lochan</span><span class="o">=</span><span class="n">iseg</span><span class="o">*</span><span class="n">dNchan_tmp</span>
                                                <span class="n">hichan</span><span class="o">=</span><span class="p">(</span><span class="n">iseg</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">dNchan_tmp</span>
                                                <span class="k">for</span> <span class="n">icor</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nCor</span><span class="p">):</span>
                                                    <span class="c1"># Edits N in place! just does the fit to get zero baseline. </span>
                                                    <span class="c1"># This is calcuating the ReNorm scaling per ant !!!</span>
                                                    <span class="k">if</span> <span class="n">checkLineForest</span> <span class="ow">and</span> <span class="n">nseg_tmp</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
                                                        <span class="n">redo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calcReNorm1</span><span class="p">(</span>
                                                                <span class="n">N_tmp</span><span class="p">[</span><span class="n">icor</span><span class="p">,</span><span class="n">lochan</span><span class="p">:</span><span class="n">hichan</span><span class="p">,</span><span class="n">iant</span><span class="p">],</span>
                                                                <span class="n">checkFit</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                                <span class="n">doplot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                                                <span class="n">iden</span><span class="o">=</span><span class="s1">&#39;Ant&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">iant</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;Seg&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">iseg</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;Corr&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">icor</span><span class="p">),</span>
                                                                <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span>
                                                                <span class="p">)</span>
                                                    <span class="k">else</span><span class="p">:</span>
                                                        <span class="bp">self</span><span class="o">.</span><span class="n">calcReNorm1</span><span class="p">(</span>
                                                                <span class="n">N_tmp</span><span class="p">[</span><span class="n">icor</span><span class="p">,</span><span class="n">lochan</span><span class="p">:</span><span class="n">hichan</span><span class="p">,</span><span class="n">iant</span><span class="p">],</span>
                                                                <span class="n">checkFit</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                                                <span class="n">doplot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                                                <span class="n">iden</span><span class="o">=</span><span class="s1">&#39;Ant&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">iant</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;Seg&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">iseg</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;Corr&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">icor</span><span class="p">),</span>
                                                                <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span>
                                                                <span class="p">)</span>

                                                    <span class="c1"># If we applied an ATM correction to the data, want to</span>
                                                    <span class="c1"># also see the non-ATM corrected data.</span>
                                                    <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">corrATM</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">skipAtmCorr</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)</span> <span class="ow">in</span> <span class="n">excludechan</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                                                        <span class="bp">self</span><span class="o">.</span><span class="n">calcReNorm1</span><span class="p">(</span>
                                                                <span class="n">N_atm_tmp</span><span class="p">[</span><span class="n">icor</span><span class="p">,</span><span class="n">lochan</span><span class="p">:</span><span class="n">hichan</span><span class="p">,</span><span class="n">iant</span><span class="p">],</span>
                                                                <span class="n">checkFit</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                                                <span class="n">doplot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                                                <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span>
                                                                <span class="p">)</span>
                                                    <span class="k">if</span> <span class="n">redo</span><span class="p">:</span>
                                                        <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;    Widening segment and retrying fit.&#39;</span><span class="p">)</span>
                                                        <span class="k">break</span>
                                                <span class="k">if</span> <span class="n">redo</span><span class="p">:</span>
                                                    <span class="k">break</span>
                                            <span class="k">if</span> <span class="n">redo</span><span class="p">:</span>
                                                <span class="k">break</span>
                                        <span class="k">if</span> <span class="n">redo</span><span class="p">:</span>
                                            <span class="p">(</span><span class="n">nseg_tmp</span><span class="p">,</span><span class="n">dNchan_tmp</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calcChanRanges</span><span class="p">(</span>
                                                            <span class="n">ispw</span><span class="p">,</span>
                                                            <span class="n">bwthresh</span><span class="p">,</span>
                                                            <span class="nb">max</span><span class="p">(</span><span class="n">nseg_tmp</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span>
                                                            <span class="n">edge</span><span class="o">=</span><span class="n">mededge</span><span class="p">,</span>
                                                            <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span>
                                                            <span class="p">)</span>
                                            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
                                            <span class="k">continue</span>


                                        <span class="c1"># Now check to see if any of the +/- 10 channels near the upper or</span>
                                        <span class="c1"># lower segment edge are greater than 0.5% indicating an issue. If</span>
                                        <span class="c1"># there is an issue, then reset and do the above again with 2 fewer</span>
                                        <span class="c1"># segments</span>
                                        <span class="c1">#</span>
                                        <span class="c1"># Ignore the very edges, nothing we can do there anyway!</span>
                                        <span class="n">Nmed_tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmedian</span><span class="p">(</span><span class="n">N_tmp</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
                                        <span class="k">for</span> <span class="n">iseg</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">nseg_tmp</span><span class="p">):</span>
                                            <span class="n">seg_border</span><span class="o">=</span><span class="n">iseg</span><span class="o">*</span><span class="n">dNchan_tmp</span>
                                            <span class="c1"># Want to check +/- 10 MHz on either side of the segment border</span>
                                            <span class="c1"># or at least 10 channels.</span>
                                            <span class="n">limit</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">ceil</span><span class="p">(</span><span class="mf">10.e6</span> <span class="o">/</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">msmeta</span><span class="o">.</span><span class="n">chanwidths</span><span class="p">(</span><span class="n">ispw</span><span class="p">)[</span><span class="mi">0</span><span class="p">])))</span>
                                            <span class="k">if</span> <span class="n">nseg_tmp</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                                                <span class="n">trigger_floor</span> <span class="o">=</span> <span class="mf">1.005</span>
                                                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                                                    <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">Checking segment border at chan=&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">seg_border</span><span class="p">))</span>
                                                <span class="k">if</span> <span class="p">(</span><span class="n">Nmed_tmp</span><span class="p">[:,</span><span class="n">seg_border</span><span class="o">-</span><span class="n">limit</span><span class="p">:</span><span class="n">seg_border</span><span class="o">+</span><span class="n">limit</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">trigger_floor</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                                                    <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">Large scaling spectrum value (&gt;&#39;</span> \
                                                            <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">round</span><span class="p">((</span><span class="n">trigger_floor</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mi">100</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span> \
                                                            <span class="o">+</span> <span class="s1">&#39;%) found at border, resizing segments and trying again.&#39;</span><span class="p">)</span>
                                                    <span class="p">(</span><span class="n">nseg_tmp</span><span class="p">,</span><span class="n">dNchan_tmp</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calcChanRanges</span><span class="p">(</span>
                                                            <span class="n">ispw</span><span class="p">,</span>
                                                            <span class="n">bwthresh</span><span class="p">,</span>
                                                            <span class="nb">max</span><span class="p">(</span><span class="n">nseg_tmp</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span>
                                                            <span class="n">edge</span><span class="o">=</span><span class="n">mededge</span><span class="p">,</span>
                                                            <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span>
                                                            <span class="p">)</span>
                                                    <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
                                                    <span class="n">redo</span><span class="o">=</span><span class="kc">True</span>
                                                    <span class="k">break</span>
                                        <span class="c1"># Redo the fitting and such if we need to, otherwise, we&#39;re finished.</span>
                                        <span class="k">if</span> <span class="n">redo</span><span class="p">:</span>
                                            <span class="k">continue</span>
                                        <span class="k">else</span><span class="p">:</span>
                                            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                                                <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">Completed fitting procedure with nseg=&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">nseg_tmp</span><span class="p">))</span>
                                            <span class="k">break</span>

                                    <span class="c1"># Make sure to set N and N_atm correctly as well as capture the </span>
                                    <span class="c1"># final nseg and dNchan that was used. Note that this only keeps</span>
                                    <span class="c1"># the very last nseg and dNchan that was used so if the final scan</span>
                                    <span class="c1"># was different, it will not reflect the aggreagate choice, only</span>
                                    <span class="c1"># the very last choice.</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;inputs&#39;</span><span class="p">][</span><span class="n">target</span><span class="p">][</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)][</span><span class="s1">&#39;num_segments&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nseg_tmp</span><span class="p">)</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;inputs&#39;</span><span class="p">][</span><span class="n">target</span><span class="p">][</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)][</span><span class="s1">&#39;dNchan&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dNchan_tmp</span><span class="p">)</span>
                                    <span class="n">N</span> <span class="o">=</span> <span class="n">N_tmp</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                                    <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">corrATM</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">skipAtmCorr</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)</span> <span class="ow">in</span> <span class="n">excludechan</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                                        <span class="n">N_atm</span> <span class="o">=</span> <span class="n">N_atm_tmp</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

                                <span class="c1"># If we don&#39;t want to dynamically change the segment sizes or have specified one to </span>
                                <span class="c1"># use, just do it once and move on.</span>
                                <span class="k">else</span><span class="p">:</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;inputs&#39;</span><span class="p">][</span><span class="n">target</span><span class="p">][</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)][</span><span class="s1">&#39;num_segments&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nseg</span><span class="p">)</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;inputs&#39;</span><span class="p">][</span><span class="n">target</span><span class="p">][</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)][</span><span class="s1">&#39;dNchan&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dNchan</span><span class="p">)</span>

                                    <span class="c1">#If we are not using dynamic segments, then calculate what we have.</span>
                                    <span class="k">for</span> <span class="n">iant</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nAnt</span><span class="p">):</span>
                                        <span class="k">for</span> <span class="n">iseg</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nseg</span><span class="p">):</span>
                                            <span class="n">lochan</span><span class="o">=</span><span class="n">iseg</span><span class="o">*</span><span class="n">dNchan</span>
                                            <span class="n">hichan</span><span class="o">=</span><span class="p">(</span><span class="n">iseg</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">dNchan</span>
                                            <span class="k">for</span> <span class="n">icor</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nCor</span><span class="p">):</span>
                                                <span class="c1"># edits N in place! just does the fit to get zero baseline - this is calcuating the ReNorm scaling per ant !!!</span>
                                                <span class="bp">self</span><span class="o">.</span><span class="n">calcReNorm1</span><span class="p">(</span>
                                                        <span class="n">N</span><span class="p">[</span><span class="n">icor</span><span class="p">,</span><span class="n">lochan</span><span class="p">:</span><span class="n">hichan</span><span class="p">,</span><span class="n">iant</span><span class="p">],</span>
                                                        <span class="n">doplot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                                        <span class="n">iden</span><span class="o">=</span><span class="s1">&#39;Ant&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">iant</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;Seg&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">iseg</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;Corr&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">icor</span><span class="p">)</span>
                                                        <span class="p">)</span>
                                                <span class="c1">#N[icor,lochan:hichan,iant] = self.calcRenormLegendre(N[icor,lochan:hichan,iant])</span>

                                                <span class="c1"># If we applied an ATM correction to the data, want to</span>
                                                <span class="c1"># also see the non-ATM corrected data.</span>
                                                <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">corrATM</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">skipAtmCorr</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)</span> <span class="ow">in</span> <span class="n">excludechan</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                                                     <span class="bp">self</span><span class="o">.</span><span class="n">calcReNorm1</span><span class="p">(</span><span class="n">N_atm</span><span class="p">[</span><span class="n">icor</span><span class="p">,</span><span class="n">lochan</span><span class="p">:</span><span class="n">hichan</span><span class="p">,</span><span class="n">iant</span><span class="p">],</span><span class="n">doplot</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>                                    

                                <span class="c1">## LM added </span>
                                <span class="k">if</span> <span class="n">mededge</span><span class="p">:</span>
                                    <span class="c1"># will set the 0.01 (1% - default) of all edge channels to the median value of the scaling spectrum (circa 1)</span>
                                    <span class="c1"># stops high edge outliers</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">calcSetEdge</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">edge</span><span class="o">=</span><span class="n">mededge</span><span class="p">)</span>
                                    <span class="c1"># If we applied an ATM correction to the data, want to</span>
                                    <span class="c1"># also see the non-ATM corrected data.</span>
                                    <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">corrATM</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">skipAtmCorr</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)</span> <span class="ow">in</span> <span class="n">excludechan</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">calcSetEdge</span><span class="p">(</span><span class="n">N_atm</span><span class="p">,</span> <span class="n">edge</span><span class="o">=</span><span class="n">mededge</span><span class="p">)</span>


                                <span class="c1"># LM added - excflagged</span>
                                <span class="c1"># regardless of any manually input excludeants we still check the cross-corr</span>
                                <span class="c1"># data for those antennas and simply see if it is entirely flagged</span>
                                <span class="c1"># i.e. 100% flagged antenna we set to 1.0 - i.e. no scaling</span>
                                <span class="c1"># thus plots are not skewed and anyway these antennas are not in the IF data</span>
                                <span class="k">if</span> <span class="n">excflagged</span><span class="p">:</span>
                                    <span class="c1"># get the XC flags - if true returned its 100% flagged - deals with spw SPW, per scan basis as it is selected</span>
                                    <span class="n">antflagged</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getXCflags</span><span class="p">(</span><span class="n">iscan</span><span class="p">,</span><span class="n">ispw</span><span class="p">,</span><span class="n">ifld</span><span class="p">,</span><span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
                                    <span class="c1"># adds to excludeants list if its not already there</span>
                                    <span class="k">for</span> <span class="n">excant</span> <span class="ow">in</span> <span class="n">antflagged</span><span class="p">:</span>
                                        <span class="n">N</span><span class="p">[:,:,</span><span class="n">excant</span><span class="p">]</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span>
                                        <span class="c1"># If we applied an ATM correction to the data, want to</span>
                                        <span class="c1"># also see the non-ATM corrected data.</span>
                                        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">corrATM</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">skipAtmCorr</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)</span> <span class="ow">in</span> <span class="n">excludechan</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                                            <span class="n">N_atm</span><span class="p">[:,:,</span><span class="n">excant</span><span class="p">]</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span>
                                        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                                            <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;**** auto flagged antenna: &#39;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">AntName</span><span class="p">[</span><span class="n">excant</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39; for SPW=&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;, scan=&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">iscan</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;, field=&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">ifld</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39; ****&#39;</span><span class="p">)</span>

                                <span class="k">if</span> <span class="n">excludeants</span><span class="p">:</span>
                                    <span class="c1"># we are excluding antennas all by index - converted above from names if input</span>
                                    <span class="c1"># they should be set to 1.0 - this is a workaround to</span>
                                    <span class="c1"># avoid bad antennas messing up the plots - if an analyst really needed</span>
                                    <span class="c1"># to make a list of badantennas, and they were not flagged by pipeline</span>
                                    <span class="c1"># then it is worrying why data are bad ...</span>
                                    <span class="k">for</span> <span class="n">excant</span> <span class="ow">in</span> <span class="n">excludeants</span><span class="p">:</span>
                                        <span class="n">N</span><span class="p">[:,:,</span><span class="n">excant</span><span class="p">]</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span>
                                        <span class="c1"># If we applied an ATM correction to the data, want to</span>
                                        <span class="c1"># also see the non-ATM corrected data.</span>
                                        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">corrATM</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">skipAtmCorr</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)</span> <span class="ow">in</span> <span class="n">excludechan</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                                            <span class="n">N_atm</span><span class="p">[:,:,</span><span class="n">excant</span><span class="p">]</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span>


                                <span class="c1"># Check and fix outlier antennas compared to a representative median spectrum</span>
                                <span class="k">if</span> <span class="n">fixOutliers</span><span class="p">:</span> 
                                    <span class="n">AntChk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">checkOutlierAnt</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>

                                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">AntChk</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                                        <span class="c1"># pass badant to the fix code for channel by channel investigation and correction</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">calcFixReNorm</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="n">AntChk</span><span class="p">,</span><span class="n">iscan</span><span class="p">,</span><span class="n">ispw</span><span class="p">,</span><span class="n">ifld</span><span class="p">,</span><span class="n">doplot</span><span class="o">=</span><span class="n">antHeuristicsSpectra</span><span class="p">,</span><span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span> 
                                        <span class="c1"># If we applied an ATM correction to the data, want to</span>
                                        <span class="c1"># also see the non-ATM corrected data.</span>
                                        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">corrATM</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">skipAtmCorr</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)</span> <span class="ow">in</span> <span class="n">excludechan</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                                            <span class="bp">self</span><span class="o">.</span><span class="n">calcFixReNorm</span><span class="p">(</span><span class="n">N_atm</span><span class="p">,</span><span class="n">AntChk</span><span class="p">,</span><span class="n">iscan</span><span class="p">,</span><span class="n">ispw</span><span class="p">,</span><span class="n">ifld</span><span class="p">,</span><span class="n">doplot</span><span class="o">=</span><span class="n">antHeuristicsSpectra</span><span class="p">,</span><span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span> 

                                <span class="c1"># No need to do any of this on the second round of data </span>
                                <span class="k">if</span> <span class="ow">not</span> <span class="n">second_pass</span><span class="p">:</span>            
                                    <span class="c1"># Need to calculate the maximum &quot;N&quot; value found, averaging over all antennas.</span>
                                    <span class="c1"># We also need to exclude values of 1.0 if/where ants are flagged - otherwise </span>
                                    <span class="c1"># the output will be skewed by those values and misrepresented. Here we use </span>
                                    <span class="c1"># the found maximum when the max value != 1, otherwise we set it to a NaN and</span>
                                    <span class="c1"># then calculate the mean ignoring NaN&#39;s. </span>
                                    <span class="n">Nmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">N</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">!=</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> 

                                    <span class="c1"># If we wish to check for &quot;false positives&quot; where application of renormalization is</span>
                                    <span class="c1"># falsely triggered by an ATM feature, then do the same calculation as above but</span>
                                    <span class="c1"># only in the areas of the spectrum where ATM features are located. If there is a</span>
                                    <span class="c1"># feature above the set &quot;hardLim&quot; (usually 2%) then renorm will get triggered for it</span>
                                    <span class="c1"># or at least wrongly applied in that region. </span>
                                    <span class="c1"># </span>
                                    <span class="c1"># Also we want to keep track of the false positives if they occur (or not) using </span>
                                    <span class="c1"># an attribute of the renorm object - self.atmWarning[target][spw]</span>
                                    <span class="k">if</span> <span class="n">checkFalsePositives</span><span class="p">:</span>
                                        <span class="c1"># Check and make sure there actually is an ATM line, otherwise ignore.</span>
                                        <span class="k">if</span> <span class="n">atm_mask</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                                            <span class="c1"># If we automatically excluded ATM lines then everything is set to 1.0</span>
                                            <span class="c1"># in the range, therefore we need to check the N_atm array rather than</span>
                                            <span class="c1"># the N array.</span>
                                            <span class="k">if</span> <span class="n">atmAutoExclude</span><span class="p">:</span>
                                                <span class="n">Nmax_atm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span>
                                                        <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                                                            <span class="n">N_atm</span><span class="p">[:,</span><span class="n">atm_mask</span><span class="p">,:]</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">,</span>
                                                            <span class="n">N_atm</span><span class="p">[:,</span><span class="n">atm_mask</span><span class="p">,:]</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span>
                                                            <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                                                            <span class="p">),</span>
                                                        <span class="n">axis</span><span class="o">=</span><span class="mi">1</span>
                                                        <span class="p">)</span>
                                            <span class="k">else</span><span class="p">:</span>
                                                <span class="n">Nmax_atm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span>
                                                        <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                                                            <span class="n">N</span><span class="p">[:,</span><span class="n">atm_mask</span><span class="p">,:]</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">,</span>
                                                            <span class="n">N</span><span class="p">[:,</span><span class="n">atm_mask</span><span class="p">,:]</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span>
                                                            <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                                                            <span class="p">),</span>
                                                        <span class="n">axis</span><span class="o">=</span><span class="mi">1</span>
                                                        <span class="p">)</span>
                                            <span class="c1"># Check to see if the atm region was blanked by other means (excludechan)</span>
                                            <span class="c1"># such that the np.nanmean() of it will return NaN. </span>
                                            <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">Nmax_atm</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">Nmax_atm</span><span class="p">):</span>
                                                <span class="bp">self</span><span class="o">.</span><span class="n">atmWarning</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">fldname</span><span class="p">)][</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)]</span> <span class="o">=</span> <span class="kc">False</span>
                                            <span class="k">else</span><span class="p">:</span>
                                                <span class="k">if</span> <span class="p">(</span><span class="n">Nmax_atm</span> <span class="o">&gt;</span> <span class="n">hardLim</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                                                    <span class="k">if</span> <span class="n">atmAutoExclude</span><span class="p">:</span>
                                                        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                                                            <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;   Significant atmospheric signal was removed by atmAutoExclude.&#39;</span><span class="p">)</span>
                                                    <span class="k">else</span><span class="p">:</span>
                                                        <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;   WARNING! There may be significant artifical signal from an&#39;</span> \
                                                                    <span class="s1">&#39; atmospheric feature that will trigger renorm application!!!&#39;</span><span class="p">)</span>
                                                    <span class="bp">self</span><span class="o">.</span><span class="n">atmWarning</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">fldname</span><span class="p">)][</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)]</span> <span class="o">=</span> <span class="kc">True</span>
                                                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">atmWarning</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">fldname</span><span class="p">)][</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)]:</span>
                                                    <span class="k">pass</span>
                                                <span class="k">else</span><span class="p">:</span>
                                                    <span class="bp">self</span><span class="o">.</span><span class="n">atmWarning</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">fldname</span><span class="p">)][</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)]</span> <span class="o">=</span> <span class="kc">False</span>
                                        <span class="k">else</span><span class="p">:</span>
                                            <span class="bp">self</span><span class="o">.</span><span class="n">atmWarning</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">fldname</span><span class="p">)][</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)]</span> <span class="o">=</span> <span class="kc">False</span> 

                                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">Nmax</span><span class="p">)):</span>
                                        <span class="n">Nmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">1.0</span><span class="p">])</span>
                                    <span class="n">Nmads</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmedian</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">N</span><span class="o">!=</span><span class="mf">1.0</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="mf">1.0</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">),[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span> 
                                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">Nmads</span><span class="p">)):</span>
                                        <span class="n">Nmads</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">])</span>
                                    <span class="n">scanNmax</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">Nmax</span><span class="p">))</span>
                                    <span class="n">alarm</span><span class="o">=</span><span class="s1">&#39;   &#39;</span>
                                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">greater</span><span class="p">(</span><span class="n">Nmax</span><span class="p">,</span><span class="mf">1.0</span><span class="o">+</span><span class="n">usefthresh</span><span class="p">)):</span>
                                        <span class="n">alarm</span><span class="o">=</span><span class="s1">&#39;***&#39;</span>
                                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                                        <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;  Mean peak renormalization factor (power) per polarization = &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">alarm</span><span class="p">)</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">Nmax</span><span class="p">))</span>
                                        <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;  Median renormalization deviation (power) per polarization = &#39;</span><span class="o">+</span><span class="s1">&#39;   &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">Nmads</span><span class="p">))</span> 

                                    <span class="c1"># Diagnoastic plots - one level more detail vs. summary plots</span>
                                    <span class="c1"># this is really the ant level what will be applied as a scaling</span>
                                    <span class="c1">#</span>
                                    <span class="c1"># skip these if second pass...</span>
                                    <span class="k">if</span> <span class="n">diagSpectra</span><span class="p">:</span>
                                        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">corrATM</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">skipAtmCorr</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)</span> <span class="ow">in</span> <span class="n">excludechan</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                                            <span class="bp">self</span><span class="o">.</span><span class="n">plotdiagSpectra</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">iscan</span><span class="p">,</span> <span class="n">ispw</span><span class="p">,</span> <span class="n">ifld</span><span class="p">,</span> <span class="n">plotATM</span><span class="o">=</span><span class="n">plotATM</span><span class="p">,</span> <span class="n">N_atm</span><span class="o">=</span><span class="n">N_atm</span><span class="p">)</span>
                                        <span class="k">else</span><span class="p">:</span>
                                            <span class="bp">self</span><span class="o">.</span><span class="n">plotdiagSpectra</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">iscan</span><span class="p">,</span> <span class="n">ispw</span><span class="p">,</span> <span class="n">ifld</span><span class="p">,</span> <span class="n">plotATM</span><span class="o">=</span><span class="n">plotATM</span><span class="p">)</span>

                                    <span class="c1"># In the spectra, antennas that have some scans as 1.0 due to being </span>
                                    <span class="c1"># interferometrically flagged (or we excluded) we don&#39;t want them</span>
                                    <span class="c1"># to skew the summary cumulative average plots using the rnstats</span>
                                    <span class="c1"># if some scans are flagged and some are unflagged</span>
                                    <span class="k">if</span> <span class="n">excflagged</span><span class="p">:</span>  
                                        <span class="c1"># regardless of flagged antennas or not we need to initiate the rnstats on the first scan</span>
                                        <span class="k">if</span> <span class="n">ngoodscan</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                                            <span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;N&#39;</span><span class="p">][</span><span class="n">target</span><span class="p">][</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)]</span><span class="o">=</span> <span class="n">N</span>
                                            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">corrATM</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">skipAtmCorr</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)</span> <span class="ow">in</span> <span class="n">excludechan</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                                                <span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;N_atm&#39;</span><span class="p">][</span><span class="n">target</span><span class="p">][</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)]</span><span class="o">=</span> <span class="n">N_atm</span>
                                            <span class="n">ngoodscan</span><span class="o">+=</span><span class="mi">1</span>
                                        <span class="k">elif</span> <span class="n">antflagged</span> <span class="ow">and</span> <span class="n">ngoodscan</span><span class="o">!=</span><span class="mi">0</span><span class="p">:</span>
                                            <span class="c1"># enter this loop if there ARE flagged antennas  </span>
                                            <span class="k">for</span> <span class="n">lpAnt</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nAnt</span><span class="p">):</span>
                                                <span class="c1"># if the antenna is not listed as flagged and the initiated first</span>
                                                <span class="c1"># entry to rnstats[&#39;N&#39;] is not 1.0 (i.e. flagged) we do</span>
                                                <span class="c1"># the cumulative sum for the average spectra</span>
                                                <span class="k">if</span> <span class="n">lpAnt</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">antflagged</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;N&#39;</span><span class="p">][</span><span class="n">target</span><span class="p">][</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)][:,:,</span><span class="n">lpAnt</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">nCha</span><span class="p">)</span><span class="o">!=</span><span class="mf">1.0</span><span class="p">:</span>
                                                    <span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;N&#39;</span><span class="p">][</span><span class="n">target</span><span class="p">][</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)][:,:,</span><span class="n">lpAnt</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;N&#39;</span><span class="p">][</span><span class="n">target</span><span class="p">][</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)][:,:,</span><span class="n">lpAnt</span><span class="p">]</span><span class="o">*</span><span class="n">ngoodscan</span><span class="o">/</span><span class="p">(</span><span class="n">ngoodscan</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>  <span class="o">+</span> <span class="n">N</span><span class="p">[:,:,</span><span class="n">lpAnt</span><span class="p">]</span><span class="o">/</span><span class="p">(</span><span class="n">ngoodscan</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
                                                <span class="c1"># if the stored antenna scan value in rnstats is 1.0 (i.e. initiated with a flagged antenna</span>
                                                <span class="c1"># but the antenna scan value we want to add now is good</span>
                                                <span class="c1"># then just replace the rnstat antenna scaling values entirely</span>
                                                <span class="k">elif</span> <span class="n">lpAnt</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">antflagged</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;N&#39;</span><span class="p">][</span><span class="n">target</span><span class="p">][</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)][:,:,</span><span class="n">lpAnt</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">nCha</span><span class="p">)</span><span class="o">==</span><span class="mf">1.0</span><span class="p">:</span>
                                                    <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;replacing scan with good for &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">AntName</span><span class="p">[</span><span class="n">lpAnt</span><span class="p">]))</span>
                                                    <span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;N&#39;</span><span class="p">][</span><span class="n">target</span><span class="p">][</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)][:,:,</span><span class="n">lpAnt</span><span class="p">]</span><span class="o">=</span> <span class="n">N</span><span class="p">[:,:,</span><span class="n">lpAnt</span><span class="p">]</span> 
                                                <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">corrATM</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">skipAtmCorr</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)</span> <span class="ow">in</span> <span class="n">excludechan</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                                                    <span class="k">try</span><span class="p">:</span> 
                                                        <span class="k">if</span> <span class="n">lpAnt</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">antflagged</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;N_atm&#39;</span><span class="p">][</span><span class="n">target</span><span class="p">][</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)][:,:,</span><span class="n">lpAnt</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">nCha</span><span class="p">)</span><span class="o">!=</span><span class="mf">1.0</span><span class="p">:</span>
                                                            <span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;N_atm&#39;</span><span class="p">][</span><span class="n">target</span><span class="p">][</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)][:,:,</span><span class="n">lpAnt</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;N_atm&#39;</span><span class="p">][</span><span class="n">target</span><span class="p">][</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)][:,:,</span><span class="n">lpAnt</span><span class="p">]</span><span class="o">*</span><span class="n">ngoodscan</span><span class="o">/</span><span class="p">(</span><span class="n">ngoodscan</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>  <span class="o">+</span> <span class="n">N_atm</span><span class="p">[:,:,</span><span class="n">lpAnt</span><span class="p">]</span><span class="o">/</span><span class="p">(</span><span class="n">ngoodscan</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
                                                        <span class="k">elif</span> <span class="n">lpAnt</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">antflagged</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;N_atm&#39;</span><span class="p">][</span><span class="n">target</span><span class="p">][</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)][:,:,</span><span class="n">lpAnt</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">nCha</span><span class="p">)</span><span class="o">==</span><span class="mf">1.0</span><span class="p">:</span>
                                                            <span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;N_atm&#39;</span><span class="p">][</span><span class="n">target</span><span class="p">][</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)][:,:,</span><span class="n">lpAnt</span><span class="p">]</span><span class="o">=</span> <span class="n">N_atm</span><span class="p">[:,:,</span><span class="n">lpAnt</span><span class="p">]</span>
                                                    <span class="c1"># If we end up here, then the atmAutoExclude algorithm has only just </span>
                                                    <span class="c1"># started excluding scans. So we need to instantiate the N_atm dict</span>
                                                    <span class="c1"># with everything that is contained in N so far and then we can add</span>
                                                    <span class="c1"># the new data.</span>
                                                    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                                                        <span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;N_atm&#39;</span><span class="p">][</span><span class="n">target</span><span class="p">][</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;N&#39;</span><span class="p">][</span><span class="n">target</span><span class="p">][</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)]</span>
                                                        <span class="k">if</span> <span class="n">lpAnt</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">antflagged</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;N_atm&#39;</span><span class="p">][</span><span class="n">target</span><span class="p">][</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)][:,:,</span><span class="n">lpAnt</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">nCha</span><span class="p">)</span><span class="o">!=</span><span class="mf">1.0</span><span class="p">:</span>
                                                            <span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;N_atm&#39;</span><span class="p">][</span><span class="n">target</span><span class="p">][</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)][:,:,</span><span class="n">lpAnt</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;N_atm&#39;</span><span class="p">][</span><span class="n">target</span><span class="p">][</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)][:,:,</span><span class="n">lpAnt</span><span class="p">]</span><span class="o">*</span><span class="n">ngoodscan</span><span class="o">/</span><span class="p">(</span><span class="n">ngoodscan</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>  <span class="o">+</span> <span class="n">N_atm</span><span class="p">[:,:,</span><span class="n">lpAnt</span><span class="p">]</span><span class="o">/</span><span class="p">(</span><span class="n">ngoodscan</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
                                                        <span class="k">elif</span> <span class="n">lpAnt</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">antflagged</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;N_atm&#39;</span><span class="p">][</span><span class="n">target</span><span class="p">][</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)][:,:,</span><span class="n">lpAnt</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">nCha</span><span class="p">)</span><span class="o">==</span><span class="mf">1.0</span><span class="p">:</span>
                                                            <span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;N_atm&#39;</span><span class="p">][</span><span class="n">target</span><span class="p">][</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)][:,:,</span><span class="n">lpAnt</span><span class="p">]</span><span class="o">=</span> <span class="n">N_atm</span><span class="p">[:,:,</span><span class="n">lpAnt</span><span class="p">]</span>
                                            <span class="c1"># remember to add to the scans assessed</span>
                                            <span class="n">ngoodscan</span><span class="o">+=</span><span class="mi">1</span>
                                        <span class="k">else</span><span class="p">:</span>
                                            <span class="c1"># if no flagged antennas were passed we do the default cumulative average as normal</span>
                                            <span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;N&#39;</span><span class="p">][</span><span class="n">target</span><span class="p">][</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;N&#39;</span><span class="p">][</span><span class="n">target</span><span class="p">][</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)]</span><span class="o">*</span><span class="n">ngoodscan</span><span class="o">/</span><span class="p">(</span><span class="n">ngoodscan</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>  <span class="o">+</span> <span class="n">N</span><span class="o">/</span><span class="p">(</span><span class="n">ngoodscan</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
                                            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">corrATM</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">skipAtmCorr</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)</span> <span class="ow">in</span> <span class="n">excludechan</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                                                <span class="k">try</span><span class="p">:</span>
                                                    <span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;N_atm&#39;</span><span class="p">][</span><span class="n">target</span><span class="p">][</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;N_atm&#39;</span><span class="p">][</span><span class="n">target</span><span class="p">][</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)]</span><span class="o">*</span><span class="n">ngoodscan</span><span class="o">/</span><span class="p">(</span><span class="n">ngoodscan</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>  <span class="o">+</span> <span class="n">N_atm</span><span class="o">/</span><span class="p">(</span><span class="n">ngoodscan</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
                                                <span class="c1"># If we end up here, then the atmAutoExclude algorithm has only just </span>
                                                <span class="c1"># started excluding scans. So we need to instantiate the N_atm dict</span>
                                                <span class="c1"># with everything that is contained in N so far plus the new data.</span>
                                                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                                                    <span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;N_atm&#39;</span><span class="p">][</span><span class="n">target</span><span class="p">][</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;N&#39;</span><span class="p">][</span><span class="n">target</span><span class="p">][</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)]</span><span class="o">*</span><span class="n">ngoodscan</span><span class="o">/</span><span class="p">(</span><span class="n">ngoodscan</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">N_atm</span><span class="o">/</span><span class="p">(</span><span class="n">ngoodscan</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
                                            <span class="n">ngoodscan</span><span class="o">+=</span><span class="mi">1</span>
                                    <span class="c1">## Non flagged antenna cases</span>
                                    <span class="k">else</span><span class="p">:</span>
                                        <span class="c1"># incrementally accumulate scan-mean spectra - keeps adding even as we do per field</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;N&#39;</span><span class="p">][</span><span class="n">target</span><span class="p">][</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;N&#39;</span><span class="p">][</span><span class="n">target</span><span class="p">][</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)]</span><span class="o">*</span><span class="n">ngoodscan</span><span class="o">/</span><span class="p">(</span><span class="n">ngoodscan</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>  <span class="o">+</span> <span class="n">N</span><span class="o">/</span><span class="p">(</span><span class="n">ngoodscan</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
                                        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">corrATM</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">skipAtmCorr</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)</span> <span class="ow">in</span> <span class="n">excludechan</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                                            <span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;N_atm&#39;</span><span class="p">][</span><span class="n">target</span><span class="p">][</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;N_atm&#39;</span><span class="p">][</span><span class="n">target</span><span class="p">][</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)]</span><span class="o">*</span><span class="n">ngoodscan</span><span class="o">/</span><span class="p">(</span><span class="n">ngoodscan</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>  <span class="o">+</span> <span class="n">N_atm</span><span class="o">/</span><span class="p">(</span><span class="n">ngoodscan</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>     
                                        <span class="n">ngoodscan</span><span class="o">+=</span><span class="mi">1</span>

                                    <span class="c1"># PIPE 1168 (1)</span>
                                    <span class="c1"># Repeat the same process but now we&#39;ll only be keeping normalized spectra that is above the threshold.</span>
                                    <span class="c1"># This helps us plot mosaic sources and multi-target MSs as the mixture of empty/problem fields can wash the peaks.</span>
                                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">Nmax</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">hardLim</span><span class="p">:</span>
                                        <span class="k">if</span> <span class="n">excflagged</span><span class="p">:</span>  
                                            <span class="c1"># regardless of flagged antennas or not we need to initiate the rnstats on the first scan</span>
                                            <span class="k">if</span> <span class="n">ngoodscan_thresh</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                                                <span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;N_thresh&#39;</span><span class="p">][</span><span class="n">target</span><span class="p">][</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)]</span><span class="o">=</span> <span class="n">N</span>
                                                <span class="n">ngoodscan_thresh</span><span class="o">+=</span><span class="mi">1</span>
                                            <span class="k">elif</span> <span class="n">antflagged</span> <span class="ow">and</span> <span class="n">ngoodscan_thresh</span><span class="o">!=</span><span class="mi">0</span><span class="p">:</span>
                                                <span class="c1"># enter this loop if there ARE flagged antennas  </span>
                                                <span class="k">for</span> <span class="n">lpAnt</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nAnt</span><span class="p">):</span>
                                                    <span class="c1"># if the antenna is not listed as flagged and the initiated first</span>
                                                    <span class="c1"># entry to rnstats[&#39;N_thresh&#39;] is not 1.0 (i.e. flagged) we do</span>
                                                    <span class="c1"># the cumulative sum for the average spectra</span>
                                                    <span class="k">if</span> <span class="n">lpAnt</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">antflagged</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;N_thresh&#39;</span><span class="p">][</span><span class="n">target</span><span class="p">][</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)][:,:,</span><span class="n">lpAnt</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">nCha</span><span class="p">)</span><span class="o">!=</span><span class="mf">1.0</span><span class="p">:</span>
                                                        <span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;N_thresh&#39;</span><span class="p">][</span><span class="n">target</span><span class="p">][</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)][:,:,</span><span class="n">lpAnt</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;N_thresh&#39;</span><span class="p">][</span><span class="n">target</span><span class="p">][</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)][:,:,</span><span class="n">lpAnt</span><span class="p">]</span><span class="o">*</span><span class="n">ngoodscan_thresh</span><span class="o">/</span><span class="p">(</span><span class="n">ngoodscan_thresh</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>  <span class="o">+</span> <span class="n">N</span><span class="p">[:,:,</span><span class="n">lpAnt</span><span class="p">]</span><span class="o">/</span><span class="p">(</span><span class="n">ngoodscan_thresh</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
                                                    <span class="c1"># if the stored antenna scan value in rnstats is 1.0 (i.e. initiated with a flagged antenna</span>
                                                    <span class="c1"># but the antenna scan value we want to add now is good</span>
                                                    <span class="c1"># then just replace the rnstat antenna scaling values entirely</span>
                                                    <span class="k">elif</span> <span class="n">lpAnt</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">antflagged</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;N_thresh&#39;</span><span class="p">][</span><span class="n">target</span><span class="p">][</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)][:,:,</span><span class="n">lpAnt</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">nCha</span><span class="p">)</span><span class="o">==</span><span class="mf">1.0</span><span class="p">:</span>
                                                        <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;replacing scan with good for &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">AntName</span><span class="p">[</span><span class="n">lpAnt</span><span class="p">]))</span>
                                                        <span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;N_thresh&#39;</span><span class="p">][</span><span class="n">target</span><span class="p">][</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)][:,:,</span><span class="n">lpAnt</span><span class="p">]</span><span class="o">=</span> <span class="n">N</span><span class="p">[:,:,</span><span class="n">lpAnt</span><span class="p">]</span> 
                                                <span class="c1"># remember to add to the scans assessed</span>
                                                <span class="n">ngoodscan_thresh</span><span class="o">+=</span><span class="mi">1</span>
                                            <span class="k">else</span><span class="p">:</span>
                                                <span class="c1"># if no flagged antennas were passed we do the default cumulative average as normal</span>
                                                <span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;N_thresh&#39;</span><span class="p">][</span><span class="n">target</span><span class="p">][</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;N_thresh&#39;</span><span class="p">][</span><span class="n">target</span><span class="p">][</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)]</span><span class="o">*</span><span class="n">ngoodscan_thresh</span><span class="o">/</span><span class="p">(</span><span class="n">ngoodscan_thresh</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>  <span class="o">+</span> <span class="n">N</span><span class="o">/</span><span class="p">(</span><span class="n">ngoodscan_thresh</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
                                                <span class="n">ngoodscan_thresh</span><span class="o">+=</span><span class="mi">1</span>

                                        <span class="c1">## Non flagged antenna cases</span>
                                        <span class="k">else</span><span class="p">:</span>
                                            <span class="c1"># incrementally accumulate scan-mean spectra - keeps adding even as we do per field</span>
                                            <span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;N_thresh&#39;</span><span class="p">][</span><span class="n">target</span><span class="p">][</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;N_thresh&#39;</span><span class="p">][</span><span class="n">target</span><span class="p">][</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)]</span><span class="o">*</span><span class="n">ngoodscan_thresh</span><span class="o">/</span><span class="p">(</span><span class="n">ngoodscan_thresh</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>  <span class="o">+</span> <span class="n">N</span><span class="o">/</span><span class="p">(</span><span class="n">ngoodscan_thresh</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
                                            <span class="n">ngoodscan_thresh</span><span class="o">+=</span><span class="mi">1</span>

                                    <span class="c1"># below is George&#39;s original code and these are used in other RN.plot*  (not the spectral one)    </span>
                                    <span class="c1"># this does not add per field, it appears that only the last field will be appended currently</span>
                                    <span class="c1"># as it is not cumulative, it is a replacement that calls only ispw and iscan</span>
                                    <span class="c1"># the current median will possibly be skewed by antennas set to 1.0 if flagged</span>
                                    <span class="c1"># if the last field has no scaling, plots using these scan based stats/and latter plots</span>
                                    <span class="c1"># will not show anything useful</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;rNmax&#39;</span><span class="p">][:,:,</span><span class="n">spws</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">ispw</span><span class="p">),</span><span class="n">targscans</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">iscan</span><span class="p">)]</span><span class="o">=</span><span class="n">N</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;rNmdev&#39;</span><span class="p">][:,:,</span><span class="n">spws</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">ispw</span><span class="p">),</span><span class="n">targscans</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">iscan</span><span class="p">)]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="mf">1.0</span><span class="p">),</span><span class="mi">1</span><span class="p">)</span>

                                    <span class="c1"># write in the max value for this SPW, scan, field into the self.scalingValues dictionary</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">scalingValues</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)][</span><span class="nb">str</span><span class="p">(</span><span class="n">iscan</span><span class="p">)][</span><span class="nb">str</span><span class="p">(</span><span class="n">ifld</span><span class="p">)]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">Nmax</span><span class="p">)</span> <span class="c1"># average the correlations</span>

                                    <span class="c1"># Need to move this part out of the docorr check so that we can add a check to above thresh, then add to </span>
                                    <span class="c1"># to the dictionary. Then after each scan/field, we check for it to be above the limit and update it each</span>
                                    <span class="c1"># time to set to True/False unless it is already set to True. Should do this regardless of the number of</span>
                                    <span class="c1"># fields as it would catch single field targets that wobble around the limit. </span>
                                    <span class="c1">#</span>
                                    <span class="c1"># Check if above limit but only on the first pass through the data</span>
                                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">Nmax</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">hardLim</span><span class="p">:</span> 
                                        <span class="c1"># Nmax hold 2 values for dual corr (xx,yy) coming from mean of all maximal values of all ants  </span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">docorrApply</span><span class="p">[</span><span class="n">target</span><span class="p">][</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)]</span><span class="o">=</span><span class="kc">True</span> <span class="c1"># will correct this field</span>
                                    <span class="c1"># if this field isn&#39;t above the limit but it&#39;s already True, pass</span>
                                    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">docorrApply</span><span class="p">[</span><span class="n">target</span><span class="p">][</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)]:</span>
                                        <span class="k">pass</span>
                                    <span class="c1"># if not above the limit and not already set to True, set to False</span>
                                    <span class="k">else</span><span class="p">:</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">docorrApply</span><span class="p">[</span><span class="n">target</span><span class="p">][</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)]</span><span class="o">=</span><span class="kc">False</span>
                                
                                <span class="c1"># If we want to apply the correction and it&#39;s the second time through the data</span>
                                <span class="k">if</span> <span class="n">docorr</span> <span class="ow">and</span> <span class="n">second_pass</span><span class="p">:</span> 
                                    <span class="c1"># apply the correction</span>
                                    <span class="c1"># Antenna-based Correction factors are in voltage units (pair products are power)</span>
                                    <span class="n">Nv</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">applyReNorm</span><span class="p">(</span><span class="n">iscan</span><span class="p">,</span><span class="n">ispw</span><span class="p">,</span><span class="n">ifld</span><span class="p">,</span><span class="n">Nv</span><span class="p">,</span><span class="n">datacolumn</span><span class="p">)</span> 
                            
                                    <span class="c1"># do self.recordApply here and pass scan, spw, field too</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">recordApply</span><span class="p">(</span><span class="n">iscan</span><span class="p">,</span><span class="n">ispw</span><span class="p">,</span><span class="n">ifld</span><span class="p">)</span>

                                    <span class="c1"># ****</span>
                                    <span class="c1"># In combination with the docorrApply dictionary, and the printed message</span>
                                    <span class="c1"># PLWG might want to include also Keyword dictionaries into the MS</span>
                                    <span class="c1"># here might be a good place for this</span>
                                    <span class="c1"># ****</span>

                                    <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;Application of the ReNormalization was written to the MS history for spw&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39; scan&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">iscan</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39; field&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">ifld</span><span class="p">))</span>

                            <span class="c1"># closes the data check to see if the AC data is confirmed to be filled </span>
                            <span class="c1">#    - only gets here if None was returned</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                                    <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39; **** No data found - skipping field &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">ifld</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39; in scan &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">iscan</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39; ****&#39;</span><span class="p">)</span>
                                <span class="k">continue</span>

                            <span class="k">if</span> <span class="ow">not</span> <span class="n">second_pass</span><span class="p">:</span>
                            <span class="c1"># print per scan max val</span>
                                <span class="k">if</span> <span class="n">ifld</span> <span class="o">==</span> <span class="nb">max</span><span class="p">(</span><span class="n">Tarfld</span><span class="p">):</span>
                                    <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;  Max peak renormalization factor (power) over scan &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">iscan</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39; = &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">scanNmax</span><span class="p">)))</span>

                        <span class="c1"># After doing the first pass, if docorr is True and docorrApply was set to True, </span>
                        <span class="c1"># we now need to go through again and actually apply the renormalization </span>
                        <span class="k">if</span> <span class="n">docorr</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">second_pass</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">docorrApply</span><span class="p">[</span><span class="n">target</span><span class="p">][</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)]:</span>
                            <span class="n">second_pass_required</span> <span class="o">=</span> <span class="kc">True</span>


                    <span class="k">if</span> <span class="n">checkFalsePositives</span><span class="p">:</span>
                        <span class="n">exclude_cmd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">suggestAtmExclude</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">),</span> <span class="n">return_command</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">atmWarning</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">fldname</span><span class="p">)][</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)]:</span>
                            <span class="k">if</span> <span class="n">atmAutoExclude</span><span class="p">:</span>
                                <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;Atmospheric features above the threshold have been mitigated by atmAutoExclude.&#39;</span><span class="p">)</span>
                                <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;Equivalent manual call: &#39;</span><span class="o">+</span><span class="n">exclude_cmd</span><span class="p">)</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;ATM features may be falsely triggering renorm!&#39;</span><span class="p">)</span>
                                <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;Suggested channel exclusion: &#39;</span><span class="o">+</span><span class="n">exclude_cmd</span><span class="p">)</span>
                        <span class="k">elif</span> <span class="n">exclude_cmd</span><span class="p">:</span>
                            <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;Atmospheric features mitigated.&#39;</span><span class="p">)</span>
                            <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;Equivalent manual call: &#39;</span><span class="o">+</span><span class="n">exclude_cmd</span><span class="p">)</span>

        <span class="c1"># PIPE 1168 (3)</span>
        <span class="c1"># Loops through the scalingValue dict and populates the pipeline needed dictionary</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rnpipestats</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">target_field_ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">msmeta</span><span class="o">.</span><span class="n">fieldsforintent</span><span class="p">(</span><span class="s1">&#39;*TARGET*&#39;</span><span class="p">)</span>
        <span class="n">target_fields</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">msmeta</span><span class="o">.</span><span class="n">namesforfields</span><span class="p">(</span><span class="n">target_field_ids</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">trg</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;N&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span> <span class="c1">#target_fields:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rnpipestats</span><span class="p">[</span><span class="n">trg</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">spw</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;N&#39;</span><span class="p">][</span><span class="n">trg</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span> <span class="c1"># spws:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rnpipestats</span><span class="p">[</span><span class="n">trg</span><span class="p">][</span><span class="n">spw</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="n">scans</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">msmeta</span><span class="o">.</span><span class="n">scansforintent</span><span class="p">(</span><span class="s1">&#39;*TARGET*&#39;</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">msmeta</span><span class="o">.</span><span class="n">scansforfield</span><span class="p">(</span><span class="n">trg</span><span class="p">))</span> <span class="c1"># find scans related to this target</span>
                <span class="n">scans</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">scans</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">msmeta</span><span class="o">.</span><span class="n">scansforspw</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">spw</span><span class="p">)))</span> <span class="c1"># find scans related to given spw (spectral scan)</span>
                <span class="n">scans</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">scans</span><span class="p">,</span> <span class="n">targscans</span><span class="p">)</span> <span class="c1"># if user input scans, limit to those</span>
                <span class="n">pipe_target_sv</span><span class="p">,</span> <span class="n">pipe_target_fld</span> <span class="o">=</span> <span class="p">[],[]</span>
                <span class="k">for</span> <span class="n">scan</span> <span class="ow">in</span> <span class="n">scans</span><span class="p">:</span>
                    <span class="n">fields</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">msmeta</span><span class="o">.</span><span class="n">fieldsforintent</span><span class="p">(</span><span class="s1">&#39;*TARGET*&#39;</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">msmeta</span><span class="o">.</span><span class="n">fieldsforname</span><span class="p">(</span><span class="n">trg</span><span class="p">))</span> <span class="c1"># fields for target</span>
                    <span class="n">fields</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">fields</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">msmeta</span><span class="o">.</span><span class="n">fieldsforscan</span><span class="p">(</span><span class="n">scan</span><span class="p">))</span> <span class="c1"># fields for given scan</span>
                    <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">fields</span><span class="p">:</span>
                        <span class="n">pipe_target_sv</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scalingValues</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">spw</span><span class="p">)][</span><span class="nb">str</span><span class="p">(</span><span class="n">scan</span><span class="p">)][</span><span class="nb">str</span><span class="p">(</span><span class="n">field</span><span class="p">)])</span>
                        <span class="n">pipe_target_fld</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">field</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rnpipestats</span><span class="p">[</span><span class="n">trg</span><span class="p">][</span><span class="n">spw</span><span class="p">][</span><span class="s1">&#39;max_rn&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">pipe_target_sv</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rnpipestats</span><span class="p">[</span><span class="n">trg</span><span class="p">][</span><span class="n">spw</span><span class="p">][</span><span class="s1">&#39;max_rn_field&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pipe_target_fld</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pipe_target_sv</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">rnpipestats</span><span class="p">[</span><span class="n">trg</span><span class="p">][</span><span class="n">spw</span><span class="p">][</span><span class="s1">&#39;max_rn&#39;</span><span class="p">])[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rnpipestats</span><span class="p">[</span><span class="n">trg</span><span class="p">][</span><span class="n">spw</span><span class="p">][</span><span class="s1">&#39;threshold&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">hardLim</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;inputs&#39;</span><span class="p">][</span><span class="n">trg</span><span class="p">][</span><span class="n">spw</span><span class="p">][</span><span class="s1">&#39;dNchan&#39;</span><span class="p">]))</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">rnpipestats</span><span class="p">[</span><span class="n">trg</span><span class="p">][</span><span class="n">spw</span><span class="p">][</span><span class="s1">&#39;seg_change&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">rnpipestats</span><span class="p">[</span><span class="n">trg</span><span class="p">][</span><span class="n">spw</span><span class="p">][</span><span class="s1">&#39;seg_change&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

        
        <span class="c1"># final log end of the renormalize function</span>
        <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;*** ALMA almarenorm.py ***&#39;</span><span class="p">,</span> <span class="s1">&#39;INFO&#39;</span><span class="p">,</span> <span class="s1">&#39;ReNormalize&#39;</span><span class="p">)</span>   
        <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;*** &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">RNversion</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39; ***&#39;</span><span class="p">,</span> <span class="s1">&#39;INFO&#39;</span><span class="p">,</span> <span class="s1">&#39;ReNormalize&#39;</span><span class="p">)</span>   
        <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;*** End of renormalization run ***&#39;</span><span class="p">,</span> <span class="s1">&#39;INFO&#39;</span><span class="p">,</span> <span class="s1">&#39;ReNormalize&#39;</span><span class="p">)</span>   </div>


    <span class="k">def</span> <span class="nf">calcChanRanges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">spw</span><span class="p">,</span><span class="n">bwthresh</span><span class="o">=</span><span class="mf">120e6</span><span class="p">,</span><span class="n">bwdiv</span><span class="o">=</span><span class="s1">&#39;odd&#39;</span><span class="p">,</span><span class="n">onlyfdm</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">edge</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span><span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        
        <span class="n">Tbw</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">msmeta</span><span class="o">.</span><span class="n">bandwidths</span><span class="p">(</span><span class="n">spw</span><span class="p">)</span>
        <span class="n">nchan</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">msmeta</span><span class="o">.</span><span class="n">nchan</span><span class="p">(</span><span class="n">spw</span><span class="p">)</span>
        
        <span class="n">nseg</span><span class="o">=</span><span class="mi">1</span>
        <span class="n">dNchan</span><span class="o">=</span><span class="n">nchan</span>

        <span class="c1"># Only do non-trivial segments if bwthresh exceeded AND spw is FDM </span>
        <span class="c1"># (lots of channels). First check the number of channels explicitly. </span>
        <span class="c1"># If we have a small number of channels, we don&#39;t want to divide up </span>
        <span class="c1"># the spectrum into a ridiculous number of divisions and overfit. Less</span>
        <span class="c1"># than 128, no need to divide the window up at all, from there scale </span>
        <span class="c1"># up to a max of 7.</span>
        <span class="k">if</span> <span class="n">nchan</span> <span class="o">&lt;=</span> <span class="mi">128</span><span class="p">:</span>
            <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39; **Small number of channels found, will not divide up the spw.&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">bwdiv</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">:</span>
                <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39; Ignoring input bwdiv of &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">bwdiv</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39; since number of channels is already small.&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">nseg</span><span class="p">,</span><span class="n">dNchan</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">nchan</span> <span class="o">&lt;=</span> <span class="mi">300</span><span class="p">:</span>
            <span class="n">max_divs</span> <span class="o">=</span> <span class="mf">3.0</span>
        <span class="k">elif</span> <span class="n">nchan</span> <span class="o">&lt;=</span> <span class="mi">550</span><span class="p">:</span>
            <span class="n">max_divs</span> <span class="o">=</span> <span class="mf">5.0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">max_divs</span> <span class="o">=</span> <span class="mf">7.0</span>
        <span class="c1"># check first if we are forcing a divide</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">bwdiv</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span> <span class="ow">and</span> <span class="n">spw</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fdmspws</span><span class="p">:</span>
            <span class="c1"># make float so we can check dNchan</span>
            <span class="n">nseg</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">bwdiv</span><span class="p">)</span>
            <span class="n">dNchan</span><span class="o">=</span><span class="n">nchan</span><span class="o">/</span><span class="n">nseg</span>
            <span class="c1"># check if nseg gives an integer nchans or if the remaining chans </span>
            <span class="c1"># when dNchan is not an int will be covered by the edge boundaries</span>
            <span class="k">if</span> <span class="n">dNchan</span><span class="o">.</span><span class="n">is_integer</span><span class="p">()</span> <span class="ow">or</span> <span class="n">nchan</span><span class="o">%</span><span class="n">nseg</span> <span class="o">&lt;</span> <span class="n">edge</span><span class="o">*</span><span class="n">nchan</span><span class="p">:</span>
                <span class="n">dNchan</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">dNchan</span><span class="p">)</span>
                <span class="n">nseg</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">nseg</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s2">&quot; Input bwdiv (nseg) does not divide the SPW into an integer number of channels &quot;</span><span class="p">)</span>
                <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s2">&quot; and the remaining channels are not excluded in the edges &quot;</span><span class="p">)</span>
                <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s2">&quot; Will default to power of 2 division based on bwthresh &quot;</span><span class="p">)</span>
                <span class="n">nseg</span><span class="o">=</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="o">**</span><span class="nb">int</span><span class="p">(</span><span class="n">ceil</span><span class="p">(</span><span class="n">log</span><span class="p">(</span><span class="n">Tbw</span><span class="o">/</span><span class="n">bwthresh</span><span class="p">)</span><span class="o">/</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span><span class="p">))))</span>
                <span class="n">dNchan</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">nchan</span><span class="o">/</span><span class="n">nseg</span><span class="p">)</span>
        <span class="c1"># This is overkill given the above restrictions, limiting to 3, 5, or 7</span>
        <span class="c1"># segments ensures that there are no answers for which the remainder </span>
        <span class="c1"># does not fall into the edge channel rejection...</span>
        <span class="k">elif</span> <span class="n">Tbw</span><span class="o">&gt;</span><span class="n">bwthresh</span> <span class="ow">and</span> <span class="n">spw</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fdmspws</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">bwdiv</span><span class="o">==</span><span class="s1">&#39;odd&#39;</span><span class="p">:</span>
                <span class="c1"># work out best odd divisibile when dNchan is an int need to</span>
                <span class="c1"># avoid splitting up wide spws into too many slices which can</span>
                <span class="c1"># cause major issues</span>
                <span class="n">nseg</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">max_divs</span><span class="p">,</span> <span class="n">Tbw</span><span class="o">/</span><span class="n">bwthresh</span><span class="p">)</span>
                <span class="n">dNchan</span><span class="o">=</span><span class="n">nchan</span><span class="o">/</span><span class="n">nseg</span>
                
                <span class="c1"># while condition is met when float value is equivalent to an </span>
                <span class="c1"># int value (i.e. 7.0.is_integer() = True)</span>
                <span class="k">while</span> <span class="ow">not</span> <span class="n">dNchan</span><span class="o">.</span><span class="n">is_integer</span><span class="p">():</span>
                    <span class="n">nseg</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">ceil</span><span class="p">(</span><span class="n">nseg</span><span class="p">))</span>
                    <span class="n">dNchan</span><span class="o">=</span><span class="n">nchan</span><span class="o">/</span><span class="n">nseg</span>
                    <span class="c1"># check if the new nseg is actually odd, otherwise make it odd</span>
                    <span class="k">if</span> <span class="n">nseg</span><span class="o">%</span><span class="mi">2</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">nseg</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">ceil</span><span class="p">(</span><span class="n">nseg</span><span class="p">))</span><span class="o">+</span><span class="mf">1.0</span>
                        <span class="n">dNchan</span><span class="o">=</span><span class="n">nchan</span><span class="o">/</span><span class="n">nseg</span>
                    <span class="c1"># check if the remainder for this odd nseg falls into the </span>
                    <span class="c1"># median set edges i.e don&#39;t need to worry if nchan/nseg </span>
                    <span class="c1"># is a true integer division </span>
                    <span class="c1"># e.g. 2048 into 5, dNchan is 409.6, so 5x409 segs and </span>
                    <span class="c1">#      remaining is 3 chans, but edge chans are 20, so </span>
                    <span class="c1">#      they are anyway set to to the median value (~1)</span>
                    <span class="c1">#      and we can use nseg = 5 without worry </span>
                    <span class="k">if</span> <span class="n">nchan</span><span class="o">%</span><span class="n">nseg</span> <span class="o">&lt;</span> <span class="n">edge</span><span class="o">*</span><span class="n">nchan</span><span class="p">:</span>
                        <span class="c1"># round down to nearest int and exit the while statment                        </span>
                        <span class="n">dNchan</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">dNchan</span><span class="p">))</span> 
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># if remainder not in edges, add to nseg and continue </span>
                        <span class="n">nseg</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">ceil</span><span class="p">(</span><span class="n">nseg</span><span class="p">))</span><span class="o">+</span><span class="mf">1.0</span>
                            
                    <span class="c1"># case where odd numbers just will not go into the channel </span>
                    <span class="c1"># number inc remainder accounting</span>
                    <span class="k">if</span> <span class="n">nseg</span> <span class="o">&gt;</span> <span class="mi">50</span><span class="p">:</span>
                        <span class="n">nseg</span><span class="o">=</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="o">**</span><span class="nb">int</span><span class="p">(</span><span class="n">ceil</span><span class="p">(</span><span class="n">log</span><span class="p">(</span><span class="n">Tbw</span><span class="o">/</span><span class="n">bwthresh</span><span class="p">)</span><span class="o">/</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span><span class="p">))))</span>
                        <span class="k">break</span>

                <span class="n">nseg</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">ceil</span><span class="p">(</span><span class="n">nseg</span><span class="p">))</span>
                <span class="n">dNchan</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">nchan</span><span class="o">/</span><span class="n">nseg</span><span class="p">)</span> 

            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># George&#39;s base function</span>
                <span class="n">nseg</span><span class="o">=</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="o">**</span><span class="nb">int</span><span class="p">(</span><span class="n">ceil</span><span class="p">(</span><span class="n">log</span><span class="p">(</span><span class="n">Tbw</span><span class="o">/</span><span class="n">bwthresh</span><span class="p">)</span><span class="o">/</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span><span class="p">))))</span>
                <span class="n">dNchan</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">nchan</span><span class="o">/</span><span class="n">nseg</span><span class="p">)</span>

        <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">Dividing spw into &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">nseg</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39; segments of &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">dNchan</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39; channels each.&#39;</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="p">(</span><span class="n">nseg</span><span class="p">,</span><span class="n">dNchan</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">stats</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span>

<div class="viewcode-block" id="ACreNorm.merge_dicts">
<a class="viewcode-back" href="../../../_autosummary/pipeline.extern.almarenorm_pl2023.ACreNorm.html#pipeline.h.tasks.restoredata.restoredata.ACreNorm.merge_dicts">[docs]</a>
    <span class="k">def</span> <span class="nf">merge_dicts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dict1</span><span class="p">,</span> <span class="n">dict2</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Purpose:</span>
<span class="sd">            Given two dictionaries, merge them together such that common</span>
<span class="sd">            keys do not get overwritten. The main purpose is for merging</span>
<span class="sd">            user input excludechan ranges with ATM excludechan ranges.</span>

<span class="sd">        Inputs:</span>
<span class="sd">            dict1, dict2 : dictionaries</span>
<span class="sd">                The two dictionaries to merge together.</span>

<span class="sd">        Outputs:</span>
<span class="sd">            The merged dictionary.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dict3</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">dict1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">dict2</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dict3</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">dict3</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cval</span> <span class="o">=</span> <span class="n">dict3</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
                <span class="n">dict3</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">cval</span><span class="o">+</span><span class="s1">&#39;;&#39;</span><span class="o">+</span><span class="n">value</span>
        <span class="k">return</span> <span class="n">dict3</span></div>


<div class="viewcode-block" id="ACreNorm.interpretExcludechan">
<a class="viewcode-back" href="../../../_autosummary/pipeline.extern.almarenorm_pl2023.ACreNorm.html#pipeline.h.tasks.restoredata.restoredata.ACreNorm.interpretExcludechan">[docs]</a>
    <span class="k">def</span> <span class="nf">interpretExcludechan</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ranges</span><span class="p">,</span> <span class="n">spw</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pupose: </span>
<span class="sd">            As an option to the self.renormalize() method, a user may input </span>
<span class="sd">            channel ranges to be excluded from the analysis via the excludechan </span>
<span class="sd">            option. Additionally, if the atmAutoExclude option is enabled the </span>
<span class="sd">            renormalize method will attempt to fix any atmospheric features </span>
<span class="sd">            that it thinks to be problematic. Those channel ranges, either </span>
<span class="sd">            input or generated, are added to a dictionary and then need to be </span>
<span class="sd">            interpreted correctly for both the exclusion and later plotting. </span>

<span class="sd">        Inputs: </span>
<span class="sd">            ranges : list</span>
<span class="sd">                This is a list of the different ranges within a single spectral</span>
<span class="sd">                window that need to be excluded. The expected format is:</span>
<span class="sd">                    </span>
<span class="sd">                [&quot;low_channel~high_channel&quot;; &quot;low_channel~high_channel&quot;; ...]</span>

<span class="sd">            spw : integer</span>
<span class="sd">                This is the spectral window number. This is only needed if the</span>
<span class="sd">                inputs of ranges are in frequency but must always be given.</span>

<span class="sd">        Outputs: </span>
<span class="sd">            starts : list</span>
<span class="sd">                A list containing the starting channels for each range to be </span>
<span class="sd">                excluded.</span>

<span class="sd">            ends : list</span>
<span class="sd">                A list containing the ending channels for each range to be </span>
<span class="sd">                excluded.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">starts</span><span class="p">,</span> <span class="n">ends</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">rng</span> <span class="ow">in</span> <span class="n">ranges</span><span class="p">:</span>
            <span class="c1"># If the range is given in GHz rather than channels, need to find the </span>
            <span class="c1"># correct indicies for that frequency range.</span>
            <span class="k">if</span> <span class="s1">&#39;GHz&#39;</span> <span class="ow">in</span> <span class="n">rng</span><span class="p">:</span>
                <span class="n">exlofq</span><span class="p">,</span> <span class="n">exhifq</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;~&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="s1">&#39;GHz&#39;</span> <span class="ow">in</span> <span class="n">exlofq</span><span class="p">:</span>
                    <span class="n">exlofq</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">exlofq</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;GHz&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">exlofq</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">exlofq</span><span class="p">)</span>
                <span class="n">exloch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">findNearest</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">msmeta</span><span class="o">.</span><span class="n">chanfreqs</span><span class="p">(</span><span class="n">spw</span><span class="p">,</span> <span class="s1">&#39;GHz&#39;</span><span class="p">),</span> 
                        <span class="n">exlofq</span><span class="p">,</span> 
                        <span class="n">index</span><span class="o">=</span><span class="kc">True</span>
                        <span class="p">)</span>
                <span class="k">if</span> <span class="s1">&#39;GHz&#39;</span> <span class="ow">in</span> <span class="n">exhifq</span><span class="p">:</span>
                    <span class="n">exhifq</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">exhifq</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;GHz&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">exhifq</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">exhifq</span><span class="p">)</span>
                <span class="n">exhich</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">findNearest</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">msmeta</span><span class="o">.</span><span class="n">chanfreqs</span><span class="p">(</span><span class="n">spw</span><span class="p">,</span> <span class="s1">&#39;GHz&#39;</span><span class="p">),</span> 
                        <span class="n">exhifq</span><span class="p">,</span> 
                        <span class="n">index</span><span class="o">=</span><span class="kc">True</span>
                        <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">rng</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;~&#39;</span><span class="p">)</span>
                <span class="n">exloch</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">rng</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">exhich</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">rng</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="c1"># Protect from &quot;backward&quot; inputs.     </span>
            <span class="k">if</span> <span class="n">exloch</span> <span class="o">&gt;</span> <span class="n">exhich</span><span class="p">:</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="n">exloch</span>
                <span class="n">exloch</span> <span class="o">=</span> <span class="n">exhich</span>
                <span class="n">exhich</span> <span class="o">=</span> <span class="n">tmp</span>
            <span class="n">starts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">exloch</span><span class="p">)</span>
            <span class="n">ends</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">exhich</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">starts</span><span class="p">,</span> <span class="n">ends</span></div>


<div class="viewcode-block" id="ACreNorm.fitAtmLines">
<a class="viewcode-back" href="../../../_autosummary/pipeline.extern.almarenorm_pl2023.ACreNorm.html#pipeline.h.tasks.restoredata.restoredata.ACreNorm.fitAtmLines">[docs]</a>
    <span class="k">def</span> <span class="nf">fitAtmLines</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ATMprof</span><span class="p">,</span> <span class="n">spw</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Purpose:</span>
<span class="sd">            Given an atmospheric profile, find the features caused by water/ozone/etc </span>
<span class="sd">            and fit a Lorentizian profile to it, returning the center and gamma scale.</span>

<span class="sd">        Inputs:</span>
<span class="sd">            ATMprof : numpy.ndarray</span>
<span class="sd">                An atmospheric profile as returned by ATMtrans()</span>

<span class="sd">            verbose : boolean : OPTIONAL</span>
<span class="sd">                If True, then information about the fit will be printed to the terminal.</span>

<span class="sd">        Outputs:</span>
<span class="sd">            centers : list of floats</span>
<span class="sd">                The center channel of found features. </span>

<span class="sd">            scales : list of floats</span>
<span class="sd">                The gamma scale factor of found features. </span>

<span class="sd">        Note:</span>
<span class="sd">            This utilizes the scipy package, specifically scipy.signal.find_peaks and</span>
<span class="sd">            scipy.optimize.curve_fit. </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">curve_fit</span>
        <span class="kn">from</span> <span class="nn">scipy.signal</span> <span class="kn">import</span> <span class="n">find_peaks</span>

        <span class="k">def</span> <span class="nf">get_atm_peaks</span><span class="p">(</span><span class="n">ATMprof</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Purpose: Use scipy&#39;s peak finding algorithm to find ATM dips &gt;1%.</span>
<span class="sd">            </span>
<span class="sd">            Inputs: </span>
<span class="sd">                ATMprof : array</span>
<span class="sd">                    An atmospheric profile which is simply a 1 dimensional array.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">normATM</span> <span class="o">=</span> <span class="o">-</span><span class="n">ATMprof</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">ATMprof</span><span class="p">)</span>
            <span class="n">peaks</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">find_peaks</span><span class="p">(</span><span class="n">normATM</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="mf">0.01</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">peaks</span>

        <span class="k">def</span> <span class="nf">lorentzian</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">gam</span><span class="p">,</span> <span class="n">off</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Purpose: Standard definition of a Lorentizian to optimize.</span>

<span class="sd">            Inputs:</span>
<span class="sd">                x : array</span>
<span class="sd">                    The x data to fit to</span>
<span class="sd">                x0 : float</span>
<span class="sd">                    The line center.</span>
<span class="sd">                a : float</span>
<span class="sd">                    The amplitude of the feature.</span>
<span class="sd">                gam : float</span>
<span class="sd">                    The width of the feature (2*gamma = FWHM).</span>
<span class="sd">                off : float</span>
<span class="sd">                    The offset from 0.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="n">a</span> <span class="o">*</span> <span class="n">gam</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="n">gam</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span> <span class="n">x</span> <span class="o">-</span> <span class="n">x0</span> <span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">off</span>

        <span class="k">def</span> <span class="nf">get_gamma_bounds</span><span class="p">(</span><span class="n">center</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mf">50.</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Purpose: Assuming that atmospheric features are typically about 50km/s</span>
<span class="sd">                     wide, return the frequency width for a given center frequency</span>
<span class="sd">                     using the standard radio convention for velocity width.</span>

<span class="sd">                        delta_V = delta_nu / nu_0 * c</span>
<span class="sd">            Inputs:</span>
<span class="sd">                center : float</span>
<span class="sd">                    Freqency location of the line center, nu_0 in the above equation.</span>

<span class="sd">                width : float : OPTIONAL</span>
<span class="sd">                    The velocity width in km/s.</span>
<span class="sd">                    Default: 50.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">ckms</span> <span class="o">=</span> <span class="mf">299792.4580</span>
            <span class="k">return</span> <span class="n">width</span><span class="o">*</span><span class="n">center</span><span class="o">/</span><span class="n">ckms</span>
        
        <span class="c1"># Find atmospheric features in the profile</span>
        <span class="n">atm_feature_idxs</span> <span class="o">=</span> <span class="n">get_atm_peaks</span><span class="p">(</span><span class="n">ATMprof</span><span class="p">)</span>
        
        <span class="c1"># Define our x and y data.</span>
        <span class="n">xData</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">ATMprof</span><span class="p">))</span>
        <span class="n">yData</span> <span class="o">=</span> <span class="n">ATMprof</span>
        
        <span class="c1"># Loop over each feature, fitting a Lorentizian and reporting the fits.</span>
        <span class="n">centers</span><span class="p">,</span> <span class="n">scales</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">atm_feature_idxs</span><span class="p">)):</span>
            <span class="n">x0_guess</span> <span class="o">=</span> <span class="n">atm_feature_idxs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> 
            <span class="n">a_guess</span> <span class="o">=</span> <span class="n">yData</span><span class="p">[</span><span class="n">x0_guess</span><span class="p">]</span> <span class="o">-</span> <span class="nb">max</span><span class="p">(</span><span class="n">yData</span><span class="p">)</span>
            <span class="n">gamma_guess</span> <span class="o">=</span> <span class="mf">1.0</span>
            <span class="n">off_guess</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">yData</span><span class="p">)</span>

            <span class="c1"># center must be +/- 20 channels, </span>
            <span class="c1"># amp must be between 0 and -1 (atm dips are always negative here)</span>
            <span class="c1"># gamma must be between 1 channel and full spw width.</span>
            <span class="c1"># offset is between 0 (no transmission at all) and 1 (no opacity issues).</span>
            <span class="n">x0_bounds</span> <span class="o">=</span> <span class="p">[</span><span class="n">x0_guess</span><span class="o">-</span><span class="mi">20</span><span class="p">,</span> <span class="n">x0_guess</span><span class="o">+</span><span class="mi">20</span><span class="p">]</span>
            <span class="n">a_bounds</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">gamma_bounds</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="mi">1</span><span class="p">,</span> 
                    <span class="n">get_gamma_bounds</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">msmeta</span><span class="o">.</span><span class="n">chanfreqs</span><span class="p">(</span><span class="n">spw</span><span class="p">)[</span><span class="n">x0_guess</span><span class="p">])</span><span class="o">/</span><span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">msmeta</span><span class="o">.</span><span class="n">chanwidths</span><span class="p">(</span><span class="n">spw</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="p">]</span>
            <span class="n">off_bounds</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>

            <span class="n">popt</span><span class="p">,</span> <span class="n">cov</span> <span class="o">=</span> <span class="n">curve_fit</span><span class="p">(</span>
                            <span class="n">f</span><span class="o">=</span><span class="n">lorentzian</span><span class="p">,</span> 
                            <span class="n">xdata</span><span class="o">=</span><span class="n">xData</span><span class="p">,</span> 
                            <span class="n">ydata</span><span class="o">=</span><span class="n">yData</span><span class="p">,</span> 
                            <span class="n">p0</span><span class="o">=</span><span class="p">[</span><span class="n">x0_guess</span><span class="p">,</span><span class="n">a_guess</span><span class="p">,</span><span class="n">gamma_guess</span><span class="p">,</span> <span class="n">off_guess</span><span class="p">],</span>
                            <span class="n">bounds</span><span class="o">=</span><span class="p">(</span>
                                <span class="p">[</span><span class="n">x0_bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">a_bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">gamma_bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">off_bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>
                                <span class="p">[</span><span class="n">x0_bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">a_bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">gamma_bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">off_bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
                                <span class="p">)</span>
                        <span class="p">)</span>
            <span class="n">centers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">popt</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">scales</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">popt</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;Initial Guesses:&#39;</span><span class="p">)</span>
                <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">x0 = &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">x0_guess</span><span class="p">))</span>
                <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">a = &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">a_guess</span><span class="p">))</span>
                <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">gamma = &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">gamma_guess</span><span class="p">))</span>
                <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">offset = &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">off_guess</span><span class="p">))</span>
                <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
                <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;Bounds:&#39;</span><span class="p">)</span>
                <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">x0 : [&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">x0_bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">+</span><span class="s1">&#39;, &#39;</span><span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">x0_bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">+</span><span class="s1">&#39;]&#39;</span><span class="p">)</span>
                <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">a : [&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">a_bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">+</span><span class="s1">&#39;, &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">a_bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">+</span><span class="s1">&#39;]&#39;</span><span class="p">)</span>
                <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">gamma : [&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">gamma_bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">+</span><span class="s1">&#39;, &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">gamma_bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">+</span><span class="s1">&#39;]&#39;</span><span class="p">)</span>
                <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">offset : [&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">off_bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">+</span><span class="s1">&#39;, &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">off_bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">+</span><span class="s1">&#39;]&#39;</span><span class="p">)</span>
                <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
                <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;Best Fit from scipy.optimize.curve_fit:&#39;</span><span class="p">)</span>
                <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">x0 = &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">popt</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
                <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">a = &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">popt</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">gamma = &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">popt</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
                <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">offset = &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">popt</span><span class="p">[</span><span class="mi">3</span><span class="p">]))</span>
                <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
                <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">covariance matrix:&#39;</span><span class="p">)</span>
                <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">cov</span><span class="p">))</span>
                <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
                <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> std_devs = &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">cov</span><span class="p">))))</span>
        <span class="k">return</span> <span class="n">centers</span><span class="p">,</span> <span class="n">scales</span> </div>





<div class="viewcode-block" id="ACreNorm.plotSpectra">
<a class="viewcode-back" href="../../../_autosummary/pipeline.extern.almarenorm_pl2023.ACreNorm.html#pipeline.h.tasks.restoredata.restoredata.ACreNorm.plotSpectra">[docs]</a>
    <span class="k">def</span> <span class="nf">plotSpectra</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> 
            <span class="n">plotATM</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> 
            <span class="n">titlein</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
            <span class="n">plotDivisions</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> 
            <span class="n">hardcopy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>             
            <span class="n">createpdf</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> 
            <span class="n">includeSummary</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">plotOriginal</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">shadeAtm</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">showExcluded</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Purpose:</span>
<span class="sd">            This function makes a summary plot of the renormalization spectrum </span>
<span class="sd">            for every spectral window that has been evaluated for a </span>
<span class="sd">            renormalization correction. The plots are a cumulative average over </span>
<span class="sd">            all scans and fields for each antenna and correlation. For sources </span>
<span class="sd">            that have multiple fields per scan (mosaics), only those fields </span>
<span class="sd">            that exceed the threshold are shown in the plot. This also means </span>
<span class="sd">            that even single pointings that oscillate around the threshold will </span>
<span class="sd">            have only those scans that exceed the threshold included in the </span>
<span class="sd">            summary plot created. Additionally, any antenna that were fully </span>
<span class="sd">            flagged during calibration will have their renormalization values </span>
<span class="sd">            set to 1.0.</span>
<span class="sd">            </span>
<span class="sd">            Note that renormalization() must be run before this can be run.</span>

<span class="sd">        Inputs:</span>
<span class="sd">            plotATM : boolean : OPTIONAL</span>
<span class="sd">                This is a boolean switch to include the ATM transmission curves</span>
<span class="sd">                in the plots. The bandpass is used as the representative ATM </span>
<span class="sd">                transmission curve. Note that in Bands 9 and 10, the image </span>
<span class="sd">                sideband transmission curve is also shown as a black line. </span>
<span class="sd">                Default: True</span>

<span class="sd">            titlein: string: OPTIONAL</span>
<span class="sd">                This allows one to introduce their own title text. </span>
<span class="sd">                Default: None</span>

<span class="sd">            plotDivisions: boolean: OPTIONAL</span>
<span class="sd">                This is a boolean switch to include vertical lines at all </span>
<span class="sd">                locations where the spectral window was broken up during the </span>
<span class="sd">                calcReNorm() stage when the spectral window renormalization </span>
<span class="sd">                spectrum was fit to flatten the spectrum. </span>
<span class="sd">                Default: True</span>

<span class="sd">            hardcopy : boolean : OPTIONAL</span>
<span class="sd">                This is a boolean switch to create a hardcopy of the plot as a</span>
<span class="sd">                PNG file. If this is set to False, the plots will be shown </span>
<span class="sd">                interactively but not saved.</span>
<span class="sd">                Default: True</span>

<span class="sd">            createpdf : boolean : OPTIONAL</span>
<span class="sd">                This is a boolean switch to create a PDF of the summary plot </span>
<span class="sd">                using the convertPlotsToPDF() method. This will only trigger </span>
<span class="sd">                if hardcopy is also set to True.</span>
<span class="sd">                Default: True</span>

<span class="sd">            includeSummary : boolean : OPTIONAL</span>
<span class="sd">                This is a boolean switch to include the summary plot in the </span>
<span class="sd">                created PDF. As such, this is only evaluated if both hardcopy </span>
<span class="sd">                and createpdf are set to True.</span>
<span class="sd">                Default: True</span>

<span class="sd">            plotOriginal : boolean : OPTIONAL</span>
<span class="sd">                This is a boolean switch to overplot the original data before </span>
<span class="sd">                any ATM correction was performed. </span>
<span class="sd">                Default: True</span>

<span class="sd">            shadeAtm : boolean : OPTIONAL</span>
<span class="sd">                If set to True, this will shade the region of the spectrum </span>
<span class="sd">                influenced by atmospheric features. Features are found and </span>
<span class="sd">                fitted if plotATM=True, otherwise this option has no effect.</span>
<span class="sd">                Default: True</span>

<span class="sd">            showExcluded : boolean : OPTIONAL</span>
<span class="sd">                If set to True, then areas of the spectrum that have been </span>
<span class="sd">                excluded via the excludechan option in renormalize() will </span>
<span class="sd">                be shown. </span>
<span class="sd">                Default: True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check that renormalize() has been run</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;Please run renormalize before plotting!&#39;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="c1"># Grab all available targets. </span>
        <span class="n">target_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;N&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>

        <span class="c1"># Loop over all targets and make a separate summary plot for each</span>
        <span class="k">for</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">target_list</span><span class="p">:</span>
            <span class="c1"># Check to make sure the dictionary is filled (i.e. this target </span>
            <span class="c1"># was evaluated).</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;N&#39;</span><span class="p">][</span><span class="n">target</span><span class="p">]):</span>
                <span class="k">continue</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">ioff</span><span class="p">()</span>

            <span class="c1"># Loop over all spws being processed to make a summary for each </span>
            <span class="c1"># target/spw. Grab the spws that exist after running renormalize() </span>
            <span class="c1"># (i.e. if someone chose to only run a few spws rather than all </span>
            <span class="c1"># available, only those that were processed are grabbed).</span>
            <span class="n">doSpws</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;N&#39;</span><span class="p">][</span><span class="n">target</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">spw</span> <span class="ow">in</span> <span class="n">doSpws</span><span class="p">:</span>
                <span class="n">freqs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">msmeta</span><span class="o">.</span><span class="n">chanfreqs</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">spw</span><span class="p">),</span><span class="s1">&#39;GHz&#39;</span><span class="p">)</span>
                
                <span class="c1"># Not all targets are in all scans, we need to iterate over  </span>
                <span class="c1"># only those scans containing the target</span>
                <span class="n">target_scans</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">msmeta</span><span class="o">.</span><span class="n">scansforintent</span><span class="p">(</span><span class="s1">&#39;*TARGET*&#39;</span><span class="p">),</span> 
                                        <span class="bp">self</span><span class="o">.</span><span class="n">msmeta</span><span class="o">.</span><span class="n">scansforfield</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
                                        <span class="p">)</span>
                <span class="c1"># Make an additional cut to catch only those scans which  </span>
                <span class="c1"># contain the current spw (usually only relevant for spectral </span>
                <span class="c1"># scan datasets)</span>
                <span class="n">target_scans</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span>
                                            <span class="n">target_scans</span><span class="p">,</span> 
                                            <span class="bp">self</span><span class="o">.</span><span class="n">msmeta</span><span class="o">.</span><span class="n">scansforspw</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">spw</span><span class="p">))</span>
                                            <span class="p">)</span>
                <span class="c1"># if the user specified scans during renormalize() then the  </span>
                <span class="c1"># full scan list might not be included</span>
                <span class="n">target_scans</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span>
                                                <span class="n">target_scans</span><span class="p">,</span> 
                                                <span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;scans&#39;</span><span class="p">]</span>
                                                <span class="p">)</span>
                <span class="n">nscans</span><span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">target_scans</span><span class="p">)</span>

                <span class="c1"># renormalize() will populate the N_thresh dictionary for each </span>
                <span class="c1"># target/spw only if a target/spw/scan/field exceeds the </span>
                <span class="c1"># threshold. This allows us to plot a summary that only has the </span>
                <span class="c1"># fields that exceed the threshold shown which prevents the </span>
                <span class="c1"># renormalization factor being washed out by fields with no </span>
                <span class="c1"># emission. If no field exceeded the threshold then the </span>
                <span class="c1"># dictionary is simply filled with zeros and we fall back to </span>
                <span class="c1"># the total cumulative sum. </span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;N_thresh&#39;</span><span class="p">][</span><span class="n">target</span><span class="p">][</span><span class="nb">str</span><span class="p">(</span><span class="n">spw</span><span class="p">)])</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
                    <span class="n">N</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;N&#39;</span><span class="p">][</span><span class="n">target</span><span class="p">][</span><span class="nb">str</span><span class="p">(</span><span class="n">spw</span><span class="p">)]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">N</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;N_thresh&#39;</span><span class="p">][</span><span class="n">target</span><span class="p">][</span><span class="nb">str</span><span class="p">(</span><span class="n">spw</span><span class="p">)]</span>
                    <span class="c1"># If this part is triggered then only some scans/fields </span>
                    <span class="c1"># triggered meaning that not all scans may be in the final </span>
                    <span class="c1"># plot. Therefore, properly display the number of averaged </span>
                    <span class="c1"># scans in the title.</span>
                    <span class="n">nscans</span><span class="o">=</span><span class="mi">0</span>
                    <span class="k">for</span> <span class="n">tscan</span> <span class="ow">in</span> <span class="n">target_scans</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">fld</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">scalingValues</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">spw</span><span class="p">)][</span><span class="nb">str</span><span class="p">(</span><span class="n">tscan</span><span class="p">)]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">scalingValues</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">spw</span><span class="p">)][</span><span class="nb">str</span><span class="p">(</span><span class="n">tscan</span><span class="p">)][</span><span class="n">fld</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">bandThresh</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">Band</span><span class="p">]:</span>
                                <span class="n">nscans</span><span class="o">+=</span><span class="mi">1</span>
                                <span class="k">break</span>

                <span class="k">if</span> <span class="n">plotOriginal</span><span class="p">:</span>
                    <span class="c1"># If the dictionary is zero length, then no atm </span>
                    <span class="c1"># corrections were performed and the &quot;original&quot;</span>
                    <span class="c1"># data is the data.</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;N_atm&#39;</span><span class="p">][</span><span class="n">target</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">atmCorr</span><span class="o">=</span><span class="kc">False</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># However, the first spw(s) may not necessarily be </span>
                        <span class="c1"># defined so we need to catch those cases. </span>
                        <span class="k">try</span><span class="p">:</span> 
                            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;N_atm&#39;</span><span class="p">][</span><span class="n">target</span><span class="p">][</span><span class="nb">str</span><span class="p">(</span><span class="n">spw</span><span class="p">)])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                                <span class="n">N_atm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;N_atm&#39;</span><span class="p">][</span><span class="n">target</span><span class="p">][</span><span class="nb">str</span><span class="p">(</span><span class="n">spw</span><span class="p">)]</span>
                                <span class="n">atmCorr</span><span class="o">=</span><span class="kc">True</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">atmCorr</span><span class="o">=</span><span class="kc">False</span>
                        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                            <span class="n">atmCorr</span> <span class="o">=</span> <span class="kc">False</span>

                <span class="p">(</span><span class="n">nCor</span><span class="p">,</span><span class="n">nCha</span><span class="p">,</span><span class="n">nAnt</span><span class="p">)</span><span class="o">=</span><span class="n">N</span><span class="o">.</span><span class="n">shape</span>

                <span class="c1"># Initialize the figure</span>
                <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">8</span><span class="p">))</span>
                <span class="n">ax_rn</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">,</span> <span class="n">frame_on</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">ax_rn</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Renorm Scaling&#39;</span><span class="p">)</span>
                <span class="n">ax_rn</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Frequency (GHz) (TOPO)&#39;</span><span class="p">)</span>
                <span class="n">ax_rn</span><span class="o">.</span><span class="n">minorticks_on</span><span class="p">()</span>
                <span class="n">ax_rn</span><span class="o">.</span><span class="n">ticklabel_format</span><span class="p">(</span><span class="n">useOffset</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

                <span class="c1"># Setup secondary x-axis to display channels</span>
                <span class="n">ax_rn1</span> <span class="o">=</span> <span class="n">ax_rn</span><span class="o">.</span><span class="n">twiny</span><span class="p">()</span>
                <span class="n">ax_rn1</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Channel&#39;</span><span class="p">)</span>
                <span class="n">ax_rn1</span><span class="o">.</span><span class="n">minorticks_on</span><span class="p">()</span>
                
                
                <span class="c1"># If user input a title, set it up, otherwise use default</span>
                <span class="k">if</span> <span class="n">titlein</span><span class="p">:</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span>
                            <span class="nb">str</span><span class="p">(</span><span class="n">titlein</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
                            <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">msname</span>
                            <span class="o">+</span> <span class="s1">&#39; Nant=&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nAnt</span><span class="p">)</span>
                            <span class="o">+</span> <span class="s1">&#39; &lt;Nscan=&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">nscans</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;&gt; &#39;</span><span class="p">,</span>
                            <span class="p">{</span><span class="s1">&#39;fontsize&#39;</span><span class="p">:</span> <span class="s1">&#39;medium&#39;</span><span class="p">}</span>
                            <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ax_rn</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">msname</span>
                            <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Target=&#39;</span><span class="o">+</span><span class="n">target</span>
                            <span class="o">+</span> <span class="s1">&#39; Spw=&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">spw</span><span class="p">)</span>
                            <span class="o">+</span> <span class="s1">&#39; Nant=&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nAnt</span><span class="p">)</span>
                            <span class="o">+</span> <span class="s1">&#39; &lt;Nscan=&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">nscans</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;&gt;&#39;</span><span class="p">,</span>
                            <span class="p">{</span><span class="s1">&#39;fontsize&#39;</span><span class="p">:</span> <span class="s1">&#39;medium&#39;</span><span class="p">}</span>
                            <span class="p">)</span>
                
                <span class="c1"># If we want to plot the original spectrum before dealing  </span>
                <span class="c1"># with the ATM, find the mean of the spectrum with no atm </span>
                <span class="c1"># corrections, ignoring any antennas that have had all their </span>
                <span class="c1"># values set to 1.0 (due to flagging), then plot the mean.</span>
                <span class="k">if</span> <span class="n">atmCorr</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">Nm_atm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">N_atm</span><span class="o">!=</span><span class="mi">1</span><span class="p">,</span> <span class="n">N_atm</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>
                        <span class="n">Nm_atm</span><span class="p">[:][</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">Nm_atm</span><span class="p">[:])]</span> <span class="o">=</span> <span class="mf">1.0</span>                 
                        <span class="n">style</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;k--&#39;</span><span class="p">,</span><span class="s1">&#39;k--&#39;</span><span class="p">]</span>
                        <span class="k">for</span> <span class="n">icor</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nCor</span><span class="p">):</span>
                            <span class="n">ax_rn</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
                                    <span class="n">freqs</span><span class="p">,</span> 
                                    <span class="n">Nm_atm</span><span class="p">[</span><span class="n">icor</span><span class="p">,:],</span> 
                                    <span class="n">style</span><span class="p">[</span><span class="n">icor</span><span class="p">],</span> 
                                    <span class="n">alpha</span><span class="o">=</span><span class="mf">0.25</span><span class="p">,</span> 
                                    <span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> 
                                    <span class="n">zorder</span><span class="o">=</span><span class="mi">11</span>
                                    <span class="p">)</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;ATM corrections were not properly stored, &#39;</span> \
                                <span class="o">+</span><span class="s1">&#39;cannot plot original spectrum!&#39;</span><span class="p">)</span>
               
                <span class="c1"># For each antenna/correlation, plot the cummulative sum, </span>
                <span class="c1">#  making the correlations unique colors.</span>
                <span class="n">style</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;r:&#39;</span><span class="p">,</span><span class="s1">&#39;b:&#39;</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">iant</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nAnt</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">icor</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nCor</span><span class="p">):</span>
                        <span class="n">ax_rn</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">freqs</span><span class="p">,</span> <span class="n">N</span><span class="p">[</span><span class="n">icor</span><span class="p">,:,</span><span class="n">iant</span><span class="p">],</span><span class="n">style</span><span class="p">[</span><span class="n">icor</span><span class="p">])</span>
                
                <span class="c1"># Find the mean of the spectrum over all antennas, ignoring  </span>
                <span class="c1"># any antennas that have had all their values set to 1.0 </span>
                <span class="c1"># (due to flagging).</span>
                <span class="n">Nm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">N</span><span class="o">!=</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>
                <span class="n">Nm</span><span class="p">[:][</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">Nm</span><span class="p">[:])]</span> <span class="o">=</span> <span class="mf">1.0</span>

                <span class="c1"># Plot the mean renormalization spectrum</span>
                <span class="n">style</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;r-&#39;</span><span class="p">,</span> <span class="s1">&#39;b-&#39;</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">icor</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nCor</span><span class="p">):</span>
                    <span class="n">ax_rn</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">freqs</span><span class="p">,</span> <span class="n">Nm</span><span class="p">[</span><span class="n">icor</span><span class="p">,:],</span> <span class="n">style</span><span class="p">[</span><span class="n">icor</span><span class="p">])</span>
                
                <span class="c1"># Find max over all ants then the mean of that, ignoring any  </span>
                <span class="c1"># flagged antenna. This matches the values calculated by  </span>
                <span class="c1"># renormalize(). Because of discrete sampling and noise, the  </span>
                <span class="c1"># max of the mean spectrum does not necessarily equal the mean </span>
                <span class="c1"># value of the maxes from each antenna because some antenna may  </span>
                <span class="c1"># peak in different channels for lines that spread over multiple </span>
                <span class="c1"># channels.</span>
                <span class="k">if</span> <span class="n">nCor</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">Nxmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span>
                            <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">N</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">!=</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">),</span><span class="mi">1</span>
                            <span class="p">)[</span><span class="mi">0</span><span class="p">]</span> 
                    <span class="n">Nymax</span> <span class="o">=</span> <span class="n">Nxmax</span>
                <span class="k">elif</span> <span class="n">nCor</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">Nxmax</span><span class="p">,</span> <span class="n">Nymax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span>
                            <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">N</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">!=</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">),</span><span class="mi">1</span>
                            <span class="p">)</span> 
                
                <span class="c1"># If the max in either correlation is above the alarm theshold  </span>
                <span class="c1"># (fthresh), then draw a line at that amplidude, centered in </span>
                <span class="c1"># the plot. </span>
                <span class="k">if</span> <span class="n">Nxmax</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="mf">1.0</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">fthresh</span><span class="p">)</span> <span class="ow">or</span> <span class="n">Nymax</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="mf">1.0</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">fthresh</span><span class="p">):</span>
                    <span class="n">fmin</span> <span class="o">=</span> <span class="mf">3.</span><span class="o">/</span><span class="mf">8.</span><span class="o">*</span><span class="nb">max</span><span class="p">(</span><span class="n">freqs</span><span class="p">)</span> <span class="o">+</span> <span class="mf">5.</span><span class="o">/</span><span class="mf">8.</span><span class="o">*</span><span class="nb">min</span><span class="p">(</span><span class="n">freqs</span><span class="p">)</span>
                    <span class="n">fmax</span> <span class="o">=</span> <span class="mf">5.</span><span class="o">/</span><span class="mf">8.</span><span class="o">*</span><span class="nb">max</span><span class="p">(</span><span class="n">freqs</span><span class="p">)</span> <span class="o">+</span> <span class="mf">3.</span><span class="o">/</span><span class="mf">8.</span><span class="o">*</span><span class="nb">min</span><span class="p">(</span><span class="n">freqs</span><span class="p">)</span>
                    <span class="n">ax_rn</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">fmin</span><span class="p">,</span><span class="n">fmax</span><span class="p">],[</span><span class="n">Nxmax</span><span class="p">]</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="s1">&#39;r-&#39;</span><span class="p">)</span>
                    <span class="n">ax_rn</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">fmin</span><span class="p">,</span><span class="n">Nxmax</span><span class="p">,</span><span class="s1">&#39;&lt;X&gt;=&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">Nxmax</span><span class="p">,</span> <span class="mi">4</span><span class="p">)),</span>
                            <span class="n">ha</span><span class="o">=</span><span class="s1">&#39;right&#39;</span><span class="p">,</span><span class="n">va</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">,</span><span class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span><span class="n">size</span><span class="o">=</span><span class="s1">&#39;x-small&#39;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">nCor</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="n">ax_rn</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">fmin</span><span class="p">,</span><span class="n">fmax</span><span class="p">],[</span><span class="n">Nymax</span><span class="p">]</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="s1">&#39;b-&#39;</span><span class="p">)</span>
                        <span class="n">ax_rn</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">fmax</span><span class="p">,</span><span class="n">Nymax</span><span class="p">,</span><span class="s1">&#39;&lt;Y&gt;=&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">Nymax</span><span class="p">,</span> <span class="mi">4</span><span class="p">)),</span>
                                <span class="n">va</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">,</span><span class="n">color</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="n">size</span><span class="o">=</span><span class="s1">&#39;x-small&#39;</span><span class="p">)</span>

                <span class="c1"># Grab the plot limits and set them for making it &quot;look pretty&quot;</span>
                <span class="n">lims</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">ax_rn</span><span class="o">.</span><span class="n">axis</span><span class="p">())</span>
                <span class="n">lims</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="nb">min</span><span class="p">(</span><span class="n">freqs</span><span class="p">)</span><span class="o">*</span><span class="mf">0.99999</span>
                <span class="n">lims</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="nb">max</span><span class="p">(</span><span class="n">freqs</span><span class="p">)</span><span class="o">*</span><span class="mf">1.00001</span>
                <span class="n">lims</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">=</span><span class="nb">min</span><span class="p">(</span><span class="mf">0.999</span><span class="p">,</span><span class="n">lims</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                <span class="n">lims</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">=</span><span class="nb">max</span><span class="p">(</span><span class="mf">1.15</span><span class="o">*</span><span class="n">lims</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">-</span><span class="mf">0.15</span><span class="o">*</span><span class="n">lims</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="mf">1.02</span><span class="p">)</span>
                <span class="n">ax_rn</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="n">lims</span><span class="p">)</span>
                
                <span class="c1"># If True, then show a small yellow area indicating where the </span>
                <span class="c1"># spectrum has been blanked.</span>
                <span class="k">if</span> <span class="n">showExcluded</span><span class="p">:</span>
                    <span class="c1"># Check to make sure it is not an empty input</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;inputs&#39;</span><span class="p">][</span><span class="s1">&#39;excludechan&#39;</span><span class="p">]:</span>
                        <span class="c1"># Check to make sure this spw has anything input, then grab the </span>
                        <span class="c1"># range and plot it.</span>
                        <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">spw</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;inputs&#39;</span><span class="p">][</span><span class="s1">&#39;excludechan&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                            <span class="n">ranges</span> <span class="o">=</span> <span class="p">[</span>
                                    <span class="n">rng</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> 
                                    <span class="k">for</span> <span class="n">rng</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;inputs&#39;</span><span class="p">][</span><span class="s1">&#39;excludechan&#39;</span><span class="p">][</span><span class="nb">str</span><span class="p">(</span><span class="n">spw</span><span class="p">)]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;;&#39;</span><span class="p">)</span>
                                    <span class="p">]</span>
                            <span class="n">starts</span><span class="p">,</span> <span class="n">ends</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interpretExcludechan</span><span class="p">(</span><span class="n">ranges</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">spw</span><span class="p">))</span>
                            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">starts</span><span class="p">)):</span>
                                <span class="n">ax_rn</span><span class="o">.</span><span class="n">axvspan</span><span class="p">(</span>
                                        <span class="n">freqs</span><span class="p">[</span><span class="n">starts</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span> 
                                        <span class="n">freqs</span><span class="p">[</span><span class="n">ends</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span> 
                                        <span class="n">ymin</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> 
                                        <span class="n">ymax</span><span class="o">=</span><span class="mf">0.06</span><span class="p">,</span> 
                                        <span class="n">facecolor</span><span class="o">=</span><span class="s1">&#39;yellow&#39;</span><span class="p">,</span> 
                                        <span class="n">ec</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">,</span> 
                                        <span class="n">zorder</span><span class="o">=</span><span class="mi">0</span>
                                        <span class="p">)</span>

                <span class="c1"># If True, draw thin, dotted lines at the locations where the </span>
                <span class="c1"># renormalization spectrum was broken up during the fitting </span>
                <span class="c1"># process.</span>
                <span class="c1">#</span>
                <span class="c1"># Since the number of divisions can change through renormalization</span>
                <span class="c1"># the mode is chosen and an indicator is placed in the upper right</span>
                <span class="c1"># if the number of segments changed.</span>
                <span class="k">if</span> <span class="n">plotDivisions</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rnpipestats</span><span class="p">[</span><span class="n">target</span><span class="p">][</span><span class="nb">str</span><span class="p">(</span><span class="n">spw</span><span class="p">)][</span><span class="s1">&#39;seg_change&#39;</span><span class="p">]:</span>
                        <span class="n">ax_rn</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.93</span><span class="p">,</span> <span class="s2">&quot;Segment sizes changed!&quot;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="s1">&#39;18&#39;</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="n">ax_rn</span><span class="o">.</span><span class="n">transAxes</span><span class="p">)</span>
                        <span class="n">dNchan</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span>
                                    <span class="nb">set</span><span class="p">(</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;inputs&#39;</span><span class="p">][</span><span class="n">target</span><span class="p">][</span><span class="nb">str</span><span class="p">(</span><span class="n">spw</span><span class="p">)][</span><span class="s1">&#39;dNchan&#39;</span><span class="p">]</span>
                                        <span class="p">),</span> 
                                    <span class="n">key</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;inputs&#39;</span><span class="p">][</span><span class="n">target</span><span class="p">][</span><span class="nb">str</span><span class="p">(</span><span class="n">spw</span><span class="p">)][</span><span class="s1">&#39;dNchan&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">count</span>
                                    <span class="p">)</span>
                        <span class="n">nseg</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span>
                                    <span class="nb">set</span><span class="p">(</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;inputs&#39;</span><span class="p">][</span><span class="n">target</span><span class="p">][</span><span class="nb">str</span><span class="p">(</span><span class="n">spw</span><span class="p">)][</span><span class="s1">&#39;num_segments&#39;</span><span class="p">]</span>
                                        <span class="p">),</span>
                                    <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;inputs&#39;</span><span class="p">][</span><span class="n">target</span><span class="p">][</span><span class="nb">str</span><span class="p">(</span><span class="n">spw</span><span class="p">)][</span><span class="s1">&#39;num_segments&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">count</span>
                                    <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">dNchan</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;inputs&#39;</span><span class="p">][</span><span class="n">target</span><span class="p">][</span><span class="nb">str</span><span class="p">(</span><span class="n">spw</span><span class="p">)][</span><span class="s1">&#39;dNchan&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                        <span class="n">nseg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;inputs&#39;</span><span class="p">][</span><span class="n">target</span><span class="p">][</span><span class="nb">str</span><span class="p">(</span><span class="n">spw</span><span class="p">)][</span><span class="s1">&#39;num_segments&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">nseg</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span> 
                        <span class="n">xlocs</span> <span class="o">=</span> <span class="p">[</span><span class="n">iseg</span><span class="o">*</span><span class="n">dNchan</span> <span class="k">for</span> <span class="n">iseg</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">nseg</span><span class="p">)]</span>
                        <span class="n">ax_rn</span><span class="o">.</span><span class="n">vlines</span><span class="p">(</span><span class="n">freqs</span><span class="p">[</span><span class="n">xlocs</span><span class="p">],</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">linestyles</span><span class="o">=</span><span class="s1">&#39;dotted&#39;</span><span class="p">,</span> 
                                <span class="n">colors</span><span class="o">=</span><span class="s1">&#39;grey&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
                
                <span class="c1"># Set the channels labels in the correct direction since the</span>
                <span class="c1">#  LSB will have &quot;backward&quot; frequencies and here the </span>
                <span class="c1"># frequencies are always shown low to high.</span>
                <span class="k">if</span> <span class="n">freqs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">freqs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="n">ax_rn1</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">freqs</span><span class="p">),</span><span class="mi">0</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ax_rn1</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">freqs</span><span class="p">))</span>
                
                <span class="c1"># If option selected, add the atmospheric profile to the plots, </span>
                <span class="c1"># using the bandpass as the profile. </span>
                <span class="k">if</span> <span class="n">plotATM</span><span class="p">:</span>
                    <span class="c1"># Setup the axis to draw on, using the same frequency axis</span>
                    <span class="n">ax_atm</span> <span class="o">=</span> <span class="n">ax_rn</span><span class="o">.</span><span class="n">twinx</span><span class="p">()</span>
                    <span class="c1"># Grab the bandpass scan and protect against multiple </span>
                    <span class="c1"># existing. Also protect from a missing bandpass scan by </span>
                    <span class="c1"># falling back to the phase calibrator if necessary.</span>
                    <span class="n">Bscanatm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getBscan</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">spw</span><span class="p">),</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">Bscanatm</span><span class="p">:</span>
                        <span class="n">Bscanatm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getPhscan</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">spw</span><span class="p">),</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">Bscanatm</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">:</span>
                        <span class="n">Bscanatm</span> <span class="o">=</span> <span class="n">Bscanatm</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="c1"># If renormalize(correctATM=True) was run, the ATM profile</span>
                    <span class="c1"># already exists in a dictionary so use it. Otherwise, </span>
                    <span class="c1"># grab a new one and make sure to also grab the image </span>
                    <span class="c1"># sideband ATM profile if needed.</span>
                    <span class="k">if</span> <span class="s1">&#39;BandPass&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">atmtrans</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">Band</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">]:</span>
                            <span class="n">ATMprof</span><span class="p">,</span> <span class="n">ATMprof_imageSB</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ATMtrans</span><span class="p">(</span>
                                                                <span class="n">Bscanatm</span><span class="p">,</span> 
                                                                <span class="nb">int</span><span class="p">(</span><span class="n">spw</span><span class="p">),</span> 
                                                                <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span>
                                                                <span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">ATMprof</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ATMtrans</span><span class="p">(</span>
                                                        <span class="n">Bscanatm</span><span class="p">,</span> 
                                                        <span class="nb">int</span><span class="p">(</span><span class="n">spw</span><span class="p">),</span> 
                                                        <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span>
                                                        <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># Currently, correctATM will not properly handle Bands </span>
                        <span class="c1"># 9 and 10 but eventually the image sideband will need </span>
                        <span class="c1"># to be added here.</span>
                        <span class="n">ATMprof</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atmtrans</span><span class="p">[</span><span class="s1">&#39;BandPass&#39;</span><span class="p">][</span><span class="nb">str</span><span class="p">(</span><span class="n">spw</span><span class="p">)][</span><span class="nb">str</span><span class="p">(</span><span class="n">Bscanatm</span><span class="p">)]</span>
                    
                    <span class="c1"># Plot the ATM profile</span>
                    <span class="n">ax_atm</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
                            <span class="n">freqs</span><span class="p">,</span> 
                            <span class="mi">100</span><span class="o">*</span><span class="n">ATMprof</span><span class="p">,</span> 
                            <span class="n">c</span><span class="o">=</span><span class="s1">&#39;m&#39;</span><span class="p">,</span> 
                            <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;-&#39;</span><span class="p">,</span> 
                            <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span>
                            <span class="p">)</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">Band</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">]:</span>
                        <span class="n">ax_atm</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
                                <span class="n">freqs</span><span class="p">,</span> 
                                <span class="mi">100</span><span class="o">*</span><span class="n">ATMprof_imageSB</span><span class="p">,</span> 
                                <span class="n">c</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> 
                                <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;-&#39;</span><span class="p">,</span> 
                                <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span>
                                <span class="p">)</span>
                    <span class="n">ax_atm</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">tick_right</span><span class="p">()</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">Band</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">]:</span>
                        <span class="n">peak</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">ATMprof</span><span class="p">,</span> <span class="n">ATMprof_imageSB</span><span class="p">)</span><span class="o">*</span><span class="mf">100.</span><span class="p">)</span><span class="o">+</span><span class="mi">10</span>
                        <span class="n">ax_atm</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;ATM Transmission (%), Image Sideband&#39;</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">peak</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">ATMprof</span><span class="o">*</span><span class="mi">100</span><span class="p">)</span><span class="o">+</span><span class="mi">10</span>
                        <span class="n">ax_atm</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;ATM Transmission (%)&#39;</span><span class="p">)</span>
                    <span class="n">ax_atm</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">set_label_position</span><span class="p">(</span><span class="s1">&#39;right&#39;</span><span class="p">)</span>
                    
                    <span class="c1"># Enforce a range of 100</span>
                    <span class="n">atm_ymax</span> <span class="o">=</span> <span class="n">peak</span>
                    <span class="n">atm_ymin</span> <span class="o">=</span> <span class="n">peak</span><span class="o">-</span><span class="mi">100</span>
                    <span class="n">ax_atm</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">atm_ymin</span><span class="p">,</span> <span class="n">atm_ymax</span><span class="p">)</span>

                    <span class="c1"># Make sure that we don&#39;t label values that are less </span>
                    <span class="c1"># than 0 since that has no physical meaning.</span>
                    <span class="n">yvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">atm_ymin</span><span class="p">),</span> <span class="nb">round</span><span class="p">(</span><span class="n">atm_ymax</span><span class="p">))</span>
                    <span class="n">yvals_mod</span> <span class="o">=</span> <span class="n">yvals</span><span class="o">%</span><span class="mi">20</span>
                    <span class="n">ylabels</span> <span class="o">=</span> <span class="n">yvals</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">yvals_mod</span><span class="o">==</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">])]</span>
                    <span class="n">ylabels_mask</span> <span class="o">=</span> <span class="n">ylabels</span> <span class="o">&gt;=</span> <span class="mi">0</span> 
                    <span class="n">ax_atm</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">(</span><span class="n">ylabels</span><span class="p">[</span><span class="n">ylabels_mask</span><span class="p">])</span>
                    <span class="n">ax_atm</span><span class="o">.</span><span class="n">set_yticklabels</span><span class="p">(</span>
                            <span class="p">[</span>
                                <span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">ylbl</span><span class="p">))</span> 
                                <span class="k">for</span> <span class="n">ylbl</span> <span class="ow">in</span> <span class="n">ylabels</span><span class="p">[</span><span class="n">ylabels_mask</span><span class="p">]</span>
                                <span class="p">]</span>
                            <span class="p">)</span>

                    <span class="c1"># Gather stats for pipeline development</span>
                    <span class="k">if</span> <span class="s1">&#39;atmStats&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;atmStats&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
                    <span class="k">if</span> <span class="n">target</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;atmStats&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;atmStats&#39;</span><span class="p">][</span><span class="n">target</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

                    <span class="c1"># Find the index and frequency with the maximum renorm value</span>
                    <span class="n">maxRnIdx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">Nm</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="nb">max</span><span class="p">(</span><span class="n">Nm</span><span class="p">[</span><span class="mi">0</span><span class="p">]))[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">maxRnFreq</span> <span class="o">=</span> <span class="n">freqs</span><span class="p">[</span><span class="n">maxRnIdx</span><span class="p">]</span>
                    
                    <span class="c1"># Find where the ATM lines are by fitting Lorentzian profiles</span>
                    <span class="n">atm_centers</span><span class="p">,</span> <span class="n">atm_gammas</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fitAtmLines</span><span class="p">(</span><span class="n">ATMprof</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">spw</span><span class="p">))</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">Band</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">]:</span>
                        <span class="n">num_lines</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">atm_centers</span><span class="p">)</span>
                        <span class="n">atm_centers_SB</span><span class="p">,</span> <span class="n">atm_gammas_SB</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fitAtmLines</span><span class="p">(</span>
                                                                <span class="n">ATMprof_imageSB</span><span class="p">,</span> 
                                                                <span class="nb">int</span><span class="p">(</span><span class="n">spw</span><span class="p">)</span>
                                                                <span class="p">)</span>
                        <span class="n">atm_centers</span> <span class="o">+=</span> <span class="n">atm_centers_SB</span>
                        <span class="n">atm_gammas</span> <span class="o">+=</span> <span class="n">atm_gammas_SB</span>

                    <span class="c1"># Report found lines, if any.</span>
                    <span class="c1"># PL requested that statistics of ATM lines be printed out </span>
                    <span class="c1"># with this function.</span>
                    <span class="c1">#</span>
                    <span class="c1"># Output is:</span>
                    <span class="c1">#</span>
                    <span class="c1"># UID, SPW, Freq @ max renrorm value, Max renorm value, Freq @ Atm line, renorm value @ Atm line</span>
                    <span class="c1">#</span>
                    <span class="c1"># If there are multiple atm features, then multiple lines </span>
                    <span class="c1"># are output</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">atm_centers</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;atmStats&#39;</span><span class="p">][</span><span class="n">target</span><span class="p">][</span><span class="nb">str</span><span class="p">(</span><span class="n">spw</span><span class="p">)]</span> <span class="o">=</span> \
                                <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                                        <span class="p">[</span>
                                            <span class="bp">self</span><span class="o">.</span><span class="n">msname</span><span class="p">,</span> 
                                            <span class="nb">str</span><span class="p">(</span><span class="n">spw</span><span class="p">),</span> 
                                            <span class="nb">str</span><span class="p">(</span><span class="n">maxRnFreq</span><span class="p">),</span> 
                                            <span class="nb">str</span><span class="p">(</span><span class="n">Nm</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">maxRnIdx</span><span class="p">])</span>
                                            <span class="p">]</span>
                                        <span class="p">)</span>
                        <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="si">{0:^30}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;ASDM uid&#39;</span><span class="p">)</span>  
                                <span class="o">+</span> <span class="s1">&#39;</span><span class="si">{0:^5}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;SPW&#39;</span><span class="p">)</span>  
                                <span class="o">+</span> <span class="s1">&#39;</span><span class="si">{0:^12}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;Freq@R_max&#39;</span><span class="p">)</span> 
                                <span class="o">+</span> <span class="s1">&#39;</span><span class="si">{0:^9}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;R_max&#39;</span><span class="p">)</span> 
                                <span class="p">)</span>
                        <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                            <span class="p">[</span>
                                <span class="s1">&#39;</span><span class="si">{0:^30}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">msname</span><span class="p">),</span>
                                <span class="s1">&#39;</span><span class="si">{0:^5}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">spw</span><span class="p">)),</span> 
                                <span class="s1">&#39;</span><span class="si">{0:^12}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">maxRnFreq</span><span class="p">,</span><span class="mi">6</span><span class="p">))),</span>
                                <span class="s1">&#39;</span><span class="si">{0:^9}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">Nm</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">maxRnIdx</span><span class="p">],</span><span class="mi">5</span><span class="p">)))</span> 
                                <span class="p">]</span>
                            <span class="p">)</span>
                            <span class="p">)</span>
                        <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="si">{0:^30}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;ASDM uid&#39;</span><span class="p">)</span>  
                                <span class="o">+</span> <span class="s1">&#39;</span><span class="si">{0:^5}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;SPW&#39;</span><span class="p">)</span>  
                                <span class="o">+</span> <span class="s1">&#39;</span><span class="si">{0:^12}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;Freq@R_max&#39;</span><span class="p">)</span> 
                                <span class="o">+</span> <span class="s1">&#39;</span><span class="si">{0:^9}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;R_max&#39;</span><span class="p">)</span>
                                <span class="o">+</span> <span class="s1">&#39;</span><span class="si">{0:^12}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;Freq@atm&#39;</span><span class="p">)</span> 
                                <span class="o">+</span> <span class="s1">&#39;</span><span class="si">{0:^9}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;R_atm&#39;</span><span class="p">)</span>
                                <span class="p">)</span>
                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">atm_centers</span><span class="p">)):</span>
                            <span class="c1"># Set the ATM profile we want to report which might </span>
                            <span class="c1"># vary for Bands 9 and 10</span>
                            <span class="n">profile</span> <span class="o">=</span> <span class="n">ATMprof</span>
                            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">Band</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">]:</span>
                                <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">num_lines</span><span class="p">:</span>
                                    <span class="n">profile</span> <span class="o">=</span> <span class="n">ATMprof_imageSB</span>
                            <span class="c1"># A Lorentizian has a width of gamma (which is != a </span>
                            <span class="c1"># Gaussian sigma!) where 2*gamma is the FWHM. Here </span>
                            <span class="c1"># we go a bit further to capture most of the ATM </span>
                            <span class="c1"># feature that is above the noise. This is from my </span>
                            <span class="c1"># empirical estimates from datasets I&#39;ve collected </span>
                            <span class="c1"># and seems to capture most of signal without </span>
                            <span class="c1"># catching real signal for cases where an ATM line </span>
                            <span class="c1"># is coincident (or nearly so) with a real line. </span>
                            <span class="c1">#</span>
                            <span class="c1"># PIPEREQ-228 - Need to protect instances where the</span>
                            <span class="c1"># fitted feature starts or ends outside the spw!</span>
                            <span class="n">atm_start</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span>
                                            <span class="nb">max</span><span class="p">(</span>
                                                <span class="mi">0</span><span class="p">,</span> 
                                                <span class="nb">int</span><span class="p">(</span><span class="n">atm_centers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="mf">1.3</span><span class="o">*</span><span class="n">atm_gammas</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                                                <span class="p">),</span> 
                                            <span class="nb">len</span><span class="p">(</span><span class="n">profile</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
                                            <span class="p">)</span>
                            <span class="n">atm_end</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span>
                                            <span class="mi">0</span><span class="p">,</span> 
                                            <span class="nb">min</span><span class="p">(</span>
                                                <span class="nb">int</span><span class="p">(</span><span class="n">atm_centers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="mf">1.3</span><span class="o">*</span><span class="n">atm_gammas</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> 
                                                <span class="nb">len</span><span class="p">(</span><span class="n">profile</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
                                                <span class="p">)</span>
                                            <span class="p">)</span>
                            <span class="k">if</span> <span class="n">atm_start</span> <span class="o">==</span> <span class="n">atm_end</span><span class="p">:</span>
                                <span class="k">continue</span>

                            <span class="c1"># Draw a shaded region where the line is</span>
                            <span class="k">if</span> <span class="n">shadeAtm</span><span class="p">:</span>
                                <span class="n">ax_atm</span><span class="o">.</span><span class="n">axvspan</span><span class="p">(</span>
                                        <span class="n">freqs</span><span class="p">[</span><span class="n">atm_start</span><span class="p">],</span>
                                        <span class="n">freqs</span><span class="p">[</span><span class="n">atm_end</span><span class="p">],</span>
                                        <span class="n">ymin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> 
                                        <span class="n">ymax</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
                                        <span class="n">alpha</span><span class="o">=</span><span class="mf">0.25</span><span class="p">,</span> 
                                        <span class="n">facecolor</span><span class="o">=</span><span class="s1">&#39;grey&#39;</span>
                                        <span class="p">)</span>
                            
                            <span class="c1"># Report the stats</span>
                            <span class="n">atm_min_idx</span> <span class="o">=</span> <span class="n">atm_start</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                                    <span class="n">profile</span><span class="p">[</span><span class="n">atm_start</span><span class="p">:</span><span class="n">atm_end</span><span class="p">]</span> <span class="o">==</span> <span class="nb">min</span><span class="p">(</span><span class="n">profile</span><span class="p">[</span><span class="n">atm_start</span><span class="p">:</span><span class="n">atm_end</span><span class="p">])</span>
                                    <span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                            <span class="n">atm_dip_freq</span> <span class="o">=</span> <span class="n">freqs</span><span class="p">[</span><span class="n">atm_min_idx</span><span class="p">]</span>
                            <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">spw</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;atmStats&#39;</span><span class="p">][</span><span class="n">target</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;atmStats&#39;</span><span class="p">][</span><span class="n">target</span><span class="p">][</span><span class="nb">str</span><span class="p">(</span><span class="n">spw</span><span class="p">)]</span> <span class="o">=</span> \
                                        <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                                                <span class="p">[</span>
                                                    <span class="bp">self</span><span class="o">.</span><span class="n">msname</span><span class="p">,</span> 
                                                    <span class="nb">str</span><span class="p">(</span><span class="n">spw</span><span class="p">),</span> 
                                                    <span class="nb">str</span><span class="p">(</span><span class="n">maxRnFreq</span><span class="p">),</span>
                                                    <span class="nb">str</span><span class="p">(</span><span class="n">Nm</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">maxRnIdx</span><span class="p">]),</span> 
                                                    <span class="nb">str</span><span class="p">(</span><span class="n">atm_dip_freq</span><span class="p">),</span>
                                                    <span class="nb">str</span><span class="p">(</span><span class="n">Nm</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">atm_min_idx</span><span class="p">]),</span>
                                                    <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
                                                    <span class="p">]</span>
                                                <span class="p">)</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;atmStats&#39;</span><span class="p">][</span><span class="n">target</span><span class="p">][</span><span class="nb">str</span><span class="p">(</span><span class="n">spw</span><span class="p">)]</span> <span class="o">+=</span> \
                                        <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                                                <span class="p">[</span>
                                                    <span class="bp">self</span><span class="o">.</span><span class="n">msname</span><span class="p">,</span> 
                                                    <span class="nb">str</span><span class="p">(</span><span class="n">spw</span><span class="p">),</span> 
                                                    <span class="nb">str</span><span class="p">(</span><span class="n">maxRnFreq</span><span class="p">),</span>
                                                    <span class="nb">str</span><span class="p">(</span><span class="n">Nm</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">maxRnIdx</span><span class="p">]),</span> 
                                                    <span class="nb">str</span><span class="p">(</span><span class="n">atm_dip_freq</span><span class="p">),</span>
                                                    <span class="nb">str</span><span class="p">(</span><span class="n">Nm</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">atm_min_idx</span><span class="p">]),</span>
                                                    <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
                                                    <span class="p">]</span>
                                                <span class="p">)</span>

                            <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                                <span class="p">[</span>
                                    <span class="s1">&#39;</span><span class="si">{0:^30}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">msname</span><span class="p">),</span>
                                    <span class="s1">&#39;</span><span class="si">{0:^5}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">spw</span><span class="p">)),</span> 
                                    <span class="s1">&#39;</span><span class="si">{0:^12}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">maxRnFreq</span><span class="p">,</span><span class="mi">6</span><span class="p">))),</span>
                                    <span class="s1">&#39;</span><span class="si">{0:^9}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">Nm</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">maxRnIdx</span><span class="p">],</span><span class="mi">5</span><span class="p">))),</span> 
                                    <span class="s1">&#39;</span><span class="si">{0:^12}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">atm_dip_freq</span><span class="p">,</span><span class="mi">6</span><span class="p">))),</span>
                                    <span class="s1">&#39;</span><span class="si">{0:^9}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">Nm</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">atm_min_idx</span><span class="p">],</span><span class="mi">5</span><span class="p">)))</span>
                                    <span class="p">]</span>
                                <span class="p">)</span>
                                <span class="p">)</span>
                        <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>

                <span class="c1"># If option is selected, save a hardcopy of the plots. </span>
                <span class="c1"># Otherwise, produce interactive plot and wait for user </span>
                <span class="c1"># input to go on to the next plot.</span>
                <span class="k">if</span> <span class="n">hardcopy</span><span class="p">:</span>
                    <span class="c1"># Ensure the plots directory exists, if not, create it.</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="s1">&#39;RN_plots&#39;</span><span class="p">):</span>
                        <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="s1">&#39;RN_plots&#39;</span><span class="p">)</span>
                    <span class="n">fname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">msname</span> \
                            <span class="o">+</span> <span class="s1">&#39;_&#39;</span><span class="o">+</span><span class="n">target</span> \
                            <span class="o">+</span> <span class="s1">&#39;_spw&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">spw</span><span class="p">)</span> \
                            <span class="o">+</span> <span class="s1">&#39;_ReNormSpectra.png&#39;</span>
                    <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;Saving hardcopy plot: &#39;</span><span class="o">+</span><span class="n">fname</span><span class="p">)</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;./RN_plots/&#39;</span><span class="o">+</span><span class="n">fname</span><span class="p">)</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
                    <span class="c1"># Save the filename of the plot to the rnpipestats </span>
                    <span class="c1"># dictionary so Pipeline can easily reference it.</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">rnpipestats</span><span class="p">[</span><span class="n">target</span><span class="p">][</span><span class="nb">str</span><span class="p">(</span><span class="n">spw</span><span class="p">)][</span><span class="s1">&#39;spec_plot&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">fname</span>
                    <span class="k">if</span> <span class="n">createpdf</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">convertPlotsToPDF</span><span class="p">(</span>
                                <span class="n">target</span><span class="p">,</span> 
                                <span class="nb">int</span><span class="p">(</span><span class="n">spw</span><span class="p">),</span> 
                                <span class="n">include_summary</span><span class="o">=</span><span class="n">includeSummary</span><span class="p">,</span> 
                                <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span>
                                <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
                    <span class="c1"># Python 2 vs. 3, raw_input() changed to input()</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">raw_input</span><span class="p">(</span>
                                <span class="s1">&#39;Please close plot and press ENTER to continue.&#39;</span>
                                <span class="p">)</span>
                    <span class="k">except</span> <span class="ne">NameError</span><span class="p">:</span>
                        <span class="nb">input</span><span class="p">(</span><span class="s1">&#39;Please close plot and press ENTER to continue.&#39;</span><span class="p">)</span></div>




    <span class="c1"># George&#39;s default code</span>
    <span class="k">def</span> <span class="nf">plotScanStats</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">hardcopy</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;Please run renormalize before plotting!&#39;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ioff</span><span class="p">()</span>
        <span class="n">pfig</span><span class="o">=</span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">14</span><span class="p">,</span><span class="mi">9</span><span class="p">))</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ioff</span><span class="p">()</span>
        <span class="n">pfig</span><span class="o">.</span><span class="n">clf</span><span class="p">()</span>

        <span class="n">sh</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;rNmax&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>

        <span class="n">nSpw</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;spws&#39;</span><span class="p">])</span>
        <span class="n">nXspw</span><span class="p">,</span><span class="n">nYspw</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyplots</span><span class="p">(</span><span class="n">nSpw</span><span class="p">)</span>
        
        <span class="n">plt</span><span class="o">.</span><span class="n">clf</span><span class="p">()</span>
        <span class="n">k</span><span class="o">=</span><span class="mi">1</span>
        <span class="n">scans</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;scans&#39;</span><span class="p">])</span>
        <span class="n">loscan</span><span class="o">=</span><span class="n">scans</span><span class="o">.</span><span class="n">min</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span>
        <span class="n">hiscan</span><span class="o">=</span><span class="n">scans</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">+</span><span class="mi">1</span>
        <span class="k">for</span> <span class="n">spw</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;spws&#39;</span><span class="p">]:</span>
            <span class="n">ispw</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;spws&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">spw</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="n">nYspw</span><span class="p">,</span><span class="n">nXspw</span><span class="p">,</span><span class="n">k</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">ioff</span><span class="p">()</span>
            <span class="c1"># CASA 6 units change unless specificed</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">ticklabel_format</span><span class="p">(</span><span class="n">style</span><span class="o">=</span><span class="s1">&#39;plain&#39;</span><span class="p">,</span> <span class="n">useOffset</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="n">nXspw</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Peak frac renorm scale&#39;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">k</span><span class="o">&gt;</span><span class="p">(</span><span class="n">nSpw</span><span class="o">-</span><span class="n">nXspw</span><span class="p">):</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Scan&#39;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">k</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">msname</span>
                        <span class="o">+</span><span class="s1">&#39; Nant=&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nAnt</span><span class="p">)</span>
                        <span class="o">+</span><span class="s1">&#39; Nscan=&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;scans&#39;</span><span class="p">])),</span>
                        <span class="p">{</span>
                            <span class="s1">&#39;horizontalalignment&#39;</span><span class="p">:</span> <span class="s1">&#39;left&#39;</span><span class="p">,</span> 
                            <span class="s1">&#39;fontsize&#39;</span><span class="p">:</span> <span class="s1">&#39;medium&#39;</span><span class="p">,</span>
                            <span class="s1">&#39;verticalalignment&#39;</span><span class="p">:</span> <span class="s1">&#39;bottom&#39;</span>
                            <span class="p">}</span>
                        <span class="p">)</span>

            <span class="n">k</span><span class="o">+=</span><span class="mi">1</span>
            <span class="n">F</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;rNmax&#39;</span><span class="p">][:,:,</span><span class="n">ispw</span><span class="p">,:]</span><span class="o">-</span><span class="mf">1.0</span>
            <span class="n">Ferr</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;rNmdev&#39;</span><span class="p">][:,:,</span><span class="n">ispw</span><span class="p">,:]</span>
            <span class="n">Fmax</span><span class="o">=</span><span class="n">F</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">*</span><span class="mf">1.15</span>
            <span class="n">Fmax</span><span class="o">=</span><span class="nb">max</span><span class="p">(</span><span class="mf">0.01</span><span class="p">,</span><span class="n">Fmax</span><span class="p">)</span>
            
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sh</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sh</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">scans</span><span class="p">,</span><span class="n">F</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">,:],</span><span class="s1">&#39;-&#39;</span><span class="p">)</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">scans</span><span class="p">,</span><span class="n">F</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">,:],</span><span class="s1">&#39;k.&#39;</span><span class="p">)</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">scans</span><span class="p">,</span><span class="n">Ferr</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">,:],</span><span class="s1">&#39;:&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">([</span><span class="n">loscan</span><span class="p">,</span><span class="n">hiscan</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="n">Fmax</span><span class="p">])</span>
            
            <span class="n">plt</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">loscan</span><span class="o">+</span><span class="mf">0.25</span><span class="p">,</span><span class="mf">0.9</span><span class="o">*</span><span class="n">Fmax</span><span class="p">,</span><span class="s1">&#39;Spw=&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">spw</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">hardcopy</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="s1">&#39;RN_plots&#39;</span><span class="p">):</span>
                <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="s1">&#39;RN_plots&#39;</span><span class="p">)</span>
            <span class="n">fname</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">msname</span><span class="o">+</span><span class="s1">&#39;_ReNormAmpVsScan.png&#39;</span>
            <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;Saving hardcopy plot: &#39;</span><span class="o">+</span><span class="n">fname</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;./RN_plots/&#39;</span><span class="o">+</span><span class="n">fname</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

    <span class="c1"># George&#39;s default code </span>
    <span class="c1">#</span>
    <span class="c1"># Won&#39;t work with 1 correlation</span>
    <span class="k">def</span> <span class="nf">plotSpwStats</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">hardcopy</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;Please run renormalize before plotting!&#39;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ioff</span><span class="p">()</span>
        <span class="n">pfig</span><span class="o">=</span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="mi">13</span><span class="p">,</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">14</span><span class="p">,</span><span class="mi">9</span><span class="p">))</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ioff</span><span class="p">()</span>
        <span class="n">pfig</span><span class="o">.</span><span class="n">clf</span><span class="p">()</span>

        <span class="n">sh</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;rNmax&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>

        <span class="n">spws</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;spws&#39;</span><span class="p">])</span>
        <span class="n">lospw</span><span class="o">=</span><span class="n">spws</span><span class="o">.</span><span class="n">min</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span>
        <span class="n">hispw</span><span class="o">=</span><span class="n">spws</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">+</span><span class="mi">1</span>

        <span class="n">F</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;rNmax&#39;</span><span class="p">],</span><span class="mi">3</span><span class="p">)</span><span class="o">-</span><span class="mf">1.0</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">clf</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sh</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">spws</span><span class="o">-</span><span class="mf">0.05</span><span class="p">,</span><span class="n">F</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">i</span><span class="p">,:],</span><span class="s1">&#39;r.&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">spws</span><span class="o">+</span><span class="mf">0.05</span><span class="p">,</span><span class="n">F</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="p">,:],</span><span class="s1">&#39;b.&#39;</span><span class="p">)</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">([</span><span class="n">lospw</span><span class="p">,</span><span class="n">hispw</span><span class="p">]</span><span class="o">+</span><span class="nb">list</span><span class="p">(</span><span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">()[</span><span class="mi">2</span><span class="p">:]))</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Spw Id&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Scan-mean Peak frac renorm scale&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">msname</span>
                <span class="o">+</span> <span class="s1">&#39; Nant=&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nAnt</span><span class="p">)</span>
                <span class="o">+</span> <span class="s1">&#39; &lt;Nscan=&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;scans&#39;</span><span class="p">]))</span><span class="o">+</span><span class="s1">&#39;&gt;&#39;</span><span class="p">,</span>
                <span class="p">{</span>
                    <span class="s1">&#39;horizontalalignment&#39;</span><span class="p">:</span> <span class="s1">&#39;center&#39;</span><span class="p">,</span> 
                    <span class="s1">&#39;fontsize&#39;</span><span class="p">:</span> <span class="s1">&#39;medium&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;verticalalignment&#39;</span><span class="p">:</span> <span class="s1">&#39;bottom&#39;</span>
                    <span class="p">}</span>
                <span class="p">)</span>
       
        <span class="k">if</span> <span class="n">hardcopy</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="s1">&#39;RN_plots&#39;</span><span class="p">):</span>
                <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="s1">&#39;RN_plots&#39;</span><span class="p">)</span>
            <span class="n">fname</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">msname</span><span class="o">+</span><span class="s1">&#39;_ReNormAmpVsSpw.png&#39;</span>
            <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;Saving hardcopy plot: &#39;</span><span class="o">+</span><span class="n">fname</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;./RN_plots/&#39;</span><span class="o">+</span><span class="n">fname</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

    <span class="c1">## LM added field input</span>
    <span class="c1"># AL added XX only case</span>
    <span class="k">def</span> <span class="nf">applyReNorm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">scan</span><span class="p">,</span><span class="n">spw</span><span class="p">,</span><span class="n">field</span><span class="p">,</span><span class="n">rN</span><span class="p">,</span><span class="n">datacolumn</span><span class="o">=</span><span class="s1">&#39;CORRECTED_DATA&#39;</span><span class="p">):</span>

        <span class="p">(</span><span class="n">a1</span><span class="p">,</span><span class="n">a2</span><span class="p">,</span><span class="n">X</span><span class="p">)</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getXCdata</span><span class="p">(</span><span class="n">scan</span><span class="p">,</span><span class="n">spw</span><span class="p">,</span><span class="n">field</span><span class="p">,</span><span class="n">datacolumn</span><span class="p">)</span>

        <span class="p">(</span><span class="n">nCor</span><span class="p">,</span><span class="n">nCha</span><span class="p">,</span><span class="n">nRow</span><span class="p">)</span><span class="o">=</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">for</span> <span class="n">irow</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nRow</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">icor</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nCor</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">nCor</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">X</span><span class="p">[</span><span class="n">icor</span><span class="p">,:,</span><span class="n">irow</span><span class="p">]</span><span class="o">*=</span><span class="p">(</span><span class="n">rN</span><span class="p">[</span><span class="n">icor</span><span class="p">,:,</span><span class="n">a1</span><span class="p">[</span><span class="n">irow</span><span class="p">]]</span><span class="o">*</span><span class="n">rN</span><span class="p">[</span><span class="n">icor</span><span class="p">,:,</span><span class="n">a2</span><span class="p">[</span><span class="n">irow</span><span class="p">]])</span>
                <span class="k">elif</span> <span class="n">nCor</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
                    <span class="n">X</span><span class="p">[</span><span class="n">icor</span><span class="p">,:,</span><span class="n">irow</span><span class="p">]</span><span class="o">*=</span><span class="p">(</span><span class="n">rN</span><span class="p">[</span><span class="n">icor</span><span class="p">,:,</span><span class="n">a1</span><span class="p">[</span><span class="n">irow</span><span class="p">]]</span><span class="o">*</span><span class="n">rN</span><span class="p">[</span><span class="n">icor</span><span class="p">,:,</span><span class="n">a2</span><span class="p">[</span><span class="n">irow</span><span class="p">]])</span>
                <span class="k">elif</span> <span class="n">nCor</span><span class="o">==</span><span class="mi">4</span><span class="p">:</span>
                    <span class="n">X</span><span class="p">[</span><span class="n">icor</span><span class="p">,:,</span><span class="n">irow</span><span class="p">]</span><span class="o">*=</span><span class="p">(</span><span class="n">rN</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">icor</span><span class="o">/</span><span class="mi">2</span><span class="p">),:,</span><span class="n">a1</span><span class="p">[</span><span class="n">irow</span><span class="p">]]</span><span class="o">*</span><span class="n">rN</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">icor</span><span class="o">%</span><span class="mi">2</span><span class="p">),:,</span><span class="n">a2</span><span class="p">[</span><span class="n">irow</span><span class="p">]])</span>
                    
        <span class="bp">self</span><span class="o">.</span><span class="n">putXCdata</span><span class="p">(</span><span class="n">scan</span><span class="p">,</span><span class="n">spw</span><span class="p">,</span><span class="n">field</span><span class="p">,</span><span class="n">X</span><span class="p">,</span><span class="n">datacolumn</span><span class="p">)</span>

<div class="viewcode-block" id="ACreNorm.calcReNorm1">
<a class="viewcode-back" href="../../../_autosummary/pipeline.extern.almarenorm_pl2023.ACreNorm.html#pipeline.h.tasks.restoredata.restoredata.ACreNorm.calcReNorm1">[docs]</a>
    <span class="k">def</span> <span class="nf">calcReNorm1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">checkFit</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">doplot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">iden</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>   
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Purpose:</span>
<span class="sd">            Perform a simple polynomial fit to the renormalization scaling </span>
<span class="sd">            spectrum to remove any residual baseline ripples. Used within the</span>
<span class="sd">            renormalize method to fit a baseline to each segment of the full </span>
<span class="sd">            spectrum. </span>

<span class="sd">            Note that this operates directly on the input spectrum!</span>

<span class="sd">        Inputs:</span>
<span class="sd">            R : numpy.array</span>
<span class="sd">                Scaling spectrum for a specific scan, spw, field and pol.</span>

<span class="sd">            doplot : boolean : OPTIONAL</span>
<span class="sd">                If set to True, produce a plot showing the polynomial fits </span>
<span class="sd">                that have been applied to the data. </span>

<span class="sd">            iden : str : OPTIONAL</span>
<span class="sd">                An optional identifier to append to image names to make them</span>
<span class="sd">                unique, otherwise they will get written over. </span>

<span class="sd">        Outputs:</span>
<span class="sd">            None directly, but note that the input scaling spectrum will be </span>
<span class="sd">            adjusted directly.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># NB:  R will be adjust in place</span>

        <span class="n">nCha</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>

        <span class="n">x</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">nCha</span><span class="p">))</span><span class="o">*</span><span class="mf">1.0</span><span class="o">/</span><span class="n">nCha</span> <span class="o">-</span> <span class="mf">0.5</span>

        <span class="n">mask</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">R</span><span class="p">),</span><span class="nb">bool</span><span class="p">)</span>
        <span class="n">ylim</span><span class="o">=</span><span class="mf">0.0</span>

        <span class="k">if</span> <span class="n">doplot</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">ioff</span><span class="p">()</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">clf</span><span class="p">()</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>
        
        <span class="c1"># Find where ATM was masked</span>
        <span class="n">atm_masked</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">R</span><span class="o">==</span><span class="mf">1.0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        
        <span class="n">atm_mask</span> <span class="o">=</span> <span class="n">mask</span>
        <span class="n">atm_mask</span><span class="p">[</span><span class="n">atm_masked</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># initial &quot;fit&quot; - Ignoring atm regions</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="n">atm_mask</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;    WARN: No data left in segment after removing atm features.&#39;</span><span class="p">)</span>
            <span class="n">refit</span><span class="o">=</span><span class="kc">True</span>
            <span class="k">return</span> <span class="n">refit</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">f</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="n">atm_mask</span><span class="p">])])</span>


        <span class="k">for</span> <span class="n">ifit</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nfit</span><span class="p">):</span>

            <span class="n">R0</span><span class="o">=</span><span class="n">R</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

            <span class="c1"># ~flattened, zeroed spectrum</span>
            <span class="n">R0</span><span class="o">/=</span><span class="n">np</span><span class="o">.</span><span class="n">polyval</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="n">x</span><span class="p">)</span>
            <span class="n">R0</span><span class="o">-=</span><span class="mf">1.0</span>
                            
            <span class="c1"># thresh is half peak negative</span>
            <span class="c1">#thresh=abs(R0.min()/2.0)</span>

            <span class="c1"># thresh is 2x median deviation (~1.33 sigma) </span>
            <span class="c1"># need to ignore regions of the spectrum with atm features</span>
            <span class="n">thresh</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">R0</span><span class="p">[</span><span class="n">atm_mask</span><span class="p">]))</span><span class="o">*</span><span class="mf">2.0</span>
            
            <span class="c1"># mask outside thresh</span>
            <span class="n">mask</span><span class="p">[:]</span><span class="o">=</span><span class="kc">True</span>
            <span class="n">mask</span><span class="p">[</span><span class="n">R0</span><span class="o">&lt;-</span><span class="n">thresh</span><span class="p">]</span><span class="o">=</span><span class="kc">False</span>
            <span class="n">mask</span><span class="p">[</span><span class="n">R0</span><span class="o">&gt;</span><span class="n">thresh</span><span class="p">]</span><span class="o">=</span><span class="kc">False</span>
            
            <span class="c1"># This was meant to check for line forest like data but ultimately</span>
            <span class="c1"># just fails when there is an atm feature and noisy data</span>
            <span class="c1">#if checkFit:</span>
            <span class="c1">#    if sum(mask)/len(mask) &gt; 0.5:</span>
            <span class="c1">#        refit=False</span>
            <span class="c1">#    else:</span>
            <span class="c1">#        if verbose:</span>
            <span class="c1">#            casalog.post(&#39;    WARN: More than 50% of the selected data is masked in the fit.&#39;)</span>
            <span class="c1">#        refit=True</span>
            <span class="c1">#        # Exit here since we need to refit anyway, no sense in</span>
            <span class="c1">#        # wasting compute time. There&#39;s also a small chance that</span>
            <span class="c1">#        # the entire segment is masked from an atm feature.</span>
            <span class="c1">#        return refit</span>

            <span class="c1"># ignore ATM masked regions</span>
            <span class="n">mask</span><span class="p">[</span><span class="n">atm_masked</span><span class="p">]</span><span class="o">=</span><span class="kc">False</span>

            <span class="k">if</span> <span class="n">checkFit</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.1</span><span class="p">:</span>
                    <span class="n">refit</span><span class="o">=</span><span class="kc">False</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                        <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;    WARN: Less than 10</span><span class="si">% o</span><span class="s1">f the selected data is available &#39;</span> \
                                <span class="o">+</span><span class="s1">&#39;to fit likely due to atm and/or science line features.&#39;</span><span class="p">)</span>
                        <span class="n">refit</span><span class="o">=</span><span class="kc">True</span>
                        <span class="c1"># Exit here since we need to refit because there&#39;s </span>
                        <span class="c1"># almost no data left.</span>
                        <span class="k">return</span> <span class="n">refit</span>

            <span class="k">if</span> <span class="n">doplot</span><span class="p">:</span>
                <span class="n">med</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nfit</span><span class="p">,</span><span class="n">ifit</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">nCha</span><span class="p">),</span><span class="n">R</span><span class="p">,</span><span class="s1">&#39;b,&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Data&#39;</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">nCha</span><span class="p">))[</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">mask</span><span class="p">)],</span>
                        <span class="n">R</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">mask</span><span class="p">)],</span>
                        <span class="s1">&#39;r.&#39;</span><span class="p">,</span>
                        <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Masked&#39;</span>
                        <span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">nCha</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">polyval</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="n">x</span><span class="p">),</span><span class="s1">&#39;r-&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Initial/Last Fit&#39;</span><span class="p">)</span>
                <span class="c1">#plt.axis([-1,nCha,med-0.003,med+0.003])</span>
                            
                <span class="k">if</span> <span class="n">ylim</span><span class="o">==</span><span class="mf">0.0</span><span class="p">:</span>
                    <span class="n">ylim</span><span class="o">=</span><span class="mi">5</span><span class="o">*</span><span class="n">thresh</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nfit</span><span class="p">,</span><span class="n">ifit</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">nfit</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">nCha</span><span class="p">),</span><span class="n">R0</span><span class="p">,</span><span class="s1">&#39;b,&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Data after last fit&#39;</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">nCha</span><span class="p">],[</span><span class="o">-</span><span class="n">thresh</span><span class="p">,</span><span class="o">-</span><span class="n">thresh</span><span class="p">],</span><span class="s1">&#39;r:&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Threshold&#39;</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">nCha</span><span class="p">],[</span><span class="n">thresh</span><span class="p">,</span><span class="n">thresh</span><span class="p">],</span><span class="s1">&#39;r:&#39;</span><span class="p">)</span>
                <span class="c1">#plt.axis([-1,nCha,-ylim,ylim])</span>
                <span class="c1">#casalog.post(ifit-1, thresh, abs(R0.min()/2.0), np.sum(mask), f)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>

            <span class="c1"># fit to _R_ in masked spectra</span>
            <span class="n">f</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">polyfit</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">mask</span><span class="p">],</span><span class="n">R</span><span class="p">[</span><span class="n">mask</span><span class="p">],</span><span class="n">ifit</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="n">doplot</span><span class="p">:</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nfit</span><span class="p">,</span><span class="n">ifit</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">nCha</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">polyval</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="n">x</span><span class="p">),</span><span class="s1">&#39;g-&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;N=&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">ifit</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39; Fit&#39;</span><span class="p">)</span>
                <span class="c1">#casalog.post(ifit, f)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>

        <span class="n">R</span><span class="o">/=</span><span class="n">np</span><span class="o">.</span><span class="n">polyval</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="n">x</span><span class="p">)</span>

        <span class="c1"># reset ATM masked region</span>
        <span class="n">R</span><span class="p">[</span><span class="n">atm_masked</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>

        <span class="k">if</span> <span class="n">doplot</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nfit</span><span class="p">,</span><span class="n">ifit</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">nCha</span><span class="p">),</span><span class="n">R</span><span class="p">,</span><span class="s1">&#39;g-&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Final Data After Fitting&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span>
                    <span class="s1">&#39;./RN_plots/seg_fitting_results_&#39;</span><span class="o">+</span><span class="n">iden</span><span class="o">+</span><span class="s1">&#39;.png&#39;</span><span class="p">,</span> 
                    <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;png&#39;</span><span class="p">,</span> 
                    <span class="n">bbox_inches</span><span class="o">=</span><span class="s1">&#39;tight&#39;</span>
                    <span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        
        <span class="k">if</span> <span class="n">checkFit</span><span class="p">:</span>        
            <span class="k">return</span> <span class="n">refit</span></div>


<div class="viewcode-block" id="ACreNorm.calcRenormLegendre">
<a class="viewcode-back" href="../../../_autosummary/pipeline.extern.almarenorm_pl2023.ACreNorm.html#pipeline.h.tasks.restoredata.restoredata.ACreNorm.calcRenormLegendre">[docs]</a>
    <span class="k">def</span> <span class="nf">calcRenormLegendre</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">nseg</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Purpose:</span>
<span class="sd">            Perform a fit to the renormalization spectrum to flatten the </span>
<span class="sd">            profile and make it so that outside of spectral features the </span>
<span class="sd">            data is unchanged (i.e. multiplied by 1.0). Here, Legendre </span>
<span class="sd">            polynomials are used for the fitting process. </span>

<span class="sd">        Inputs:</span>
<span class="sd">            R : numpy.array</span>
<span class="sd">                This is the segment of renormalization spectrum you wish to </span>
<span class="sd">                perform a fit on.  </span>

<span class="sd">            nseg : integer</span>
<span class="sd">                This is the number of segments that calcChannelRanges() </span>
<span class="sd">                suggested. This function will decide on the order of the fit </span>
<span class="sd">                based on the number of segments and the self.nfit parameter </span>
<span class="sd">                as self.nfit*nseg.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># First we make a quick copy of the array. We are going to need to </span>
        <span class="c1"># ignore sections of the spectrum where actual spectral features exist </span>
        <span class="c1"># so we quickly operate on a copy but perform the fit on the actual </span>
        <span class="c1"># given array.</span>
        <span class="n">R0</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="c1"># Define x</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">R0</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">R0</span><span class="p">))</span>

        <span class="c1"># Legendre polynomials are bounded within [-1,1] so convert our x to </span>
        <span class="c1"># that space.</span>
        <span class="n">nx</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">/</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="c1"># An &quot;initial fit&quot; to our array copy just to somewhat flatten it and  </span>
        <span class="c1"># move everything to around 0.0.</span>
        <span class="n">ifit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">R0</span><span class="p">)])</span>
        <span class="n">R0</span> <span class="o">=</span> <span class="n">R0</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">polyval</span><span class="p">(</span><span class="n">ifit</span><span class="p">,</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="mf">1.0</span>
        
        <span class="c1"># Now find where there are spectral features and create a mask on them.</span>
        <span class="n">thresh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">R0</span><span class="p">))</span> <span class="o">*</span> <span class="mf">3.0</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">R</span><span class="p">),</span> <span class="nb">bool</span><span class="p">)</span>
        <span class="n">mask</span><span class="p">[:]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">mask</span><span class="p">[</span><span class="n">R0</span> <span class="o">&lt;-</span> <span class="n">thresh</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">mask</span><span class="p">[</span><span class="n">R0</span> <span class="o">&gt;</span> <span class="n">thresh</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Perform the least-squares fit to everywhere else in the real </span>
        <span class="c1"># given array</span>
        <span class="n">coeffs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polynomial</span><span class="o">.</span><span class="n">legendre</span><span class="o">.</span><span class="n">legfit</span><span class="p">(</span>
                                            <span class="n">nx</span><span class="p">[</span><span class="n">mask</span><span class="p">],</span> 
                                            <span class="n">R</span><span class="p">[</span><span class="n">mask</span><span class="p">],</span>
                                            <span class="bp">self</span><span class="o">.</span><span class="n">nfit</span><span class="o">*</span><span class="n">nseg</span>
                                            <span class="p">)</span>

        <span class="c1"># Evaluate the amplitudes from out fit.</span>
        <span class="n">fit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polynomial</span><span class="o">.</span><span class="n">legendre</span><span class="o">.</span><span class="n">legval</span><span class="p">(</span>
                                            <span class="n">nx</span><span class="p">,</span>
                                            <span class="n">coeffs</span>
                                            <span class="p">)</span>

        <span class="c1"># Apply the fit to our data.</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">R</span><span class="o">/</span><span class="n">fit</span>
        <span class="k">return</span> <span class="n">R</span></div>



<div class="viewcode-block" id="ACreNorm.checkOutlierAnt">
<a class="viewcode-back" href="../../../_autosummary/pipeline.extern.almarenorm_pl2023.ACreNorm.html#pipeline.h.tasks.restoredata.restoredata.ACreNorm.checkOutlierAnt">[docs]</a>
    <span class="k">def</span> <span class="nf">checkOutlierAnt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">R</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Purpose:</span>
<span class="sd">            Perform a check of each antenna in a renormalization spectrum</span>
<span class="sd">            dictionary and return a list of possibly problematic antenna</span>
<span class="sd">            that may need flagging due to outlier data (e.g. from birdies).</span>

<span class="sd">        Inputs:</span>
<span class="sd">            R : dictionary</span>
<span class="sd">               The renormalization spectrum as created by the renormalize()</span>
<span class="sd">                method.</span>

<span class="sd">        Outputs:</span>
<span class="sd">            AntChk : list of strings</span>
<span class="sd">                A list of antennas that may contain problematic data which </span>
<span class="sd">                can be used as input for the calcFixReNorm method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">AntChk</span><span class="o">=</span><span class="p">[]</span>

        <span class="c1"># Median spectra for each pol. In principle all ants should be the </span>
        <span class="c1"># same per field. Need to be careful to avoid an issue if there are </span>
        <span class="c1"># too many 1.0&#39;s from flagged data - median ends up being 1.0! </span>
        <span class="c1"># Exclude channels that equal 1.0 for taking the median and then </span>
        <span class="c1"># replace them after the calculation so we don&#39;t have to deal with NaN.</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmedian</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">R</span><span class="o">!=</span><span class="mi">1</span><span class="p">,</span><span class="n">R</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">),</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">M</span><span class="p">[:][</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">M</span><span class="p">[:])]</span><span class="o">=</span><span class="mf">1.0</span> 

        <span class="c1"># Median in channel axis. Left with MAD per corr per ant, </span>
        <span class="c1"># then median of all</span>
        <span class="n">medMAD</span> <span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">R</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">),</span><span class="mi">1</span><span class="p">))</span>

        <span class="c1"># Mean max value per pol - as above</span>
        <span class="n">Rmax</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">R</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Values &lt;0.25% are trivial</span>
        <span class="n">thresh</span> <span class="o">=</span> <span class="mf">1.0025</span>  

        <span class="c1"># TBD some bad ants have &gt;1.025</span>
        <span class="k">for</span> <span class="n">jcor</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">R</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="c1"># set thresh to avoid a line free spectrum defining </span>
            <span class="c1"># &#39;noise&#39; as differences</span>
            <span class="n">RmaxT</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">Rmax</span><span class="p">[</span><span class="n">jcor</span><span class="p">]</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">0.0025</span><span class="p">)</span>

            <span class="c1"># first review the median for birdies (same as the calcFixReNorm),</span>
            <span class="c1"># pass over a range and check for huge spikes</span>
            <span class="k">for</span> <span class="n">nch</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="n">M</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">10</span><span class="p">):</span> 
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="n">jcor</span><span class="p">,</span><span class="n">nch</span><span class="o">-</span><span class="mi">2</span><span class="p">:</span><span class="n">nch</span><span class="o">+</span><span class="mi">3</span><span class="p">])</span><span class="o">-</span><span class="n">M</span><span class="p">[</span><span class="n">jcor</span><span class="p">,</span><span class="n">nch</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">RmaxT</span><span class="p">:</span>
                    <span class="n">M</span><span class="p">[</span><span class="n">jcor</span><span class="p">,</span><span class="n">nch</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="n">jcor</span><span class="p">,</span><span class="n">nch</span><span class="o">-</span><span class="mi">2</span><span class="p">:</span><span class="n">nch</span><span class="o">+</span><span class="mi">3</span><span class="p">])</span>

            <span class="k">for</span> <span class="n">jant</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">R</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]):</span>
                <span class="n">Rcomp</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">((</span><span class="n">R</span><span class="p">[</span><span class="n">jcor</span><span class="p">,:,</span><span class="n">jant</span><span class="p">]</span><span class="o">/</span><span class="n">M</span><span class="p">[</span><span class="n">jcor</span><span class="p">,:])</span><span class="o">-</span><span class="mf">1.0</span><span class="p">)</span>

                <span class="c1"># now check if any channel triggers a real outlier - do not assess </span>
                <span class="c1"># per channel here just store to the outlier ant list for detailed </span>
                <span class="c1"># investigation later</span>
                <span class="k">if</span> <span class="n">Rcomp</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">thresh</span> <span class="ow">and</span> <span class="n">jant</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">AntChk</span><span class="p">:</span>
                    <span class="n">AntChk</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">jant</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">AntChk</span></div>


<div class="viewcode-block" id="ACreNorm.calcFixReNorm">
<a class="viewcode-back" href="../../../_autosummary/pipeline.extern.almarenorm_pl2023.ACreNorm.html#pipeline.h.tasks.restoredata.restoredata.ACreNorm.calcFixReNorm">[docs]</a>
    <span class="k">def</span> <span class="nf">calcFixReNorm</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">R</span><span class="p">,</span>
            <span class="n">AntUse</span><span class="p">,</span>
            <span class="n">scanin</span><span class="p">,</span> 
            <span class="n">spwin</span><span class="p">,</span>
            <span class="n">fldin</span><span class="p">,</span>
            <span class="n">doplot</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> 
            <span class="n">plotDivisions</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> 
            <span class="n">hardcopy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span>
            <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Purpose:</span>
<span class="sd">            This function takes in a renormalization spectrum and performs a </span>
<span class="sd">            set of heuristics to check for outliers caused by issues with the</span>
<span class="sd">            autocorrelations (e.g. birdies). Outlier channels are replaced with</span>
<span class="sd">            the median spectrum. If many channels are found to be outliers </span>
<span class="sd">            (greater than 10 consecutive channels or &gt;10% of total spectrum), </span>
<span class="sd">            then the whole median spectrum of that correlation is used for the </span>
<span class="sd">            replacement instead. </span>

<span class="sd">            Note that this operates on the input renormalization spectrum </span>
<span class="sd">            directly! Therefore the input spectrum will be directly adjusted.</span>

<span class="sd">        Inputs:</span>
<span class="sd">            R : dictionary</span>
<span class="sd">                The renormalization spectrum as created by the renormalize()</span>
<span class="sd">                method.</span>

<span class="sd">            AntUse : list of strings</span>
<span class="sd">                This is a list of antennas to investigate for outliers. The</span>
<span class="sd">                checkOutlierAnt method will return an appropriate list to</span>
<span class="sd">                be used as input here.</span>

<span class="sd">            scanin : string</span>
<span class="sd">                The scan number to check.</span>

<span class="sd">            spwin : string</span>
<span class="sd">                The spw number to check.</span>

<span class="sd">            fldin : string</span>
<span class="sd">                The field number to check.</span>

<span class="sd">            doplot : boolean : OPTIONAL</span>
<span class="sd">                If set to True, produce plots that show original spectrum</span>
<span class="sd">                and replaced values. </span>
<span class="sd">                Default: True</span>

<span class="sd">            plotDivisions : boolean : OPTIONAL</span>
<span class="sd">                If set to True, then include vertical lines of the plots that</span>
<span class="sd">                show where the spectrum was divided up during the fitting </span>
<span class="sd">                process of the calcReNorm1 method.</span>
<span class="sd">                Default: True</span>

<span class="sd">            hardcopy : boolean : OPTIONAL</span>
<span class="sd">                If set to True, save a hardcopy of the produced plot to disk.</span>
<span class="sd">                Default: True</span>

<span class="sd">            verbose : boolean : OPTIONAL</span>
<span class="sd">                If set to True, produce additional output.</span>
<span class="sd">                Default: False</span>

<span class="sd">        Outputs:</span>
<span class="sd">            The input renormalization spectrum, R, is operated on directly.</span>
<span class="sd">            No additional output is generated.</span>

<span class="sd">        Notes for Improvement: </span>
<span class="sd">            If AntUse is not defined, could default to running checkOutlierAnt</span>
<span class="sd">            method by default.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Median spectra for each pol - in principle all ants should be the </span>
        <span class="c1"># same per field. However, there can be a problem if there are too </span>
        <span class="c1"># many 1.0&#39;s from flagged data because median ends up being 1.0. For</span>
        <span class="c1"># excluded chan ranges which are &#39;nan&#39; need to set back to 1.0, </span>
        <span class="c1"># otherwise median has nan values and rest of stats max, min, etc </span>
        <span class="c1"># do not deal with it.</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmedian</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">R</span><span class="o">!=</span><span class="mi">1</span><span class="p">,</span><span class="n">R</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">),</span><span class="mi">2</span><span class="p">)</span>  
        <span class="n">M</span><span class="p">[:][</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">M</span><span class="p">[:])]</span><span class="o">=</span><span class="mf">1.0</span> 
        <span class="n">Mabs</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">M</span><span class="o">-</span><span class="mf">1.0</span><span class="p">)</span>

        <span class="c1"># mean max value per pol - as above</span>
        <span class="n">Rmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">R</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="mi">1</span><span class="p">)</span> 
        <span class="n">Rmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">R</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Median in channel axis. Left with MAD per corr per ant, </span>
        <span class="c1"># then median of all</span>
        <span class="n">medMAD</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">R</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">),</span><span class="mi">1</span><span class="p">))</span>  

        <span class="c1"># Scales of this magnitude are negligable </span>
        <span class="n">thresh</span> <span class="o">=</span> <span class="mf">1.0025</span> 

        <span class="k">if</span> <span class="n">doplot</span><span class="p">:</span>
            <span class="c1"># Make a copy for plotting</span>
            <span class="n">Rorig</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> 

        <span class="c1"># Assuming 2 corr/pols but this doesn&#39;t hurt single pol or full pol</span>
        <span class="n">lineOut</span><span class="o">=</span><span class="p">[[],[]]</span>
        <span class="n">plttxt</span><span class="o">=</span><span class="p">[[],[]]</span>
        <span class="n">corPrt</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;XX&#39;</span><span class="p">,</span><span class="s1">&#39;YY&#39;</span><span class="p">]</span>
        
        <span class="c1"># This repeats the median spectrum making and checking actively - fast </span>
        <span class="c1"># so just copied as from cehckOutlierAnt code </span>
        <span class="k">for</span> <span class="n">jcor</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">R</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>

            <span class="n">RmaxT</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">Rmax</span><span class="p">[</span><span class="n">jcor</span><span class="p">]</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">0.0025</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">nch</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="n">M</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">10</span><span class="p">):</span> 
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="n">jcor</span><span class="p">,</span><span class="n">nch</span><span class="o">-</span><span class="mi">2</span><span class="p">:</span><span class="n">nch</span><span class="o">+</span><span class="mi">3</span><span class="p">])</span><span class="o">-</span><span class="n">M</span><span class="p">[</span><span class="n">jcor</span><span class="p">,</span><span class="n">nch</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">RmaxT</span><span class="p">:</span>
                    <span class="n">M</span><span class="p">[</span><span class="n">jcor</span><span class="p">,</span><span class="n">nch</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="n">jcor</span><span class="p">,</span><span class="n">nch</span><span class="o">-</span><span class="mi">2</span><span class="p">:</span><span class="n">nch</span><span class="o">+</span><span class="mi">3</span><span class="p">])</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">birdiechan</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">spwin</span><span class="p">)]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                            <span class="s1">&#39;chan&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">nch</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;_scan&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">scanin</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;_field&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">fldin</span><span class="p">)</span>
                            <span class="p">)</span>

        <span class="c1"># setup threshold, for the read in spw, scan, field</span>
        <span class="n">thresharr</span><span class="o">=</span><span class="n">M</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># Now we set to a max value of either thresh or the median array max taken over 10 </span>
        <span class="c1"># channels assesses +/- 5 chans max values in median spec and then compares with </span>
        <span class="c1"># thresh and attributes to the max over +/- 5 assessed over the same 5 channels if </span>
        <span class="c1"># over thresh acts as the buffer the not miss -ve in absorbtion features (black-</span>
        <span class="c1"># dashed in plot) set to +/- 10 now due to abs/emm CO lines in ALMA-IMF data </span>
        <span class="k">for</span> <span class="n">jcor</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">R</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span> 
            <span class="n">thresharr</span><span class="p">[</span><span class="n">jcor</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="mi">10</span><span class="p">][</span><span class="n">thresharr</span><span class="p">[</span><span class="n">jcor</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="mi">10</span><span class="p">]</span><span class="o">&lt;</span><span class="n">thresh</span><span class="p">]</span><span class="o">=</span><span class="n">thresh</span> <span class="c1"># set ends</span>
            <span class="n">thresharr</span><span class="p">[</span><span class="n">jcor</span><span class="p">,</span><span class="o">-</span><span class="mi">10</span><span class="p">:][</span><span class="n">thresharr</span><span class="p">[</span><span class="n">jcor</span><span class="p">,</span><span class="o">-</span><span class="mi">10</span><span class="p">:]</span><span class="o">&lt;</span><span class="n">thresh</span><span class="p">]</span><span class="o">=</span><span class="n">thresh</span> <span class="c1"># set ends</span>
            <span class="n">thresharr</span><span class="p">[</span><span class="n">jcor</span><span class="p">,</span><span class="mi">10</span><span class="p">:</span><span class="o">-</span><span class="mi">10</span><span class="p">]</span><span class="o">=</span><span class="p">[</span>
                    <span class="n">thresh</span> 
                    <span class="k">if</span> <span class="n">thresharr</span><span class="p">[</span><span class="n">jcor</span><span class="p">,</span><span class="n">nch</span><span class="o">-</span><span class="mi">10</span><span class="p">:</span><span class="n">nch</span><span class="o">+</span><span class="mi">10</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">thresh</span> 
                    <span class="k">else</span> <span class="n">thresharr</span><span class="p">[</span><span class="n">jcor</span><span class="p">,</span><span class="n">nch</span><span class="o">-</span><span class="mi">10</span><span class="p">:</span><span class="n">nch</span><span class="o">+</span><span class="mi">10</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> 
                    <span class="k">for</span> <span class="n">nch</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="n">M</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">10</span><span class="p">)</span>
                    <span class="p">]</span>

           
        <span class="c1"># loops ants that triggered in outlier list</span>
        <span class="k">for</span> <span class="n">jant</span> <span class="ow">in</span> <span class="n">AntUse</span><span class="p">:</span>

            <span class="c1"># append to known dict if not there already</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">AntName</span><span class="p">[</span><span class="n">jant</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">AntOut</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">spwin</span><span class="p">)]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span> 
                <span class="bp">self</span><span class="o">.</span><span class="n">AntOut</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">spwin</span><span class="p">)][</span><span class="bp">self</span><span class="o">.</span><span class="n">AntName</span><span class="p">[</span><span class="n">jant</span><span class="p">]]</span><span class="o">=</span><span class="p">{}</span>
                
            <span class="c1"># for later logic of action if required</span>
            <span class="n">replaceCorr</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span> <span class="k">for</span> <span class="n">iCor</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_corrs</span><span class="p">)]</span>
            
            <span class="k">for</span> <span class="n">jcor</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">R</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>  

                <span class="n">Rcomp</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">((</span><span class="n">R</span><span class="p">[</span><span class="n">jcor</span><span class="p">,:,</span><span class="n">jant</span><span class="p">]</span><span class="o">/</span><span class="n">M</span><span class="p">[</span><span class="n">jcor</span><span class="p">,:])</span><span class="o">-</span><span class="mf">1.0</span><span class="p">)</span>
                <span class="c1"># make channel based assessment and reset to specific channel value in median </span>
                <span class="c1"># spectrum (default operation) but as we replace we store how many channels </span>
                <span class="c1"># are replaced for later logic</span>
                <span class="n">R</span><span class="p">[</span><span class="n">jcor</span><span class="p">,:,</span><span class="n">jant</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
                        <span class="n">M</span><span class="p">[</span><span class="n">jcor</span><span class="p">][</span><span class="n">nch</span><span class="p">]</span> 
                        <span class="k">if</span> <span class="n">Rcomp</span><span class="p">[</span><span class="n">nch</span><span class="p">]</span><span class="o">&gt;</span><span class="n">thresharr</span><span class="p">[</span><span class="n">jcor</span><span class="p">][</span><span class="n">nch</span><span class="p">]</span> 
                        <span class="k">else</span> <span class="n">R</span><span class="p">[</span><span class="n">jcor</span><span class="p">,:,</span><span class="n">jant</span><span class="p">][</span><span class="n">nch</span><span class="p">]</span> 
                        <span class="k">for</span> <span class="n">nch</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                        <span class="p">]</span>
                <span class="n">lineOut</span><span class="p">[</span><span class="n">jcor</span><span class="p">]</span><span class="o">=</span><span class="p">[</span>
                        <span class="n">spl</span> 
                        <span class="k">for</span> <span class="n">spl</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> 
                        <span class="k">if</span> <span class="n">Rcomp</span><span class="p">[</span><span class="n">spl</span><span class="p">]</span><span class="o">&gt;</span><span class="n">thresharr</span><span class="p">[</span><span class="n">jcor</span><span class="p">][</span><span class="n">spl</span><span class="p">]</span>
                        <span class="p">]</span>

                <span class="c1"># store a print statement for plot - can be later overwritten</span>
                <span class="n">plttxt</span><span class="p">[</span><span class="n">jcor</span><span class="p">]</span><span class="o">=</span><span class="s1">&#39; **** Replace flagged channels with that from median spectrum **** &#39;</span> 
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lineOut</span><span class="p">[</span><span class="n">jcor</span><span class="p">])</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                        <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">Outlier antenna identified &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">AntName</span><span class="p">[</span><span class="n">jant</span><span class="p">])</span> \
                                <span class="o">+</span><span class="s1">&#39; &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">corPrt</span><span class="p">[</span><span class="n">jcor</span><span class="p">])</span><span class="o">+</span><span class="s1">&#39; will repair outlier channels&#39;</span><span class="p">)</span>

                    <span class="c1"># open the list for outlier channels if not already existing (fill below)</span>
                    <span class="k">if</span> <span class="n">corPrt</span><span class="p">[</span><span class="n">jcor</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">AntOut</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">spwin</span><span class="p">)][</span><span class="bp">self</span><span class="o">.</span><span class="n">AntName</span><span class="p">[</span><span class="n">jant</span><span class="p">]]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span> 
                        <span class="bp">self</span><span class="o">.</span><span class="n">AntOut</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">spwin</span><span class="p">)][</span><span class="bp">self</span><span class="o">.</span><span class="n">AntName</span><span class="p">[</span><span class="n">jant</span><span class="p">]][</span><span class="n">corPrt</span><span class="p">[</span><span class="n">jcor</span><span class="p">]]</span><span class="o">=</span><span class="p">[]</span>
                    
                    <span class="c1"># also want to know the maximum consecutive channels </span>
                    <span class="n">maxConseq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calcMaxConseq</span><span class="p">(</span><span class="n">lineOut</span><span class="p">[</span><span class="n">jcor</span><span class="p">])</span>

                    <span class="c1"># if there are more than 10 consecutive lines replace with median spectrum</span>
                    <span class="k">if</span> <span class="n">maxConseq</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">:</span> 
                        <span class="n">replaceCorr</span><span class="p">[</span><span class="n">jcor</span><span class="p">]</span><span class="o">=</span><span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># There were no triggered lines, maybe only one pol was </span>
                    <span class="c1"># bad - don&#39;t assess any further. It triggered the </span>
                    <span class="c1"># outlierAnt but this pol wasn&#39;t bad</span>
                    <span class="k">continue</span> 
        
                <span class="c1"># If we find a lot of outlier channels, or the consecutive </span>
                <span class="c1"># amount of bad channels is triggered, we work out what action </span>
                <span class="c1"># to take - 10% of SPW must be bad in total - this is a hard </span>
                <span class="c1"># coded choice </span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lineOut</span><span class="p">[</span><span class="n">jcor</span><span class="p">])</span><span class="o">&gt;</span><span class="mf">0.1</span><span class="o">*</span><span class="n">M</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">or</span> <span class="n">replaceCorr</span><span class="p">[</span><span class="n">jcor</span><span class="p">]:</span>
                    <span class="n">R</span><span class="p">[</span><span class="n">jcor</span><span class="p">,:,</span><span class="n">jant</span><span class="p">]</span><span class="o">=</span><span class="n">M</span><span class="p">[</span><span class="n">jcor</span><span class="p">]</span>
                    <span class="n">plttxt</span><span class="p">[</span><span class="n">jcor</span><span class="p">]</span><span class="o">=</span><span class="s1">&#39; **** Replaced &#39;</span><span class="o">+</span><span class="n">corPrt</span><span class="p">[</span><span class="n">jcor</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39; spectrum with median &#39;</span> \
                            <span class="o">+</span><span class="n">corPrt</span><span class="p">[</span><span class="n">jcor</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39; spectrum **** &#39;</span>

                <span class="c1"># Only plot those where some replacement of the spectrum was needed</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lineOut</span><span class="p">[</span><span class="n">jcor</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mi">10</span> \
                        <span class="ow">and</span> <span class="nb">set</span><span class="p">(</span>
                                <span class="n">lineOut</span><span class="p">[</span><span class="n">jcor</span><span class="p">]</span>
                                <span class="p">)</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">AntOut</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">spwin</span><span class="p">)][</span><span class="bp">self</span><span class="o">.</span><span class="n">AntName</span><span class="p">[</span><span class="n">jant</span><span class="p">]][</span><span class="n">corPrt</span><span class="p">[</span><span class="n">jcor</span><span class="p">]]</span>
                                        <span class="p">):</span>
                    <span class="c1"># usually plot the per spw, per scan, per field correction made, but if that </span>
                    <span class="c1"># ant was shown already, don&#39;t repeat i.e. known as problematic don&#39;t really </span>
                    <span class="c1"># need to show the same channel &#39;fix&#39; for all scans/fields</span>
                    <span class="k">if</span> <span class="n">hardcopy</span> <span class="ow">and</span> <span class="n">doplot</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                            <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">Not saving hardcopy - &#39;</span> \
                                    <span class="o">+</span> <span class="s1">&#39;channels already identified for this antenna&#39;</span><span class="p">)</span>
                    <span class="k">continue</span>                  
                <span class="k">elif</span> <span class="n">maxConseq</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">hardcopy</span> <span class="ow">and</span> <span class="n">doplot</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                            <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">Not saving hardcopy - &#39;</span> \
                                    <span class="o">+</span><span class="s1">&#39;less than 10 conseq channels adjusted - &#39;</span> \
                                    <span class="o">+</span><span class="s1">&#39;only birdies outliers&#39;</span><span class="p">)</span>
                    <span class="k">continue</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># extend the list to add known channels now and follow to the plots</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">AntOut</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">spwin</span><span class="p">)][</span><span class="bp">self</span><span class="o">.</span><span class="n">AntName</span><span class="p">[</span><span class="n">jant</span><span class="p">]][</span><span class="n">corPrt</span><span class="p">[</span><span class="n">jcor</span><span class="p">]]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                            <span class="p">[</span>
                                <span class="n">lineO</span> 
                                <span class="k">for</span> <span class="n">lineO</span> <span class="ow">in</span> <span class="n">lineOut</span><span class="p">[</span><span class="n">jcor</span><span class="p">]</span> 
                                <span class="k">if</span> <span class="n">lineO</span> <span class="ow">not</span> <span class="ow">in</span> \
                                        <span class="bp">self</span><span class="o">.</span><span class="n">AntOut</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">spwin</span><span class="p">)][</span><span class="bp">self</span><span class="o">.</span><span class="n">AntName</span><span class="p">[</span><span class="n">jant</span><span class="p">]][</span><span class="n">corPrt</span><span class="p">[</span><span class="n">jcor</span><span class="p">]]</span>
                                <span class="p">]</span>
                            <span class="p">)</span>
                    
                <span class="c1"># These are the heuristics diagnostic plots to be used for </span>
                <span class="c1"># checking the heuristics logic to see what was occuring. This</span>
                <span class="c1"># can make 100+ plots, so if heursitics are trusted they don&#39;t </span>
                <span class="c1"># really need investigation and are mostly for testing and </span>
                <span class="c1"># deep dives later if needed.</span>
                <span class="k">if</span> <span class="n">doplot</span><span class="p">:</span>
                    <span class="c1"># Initialize figure and clear buffer</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">ioff</span><span class="p">()</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">clf</span><span class="p">()</span>
                    <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">8</span><span class="p">))</span>
                    <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">,</span><span class="n">frame_on</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

                    <span class="c1"># Plot the original renorm spectrum, the comparison median spectrum, </span>
                    <span class="c1"># the adjusted spectra, and the threshold.</span>
                    <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">Rorig</span><span class="p">[</span><span class="n">jcor</span><span class="p">,:,</span><span class="n">jant</span><span class="p">],</span><span class="n">c</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span><span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Orig. Spec.&#39;</span><span class="p">)</span> 
                    <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">Rcomp</span><span class="p">,</span><span class="n">c</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="n">label</span><span class="o">=</span><span class="s1">&#39;Divided (comp) spec.&#39;</span><span class="p">,</span><span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
                    <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="n">jcor</span><span class="p">],</span><span class="n">c</span><span class="o">=</span><span class="s1">&#39;g&#39;</span><span class="p">,</span><span class="n">linewidth</span><span class="o">=</span><span class="s1">&#39;2&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Median Spec.&#39;</span><span class="p">)</span>
                    <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="n">jcor</span><span class="p">,:,</span><span class="n">jant</span><span class="p">],</span><span class="n">c</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span><span class="n">label</span><span class="o">=</span><span class="s1">&#39;New Spec.&#39;</span><span class="p">)</span> 
                    <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
                            <span class="n">thresharr</span><span class="p">[</span><span class="n">jcor</span><span class="p">],</span>
                            <span class="n">c</span><span class="o">=</span><span class="s1">&#39;0.5&#39;</span><span class="p">,</span>
                            <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
                            <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">,</span>
                            <span class="n">linewidth</span><span class="o">=</span><span class="s1">&#39;3&#39;</span><span class="p">,</span>
                            <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Threshold&#39;</span>
                            <span class="p">)</span>
                    
                    <span class="c1"># Plot any birdies/outliers that have been found</span>
                    <span class="k">for</span> <span class="n">lineP</span> <span class="ow">in</span> <span class="n">lineOut</span><span class="p">[</span><span class="n">jcor</span><span class="p">]:</span>
                        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">lineP</span><span class="p">,</span><span class="mf">0.999</span><span class="p">,</span><span class="n">c</span><span class="o">=</span><span class="s1">&#39;y&#39;</span><span class="p">,</span><span class="n">marker</span><span class="o">=</span><span class="s1">&#39;s&#39;</span><span class="p">)</span>
                    <span class="c1"># to get the single label</span>
                    <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">lineOut</span><span class="p">[</span><span class="n">jcor</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="mf">0.999</span><span class="p">,</span><span class="n">c</span><span class="o">=</span><span class="s1">&#39;y&#39;</span><span class="p">,</span><span class="n">marker</span><span class="o">=</span><span class="s1">&#39;s&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Outlier Chns.&#39;</span><span class="p">)</span>

                    <span class="c1"># Find the data edges to set plot size</span>
                    <span class="n">pltmin</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                            <span class="p">[</span><span class="n">R</span><span class="p">[</span><span class="n">jcor</span><span class="p">,:,</span><span class="n">jant</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="mf">0.9977</span><span class="p">,</span><span class="n">Rorig</span><span class="p">[</span><span class="n">jcor</span><span class="p">,:,</span><span class="n">jant</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="mi">0</span><span class="p">)]</span>
                            <span class="p">)</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">Pmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                            <span class="p">[</span><span class="n">R</span><span class="p">[</span><span class="n">jcor</span><span class="p">,:,</span><span class="n">jant</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="mf">1.015</span><span class="p">,</span><span class="n">Rcomp</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="n">thresharr</span><span class="p">[</span><span class="n">jcor</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="mi">0</span><span class="p">)]</span>
                            <span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">pltmax</span><span class="o">=</span> <span class="mf">1.</span><span class="o">+</span><span class="p">(</span><span class="n">Pmax</span><span class="o">-</span><span class="mf">1.</span><span class="p">)</span><span class="o">*</span><span class="mf">1.10</span>
                    <span class="n">ax</span><span class="o">.</span><span class="n">axis</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span><span class="n">M</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">pltmin</span><span class="p">,</span><span class="n">pltmax</span><span class="p">])</span>

                    <span class="c1"># If a substitution was made above, inform on plot</span>
                    <span class="k">if</span> <span class="n">plttxt</span><span class="p">[</span><span class="n">jcor</span><span class="p">]:</span>
                        <span class="n">ax</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mf">1.</span><span class="o">+</span><span class="p">(</span><span class="n">Pmax</span><span class="o">-</span><span class="mf">1.</span><span class="p">)</span><span class="o">*</span><span class="mf">1.04</span><span class="p">,</span><span class="n">plttxt</span><span class="p">[</span><span class="n">jcor</span><span class="p">])</span>

                    <span class="c1"># If selected, plot the locations where the spectrum was broken up </span>
                    <span class="c1"># during fitting</span>
                    <span class="k">if</span> <span class="n">plotDivisions</span><span class="p">:</span>
                        <span class="n">target</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">msmeta</span><span class="o">.</span><span class="n">namesforfields</span><span class="p">(</span><span class="n">fldin</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="n">dNchan</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;inputs&#39;</span><span class="p">][</span><span class="n">target</span><span class="p">][</span><span class="nb">str</span><span class="p">(</span><span class="n">spwin</span><span class="p">)][</span><span class="s1">&#39;dNchan&#39;</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                        <span class="n">nseg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;inputs&#39;</span><span class="p">][</span><span class="n">target</span><span class="p">][</span><span class="nb">str</span><span class="p">(</span><span class="n">spwin</span><span class="p">)][</span><span class="s1">&#39;num_segments&#39;</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                        <span class="c1"># if there is only 1 segment, then no lines to draw</span>
                        <span class="k">if</span> <span class="n">nseg</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                            <span class="n">plotDivisions</span><span class="o">=</span><span class="kc">False</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">xlocs</span> <span class="o">=</span> <span class="p">[</span><span class="n">iseg</span><span class="o">*</span><span class="n">dNchan</span> <span class="k">for</span> <span class="n">iseg</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">nseg</span><span class="p">)]</span>                    
                            <span class="n">ax</span><span class="o">.</span><span class="n">vlines</span><span class="p">(</span>
                                    <span class="n">xlocs</span><span class="p">,</span> 
                                    <span class="mf">0.5</span><span class="p">,</span> 
                                    <span class="mi">5</span><span class="p">,</span> 
                                    <span class="n">linestyles</span><span class="o">=</span><span class="s1">&#39;dotted&#39;</span><span class="p">,</span> 
                                    <span class="n">colors</span><span class="o">=</span><span class="s1">&#39;grey&#39;</span><span class="p">,</span> 
                                    <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> 
                                    <span class="n">zorder</span><span class="o">=</span><span class="mi">10</span>
                                    <span class="p">)</span>
                    <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Channels&#39;</span><span class="p">)</span>
                    <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;ReNorm Scaling&#39;</span><span class="p">)</span>
                    <span class="n">fname</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">msname</span><span class="o">+</span><span class="s1">&#39;_ReNormHeuristicOutlierAnt_&#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">AntName</span><span class="p">[</span><span class="n">jant</span><span class="p">]</span> \
                            <span class="o">+</span> <span class="s1">&#39;_spw&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">spwin</span><span class="p">)</span> \
                            <span class="o">+</span> <span class="s1">&#39;_scan&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">scanin</span><span class="p">)</span> \
                            <span class="o">+</span> <span class="s1">&#39;_field&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">fldin</span><span class="p">)</span> \
                            <span class="o">+</span> <span class="s1">&#39;_&#39;</span><span class="o">+</span><span class="n">corPrt</span><span class="p">[</span><span class="n">jcor</span><span class="p">]</span>
                    <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">msname</span>
                                <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Antenna &#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">AntName</span><span class="p">[</span><span class="n">jant</span><span class="p">]</span>
                                <span class="o">+</span> <span class="s1">&#39; Spw: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">spwin</span><span class="p">)</span>
                                <span class="o">+</span> <span class="s1">&#39; Scan: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">scanin</span><span class="p">)</span>
                                <span class="o">+</span> <span class="s1">&#39; Field: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">fldin</span><span class="p">)</span>
                                <span class="o">+</span> <span class="s1">&#39; Corr: &#39;</span> <span class="o">+</span> <span class="n">corPrt</span><span class="p">[</span><span class="n">jcor</span><span class="p">],</span> 
                            <span class="p">{</span><span class="s1">&#39;fontsize&#39;</span><span class="p">:</span> <span class="s1">&#39;medium&#39;</span><span class="p">}</span>
                            <span class="p">)</span>

                    <span class="c1"># legend lines</span>
                    <span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span>
                            <span class="n">loc</span><span class="o">=</span><span class="s1">&#39;lower center&#39;</span><span class="p">,</span>
                            <span class="n">bbox_to_anchor</span><span class="o">=</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span><span class="o">-</span><span class="mf">0.28</span><span class="p">),</span>
                            <span class="n">prop</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;size&#39;</span><span class="p">:</span><span class="mi">8</span><span class="p">},</span>
                            <span class="n">ncol</span><span class="o">=</span><span class="mi">3</span>
                            <span class="p">)</span>
                    <span class="n">fig</span><span class="o">.</span><span class="n">subplots_adjust</span><span class="p">(</span><span class="n">bottom</span><span class="o">=</span><span class="mf">0.20</span><span class="p">)</span>
                    
                    <span class="c1"># Create secondary x-axis with frequency labels</span>
                    <span class="n">freqs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">msmeta</span><span class="o">.</span><span class="n">chanfreqs</span><span class="p">(</span><span class="n">spwin</span><span class="p">,</span><span class="s1">&#39;GHz&#39;</span><span class="p">)</span>
                    <span class="n">ax1</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">twiny</span><span class="p">()</span>
                    <span class="n">ax1</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Frequency (GHz) (TOPO)&#39;</span><span class="p">)</span>
                    <span class="n">ax1</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">freqs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">freqs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                    <span class="n">ax1</span><span class="o">.</span><span class="n">ticklabel_format</span><span class="p">(</span><span class="n">useOffset</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

                    <span class="c1"># Save a hardcopy of the plots if desired </span>
                    <span class="c1"># or show plots interactively</span>
                    <span class="k">if</span> <span class="n">hardcopy</span><span class="p">:</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="s1">&#39;RN_plots&#39;</span><span class="p">):</span>
                            <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="s1">&#39;RN_plots&#39;</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                            <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">Saving hardcopy plot: &#39;</span><span class="o">+</span><span class="n">fname</span><span class="p">)</span>
                        <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;./RN_plots/&#39;</span><span class="o">+</span><span class="n">fname</span><span class="o">+</span><span class="s1">&#39;.png&#39;</span><span class="p">)</span>
                        <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="s1">&#39;all&#39;</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>


            

    <span class="c1"># Main diagnostic spectra at lowest level - scaling that each spw, scan, field, ant, correlation will have</span>
    <span class="c1"># these plots should look good</span>
<div class="viewcode-block" id="ACreNorm.plotdiagSpectra">
<a class="viewcode-back" href="../../../_autosummary/pipeline.extern.almarenorm_pl2023.ACreNorm.html#pipeline.h.tasks.restoredata.restoredata.ACreNorm.plotdiagSpectra">[docs]</a>
    <span class="k">def</span> <span class="nf">plotdiagSpectra</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> 
            <span class="n">R</span><span class="p">,</span> 
            <span class="n">scanin</span><span class="p">,</span> 
            <span class="n">spwin</span><span class="p">,</span> 
            <span class="n">fldin</span><span class="p">,</span> 
            <span class="n">threshline</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
            <span class="n">plotATM</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> 
            <span class="n">plotDivisions</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> 
            <span class="n">N_atm</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
            <span class="n">shadeAtm</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> 
            <span class="n">showExcluded</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Purpose: </span>
<span class="sd">            This creates diagnotic spectra at the per field per spectral window level for each scan.</span>
<span class="sd">            Each antenna and correlation are plotted for each field.</span>
<span class="sd">        Inputs:</span>
<span class="sd">            R : numpy.array</span>
<span class="sd">                This is the renormalization spectrum that you wish to plot. Requires data in the form</span>
<span class="sd">                of a numpy array in the shape [correlation, channel, antenna] such that [0,:,0] would</span>
<span class="sd">                be the 0-th correlation (XX), all channels, for the 0-th antenna (e.g. DA45) and would</span>
<span class="sd">                be the found renormalization spectrum.</span>

<span class="sd">            scanin : int</span>
<span class="sd">                This is the scan number which corresponds to the renormalization spectrum supplied.</span>

<span class="sd">            spwin : int</span>
<span class="sd">                This is the spectral window number which corresponds to the renormalization spectrum</span>
<span class="sd">                supplied.</span>

<span class="sd">            fldin : int</span>
<span class="sd">                This is the field number which corresponds to the normalization spectrum supplied.</span>

<span class="sd">            plotATM : boolean : OPTIONAL</span>
<span class="sd">                This option will plot (or not) the atmospheric transmission profile for the input</span>
<span class="sd">                spectrum.</span>
<span class="sd">                Default: True</span>

<span class="sd">            plotDivisions : boolean : OPTIONAL</span>
<span class="sd">                This option will plot (or not) the division lines as vertical, grey, dotted lines</span>
<span class="sd">                at all the locations where the renormalization spectrum was broken up during the</span>
<span class="sd">                fitting stage.</span>
<span class="sd">                Default: True</span>

<span class="sd">            threshLine : float or None : OPTIONAL</span>
<span class="sd">                This option allows the user to draw a line of the plot to represent the threshold</span>
<span class="sd">                level.</span>
<span class="sd">                Default: None</span>

<span class="sd">            N_atm : numpy.array OR None : OPTIONAL</span>
<span class="sd">                Similar to R above, this is the renormalization spectrum that you want to plot except</span>
<span class="sd">                this should be the renormalization spectrum that has not had any atmospheric corrections</span>
<span class="sd">                applited to it. If provided, then this &quot;original&quot; data will be plotted showing the </span>
<span class="sd">                differences between this and the renormalization spectrum that will be applied.</span>
<span class="sd">                Default: None</span>

<span class="sd">            shadeAtm : boolean : OPTIONAL</span>
<span class="sd">                If set to True, this will find atmospheric features, fit them with a Lorentzian </span>
<span class="sd">                profile and shade the regions of the spectrum influenced by the feature.</span>
<span class="sd">                Default: True</span>

<span class="sd">            showExcluded : boolean : OPTIONAL</span>
<span class="sd">                If set to True, then areas of the spectrum that have been excluded via the </span>
<span class="sd">                excludechan option in renormalize() will be shown. </span>
<span class="sd">                Default: True</span>
<span class="sd">         </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># If an original Renormalization spectrum was provided (i.e. one without any atmospheric</span>
        <span class="c1"># corrections applied to it) then find the median (avoiding zeros) so that we can overplot </span>
        <span class="c1"># it to see the improvements directly.</span>
        <span class="k">if</span> <span class="n">N_atm</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">plot_original</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">M_atm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmedian</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">N_atm</span><span class="o">!=</span><span class="mi">1</span><span class="p">,</span><span class="n">N_atm</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">),</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">M_atm</span><span class="p">[:][</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">M_atm</span><span class="p">[:])]</span><span class="o">=</span><span class="mf">1.0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">plot_original</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Grab the median renormalization spectrum, avoiding values set to exactly 1.0 since that</span>
        <span class="c1"># indicates that an antenna has been completely flagged and skews the median. Then, reset </span>
        <span class="c1"># spectrum after found.</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmedian</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">R</span><span class="o">!=</span><span class="mi">1</span><span class="p">,</span><span class="n">R</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">),</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">M</span><span class="p">[:][</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">M</span><span class="p">[:])]</span><span class="o">=</span><span class="mf">1.0</span> 

        <span class="c1"># Grab the frequencies</span>
        <span class="n">freqs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">msmeta</span><span class="o">.</span><span class="n">chanfreqs</span><span class="p">(</span><span class="n">spwin</span><span class="p">,</span> <span class="s1">&#39;GHz&#39;</span><span class="p">)</span>

        <span class="c1"># Simple scaling to abide by for plots to try somewhat keep default axes</span>
        <span class="c1"># but as we do a diag for each spw, scan, fld as the scaling spectrum is </span>
        <span class="c1"># found, then we don&#39;t store or compare between and get an &#39;overall&#39; </span>
        <span class="c1"># range for plotting </span>
        <span class="n">maxVal</span><span class="o">=</span><span class="p">[</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">1.02</span><span class="p">,</span><span class="mf">1.05</span><span class="p">,</span><span class="mf">1.1</span><span class="p">,</span><span class="mf">1.2</span><span class="p">,</span><span class="mf">1.3</span><span class="p">,</span><span class="mf">1.4</span><span class="p">,</span><span class="mf">1.5</span><span class="p">,</span><span class="mf">2.0</span><span class="p">,</span><span class="mf">2.5</span><span class="p">]</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">plMax</span> <span class="o">=</span> <span class="p">[</span><span class="n">plM</span> <span class="k">for</span> <span class="n">plM</span> <span class="ow">in</span> <span class="n">maxVal</span> <span class="k">if</span> <span class="n">plM</span> <span class="o">&gt;=</span> <span class="n">R</span><span class="o">.</span><span class="n">max</span><span class="p">()][</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="n">plMax</span> <span class="o">=</span> <span class="mf">3.0</span>
            <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n\t</span><span class="s1">WARNING!!!!&#39;</span><span class="p">)</span>
            <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">UNREALISTICALLY HIGH RENORM VALUE FOUND!! THERE ARE LIKELY CORRELATOR </span><span class="se">\</span>
<span class="s1">                    ISSUES WITH SCAN &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">scanin</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39; OR THE FITTING HAS DIVERGED.</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">plMax</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">plMax</span><span class="p">,</span> <span class="mf">1.02</span><span class="p">)</span>
        <span class="n">plMin</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">R</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="mf">0.995</span><span class="p">)</span>
        
        <span class="c1"># Grab the target name</span>
        <span class="n">target</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">msmeta</span><span class="o">.</span><span class="n">namesforfields</span><span class="p">(</span><span class="n">fldin</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Initialize the plot</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="s1">&#39;all&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ioff</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">clf</span><span class="p">()</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">8</span><span class="p">))</span>
        <span class="n">ax_rn</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">,</span> <span class="n">frame_on</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">ax_rn</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Renorm Amplitude&#39;</span><span class="p">)</span>
        <span class="n">ax_rn</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Frequency (GHz) (TOPO)&#39;</span><span class="p">)</span>
        <span class="n">ax_rn</span><span class="o">.</span><span class="n">minorticks_on</span><span class="p">()</span>

        <span class="c1"># Initialize secondary x-axis and label channels in the correct direction</span>
        <span class="n">ax_rn1</span> <span class="o">=</span> <span class="n">ax_rn</span><span class="o">.</span><span class="n">twiny</span><span class="p">()</span>
        <span class="n">ax_rn1</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Channel&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">freqs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">freqs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">ax_rn1</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">freqs</span><span class="p">),</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ax_rn1</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">freqs</span><span class="p">))</span>
        <span class="n">ax_rn1</span><span class="o">.</span><span class="n">minorticks_on</span><span class="p">()</span>

        <span class="c1"># Plot renormalization spectrum for each antenna and correlation using </span>
        <span class="c1"># different styles. Also plot median spectrum.</span>
        <span class="n">corColor</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;r&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">]</span>
        <span class="n">medColor</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;k&#39;</span><span class="p">,</span><span class="s1">&#39;g&#39;</span><span class="p">]</span>
        <span class="n">medLine</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;:&#39;</span><span class="p">,</span><span class="s1">&#39;--&#39;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">iCor</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">R</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">for</span> <span class="n">iAnt</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">R</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]):</span>
                <span class="n">ax_rn</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">freqs</span><span class="p">,</span> <span class="n">R</span><span class="p">[</span><span class="n">iCor</span><span class="p">,:,</span><span class="n">iAnt</span><span class="p">],</span><span class="n">c</span><span class="o">=</span><span class="n">corColor</span><span class="p">[</span><span class="n">iCor</span><span class="p">],</span><span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
            <span class="n">ax_rn</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
                    <span class="n">freqs</span><span class="p">,</span> 
                    <span class="n">M</span><span class="p">[</span><span class="n">iCor</span><span class="p">],</span>
                    <span class="n">c</span><span class="o">=</span><span class="n">medColor</span><span class="p">[</span><span class="n">iCor</span><span class="p">],</span>
                    <span class="n">linewidth</span><span class="o">=</span><span class="s1">&#39;4&#39;</span><span class="p">,</span>
                    <span class="n">linestyle</span><span class="o">=</span><span class="n">medLine</span><span class="p">[</span><span class="n">iCor</span><span class="p">]</span>
                    <span class="p">)</span>
            <span class="c1"># If provided the original data, plot it in the background.</span>
            <span class="k">if</span> <span class="n">plot_original</span><span class="p">:</span>
                <span class="n">ax_rn</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
                        <span class="n">freqs</span><span class="p">,</span> 
                        <span class="n">M_atm</span><span class="p">[</span><span class="n">iCor</span><span class="p">],</span> 
                        <span class="n">c</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> 
                        <span class="n">linewidth</span><span class="o">=</span><span class="s1">&#39;2&#39;</span><span class="p">,</span> 
                        <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">,</span> 
                        <span class="n">alpha</span><span class="o">=</span><span class="mf">0.25</span><span class="p">,</span> 
                        <span class="n">zorder</span><span class="o">=</span><span class="mi">11</span>
                        <span class="p">)</span>

        <span class="c1"># If supplied, plot a threshold line</span>
        <span class="k">if</span> <span class="n">threshline</span> <span class="ow">and</span> <span class="n">threshline</span> <span class="o">&lt;</span> <span class="n">plMax</span><span class="p">:</span>
            <span class="n">ax_rn</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
                    <span class="p">[</span><span class="nb">min</span><span class="p">(</span><span class="n">freqs</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">freqs</span><span class="p">)],</span>
                    <span class="p">[</span><span class="n">threshline</span><span class="p">,</span> <span class="n">threshline</span><span class="p">],</span>
                    <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;-&#39;</span><span class="p">,</span>
                    <span class="n">c</span><span class="o">=</span><span class="s1">&#39;c&#39;</span><span class="p">,</span>
                    <span class="n">linewidth</span><span class="o">=</span><span class="s1">&#39;2&#39;</span>
                    <span class="p">)</span>

        <span class="c1"># Set the labels and such</span>
        <span class="n">ax_rn</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">msname</span><span class="o">+</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Target: &#39;</span><span class="o">+</span><span class="n">target</span><span class="o">+</span><span class="s1">&#39; Spw: &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">spwin</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39; Scan: &#39;</span> \
                        <span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">scanin</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39; Field: &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">fldin</span><span class="p">),</span>
                        <span class="p">{</span><span class="s1">&#39;fontsize&#39;</span><span class="p">:</span> <span class="s1">&#39;medium&#39;</span><span class="p">}</span>
                        <span class="p">)</span>
        <span class="n">ax_rn</span><span class="o">.</span><span class="n">ticklabel_format</span><span class="p">(</span><span class="n">useOffset</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">ax_rn</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">freqs</span><span class="p">)</span><span class="o">*</span><span class="mf">0.99999</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">freqs</span><span class="p">)</span><span class="o">*</span><span class="mf">1.00001</span><span class="p">)</span>
        <span class="n">ax_rn</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">plMin</span><span class="p">,</span><span class="n">plMax</span><span class="p">)</span>

        <span class="c1"># If True, then show a small yellow area indicating where the spectrum</span>
        <span class="c1"># has been blanked.</span>
        <span class="k">if</span> <span class="n">showExcluded</span><span class="p">:</span>
            <span class="c1"># Check to make sure it is not an empty input</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;inputs&#39;</span><span class="p">][</span><span class="s1">&#39;excludechan&#39;</span><span class="p">]:</span>
                <span class="c1"># Check to make sure this spw has anything input, then grab the </span>
                <span class="c1"># range and plot it.</span>
                <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">spwin</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;inputs&#39;</span><span class="p">][</span><span class="s1">&#39;excludechan&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="n">ranges</span> <span class="o">=</span> <span class="p">[</span>
                            <span class="n">rng</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> 
                            <span class="k">for</span> <span class="n">rng</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;inputs&#39;</span><span class="p">][</span><span class="s1">&#39;excludechan&#39;</span><span class="p">][</span><span class="nb">str</span><span class="p">(</span><span class="n">spwin</span><span class="p">)]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;;&#39;</span><span class="p">)</span>
                            <span class="p">]</span>
                    <span class="n">starts</span><span class="p">,</span> <span class="n">ends</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interpretExcludechan</span><span class="p">(</span><span class="n">ranges</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">spwin</span><span class="p">))</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">starts</span><span class="p">)):</span>
                        <span class="n">ax_rn</span><span class="o">.</span><span class="n">axvspan</span><span class="p">(</span>
                                <span class="n">freqs</span><span class="p">[</span><span class="n">starts</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span> 
                                <span class="n">freqs</span><span class="p">[</span><span class="n">ends</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span> 
                                <span class="n">ymin</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> 
                                <span class="n">ymax</span><span class="o">=</span><span class="mf">0.06</span><span class="p">,</span> 
                                <span class="n">facecolor</span><span class="o">=</span><span class="s1">&#39;yellow&#39;</span><span class="p">,</span> 
                                <span class="n">ec</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">,</span> 
                                <span class="n">zorder</span><span class="o">=</span><span class="mi">0</span>
                                <span class="p">)</span>

        <span class="c1"># If selected, plot the locations where the spectrum was divided during the fitting process</span>
        <span class="k">if</span> <span class="n">plotDivisions</span><span class="p">:</span>
            <span class="n">dNchan</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;inputs&#39;</span><span class="p">][</span><span class="n">target</span><span class="p">][</span><span class="nb">str</span><span class="p">(</span><span class="n">spwin</span><span class="p">)][</span><span class="s1">&#39;dNchan&#39;</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">nseg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rnstats</span><span class="p">[</span><span class="s1">&#39;inputs&#39;</span><span class="p">][</span><span class="n">target</span><span class="p">][</span><span class="nb">str</span><span class="p">(</span><span class="n">spwin</span><span class="p">)][</span><span class="s1">&#39;num_segments&#39;</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">nseg</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">plotDivisions</span><span class="o">=</span><span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">xlocs</span> <span class="o">=</span> <span class="p">[</span><span class="n">iseg</span><span class="o">*</span><span class="n">dNchan</span> <span class="k">for</span> <span class="n">iseg</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">nseg</span><span class="p">)]</span>                    
                <span class="n">ax_rn</span><span class="o">.</span><span class="n">vlines</span><span class="p">(</span>
                        <span class="n">freqs</span><span class="p">[</span><span class="n">xlocs</span><span class="p">],</span> 
                        <span class="mf">0.5</span><span class="p">,</span> 
                        <span class="mi">5</span><span class="p">,</span> 
                        <span class="n">linestyles</span><span class="o">=</span><span class="s1">&#39;dotted&#39;</span><span class="p">,</span> 
                        <span class="n">colors</span><span class="o">=</span><span class="s1">&#39;grey&#39;</span><span class="p">,</span> 
                        <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> 
                        <span class="n">zorder</span><span class="o">=</span><span class="mi">10</span>
                        <span class="p">)</span>

        <span class="c1"># If selected, plot the atmospheric transmission profile(s). Note that in Bands 9 and 10,</span>
        <span class="c1"># the image sideband atmospheric transmission profile is also plotted.</span>
        <span class="k">if</span> <span class="n">plotATM</span><span class="p">:</span>
            <span class="c1"># If renormalize(correctATM=True) was used, then the ATM profile already exists in</span>
            <span class="c1"># a dictionary, use that. Otherwise, grab the profile and image sideband if necessary.</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atmtrans</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">Band</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">]:</span>
                    <span class="n">ATMprof</span><span class="p">,</span> <span class="n">ATMprof_imageSB</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ATMtrans</span><span class="p">(</span><span class="n">scanin</span><span class="p">,</span> <span class="n">spwin</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ATMprof</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ATMtrans</span><span class="p">(</span><span class="n">scanin</span><span class="p">,</span><span class="n">spwin</span><span class="p">,</span><span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">Band</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">]:</span>
                    <span class="n">ATMprof</span><span class="p">,</span> <span class="n">ATMprof_imageSB</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atmtrans</span><span class="p">[</span><span class="n">target</span><span class="p">][</span><span class="nb">str</span><span class="p">(</span><span class="n">spwin</span><span class="p">)][</span><span class="nb">str</span><span class="p">(</span><span class="n">scanin</span><span class="p">)]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ATMprof</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">atmtrans</span><span class="p">[</span><span class="n">target</span><span class="p">][</span><span class="nb">str</span><span class="p">(</span><span class="n">spwin</span><span class="p">)][</span><span class="nb">str</span><span class="p">(</span><span class="n">scanin</span><span class="p">)]</span>

            <span class="c1"># Setup secondary y-axis using the same frequency axis and plot the profile(s).</span>
            <span class="n">ax_atm</span> <span class="o">=</span> <span class="n">ax_rn</span><span class="o">.</span><span class="n">twinx</span><span class="p">()</span>
            <span class="n">ax_atm</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">freqs</span><span class="p">,</span> <span class="mf">100.</span><span class="o">*</span><span class="n">ATMprof</span><span class="p">,</span><span class="n">c</span><span class="o">=</span><span class="s1">&#39;m&#39;</span><span class="p">,</span><span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;-&#39;</span><span class="p">,</span><span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">shadeAtm</span><span class="p">:</span>
                <span class="c1"># Find where the ATM lines are by fitting Lorentzian profiles</span>
                <span class="n">atm_centers</span><span class="p">,</span> <span class="n">atm_gammas</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fitAtmLines</span><span class="p">(</span><span class="n">ATMprof</span><span class="p">,</span> <span class="n">spwin</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">Band</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">]:</span>
                    <span class="n">num_lines</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">atm_centers</span><span class="p">)</span>
                    <span class="n">atm_centers_SB</span><span class="p">,</span> <span class="n">atm_gammas_SB</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fitAtmLines</span><span class="p">(</span><span class="n">ATMprof_imageSB</span><span class="p">,</span> <span class="n">spwin</span><span class="p">)</span>
                    <span class="n">atm_centers</span> <span class="o">+=</span> <span class="n">atm_centers_SB</span>
                    <span class="n">atm_gammas</span> <span class="o">+=</span> <span class="n">atm_gammas_SB</span>

                <span class="c1"># For every ATM feature, plot a shaded area so that it is easy to distiguish.</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">atm_centers</span><span class="p">)):</span>
                    <span class="c1"># Set the ATM profile we want to report which might vary for Bands 9 and 10</span>
                    <span class="n">profile</span> <span class="o">=</span> <span class="n">ATMprof</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">Band</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">num_lines</span><span class="p">:</span>
                            <span class="n">profile</span> <span class="o">=</span> <span class="n">ATMprof_imageSB</span>
                    <span class="c1"># A Lorentizian has a width of gamma (which is != a Gaussian sigma!) </span>
                    <span class="c1"># where 2*gamma is the FWHM. Here we go a bit further to capture most</span>
                    <span class="c1"># of the ATM feature that is above the noise. This is from my empirical</span>
                    <span class="c1"># estimates from datasets I&#39;ve collected and seems to capture most of </span>
                    <span class="c1"># signal without catching real signal for cases where an ATM line is </span>
                    <span class="c1"># coincident (or nearly so) with a real line. </span>
                    <span class="c1">#</span>
                    <span class="c1"># PIPEREQ-228 - Need to protect instances where the</span>
                    <span class="c1"># fitted feature starts or ends outside the spw!</span>
                    <span class="n">atm_start</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span>
                                    <span class="nb">max</span><span class="p">(</span>
                                        <span class="mi">0</span><span class="p">,</span> 
                                        <span class="nb">int</span><span class="p">(</span><span class="n">atm_centers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="mf">1.3</span><span class="o">*</span><span class="n">atm_gammas</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                                        <span class="p">),</span> 
                                    <span class="nb">len</span><span class="p">(</span><span class="n">profile</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
                                    <span class="p">)</span>
                    <span class="n">atm_end</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span>
                                    <span class="mi">0</span><span class="p">,</span> 
                                    <span class="nb">min</span><span class="p">(</span>
                                        <span class="nb">int</span><span class="p">(</span><span class="n">atm_centers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="mf">1.3</span><span class="o">*</span><span class="n">atm_gammas</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> 
                                        <span class="nb">len</span><span class="p">(</span><span class="n">profile</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
                                        <span class="p">)</span>
                                    <span class="p">)</span>
                    <span class="k">if</span> <span class="n">atm_start</span> <span class="o">==</span> <span class="n">atm_end</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="c1"># Draw a shaded region where the line is</span>
                    <span class="n">ax_atm</span><span class="o">.</span><span class="n">axvspan</span><span class="p">(</span>
                            <span class="n">freqs</span><span class="p">[</span><span class="n">atm_start</span><span class="p">],</span>
                            <span class="n">freqs</span><span class="p">[</span><span class="n">atm_end</span><span class="p">],</span>
                            <span class="n">ymin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> 
                            <span class="n">ymax</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
                            <span class="n">alpha</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> 
                            <span class="n">facecolor</span><span class="o">=</span><span class="s1">&#39;grey&#39;</span>
                            <span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">Band</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">]:</span>
                <span class="n">ax_atm</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">freqs</span><span class="p">,</span> <span class="mf">100.</span><span class="o">*</span><span class="n">ATMprof_imageSB</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">Band</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">]:</span>
                <span class="n">peak</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">ATMprof</span><span class="p">,</span><span class="n">ATMprof_imageSB</span><span class="p">)</span><span class="o">*</span><span class="mf">100.</span><span class="p">)</span><span class="o">+</span><span class="mi">10</span>
                <span class="n">ax_atm</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;ATM Transmission (%), Image Sideband&#39;</span><span class="p">)</span>                
            <span class="k">else</span><span class="p">:</span>
                <span class="n">peak</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">ATMprof</span><span class="o">*</span><span class="mf">100.</span><span class="p">)</span><span class="o">+</span><span class="mi">10</span>
                <span class="n">ax_atm</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;ATM Transmission (%)&#39;</span><span class="p">)</span>                
            <span class="n">ax_atm</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">set_label_position</span><span class="p">(</span><span class="s1">&#39;right&#39;</span><span class="p">)</span>
            
            <span class="c1"># Avoid labelling values less than 0% since they have no physical meaning.</span>
            <span class="c1"># Enforce a range of 100</span>
            <span class="n">atm_ymax</span> <span class="o">=</span> <span class="n">peak</span>
            <span class="n">atm_ymin</span> <span class="o">=</span> <span class="n">peak</span><span class="o">-</span><span class="mi">100</span>
            <span class="n">ax_atm</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">atm_ymin</span><span class="p">,</span> <span class="n">atm_ymax</span><span class="p">)</span>

            <span class="c1">## Make sure that we don&#39;t label values that are less than 0 since that</span>
            <span class="c1">## has no physical meaning.</span>
            <span class="n">yvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">atm_ymin</span><span class="p">),</span> <span class="nb">round</span><span class="p">(</span><span class="n">atm_ymax</span><span class="p">))</span>
            <span class="n">yvals_mod</span> <span class="o">=</span> <span class="n">yvals</span><span class="o">%</span><span class="mi">20</span>
            <span class="n">ylabels</span> <span class="o">=</span> <span class="n">yvals</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">yvals_mod</span><span class="o">==</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">])]</span>
            <span class="n">ylabels_mask</span> <span class="o">=</span> <span class="n">ylabels</span> <span class="o">&gt;=</span> <span class="mi">0</span> 
            <span class="n">ax_atm</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">(</span><span class="n">ylabels</span><span class="p">[</span><span class="n">ylabels_mask</span><span class="p">])</span>
            <span class="n">ax_atm</span><span class="o">.</span><span class="n">set_yticklabels</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">ylbl</span><span class="p">))</span> <span class="k">for</span> <span class="n">ylbl</span> <span class="ow">in</span> <span class="n">ylabels</span><span class="p">[</span><span class="n">ylabels_mask</span><span class="p">]])</span>
            
        <span class="c1"># Save the plotted figure, setting up the plot directory if it doesn&#39;t already exist.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="s1">&#39;RN_plots&#39;</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="s1">&#39;RN_plots&#39;</span><span class="p">)</span>
        <span class="n">fnameM</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">msname</span><span class="o">+</span><span class="s1">&#39;_ReNormDiagnosticCheck_&#39;</span><span class="o">+</span><span class="n">target</span><span class="o">+</span><span class="s1">&#39;_spw&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">spwin</span><span class="p">)</span> \
                <span class="o">+</span><span class="s1">&#39;_scan&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">scanin</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;_field&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">fldin</span><span class="p">)</span>        
        <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;./RN_plots/&#39;</span><span class="o">+</span><span class="n">fnameM</span><span class="o">+</span><span class="s1">&#39;.png&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="s1">&#39;all&#39;</span><span class="p">)</span></div>


            
    <span class="k">def</span> <span class="nf">calcSetEdge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">R</span><span class="p">,</span><span class="n">edge</span><span class="o">=</span><span class="mf">0.01</span><span class="p">):</span>
        <span class="c1"># this changes the edge channels to the median value</span>
        <span class="p">(</span><span class="n">lpcor</span><span class="p">,</span><span class="n">lpcha</span><span class="p">,</span><span class="n">lpant</span><span class="p">)</span><span class="o">=</span><span class="n">R</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">chlo</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">ceil</span><span class="p">(</span><span class="n">edge</span><span class="o">*</span><span class="n">lpcha</span><span class="p">))</span>
        <span class="n">chhi</span><span class="o">=</span><span class="n">lpcha</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">chlo</span>
        <span class="k">for</span> <span class="n">lcor</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">lpcor</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">lant</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">lpant</span><span class="p">):</span>
                <span class="n">Rmed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="n">lcor</span><span class="p">,:,</span><span class="n">lant</span><span class="p">])</span>
                <span class="n">R</span><span class="p">[</span><span class="n">lcor</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="n">chlo</span><span class="p">,</span><span class="n">lant</span><span class="p">]</span><span class="o">=</span><span class="n">Rmed</span>
                <span class="n">R</span><span class="p">[</span><span class="n">lcor</span><span class="p">,</span><span class="n">chhi</span><span class="p">:,</span><span class="n">lant</span><span class="p">]</span><span class="o">=</span><span class="n">Rmed</span>

    <span class="k">def</span> <span class="nf">calcMaxConseq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">linelist</span><span class="p">):</span>
        <span class="n">cntConsec</span><span class="p">,</span><span class="n">maxConsec</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span>
        <span class="c1"># loops the differnce of the channels and counts the maximal </span>
        <span class="c1"># consecuitve amount - used later as a trigger to replace channels</span>
        <span class="c1"># 2021 Feb 16 added that a gap of 2 can be consecutive</span>
        <span class="c1"># as sometimes data are just fluctuating above the threshold </span>
        <span class="c1"># better to do a full replace vs. piece-meal every other channel</span>
        <span class="k">for</span> <span class="n">diffVal</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">linelist</span><span class="p">):</span>
            <span class="n">cntConsec</span> <span class="o">=</span> <span class="n">cntConsec</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">diffVal</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">diffVal</span> <span class="o">==</span> <span class="mi">2</span> <span class="k">else</span> <span class="mi">0</span>
            <span class="n">maxConsec</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">cntConsec</span><span class="p">,</span><span class="n">maxConsec</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">maxConsec</span>


<div class="viewcode-block" id="ACreNorm.ATMtrans">
<a class="viewcode-back" href="../../../_autosummary/pipeline.extern.almarenorm_pl2023.ACreNorm.html#pipeline.h.tasks.restoredata.restoredata.ACreNorm.ATMtrans">[docs]</a>
    <span class="k">def</span> <span class="nf">ATMtrans</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iscan</span><span class="p">,</span> <span class="n">ispw</span><span class="p">,</span> <span class="n">ifld</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Purpose:</span>
<span class="sd">            This function will return the atmospheric model for the input spectral window</span>
<span class="sd">            and scan. In the case of a Band 9 or 10 spectral window, the atmospheric model</span>
<span class="sd">            for the image sideband is also returned. </span>

<span class="sd">        Inputs:</span>
<span class="sd">            iscan : int</span>
<span class="sd">                The user input scan from which to get the atmospheric model. This is used</span>
<span class="sd">                to find the observation time, elevation, and weather information.</span>

<span class="sd">            ispw : int</span>
<span class="sd">                The user input spectral window.</span>

<span class="sd">            ifld : int : OPTIONAL</span>
<span class="sd">                The user input field ID. This is optional but in the case of mosaics, can</span>
<span class="sd">                make the atmospheric model slightly more accurate. </span>
<span class="sd">                Default: None</span>

<span class="sd">            verbose : boolean : OPTIONAL</span>
<span class="sd">                Setting to True will output additional information as the atmospheric profile </span>
<span class="sd">                is calculated.</span>
<span class="sd">                Default: False</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            transmission: numpy.array</span>
<span class="sd">            (transmission, transmission_SB): numpy.arrays : ONLY FOR BANDS 9 AND 10</span>
<span class="sd">                This is a 1-D array with the same length as the number of channels of the input </span>
<span class="sd">                scan/spw. The values of the array consist of the atmospheric transmission by </span>
<span class="sd">                channel as a fraction between 0.0 and 1.0.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;  Getting ATM transmission profile for spw=&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">ispw</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39; and scan=&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">iscan</span><span class="p">))</span>

        <span class="c1"># Input iscan should be type(int) but if not, attempt to use the first index.</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">iscan</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">:</span>
            <span class="n">iscan</span><span class="o">=</span><span class="n">iscan</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Find the field if none supplied</span>
        <span class="k">if</span> <span class="n">ifld</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Find all fields associated with this scan</span>
            <span class="n">ifld</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">msmeta</span><span class="o">.</span><span class="n">fieldsforscan</span><span class="p">(</span><span class="n">iscan</span><span class="p">)</span>
            <span class="c1"># If there is more than 1 field, it is a mosaic. Take the central field value, hoping</span>
            <span class="c1"># that it is near the center...</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ifld</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">Input scan is a mosaic but no field was supplied. Will attempt to use &#39;</span><span class="o">+</span> \
                        <span class="s1">&#39;central field number.</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="n">ifld</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">floor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">ifld</span><span class="p">)))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ifld</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">ifld</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> 

        <span class="c1"># Fixed parameters adopted from Todd&#39;s aU and plotbandpass3 code</span>
        <span class="c1"># - could make options later but probably not required for what we need this function to do</span>
        <span class="n">dP</span><span class="o">=</span><span class="mf">5.0</span>
        <span class="n">dPm</span><span class="o">=</span><span class="mf">1.1</span>
        <span class="n">maxAltitude</span><span class="o">=</span><span class="mf">60.0</span>
        <span class="n">h0</span><span class="o">=</span><span class="mf">1.0</span>
        <span class="n">atmType</span> <span class="o">=</span>  <span class="mi">1</span>
        <span class="n">nbands</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">telescopeName</span> <span class="o">=</span> <span class="s1">&#39;ALMA&#39;</span>

        <span class="c1"># Get x-axis information</span>
        <span class="c1">#</span>
        <span class="c1"># Hanning implementation: </span>
        <span class="c1"># We want to get the full resolution ATM model and then hanning smooth it ourselves</span>
        <span class="c1"># so we need to specify the correct number of channels. However, we need to be careful</span>
        <span class="c1"># about paying attention to the cycle. Pre-cycle 3 data does not have any way of reliably</span>
        <span class="c1"># getting the binning factor. So for those datasets we will want to just use the same</span>
        <span class="c1"># number of channels and deal with it. For everything else, we will get the binning </span>
        <span class="c1"># factor from the MS and apply that binning later. </span>
        <span class="c1">#binningFactor = self.onlineBinningFactor()[ispw]</span>
        <span class="c1">#numchan = self.msmeta.nchan(ispw)*binningFactor</span>
        <span class="c1">#freqs = np.linspace(</span>
        <span class="c1">#                self.msmeta.chanfreqs(ispw,&#39;GHz&#39;)[0],</span>
        <span class="c1">#                self.msmeta.chanfreqs(ispw,&#39;GHz&#39;)[-1],</span>
        <span class="c1">#                numchan</span>
        <span class="c1">#            )</span>
        <span class="c1">#</span>
        <span class="c1"># No benefit was found from implementing Hanning smoothing of the profile, so just</span>
        <span class="c1"># using the profile as is.</span>
        <span class="n">freqs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">msmeta</span><span class="o">.</span><span class="n">chanfreqs</span><span class="p">(</span><span class="n">ispw</span><span class="p">,</span> <span class="s1">&#39;GHz&#39;</span><span class="p">)</span>
        <span class="n">numchan</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">msmeta</span><span class="o">.</span><span class="n">nchan</span><span class="p">(</span><span class="n">ispw</span><span class="p">)</span>
        <span class="n">reffreq</span><span class="o">=</span><span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">freqs</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">numchan</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">freqs</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">numchan</span><span class="o">/</span><span class="mi">2</span><span class="p">)])</span>

        <span class="c1"># Get some metadata information about the scan. We need the sky location in Azimuth </span>
        <span class="c1"># and Elevation to know the airmass contribution. Here we use the median scan time to</span>
        <span class="c1"># calculate the Elevation, assuming that scan times aren&#39;t ridiculously long, that should</span>
        <span class="c1"># be good enough for the entire scan. The times will also help us read the weather</span>
        <span class="c1"># tables to get the right PWV values out. </span>
        <span class="n">mydirection</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">renormradec2rad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">renormdirection2radec</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">msmeta</span><span class="o">.</span><span class="n">phasecenter</span><span class="p">(</span><span class="n">ifld</span><span class="p">)))</span> 
        <span class="n">scanTimes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">msmeta</span><span class="o">.</span><span class="n">timesforscan</span><span class="p">(</span><span class="n">iscan</span><span class="p">)</span>
        <span class="n">myscantime</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">scanTimes</span><span class="p">)</span> 
        <span class="n">scanLength</span> <span class="o">=</span> <span class="n">scanTimes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">scanTimes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>        
        <span class="n">casalog</span><span class="o">.</span><span class="n">filterMsg</span><span class="p">(</span><span class="s1">&#39;Position:&#39;</span><span class="p">)</span> <span class="c1"># message filter as this prints ALMA&#39;s position each call</span>
        <span class="n">azel</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">renormcomputeAzElFromRADecMJD</span><span class="p">(</span><span class="n">mydirection</span><span class="p">,</span><span class="n">myscantime</span><span class="o">/</span><span class="mf">86400.</span><span class="p">)</span>
        <span class="n">casalog</span><span class="o">.</span><span class="n">clearFilterMsgList</span><span class="p">()</span>
        <span class="n">airmass</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">((</span><span class="mf">90.</span><span class="o">-</span><span class="n">azel</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mf">180.</span><span class="p">)</span>

        <span class="c1"># Get weather results from the MS tables and populate variables from results.</span>
        <span class="n">weatherResult</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">renormWeather</span><span class="p">(</span><span class="n">iscan</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> 
        <span class="n">P</span><span class="o">=</span> <span class="n">weatherResult</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;pressure&#39;</span><span class="p">]</span>
        <span class="n">H</span><span class="o">=</span> <span class="n">weatherResult</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;humidity&#39;</span><span class="p">]</span>
        <span class="n">T</span><span class="o">=</span> <span class="n">weatherResult</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;temperature&#39;</span><span class="p">]</span><span class="o">+</span><span class="mf">273.15</span>
        <span class="c1"># Sometimes weather values passed are zeros, even if going through the full weather code.</span>
        <span class="c1"># In those cases, set to the default values. </span>
        <span class="k">if</span> <span class="n">P</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">P</span> <span class="o">=</span> <span class="mf">563.0</span>
        <span class="k">if</span> <span class="n">H</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">H</span> <span class="o">=</span> <span class="mf">20.0</span>
        <span class="k">if</span> <span class="n">T</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">T</span> <span class="o">=</span> <span class="mf">273.15</span>    

        <span class="c1"># Get the median PWV. </span>
        <span class="c1"># The PWV measurements are taken before or after scans, so we create a timerange over</span>
        <span class="c1"># which to look for those measurements and take the median of those found values. </span>
        <span class="c1"># If none are found, then we fall back to using the PWV for the Band from the </span>
        <span class="c1"># sensitivity calculator.</span>
        <span class="n">timerange</span> <span class="o">=</span> <span class="p">[</span><span class="n">scanTimes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">scanLength</span> <span class="o">/</span> <span class="mf">2.</span><span class="p">,</span> <span class="n">scanTimes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">scanLength</span><span class="o">/</span><span class="mf">2.</span><span class="p">]</span>
        <span class="n">pwvmedian</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">renormMedianPWV</span><span class="p">(</span><span class="n">timerange</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> 
        <span class="k">if</span> <span class="n">pwvmedian</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">corrATM</span><span class="o">=</span><span class="kc">False</span>
            <span class="c1"># get the band and then set these from quartiles</span>
            <span class="n">pwvmedian</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">usePWV</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">Band</span><span class="p">]</span> <span class="c1"># so at least it will make resonable plots</span>

        <span class="c1"># Need the inputs to be in a specific form (dictionary) which the quanta tool does for us.</span>
        <span class="n">myqa</span> <span class="o">=</span> <span class="n">qatool</span><span class="p">()</span>

        <span class="c1"># Gather frequency information into the form we&#39;ll need to make the model.</span>
        <span class="c1"># For Bands 9 and 10, the spectral window also has atmospheric contributions from the </span>
        <span class="c1"># image sideband which we must also calculate. </span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">Band</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">]:</span>
            <span class="n">nbands</span> <span class="o">=</span> <span class="mi">2</span>
            <span class="n">freqs_SB</span><span class="p">,</span> <span class="n">chansep_SB</span><span class="p">,</span> <span class="n">center_SB</span><span class="p">,</span> <span class="n">width_SB</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getImageSBFreqs</span><span class="p">(</span><span class="n">ispw</span><span class="p">)</span>
            <span class="n">fCenter</span> <span class="o">=</span> <span class="n">myqa</span><span class="o">.</span><span class="n">quantity</span><span class="p">([</span><span class="n">reffreq</span><span class="p">,</span> <span class="n">center_SB</span><span class="p">],</span><span class="s1">&#39;GHz&#39;</span><span class="p">)</span>
            <span class="n">chansep</span><span class="o">=</span><span class="p">(</span><span class="n">freqs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">freqs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="n">numchan</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">fResolution</span> <span class="o">=</span> <span class="n">myqa</span><span class="o">.</span><span class="n">quantity</span><span class="p">([</span><span class="n">chansep</span><span class="p">,</span> <span class="o">-</span><span class="n">chansep</span><span class="p">],</span><span class="s1">&#39;GHz&#39;</span><span class="p">)</span>
            <span class="n">fWidth</span> <span class="o">=</span> <span class="n">myqa</span><span class="o">.</span><span class="n">quantity</span><span class="p">([</span><span class="n">numchan</span><span class="o">*</span><span class="n">chansep</span><span class="p">,</span> <span class="n">numchan</span><span class="o">*-</span><span class="n">chansep</span><span class="p">],</span><span class="s1">&#39;GHz&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fCenter</span> <span class="o">=</span> <span class="n">myqa</span><span class="o">.</span><span class="n">quantity</span><span class="p">(</span><span class="n">reffreq</span><span class="p">,</span><span class="s1">&#39;GHz&#39;</span><span class="p">)</span>
            <span class="n">chansep</span><span class="o">=</span><span class="p">(</span><span class="n">freqs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">freqs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="n">numchan</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">fResolution</span> <span class="o">=</span> <span class="n">myqa</span><span class="o">.</span><span class="n">quantity</span><span class="p">(</span><span class="n">chansep</span><span class="p">,</span><span class="s1">&#39;GHz&#39;</span><span class="p">)</span>
            <span class="n">fWidth</span> <span class="o">=</span> <span class="n">myqa</span><span class="o">.</span><span class="n">quantity</span><span class="p">(</span><span class="n">numchan</span><span class="o">*</span><span class="n">chansep</span><span class="p">,</span><span class="s1">&#39;GHz&#39;</span><span class="p">)</span>

        <span class="c1"># Setup the CASA atmosphere tool and generate the model. </span>
        <span class="c1"># Note this is more or less from inside Todd&#39;s aU of CalcAtmTransmission</span>
        <span class="c1"># from Plotbandpass3.py code</span>
        <span class="n">myat</span><span class="o">=</span><span class="n">attool</span><span class="p">()</span>
        <span class="n">ATMresult</span> <span class="o">=</span> <span class="n">myat</span><span class="o">.</span><span class="n">initAtmProfile</span><span class="p">(</span><span class="n">humidity</span><span class="o">=</span><span class="n">H</span><span class="p">,</span> <span class="n">temperature</span><span class="o">=</span><span class="n">myqa</span><span class="o">.</span><span class="n">quantity</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="s2">&quot;K&quot;</span><span class="p">),</span>
                                 <span class="n">altitude</span><span class="o">=</span><span class="n">myqa</span><span class="o">.</span><span class="n">quantity</span><span class="p">(</span><span class="mi">5059</span><span class="p">,</span><span class="s2">&quot;m&quot;</span><span class="p">),</span>
                                 <span class="n">pressure</span><span class="o">=</span><span class="n">myqa</span><span class="o">.</span><span class="n">quantity</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="s1">&#39;mbar&#39;</span><span class="p">),</span>
                                 <span class="n">atmType</span><span class="o">=</span><span class="n">atmType</span><span class="p">,</span>
                                 <span class="n">h0</span><span class="o">=</span><span class="n">myqa</span><span class="o">.</span><span class="n">quantity</span><span class="p">(</span><span class="n">h0</span><span class="p">,</span><span class="s2">&quot;km&quot;</span><span class="p">),</span>
                                 <span class="n">maxAltitude</span><span class="o">=</span><span class="n">myqa</span><span class="o">.</span><span class="n">quantity</span><span class="p">(</span><span class="n">maxAltitude</span><span class="p">,</span><span class="s2">&quot;km&quot;</span><span class="p">),</span>
                                 <span class="n">dP</span><span class="o">=</span><span class="n">myqa</span><span class="o">.</span><span class="n">quantity</span><span class="p">(</span><span class="n">dP</span><span class="p">,</span><span class="s2">&quot;mbar&quot;</span><span class="p">),</span>
                                 <span class="n">dPm</span><span class="o">=</span><span class="n">dPm</span><span class="p">)</span>
        <span class="c1"># CASA 5 vs 6 check</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">ATMresult</span><span class="p">)</span> <span class="o">==</span> <span class="nb">tuple</span><span class="p">:</span>
            <span class="n">ATMresult</span> <span class="o">=</span> <span class="n">ATMresult</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># This sets the frequency information and the PWV measurement</span>
        <span class="n">myat</span><span class="o">.</span><span class="n">initSpectralWindow</span><span class="p">(</span><span class="n">nbands</span><span class="p">,</span><span class="n">fCenter</span><span class="p">,</span><span class="n">fWidth</span><span class="p">,</span><span class="n">fResolution</span><span class="p">)</span>
        <span class="n">myat</span><span class="o">.</span><span class="n">setUserWH2O</span><span class="p">(</span><span class="n">myqa</span><span class="o">.</span><span class="n">quantity</span><span class="p">(</span><span class="n">pwvmedian</span><span class="p">,</span><span class="s1">&#39;mm&#39;</span><span class="p">))</span>

        <span class="c1"># Now calculate the model based on inputs provided above and get the transmission out</span>
        <span class="n">dry</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">myat</span><span class="o">.</span><span class="n">getDryOpacitySpec</span><span class="p">(</span><span class="mi">0</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span> <span class="c1"># CO, O3, etc. </span>
        <span class="n">wet</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">myat</span><span class="o">.</span><span class="n">getWetOpacitySpec</span><span class="p">(</span><span class="mi">0</span><span class="p">)[</span><span class="mi">1</span><span class="p">][</span><span class="s1">&#39;value&#39;</span><span class="p">])</span> <span class="c1"># water absorption</span>
        <span class="n">transmission</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">airmass</span><span class="o">*</span><span class="p">(</span><span class="n">wet</span><span class="o">+</span><span class="n">dry</span><span class="p">))</span> <span class="c1"># e^-tau; </span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">Band</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">]:</span>
            <span class="n">dry_SB</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">myat</span><span class="o">.</span><span class="n">getDryOpacitySpec</span><span class="p">(</span><span class="mi">1</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">wet_SB</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">myat</span><span class="o">.</span><span class="n">getWetOpacitySpec</span><span class="p">(</span><span class="mi">1</span><span class="p">)[</span><span class="mi">1</span><span class="p">][</span><span class="s1">&#39;value&#39;</span><span class="p">])</span>
            <span class="n">transmission_SB</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">airmass</span><span class="o">*</span><span class="p">(</span><span class="n">wet_SB</span><span class="o">+</span><span class="n">dry_SB</span><span class="p">))</span>

        <span class="c1"># Close the tools</span>
        <span class="n">myat</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="n">myqa</span><span class="o">.</span><span class="n">done</span><span class="p">()</span>

        <span class="c1"># caution, there is a netsideband affect - LSB and USB</span>
        <span class="c1"># if netsideband %2 == 0 then sense = 2, else 1</span>
        <span class="c1"># if 1, the trasnsmission flips over the loop in channels </span>

        <span class="n">mytb</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">msname</span><span class="o">+</span><span class="s1">&#39;/SPECTRAL_WINDOW&#39;</span><span class="p">)</span>
        <span class="n">refFreq</span> <span class="o">=</span> <span class="n">mytb</span><span class="o">.</span><span class="n">getcol</span><span class="p">(</span><span class="s1">&#39;REF_FREQUENCY&#39;</span><span class="p">)</span>
        <span class="n">net_sideband</span> <span class="o">=</span> <span class="n">mytb</span><span class="o">.</span><span class="n">getcol</span><span class="p">(</span><span class="s1">&#39;NET_SIDEBAND&#39;</span><span class="p">)</span>
        <span class="n">measFreqRef</span> <span class="o">=</span> <span class="n">mytb</span><span class="o">.</span><span class="n">getcol</span><span class="p">(</span><span class="s1">&#39;MEAS_FREQ_REF&#39;</span><span class="p">)</span>
        <span class="n">spwname</span><span class="o">=</span><span class="n">mytb</span><span class="o">.</span><span class="n">getcol</span><span class="p">(</span><span class="s1">&#39;NAME&#39;</span><span class="p">)</span>
        <span class="n">mytb</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="n">sense</span><span class="o">=</span><span class="mi">0</span>
        <span class="c1"># LSB are =1, USB are +2 - lower need reversing</span>
        <span class="k">if</span> <span class="n">refFreq</span><span class="p">[</span><span class="n">ispw</span><span class="p">]</span><span class="o">*</span><span class="mf">1e-9</span><span class="o">&gt;</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">freqs</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">net_sideband</span><span class="p">[</span><span class="n">ispw</span><span class="p">]</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">sense</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sense</span> <span class="o">=</span> <span class="mi">2</span>

        <span class="k">if</span> <span class="n">sense</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;********* REVERSING THE ATM FOUND FOR LSB ***********&#39;</span><span class="p">)</span>
            <span class="n">transmission</span> <span class="o">=</span> <span class="n">transmission</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># reverse the order</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">Band</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">]:</span>
                <span class="n">transmission_SB</span> <span class="o">=</span> <span class="n">transmission_SB</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        
        <span class="c1"># Hanning implementation:</span>
        <span class="c1"># Smooth the calculated transmission profile by a Hanning kernel</span>
        <span class="c1"># and then &quot;decimate&quot; the smoothed signal back down to the correct</span>
        <span class="c1"># number of channels. The Hanning smoothing sometimes drops the </span>
        <span class="c1"># edge channels which doesn&#39;t actually affect the data (even if it&#39;s</span>
        <span class="c1"># applied) but looks bad. So we set the edge channels equal to the </span>
        <span class="c1"># one next to it so it looks better.</span>
        <span class="c1">#transmission = np.convolve(transmission, [0, 0.25, 0.5, 0.25, 0], mode=&#39;same&#39;)</span>
        <span class="c1">#transmission = transmission[::binningFactor]</span>
        <span class="c1">#transmission[0] = transmission[1]</span>
        <span class="c1">#transmission[-1] = transmission[-2]</span>
        <span class="c1">#if self.Band in [9, 10]:</span>
        <span class="c1">#    transmission_SB = np.convolve(transmission_SB, [0, 0.25, 0.5, 0.25, 0], mode=&#39;same&#39;)</span>
        <span class="c1">#    transmission_SB = transmission_SB[::binningFactor]</span>
        <span class="c1">#    transmission_SB[0] = transmission_SB[1]</span>
        <span class="c1">#    transmission_SB[-1] = transmission_SB[-2]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">Band</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">]:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">transmission</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">transmission_SB</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">transmission</span></div>


<div class="viewcode-block" id="ACreNorm.onlineBinningFactor">
<a class="viewcode-back" href="../../../_autosummary/pipeline.extern.almarenorm_pl2023.ACreNorm.html#pipeline.h.tasks.restoredata.restoredata.ACreNorm.onlineBinningFactor">[docs]</a>
    <span class="k">def</span> <span class="nf">onlineBinningFactor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Purpose:</span>
<span class="sd">            Return the online channel binning factor for the relevant spectral</span>
<span class="sd">            windows. Note that for early data (&lt;Cycle 3) this will return the </span>
<span class="sd">            wrong values (i.e. it always returns 1).</span>

<span class="sd">            This is only used in the Hanning smoothing application of ATM </span>
<span class="sd">            corrections which is currently not implemented.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mytb</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">msname</span><span class="o">+</span><span class="s1">&#39;/SPECTRAL_WINDOW&#39;</span><span class="p">)</span>
        <span class="n">bins</span> <span class="o">=</span> <span class="n">mytb</span><span class="o">.</span><span class="n">getcol</span><span class="p">(</span><span class="s1">&#39;SDM_NUM_BIN&#39;</span><span class="p">)</span>
        <span class="n">mytb</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">bins</span></div>



    <span class="c1"># LM added </span>
    <span class="k">def</span> <span class="nf">ATMcorrection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">R</span><span class="p">,</span><span class="n">inscan</span><span class="p">,</span> <span class="n">inspw</span><span class="p">,</span> <span class="n">infld</span><span class="p">,</span> <span class="n">calscan</span><span class="p">,</span> <span class="n">calname</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="c1"># this is the code that will do the real difference between the </span>
        <span class="c1"># bandpass and the input target and make a correction to the </span>
        <span class="c1"># R, i.e the target AC / Bp AC</span>
        
        <span class="c1"># R is the AC input</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39; ***** Doing an ATM transmission correction for the ATM line in spw&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">inspw</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39; scan&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">inscan</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39; field&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">infld</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;*****&#39;</span><span class="p">)</span>

        <span class="c1"># crude theory here - just correct back in by the BP (or phase) and Target model transmission curves </span>
        <span class="c1"># R is Tar / bandpass   (or phase)</span>
        <span class="c1"># so we multiply back in the ATM ? </span>
        <span class="n">fldnam</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">msmeta</span><span class="o">.</span><span class="n">namesforfields</span><span class="p">(</span><span class="n">infld</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>  

        <span class="c1"># imporved way - get ratio spectrum to find actually differences and then median outside ant loop</span>
        <span class="c1">#</span>
        <span class="c1"># AL - Is this the right order??? Souldn&#39;t it be Bandpass/Target?? Also, does it make sense to subtract the medians </span>
        <span class="c1">#      first rather than multiplying the ratio and then subtract the median?</span>
        <span class="c1">#       - The order is indeed correct. The ACs are basically Tsys measurements which are a </span>
        <span class="c1">#         measure of the sky brightness which has an atmospheric contribution equal to e^tau.</span>
        <span class="c1">#         Therefore, to mitigate this effect, we must multiply by e^-tau which we estimate</span>
        <span class="c1">#         via the atmospheric model. </span>
        <span class="c1">#       - I do think that using the median causes ill effects and is the wrong thing to do.</span>
        <span class="c1">#         It ends up changing the line peaks even away from the atm features. Therefore, I </span>
        <span class="c1">#         removed it. </span>
        <span class="c1">#    - There are additional effects that are still present because 1) the models aren&#39;t perfect</span>
        <span class="c1">#      but 2) there are additional terms for when a line is located in an atm line because that</span>
        <span class="c1">#      line is being attenuated by e^-tau. Currently, all we are doing is the simple first step.</span>
        <span class="c1">#ratioATM = self.atmtrans[fldnam][str(inspw)][str(inscan)] / self.atmtrans[calfld][str(inspw)][calscan]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">Band</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">]:</span>
            <span class="n">sidebands</span><span class="o">=</span><span class="mi">2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sidebands</span><span class="o">=</span><span class="mi">1</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sidebands</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">sidebands</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">trg_atm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atmtrans</span><span class="p">[</span><span class="n">fldnam</span><span class="p">][</span><span class="nb">str</span><span class="p">(</span><span class="n">inspw</span><span class="p">)][</span><span class="nb">str</span><span class="p">(</span><span class="n">inscan</span><span class="p">)][</span><span class="n">i</span><span class="p">]</span>
                <span class="n">cal_atm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atmtrans</span><span class="p">[</span><span class="n">calname</span><span class="p">][</span><span class="nb">str</span><span class="p">(</span><span class="n">inspw</span><span class="p">)][</span><span class="nb">str</span><span class="p">(</span><span class="n">calscan</span><span class="p">)][</span><span class="n">i</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">trg_atm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atmtrans</span><span class="p">[</span><span class="n">fldnam</span><span class="p">][</span><span class="nb">str</span><span class="p">(</span><span class="n">inspw</span><span class="p">)][</span><span class="nb">str</span><span class="p">(</span><span class="n">inscan</span><span class="p">)]</span>
                <span class="n">cal_atm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atmtrans</span><span class="p">[</span><span class="n">calname</span><span class="p">][</span><span class="nb">str</span><span class="p">(</span><span class="n">inspw</span><span class="p">)][</span><span class="nb">str</span><span class="p">(</span><span class="n">calscan</span><span class="p">)]</span>                
            <span class="n">ratioATM</span> <span class="o">=</span> <span class="n">trg_atm</span><span class="o">/</span><span class="n">cal_atm</span> 
            <span class="c1">#ratioMed = np.array(np.median(ratioATM))</span>
            <span class="c1"># shift to baseline of average 1.0</span>
            <span class="c1">#ratioATM = ratioATM + (1.0 - ratioMed)</span>

            <span class="k">for</span> <span class="n">jcor</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">R</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="k">for</span> <span class="n">lpant</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">R</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]):</span>
                    <span class="c1"># TESTING casalog.post(&#39;ATM correcting corr &#39;+str(jcor)+&#39; antenna &#39;+str(lpant))</span>
                    
                    <span class="c1"># simple correction, the target is attenuated by its own ATM, so we multiply back</span>
                    <span class="c1"># whereas &quot;R&quot; here is Tar_AC/BP_AC and so to correct the BP attenuated by its own</span>
                    <span class="c1"># ATM profile we have to divide by BP ATM</span>
                    <span class="c1"># essntially we are multiplying R by (Tar_ATM/BP_ATM) - NB first test was doing just that and result were actually good</span>
                    <span class="c1">## OLD FIRST WAY R[jcor,:,lpant] = R[jcor,:,lpant] * (self.atmtrans[fldnam][str(inspw)][str(inscan)] / self.atmtrans[calfld][str(inspw)][calscan])</span>
                    <span class="n">R</span><span class="p">[</span><span class="n">jcor</span><span class="p">,:,</span><span class="n">lpant</span><span class="p">]</span> <span class="o">=</span> <span class="n">R</span><span class="p">[</span><span class="n">jcor</span><span class="p">,:,</span><span class="n">lpant</span><span class="p">]</span> <span class="o">*</span> <span class="n">ratioATM</span>

                    <span class="c1"># - improved method - set already R to ~1.0 median and the ATM ratio spectrum (done above), then correct (more notes below)</span>
                    <span class="c1">#medR = np.array(np.median(R[jcor,:,lpant]))</span>
                    <span class="c1">#R[jcor,:,lpant] = (R[jcor,:,lpant]+(1.0-medR)) * ratioATM                </span>

        <span class="c1"># LM notes:</span>

        <span class="c1"># first crude tests:</span>
        <span class="c1"># applying the correction directly as the ratio only between Tar_ATM/BP_ARM as</span>
        <span class="c1"># a multiplication accross the entire SPW will act to change the scaling</span>
        <span class="c1"># from real astronomical lines. e.g.,</span>
        <span class="c1"># - imagine an scaling spectrum (Tar_AutoCorr/BP_AutoCorr) with a baseline at ~0.9, an astronomical line that peaks at 1.2 </span>
        <span class="c1"># in the middle of the SPW, and away from the ATM line that causes a dip down to 0.8 at the upper edge</span>
        <span class="c1"># if one were to fit this to obtain the scaling spectrum, the peak rescaling is 1.3, i.e. 1.0-0.9 = 0.1 + 1.2 peak.</span>
        <span class="c1"># - consider the ratio of ATM transmission (Tar_ATM/BP_ATM) is ~0.95 AWAY from the ATM line and 1.15 at the ATM feature</span>
        <span class="c1"># this means the baseline of the scaling spectrum * ratio ATM transmission becomes 0.9 * 0.95 -&gt; 0.855</span>
        <span class="c1"># while the peak astronomical line will become 1.2 * 0.95 -&gt; 1.14</span>
        <span class="c1"># the ATM line would be almost entirely corrected out, i.e 0.8 * 1.1 -&gt; 0.88 - close to the new baseline</span>
        <span class="c1"># however now fitting this spectrum, the baseline to peak astronomical line is 1.0-0.855 + 1.14 = 1.285</span>
        <span class="c1"># thus the overall peak resacling as reduced by 1.3 - 1.285 = 0.015, 1.5%</span>
        <span class="c1"># -- the point is the ATM ratio, and the Tar_AC/BP_AC spectra are not baselined, the have </span>
        <span class="c1">#    an aribtary baseline y scale.</span>

        <span class="c1">## anyway, better to get average and apply</span>
        <span class="c1"># (i) shift all &quot;R&quot; scaling spectra to a baseline of ~1 (i.e. like first part of fitting code does anyway)</span>
        <span class="c1"># (ii) shift the ATM trans ratio correction to a baseline of 1</span>
        <span class="c1"># (iii) apply the multiplication, only regions close to the ATM line, i.e. not = 1 will</span>
        <span class="c1">#       but changed - i.e. more-or-less correcting out the ATM line residual between target and BP</span>
        <span class="c1">#  there is some low level &#39;shape&#39; remainig in the ATM line channels -  but </span>
        <span class="c1">#  this correction is made before the fitting, which goes &#39;bad/divergent&#39; when ATM lines exist as</span>
        <span class="c1"># lorenzian like profiles and cannot be fitted out - this code doesn&#39;t need to fully correct </span>
        <span class="c1"># the ATM profile, it should just remove most of the ATM residual differences so the rest of the </span>
        <span class="c1"># renorm code can handle fitting the scaling spectrum</span>
        
        <span class="c1"># option, maybe set the ATM ratio spectrum to 1.0 i.e. no scaling to any channels</span>
        <span class="c1"># except where the ATM transmission is deeper than a given value ?</span>
        
        <span class="c1"># TESTING TO CODE - i.e. run with and without ATM on many data and see effect on % scaling</span>

    <span class="c1"># No return acts on the rescaling spectrum directly </span>

<div class="viewcode-block" id="ACreNorm.suggestAtmExclude">
<a class="viewcode-back" href="../../../_autosummary/pipeline.extern.almarenorm_pl2023.ACreNorm.html#pipeline.h.tasks.restoredata.restoredata.ACreNorm.suggestAtmExclude">[docs]</a>
    <span class="k">def</span> <span class="nf">suggestAtmExclude</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">spw</span><span class="p">,</span> <span class="n">return_command</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">return_dict</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Purpose:</span>
<span class="sd">            Given that renormalization() has been run with the checkFalsePositives=True</span>
<span class="sd">            flag, the self.atmMask attribute has been filled with information where</span>
<span class="sd">            there are atmospheric features in the spectrum. This function will merge</span>
<span class="sd">            the masks from all scans and suggest channel ranges that one may input back</span>
<span class="sd">            into renormalization() using the excludechan parameter. </span>

<span class="sd">        Inputs:</span>
<span class="sd">            target : string</span>
<span class="sd">                The target source evaluated in renormalization()</span>

<span class="sd">            spw : string</span>
<span class="sd">                The spectral window you wish to evaluate a mask for assuming that it</span>
<span class="sd">                was also run in the renormalization() call. </span>

<span class="sd">            return_command : boolean : OPTIONAL</span>
<span class="sd">                If set to True, then a string is returned with the correct syntax to</span>
<span class="sd">                put into the excludechan option of a self.renormalization() call.</span>
<span class="sd">                Default: False</span>

<span class="sd">            return_dict : boolean : OPTIONAL</span>
<span class="sd">                If set to True, then a dictionary is returned with the correct syntax</span>
<span class="sd">                to fill the excludechan parameter of the self.renormalize() method.</span>
<span class="sd">                Default: False</span>
<span class="sd">                NOTE: This takes priority over return_command if both are set to True.</span>

<span class="sd">        Outputs:</span>
<span class="sd">            A list of list pairs suggesting ranges for input into the excludechan </span>
<span class="sd">            option of renormalization().</span>
<span class="sd">        &quot;&quot;&quot;</span>


        <span class="k">def</span> <span class="nf">subsets</span><span class="p">(</span><span class="n">chans</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Purpose: Find subset ranges within an array of consecutive values and</span>
<span class="sd">                     return the sub-ranges.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">class</span> <span class="nc">groupby</span><span class="p">:</span>
                <span class="c1"># A subset task of the itertools package.</span>
                <span class="c1"># https://docs.python.org/3/library/itertools.html#itertools.groupby</span>

                <span class="c1"># [k for k, g in groupby(&#39;AAAABBBCCDAABBB&#39;)] --&gt; A B C D A B</span>
                <span class="c1"># [list(g) for k, g in groupby(&#39;AAAABBBCCD&#39;)] --&gt; AAAA BBB CC D</span>
                <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iterable</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">key</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">keyfunc</span> <span class="o">=</span> <span class="n">key</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">it</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">iterable</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">tgtkey</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">currkey</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">currvalue</span> <span class="o">=</span> <span class="nb">object</span><span class="p">()</span>

                <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                    <span class="k">return</span> <span class="bp">self</span>

                <span class="k">def</span> <span class="fm">__next__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="nb">object</span><span class="p">()</span>
                    <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">currkey</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">tgtkey</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">currvalue</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">it</span><span class="p">)</span>    <span class="c1"># Exit on StopIteration</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">currkey</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">keyfunc</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">currvalue</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">tgtkey</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">currkey</span>
                    <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">currkey</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grouper</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tgtkey</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">))</span>

                <span class="k">def</span> <span class="nf">_grouper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tgtkey</span><span class="p">,</span> <span class="nb">id</span><span class="p">):</span>
                    <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">id</span> <span class="ow">is</span> <span class="nb">id</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">currkey</span> <span class="o">==</span> <span class="n">tgtkey</span><span class="p">:</span>
                        <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">currvalue</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">currvalue</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">it</span><span class="p">)</span>
                        <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
                            <span class="k">return</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">currkey</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">keyfunc</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">currvalue</span><span class="p">)</span>

            <span class="k">def</span> <span class="nf">itemgetter</span><span class="p">(</span><span class="o">*</span><span class="n">items</span><span class="p">):</span>
                <span class="c1"># A subset task of the operator package.</span>
                <span class="c1"># https://docs.python.org/3/library/operator.html#operator.itemgetter</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">items</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">item</span> <span class="o">=</span> <span class="n">items</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
                        <span class="k">return</span> <span class="n">obj</span><span class="p">[</span><span class="n">item</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
                        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">obj</span><span class="p">[</span><span class="n">item</span><span class="p">]</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">items</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">g</span>

            <span class="k">def</span> <span class="nf">consecutive_groups</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">ordering</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">):</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                A subset of the more-itertools package.</span>
<span class="sd">                https://more-itertools.readthedocs.io/en/stable</span>
<span class="sd">                        /_modules/more_itertools/more.html#consecutive_groups</span>

<span class="sd">                Yield groups of consecutive items using :func:`itertools.groupby`.</span>
<span class="sd">                The *ordering* function determines whether two items are adjacent by</span>
<span class="sd">                returning their position.</span>

<span class="sd">                By default, the ordering function is the identity function. This is</span>
<span class="sd">                suitable for finding runs of numbers:</span>

<span class="sd">                    &gt;&gt;&gt; iterable = [1, 10, 11, 12, 20, 30, 31, 32, 33, 40]</span>
<span class="sd">                    &gt;&gt;&gt; for group in consecutive_groups(iterable):</span>
<span class="sd">                    ...     print(list(group))</span>
<span class="sd">                    [1]</span>
<span class="sd">                    [10, 11, 12]</span>
<span class="sd">                    [20]</span>
<span class="sd">                    [30, 31, 32, 33]</span>
<span class="sd">                    [40]</span>

<span class="sd">                For finding runs of adjacent letters, try using the :meth:`index` method</span>
<span class="sd">                of a string of letters:</span>

<span class="sd">                    &gt;&gt;&gt; from string import ascii_lowercase</span>
<span class="sd">                    &gt;&gt;&gt; iterable = &#39;abcdfgilmnop&#39;</span>
<span class="sd">                    &gt;&gt;&gt; ordering = ascii_lowercase.index</span>
<span class="sd">                    &gt;&gt;&gt; for group in consecutive_groups(iterable, ordering):</span>
<span class="sd">                    ...     print(list(group))</span>
<span class="sd">                    [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]</span>
<span class="sd">                    [&#39;f&#39;, &#39;g&#39;]</span>
<span class="sd">                    [&#39;i&#39;]</span>
<span class="sd">                    [&#39;l&#39;, &#39;m&#39;, &#39;n&#39;, &#39;o&#39;, &#39;p&#39;]</span>

<span class="sd">                Each group of consecutive items is an iterator that shares it source with</span>
<span class="sd">                *iterable*. When an an output group is advanced, the previous group is</span>
<span class="sd">                no longer available unless its elements are copied (e.g., into a ``list``).</span>

<span class="sd">                    &gt;&gt;&gt; iterable = [1, 2, 11, 12, 21, 22]</span>
<span class="sd">                    &gt;&gt;&gt; saved_groups = []</span>
<span class="sd">                    &gt;&gt;&gt; for group in consecutive_groups(iterable):</span>
<span class="sd">                    ...     saved_groups.append(list(group))  # Copy group elements</span>
<span class="sd">                    &gt;&gt;&gt; saved_groups</span>
<span class="sd">                    [[1, 2], [11, 12], [21, 22]]</span>

<span class="sd">                Borrowed for PL use from https://pypi.org/project/more-itertools/</span>
<span class="sd">                &quot;&quot;&quot;</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">groupby</span><span class="p">(</span>
                    <span class="nb">enumerate</span><span class="p">(</span><span class="n">iterable</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">ordering</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="p">):</span>
                    <span class="k">yield</span> <span class="nb">map</span><span class="p">(</span><span class="n">itemgetter</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">g</span><span class="p">)</span>

            <span class="n">subsets</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">group</span><span class="p">)</span> <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">consecutive_groups</span><span class="p">(</span><span class="n">chans</span><span class="p">)]</span>
            <span class="n">ranges</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">ss</span> <span class="ow">in</span> <span class="n">subsets</span><span class="p">:</span>
                <span class="n">ranges</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="nb">min</span><span class="p">(</span><span class="n">ss</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">ss</span><span class="p">)])</span>
            <span class="k">return</span> <span class="n">ranges</span>

        <span class="c1"># Get list of scans that were evaluated</span>
        <span class="n">scans</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atmMask</span><span class="p">[</span><span class="n">target</span><span class="p">][</span><span class="n">spw</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

        <span class="c1"># We need to compile a &quot;complete&quot; atmospheric mask. Since the objects may set throughout</span>
        <span class="c1"># the course of an observation, the atmospheric profile can get worse, leading to a </span>
        <span class="c1"># slightly different profile with wider wings. This compiles all the atmospheric masks</span>
        <span class="c1"># together into a single, full mask. </span>
        <span class="c1">#</span>
        <span class="c1"># Note that the self.atmMask arrays are set to True where atmospheric features were found</span>
        <span class="c1"># and False otherwise.</span>
        <span class="n">full_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atmMask</span><span class="p">[</span><span class="n">target</span><span class="p">][</span><span class="n">spw</span><span class="p">][</span><span class="n">scans</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">scans</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">scan</span> <span class="ow">in</span> <span class="n">scans</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="n">full_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">full_mask</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">atmMask</span><span class="p">[</span><span class="n">target</span><span class="p">][</span><span class="n">spw</span><span class="p">][</span><span class="n">scan</span><span class="p">])</span>

        <span class="c1"># With the full mask, get the channel numbers where there are atmospheric features and </span>
        <span class="c1"># calculate the channel ranges of the features.</span>
        <span class="n">atm_channels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">full_mask</span> <span class="o">==</span> <span class="kc">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">ranges</span> <span class="o">=</span> <span class="n">subsets</span><span class="p">(</span><span class="n">atm_channels</span><span class="p">)</span>

        <span class="c1"># Return either the ranges themselves or a flagging command compiling the ranges.</span>
        <span class="k">if</span> <span class="n">return_dict</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ranges</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">{</span><span class="nb">str</span><span class="p">(</span><span class="n">spw</span><span class="p">):</span><span class="s1">&#39;&#39;</span><span class="p">}</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">ranges</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">full_range</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
                <span class="k">for</span> <span class="n">rng</span> <span class="ow">in</span> <span class="n">ranges</span><span class="p">:</span>
                    <span class="n">full_range</span><span class="o">+=</span><span class="nb">str</span><span class="p">(</span><span class="n">rng</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">+</span><span class="s1">&#39;~&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">rng</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">+</span><span class="s1">&#39;;&#39;</span>
                <span class="k">return</span> <span class="p">{</span><span class="nb">str</span><span class="p">(</span><span class="n">spw</span><span class="p">):</span> <span class="n">full_range</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]}</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">{</span><span class="nb">str</span><span class="p">(</span><span class="n">spw</span><span class="p">):</span> <span class="nb">str</span><span class="p">(</span><span class="n">ranges</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span><span class="o">+</span><span class="s1">&#39;~&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">ranges</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])}</span>
        <span class="k">elif</span> <span class="n">return_command</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ranges</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="s1">&#39;No flagging suggested.&#39;</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">ranges</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">cmd</span> <span class="o">=</span> <span class="s1">&#39;excludechan={&quot;&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">spw</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;&quot;:&quot;&#39;</span>
                <span class="k">for</span> <span class="n">rng</span> <span class="ow">in</span> <span class="n">ranges</span><span class="p">:</span>
                    <span class="n">cmd</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="n">rng</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">+</span><span class="s1">&#39;~&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">rng</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">+</span><span class="s1">&#39;;&#39;</span>
                <span class="n">cmd</span> <span class="o">=</span> <span class="n">cmd</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;&quot;}&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cmd</span> <span class="o">=</span> <span class="s1">&#39;excludechan={&quot;&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">spw</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;&quot;:&quot;&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">ranges</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span><span class="o">+</span><span class="s1">&#39;~&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">ranges</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span><span class="o">+</span><span class="s1">&#39;&quot;}&#39;</span>
            <span class="k">return</span> <span class="n">cmd</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ranges</span></div>


<div class="viewcode-block" id="ACreNorm.recordApply">
<a class="viewcode-back" href="../../../_autosummary/pipeline.extern.almarenorm_pl2023.ACreNorm.html#pipeline.h.tasks.restoredata.restoredata.ACreNorm.recordApply">[docs]</a>
    <span class="k">def</span> <span class="nf">recordApply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scanout</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">spwout</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fldout</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Purpose:</span>
<span class="sd">            This will write to the history of the dataset upon application of</span>
<span class="sd">            renorm (i.e. self.renormalize(docorr=True)). Within the </span>
<span class="sd">            renormalize() method, a check of the MS HISTORY table is performed</span>
<span class="sd">            to ensure that double application is avoided. </span>

<span class="sd">        Inputs:</span>
<span class="sd">            scanout, spwout, fldout : int : OPTIONAL</span>
<span class="sd">                The scan, spw, and field numbers where renormalization was </span>
<span class="sd">                applied. If set to None then a generic message is filled.</span>
<span class="sd">            Default: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">scanout</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">spwout</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">fldout</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">messageIn</span> <span class="o">=</span> <span class="s1">&#39;ReNormalization correction applied to spw&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">spwout</span><span class="p">)</span> \
                    <span class="o">+</span><span class="s1">&#39; scan&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">scanout</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39; field&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">fldout</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39; &#39;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">RNversion</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">messageIn</span> <span class="o">=</span> <span class="s1">&#39;ReNormalization correction applied &#39;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">RNversion</span>
        <span class="n">myms</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">msname</span><span class="p">)</span>
        <span class="n">myms</span><span class="o">.</span><span class="n">writehistory</span><span class="p">(</span><span class="n">messageIn</span><span class="p">)</span>
        <span class="n">myms</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></div>


    <span class="k">def</span> <span class="nf">checkApply</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># just need to get the history column</span>
        <span class="c1"># appears that list history is useless and only writes to the logger ?</span>
        <span class="n">mytb</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">msname</span><span class="o">+</span><span class="s1">&#39;/HISTORY&#39;</span><span class="p">)</span>
        <span class="n">messageOut</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">mytb</span><span class="o">.</span><span class="n">getcol</span><span class="p">(</span><span class="s1">&#39;MESSAGE&#39;</span><span class="p">))</span>
        <span class="n">applyStatus</span> <span class="o">=</span> <span class="kc">False</span> <span class="c1"># i.e. assume not applied</span>
        <span class="k">for</span> <span class="n">messLine</span> <span class="ow">in</span> <span class="n">messageOut</span><span class="p">:</span>
            <span class="c1"># only need to check for this statement</span>
            <span class="k">if</span> <span class="s1">&#39;ReNormalization&#39;</span> <span class="ow">in</span> <span class="n">messLine</span><span class="p">:</span>
                <span class="n">applyStatus</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">mytb</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">applyStatus</span>

<div class="viewcode-block" id="ACreNorm.getband">
<a class="viewcode-back" href="../../../_autosummary/pipeline.extern.almarenorm_pl2023.ACreNorm.html#pipeline.h.tasks.restoredata.restoredata.ACreNorm.getband">[docs]</a>
    <span class="k">def</span> <span class="nf">getband</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">freq</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; </span>
<span class="sd">        Identify the Band for specific frequency (in GHz)</span>

<span class="sd">        Note that the Band 2/3 identification is currently not</span>
<span class="sd">        guaranteed to be correct.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lo</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">35</span><span class="p">,</span><span class="mi">67</span><span class="p">,</span><span class="mi">84</span><span class="p">,</span><span class="mi">125</span><span class="p">,</span><span class="mi">157</span><span class="p">,</span><span class="mi">211</span><span class="p">,</span><span class="mi">275</span><span class="p">,</span><span class="mi">385</span><span class="p">,</span><span class="mi">602</span><span class="p">,</span><span class="mi">787</span><span class="p">])</span><span class="o">*</span><span class="mf">1e9</span>
        <span class="n">hi</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">50</span><span class="p">,</span><span class="mf">83.999999999</span><span class="p">,</span><span class="mi">116</span><span class="p">,</span><span class="mi">163</span><span class="p">,</span><span class="mi">212</span><span class="p">,</span><span class="mi">275</span><span class="p">,</span><span class="mi">373</span><span class="p">,</span><span class="mi">500</span><span class="p">,</span><span class="mi">720</span><span class="p">,</span><span class="mi">950</span><span class="p">])</span><span class="o">*</span><span class="mf">1e9</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">lo</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)[(</span><span class="n">freq</span><span class="o">&gt;</span><span class="n">lo</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="n">freq</span><span class="o">&lt;</span><span class="n">hi</span><span class="p">)][</span><span class="mi">0</span><span class="p">]</span></div>


<div class="viewcode-block" id="ACreNorm.writeTsysTemps">
<a class="viewcode-back" href="../../../_autosummary/pipeline.extern.almarenorm_pl2023.ACreNorm.html#pipeline.h.tasks.restoredata.restoredata.ACreNorm.writeTsysTemps">[docs]</a>
    <span class="k">def</span> <span class="nf">writeTsysTemps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dictIn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rettemplist</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Purpose:</span>
<span class="sd">            Uses the dictionary from the Tsys Plotting code and will return a</span>
<span class="sd">            list with each element being a line to be entered into the </span>
<span class="sd">            tsystemplate in PL style</span>

<span class="sd">            Optionally, an input dictionary in correct syntax can be passed. </span>
<span class="sd">          </span>
<span class="sd">            Using retflchan=True in the plotRelTsysSpectra() method will save</span>
<span class="sd">            the dictionary to the argument of the call if you want a manual </span>
<span class="sd">            view of the dict or to see and edit and input manually into this </span>
<span class="sd">            flag_lines code.</span>

<span class="sd">            NOTE: This is to be used with caution as it has not been validated</span>
<span class="sd">            yet and is mainly for helping with manual DR only!!!</span>
<span class="sd">        </span>
<span class="sd">        Inputs:</span>
<span class="sd">            dictIn : dictionary : OPTIONAL</span>
<span class="sd">                If desired, a user may input a dictionary of flags. If one is</span>
<span class="sd">                not input, then the output of self.plotRelTsysSpectra() is used</span>
<span class="sd">                instead.</span>
<span class="sd">                Default: None</span>

<span class="sd">            rettemplist : boolean : OPTIONAL</span>
<span class="sd">                If set to True, then the flags constructed during this script, </span>
<span class="sd">                in addition to being written to a file via self.writeTsysFlags(),</span>
<span class="sd">                will be returned as a list of strings.</span>

<span class="sd">        Outputs:</span>
<span class="sd">            A file of Tsys flags is written via the self.writeTsysFlags() method.</span>
<span class="sd">            Additionally, if rettemplist=True, a list of strings is returned that</span>
<span class="sd">            contains all the flagging commands.</span>
<span class="sd">       </span>
<span class="sd">        Suggestions for Improvement:</span>
<span class="sd">            - Syntax is not currently explicity checked for the dictIn option. </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">dictIn</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">dictIn</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">dict</span><span class="p">:</span>
                <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;Option dictIn must be a dictionary!&#39;</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                        <span class="s1">&#39;Option dictIn of writeTsysTemps() must be a dictionary.&#39;</span>
                        <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dictIn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">TsysReturn</span>
            
        <span class="n">listToKeep</span><span class="o">=</span><span class="p">[]</span>
        <span class="n">TDM</span><span class="o">=</span><span class="kc">True</span>
        <span class="k">for</span> <span class="n">keyuse</span> <span class="ow">in</span> <span class="n">dictIn</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">spwKeep</span> <span class="o">=</span> <span class="n">keyuse</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;=&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="c1"># then sub layer is the scan key - not intent based its </span>
            <span class="c1"># code based on Tsys TARGET intent scans </span>
            <span class="n">scanKeys</span> <span class="o">=</span> <span class="n">dictIn</span><span class="p">[</span><span class="n">keyuse</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
            <span class="c1"># check if the Tsys are in same SPW setup, i.e. in the fdmspws, then ACA </span>
            <span class="c1"># and uses a slightly different option in channel_ranges funct.</span>
            <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="n">spwKeep</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fdmspws</span><span class="p">:</span>
                <span class="n">TDM</span><span class="o">=</span><span class="kc">False</span>
            <span class="k">for</span> <span class="n">scankeyuse</span> <span class="ow">in</span> <span class="n">scanKeys</span><span class="p">:</span>
                <span class="n">scanKeep</span><span class="o">=</span> <span class="n">scankeyuse</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;=&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="c1"># pass to channel_ranges which will do some consolidation and buffering (i.e. few extra channels)</span>
                <span class="n">chanRans</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel_ranges</span><span class="p">(</span><span class="n">dictIn</span><span class="p">[</span><span class="n">keyuse</span><span class="p">][</span><span class="n">scankeyuse</span><span class="p">],</span> <span class="n">TDM</span><span class="o">=</span><span class="n">TDM</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">chanranlp</span> <span class="ow">in</span> <span class="n">chanRans</span><span class="p">:</span>
                    <span class="n">spwStrUse</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">spwKeep</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;:&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">chanranlp</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">+</span><span class="s1">&#39;~&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">chanranlp</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

                    <span class="n">listToKeep</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;mode=</span><span class="se">\&#39;</span><span class="s2">manual</span><span class="se">\&#39;</span><span class="s2"> spw=</span><span class="se">\&#39;</span><span class="si">{}</span><span class="se">\&#39;</span><span class="s2"> scan=</span><span class="se">\&#39;</span><span class="si">{}</span><span class="se">\&#39;</span><span class="s2"> reason=</span><span class="se">\&#39;</span><span class="s2">QA2:tsysflag_tsys_channel</span><span class="se">\&#39;</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">spwStrUse</span><span class="p">,</span><span class="n">scanKeep</span><span class="p">))</span>   

        <span class="c1"># already write the file here for the logs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">writeTsysFlags</span><span class="p">(</span><span class="n">listToKeep</span><span class="p">)</span>

        <span class="c1"># passes out template list to argument as option</span>
        <span class="k">if</span> <span class="n">rettemplist</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">listToKeep</span>  </div>


<div class="viewcode-block" id="ACreNorm.channel_ranges">
<a class="viewcode-back" href="../../../_autosummary/pipeline.extern.almarenorm_pl2023.ACreNorm.html#pipeline.h.tasks.restoredata.restoredata.ACreNorm.channel_ranges">[docs]</a>
    <span class="k">def</span> <span class="nf">channel_ranges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">channels</span><span class="p">,</span> <span class="n">TDM</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Purpose:</span>
<span class="sd">            Given a list of channels, this will return a list of ranges that </span>
<span class="sd">            describe them accounting for a buffer and gap in input that can be assumed </span>
<span class="sd">            as consecutive.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">channels</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        
        <span class="k">if</span> <span class="n">TDM</span><span class="p">:</span>
            <span class="n">addChan</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">gapChan</span> <span class="o">=</span> <span class="mi">3</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># To combat piece wise flags due to channels triggering just around</span>
            <span class="c1"># the threshold, set extra buffers.</span>
            <span class="n">addChan</span> <span class="o">=</span> <span class="mi">5</span>
            <span class="n">gapChan</span> <span class="o">=</span> <span class="mi">10</span> 

        <span class="n">channel_range</span> <span class="o">=</span> <span class="p">[</span><span class="n">channels</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">addChan</span><span class="p">,</span> <span class="n">channels</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="c1"># gives a wider flag buffer </span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">chan</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">channels</span><span class="p">):</span>
            <span class="c1"># checks if a gap of 3 and assumes continous</span>
            <span class="k">if</span> <span class="n">chan</span> <span class="o">&lt;=</span> <span class="n">channel_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">gapChan</span><span class="p">:</span> 
                <span class="c1"># gives a wider buffer to written flag</span>
                <span class="n">channel_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">chan</span><span class="o">+</span><span class="n">addChan</span> 
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># for discountinuty will call this funct again and &#39;appends&#39; </span>
                <span class="k">return</span> <span class="p">[</span><span class="n">channel_range</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel_ranges</span><span class="p">(</span><span class="n">channels</span><span class="p">[</span><span class="n">i</span><span class="p">:])</span>

        <span class="c1"># get here if last channel reached</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">channel_range</span><span class="p">]</span></div>


<div class="viewcode-block" id="ACreNorm.writeTsysFlags">
<a class="viewcode-back" href="../../../_autosummary/pipeline.extern.almarenorm_pl2023.ACreNorm.html#pipeline.h.tasks.restoredata.restoredata.ACreNorm.writeTsysFlags">[docs]</a>
    <span class="k">def</span> <span class="nf">writeTsysFlags</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tsys_flags</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Purpose:</span>
<span class="sd">            Given the list from the writeTsysTemps method that makes a list of </span>
<span class="sd">            flag template compatible strings, this code simply writes a PL </span>
<span class="sd">            style flag template file at the most detailed level, i.e. spw and </span>
<span class="sd">            channel per scan triggered.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">msname</span><span class="o">+</span><span class="s1">&#39;_ReNormflagtsystemplate.txt&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file_tsys</span><span class="p">:</span>
            <span class="c1"># loop over list and write</span>
            <span class="k">for</span> <span class="n">tsys_flag</span> <span class="ow">in</span> <span class="n">tsys_flags</span><span class="p">:</span>
                <span class="n">file_tsys</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">tsys_flag</span><span class="o">+</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="ACreNorm.renormcomputeAzElFromRADecMJD">
<a class="viewcode-back" href="../../../_autosummary/pipeline.extern.almarenorm_pl2023.ACreNorm.html#pipeline.h.tasks.restoredata.restoredata.ACreNorm.renormcomputeAzElFromRADecMJD">[docs]</a>
    <span class="k">def</span> <span class="nf">renormcomputeAzElFromRADecMJD</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">raDec</span><span class="p">,</span> <span class="n">mjd</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Purpose:</span>
<span class="sd">            Computes the azimuth and elevation for a specified RA, Dec, and MJD </span>
<span class="sd">            for ALMA observations using the CASA measures tool.</span>

<span class="sd">            Adapted from Todd Hunter&#39;s AU tool computeAzElFromRADecMJD.            </span>
<span class="sd">        </span>
<span class="sd">        Inputs:</span>
<span class="sd">            raDec : list or tuple</span>
<span class="sd">                Must be in radians: [ra,dec]</span>

<span class="sd">            mjd : float</span>
<span class="sd">                Must be in days.</span>

<span class="sd">        Output:</span>
<span class="sd">            The azimuth and elevation are returned as a list in degrees.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Open CASA tools and define relevant quantities</span>
        <span class="n">myme</span> <span class="o">=</span> <span class="n">metool</span><span class="p">()</span> 
        <span class="n">myqa</span> <span class="o">=</span> <span class="n">qatool</span><span class="p">()</span> 
        <span class="n">frame</span><span class="o">=</span><span class="s1">&#39;AZEL&#39;</span>
        <span class="n">raQuantity</span> <span class="o">=</span> <span class="n">myqa</span><span class="o">.</span><span class="n">quantity</span><span class="p">(</span><span class="n">raDec</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;rad&#39;</span><span class="p">)</span>
        <span class="n">decQuantity</span> <span class="o">=</span> <span class="n">myqa</span><span class="o">.</span><span class="n">quantity</span><span class="p">(</span><span class="n">raDec</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;rad&#39;</span><span class="p">)</span>
        <span class="n">mydir</span> <span class="o">=</span> <span class="n">myme</span><span class="o">.</span><span class="n">direction</span><span class="p">(</span><span class="s1">&#39;J2000&#39;</span><span class="p">,</span> <span class="n">raQuantity</span><span class="p">,</span> <span class="n">decQuantity</span><span class="p">)</span>
        <span class="n">myme</span><span class="o">.</span><span class="n">doframe</span><span class="p">(</span><span class="n">myme</span><span class="o">.</span><span class="n">epoch</span><span class="p">(</span><span class="s1">&#39;mjd&#39;</span><span class="p">,</span> <span class="n">myqa</span><span class="o">.</span><span class="n">quantity</span><span class="p">(</span><span class="n">mjd</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">)))</span>
        <span class="n">observatory</span><span class="o">=</span><span class="s1">&#39;ALMA&#39;</span>
        <span class="n">myme</span><span class="o">.</span><span class="n">doframe</span><span class="p">(</span><span class="n">myme</span><span class="o">.</span><span class="n">observatory</span><span class="p">(</span><span class="n">observatory</span><span class="p">))</span>  
        <span class="n">myqa</span><span class="o">.</span><span class="n">done</span><span class="p">()</span>
        <span class="n">myazel</span> <span class="o">=</span> <span class="n">myme</span><span class="o">.</span><span class="n">measure</span><span class="p">(</span><span class="n">mydir</span><span class="p">,</span><span class="n">frame</span><span class="p">)</span>
        <span class="n">myme</span><span class="o">.</span><span class="n">done</span><span class="p">()</span>

        <span class="c1"># Once the inputs and frames are specified, pull out solution.        </span>
        <span class="n">myaz</span> <span class="o">=</span> <span class="n">myazel</span><span class="p">[</span><span class="s1">&#39;m0&#39;</span><span class="p">][</span><span class="s1">&#39;value&#39;</span><span class="p">]</span>
        <span class="n">myel</span> <span class="o">=</span> <span class="n">myazel</span><span class="p">[</span><span class="s1">&#39;m1&#39;</span><span class="p">][</span><span class="s1">&#39;value&#39;</span><span class="p">]</span>
        
        <span class="c1"># Want output in Degrees </span>
        <span class="n">myaz</span> <span class="o">*=</span> <span class="mi">180</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
        <span class="n">myel</span> <span class="o">*=</span> <span class="mi">180</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>

        <span class="k">return</span><span class="p">([</span><span class="n">myaz</span><span class="p">,</span><span class="n">myel</span><span class="p">])</span></div>




<div class="viewcode-block" id="ACreNorm.renormradec2rad">
<a class="viewcode-back" href="../../../_autosummary/pipeline.extern.almarenorm_pl2023.ACreNorm.html#pipeline.h.tasks.restoredata.restoredata.ACreNorm.renormradec2rad">[docs]</a>
    <span class="k">def</span> <span class="nf">renormradec2rad</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">radecstring</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Purpose:</span>
<span class="sd">            Convert a sky position from a single RA/Dec sexagesimal string </span>
<span class="sd">            to RA and Dec in radians.</span>

<span class="sd">            Adapted from Todd Hunter&#39;s AU tool radec2rad.</span>

<span class="sd">        Inputs:</span>
<span class="sd">            radecstring: string</span>
<span class="sd">                Any leading &#39;J2000&#39; string is removed before consideration. </span>
<span class="sd">                </span>
<span class="sd">                The RA and Dec portions can be separated by a comma or a space.</span>
<span class="sd">                </span>
<span class="sd">                The RA portion of the string must be colon-delimited, space-</span>
<span class="sd">                delimited, or &#39;h/m/s&#39; delimited. </span>
<span class="sd">                </span>
<span class="sd">                The Dec portion of the string can be either &quot;:&quot;, &quot;.&quot; or space-</span>
<span class="sd">                delimited. If it is &quot;.&quot; delimited, then it must have degrees, </span>
<span class="sd">                minutes, *and* seconds.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The RA and Dec are retuned as a tuple in radians.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Strip off J2000 leading string if it exists.</span>
        <span class="k">if</span> <span class="n">radecstring</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;J2000&#39;</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">radecstring</span> <span class="o">=</span> <span class="n">radecstring</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;J2000&#39;</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
        
        <span class="c1"># If in hms form, replace to &quot;:&quot; separated form.</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">radecstring</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;h&#39;</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">radecstring</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">):</span>
            <span class="n">radecstring</span> <span class="o">=</span> <span class="n">radecstring</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
                                            <span class="s1">&#39;h&#39;</span><span class="p">,</span> <span class="s1">&#39;:&#39;</span>
                                            <span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
                                                    <span class="s1">&#39;m&#39;</span><span class="p">,</span> <span class="s1">&#39;:&#39;</span>
                                                    <span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
                                                            <span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;:&#39;</span>
                                                            <span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
                                                                    <span class="s1">&#39;s&#39;</span><span class="p">,</span><span class="s1">&#39;&#39;</span>
                                                                    <span class="p">)</span>
        
        <span class="c1"># Create a separation between RA and Dec, then split on spaces to find</span>
        <span class="c1"># what type of input was used.</span>
        <span class="n">radec1</span> <span class="o">=</span> <span class="n">radecstring</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">,</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
        <span class="n">tokens</span> <span class="o">=</span> <span class="n">radec1</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
        
        <span class="c1"># If input was not space separated, we have RA then Dec. If input was </span>
        <span class="c1"># space separated, we have RA and Dec split over 6 items. Otherwise, </span>
        <span class="c1"># bad input and reject it.         </span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">):</span>
            <span class="p">(</span><span class="n">ra</span><span class="p">,</span><span class="n">dec</span><span class="p">)</span> <span class="o">=</span> <span class="n">radec1</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
        <span class="k">elif</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span> <span class="o">==</span> <span class="mi">6</span><span class="p">):</span>
            <span class="n">h</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">d</span><span class="p">,</span><span class="n">dm</span><span class="p">,</span><span class="n">ds</span> <span class="o">=</span> <span class="n">radec1</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
            <span class="n">ra</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">:</span><span class="si">%s</span><span class="s1">:</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">h</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">s</span><span class="p">)</span>
            <span class="n">dec</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%+f</span><span class="s1">:</span><span class="si">%s</span><span class="s1">:</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">d</span><span class="p">),</span> <span class="n">dm</span><span class="p">,</span> <span class="n">ds</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s2">&quot;Invalid format for RA/Dec string: &quot;</span><span class="p">,</span> <span class="n">radec1</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">SyntaxError</span><span class="p">(</span><span class="s1">&#39;Invalid format for RA/Dec string: &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">radec1</span><span class="p">))</span>
        
        <span class="c1"># Evaluate found RA/Dec input which at this point we know is in &quot;:&quot; format. </span>
        <span class="c1"># Strip any errant spaces and split on &quot;:&quot; to get each portion. To get to </span>
        <span class="c1"># degrees, we need to follow: </span>
        <span class="c1">#     ra_degrees = 15 * (ra_hours + ra_minutes/60 + ra_seconds/3600)</span>
        <span class="c1">#     dec_degress = dec_degrees + dec_minutes/60 + dec_seconds/3600</span>
        <span class="n">tokens</span> <span class="o">=</span> <span class="n">ra</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;:&#39;</span><span class="p">)</span>
        <span class="n">hours</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">tokens</span><span class="p">):</span>
            <span class="n">hours</span> <span class="o">+=</span> <span class="nb">float</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">60.</span><span class="o">**</span><span class="n">i</span><span class="p">)</span>
        <span class="n">ra1</span> <span class="o">=</span> <span class="n">hours</span><span class="o">*</span><span class="mi">15</span>
        <span class="c1"># We don&#39;t yet know if Dec is in &quot;.&quot; or &quot;:&quot; format so account for both.</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">dec</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;:&#39;</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">tokens</span> <span class="o">=</span> <span class="n">dec</span><span class="o">.</span><span class="n">lstrip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;:&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">dec</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="p">(</span><span class="n">d</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">s</span><span class="p">)</span> <span class="o">=</span> <span class="n">dec</span><span class="o">.</span><span class="n">lstrip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="p">(</span><span class="n">d</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">sfraction</span><span class="p">)</span> <span class="o">=</span> <span class="n">dec</span><span class="o">.</span><span class="n">lstrip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">s</span> <span class="o">+</span> <span class="s1">&#39;.&#39;</span> <span class="o">+</span> <span class="n">sfraction</span>
            <span class="n">tokens</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">s</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># just an integer</span>
            <span class="n">tokens</span> <span class="o">=</span> <span class="p">[</span><span class="n">dec</span><span class="p">]</span>
        <span class="n">dec1</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">tokens</span><span class="p">):</span>
            <span class="n">dec1</span> <span class="o">+=</span> <span class="nb">abs</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">60.</span><span class="o">**</span><span class="n">i</span><span class="p">))</span>
        <span class="c1"># Account for possibility that Dec can be negative.</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">dec</span><span class="o">.</span><span class="n">lstrip</span><span class="p">()</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">dec1</span> <span class="o">=</span> <span class="o">-</span><span class="n">dec1</span>
        
        <span class="c1"># Convert degrees to radians.</span>
        <span class="n">decrad</span> <span class="o">=</span> <span class="n">dec1</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mf">180.</span>
        <span class="n">rarad</span> <span class="o">=</span> <span class="n">ra1</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mf">180.</span>
  
        <span class="k">return</span><span class="p">(</span><span class="n">rarad</span><span class="p">,</span><span class="n">decrad</span><span class="p">)</span></div>



<div class="viewcode-block" id="ACreNorm.renormdirection2radec">
<a class="viewcode-back" href="../../../_autosummary/pipeline.extern.almarenorm_pl2023.ACreNorm.html#pipeline.h.tasks.restoredata.restoredata.ACreNorm.renormdirection2radec">[docs]</a>
    <span class="k">def</span> <span class="nf">renormdirection2radec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">direction</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Purpose:</span>
<span class="sd">            Convert a direction dictionary to a sexadecimal string of format:</span>
<span class="sd">                HH:MM:SS.SSSSS, +DDD:MM:SS.SSSSSS</span>

<span class="sd">            Adapted from Todd Hunter&#39;s AU tool direction2radec.</span>

<span class="sd">        Inputs:</span>
<span class="sd">            direction : dictionary</span>
<span class="sd">                This input is what is returned from the msmd tool of a pointing,</span>
<span class="sd">                i.e. the return of msmdtool().phasecenter.</span>

<span class="sd">        Outputs: </span>
<span class="sd">            The RA, Dec pointing direction as a string in sexadecimal format.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ra</span>  <span class="o">=</span> <span class="n">direction</span><span class="p">[</span><span class="s1">&#39;m0&#39;</span><span class="p">][</span><span class="s1">&#39;value&#39;</span><span class="p">]</span>
        <span class="n">dec</span> <span class="o">=</span> <span class="n">direction</span><span class="p">[</span><span class="s1">&#39;m1&#39;</span><span class="p">][</span><span class="s1">&#39;value&#39;</span><span class="p">]</span>
        <span class="n">myqa</span> <span class="o">=</span> <span class="n">qatool</span><span class="p">()</span>
        <span class="n">prec</span> <span class="o">=</span> <span class="mi">5</span>
        <span class="n">mystring</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">, </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">myqa</span><span class="o">.</span><span class="n">formxxx</span><span class="p">(</span>
                                    <span class="s1">&#39;</span><span class="si">%.12f</span><span class="s1">rad&#39;</span><span class="o">%</span><span class="n">ra</span><span class="p">,</span>
                                    <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;hms&#39;</span><span class="p">,</span>
                                    <span class="n">prec</span><span class="o">=</span><span class="n">prec</span>
                                    <span class="p">),</span>
                               <span class="n">myqa</span><span class="o">.</span><span class="n">formxxx</span><span class="p">(</span>
                                   <span class="s1">&#39;</span><span class="si">%.12f</span><span class="s1">rad&#39;</span><span class="o">%</span><span class="n">dec</span><span class="p">,</span>
                                   <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;dms&#39;</span><span class="p">,</span>
                                   <span class="n">prec</span><span class="o">=</span><span class="n">prec</span>
                                   <span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span><span class="s1">&#39;:&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
        <span class="n">myqa</span><span class="o">.</span><span class="n">done</span><span class="p">()</span>
   
        <span class="k">return</span><span class="p">(</span><span class="n">mystring</span><span class="p">)</span></div>




<div class="viewcode-block" id="ACreNorm.renormWeather">
<a class="viewcode-back" href="../../../_autosummary/pipeline.extern.almarenorm_pl2023.ACreNorm.html#pipeline.h.tasks.restoredata.restoredata.ACreNorm.renormWeather">[docs]</a>
    <span class="k">def</span> <span class="nf">renormWeather</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scan</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span> 
<span class="w">        </span><span class="sd">&#39;&#39;&#39; </span>
<span class="sd">        Purpose:</span>
<span class="sd">            Returns the weather conditions and time stamps of a given scan. </span>
<span class="sd">            This is heavily adapted from Todd Hunter&#39;s analysisUtils code,</span>
<span class="sd">            au.getWeather() function.</span>

<span class="sd">        Inputs:</span>
<span class="sd">            scan : integer</span>
<span class="sd">                The scan number.</span>

<span class="sd">            verbose : boolean : OPTIONAL</span>
<span class="sd">                If set to true, some additional output is printed to screen.</span>

<span class="sd">        Returns:</span>
<span class="sd">            [conditions, myTimes]</span>
<span class="sd">                conditions : dictionary</span>
<span class="sd">                    Includes the average temperature (Celcius), humidity (%), </span>
<span class="sd">                    and Pressure (mB) for the given scan.</span>

<span class="sd">                myTimes : numpy.array</span>
<span class="sd">                    List of times during the given scan.</span>
<span class="sd">                    </span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># Use a standard preferred weather station (as noted in AU task).</span>
        <span class="n">preferredStation</span> <span class="o">=</span> <span class="s1">&#39;TB2&#39;</span>
        <span class="n">conditions</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">conditions</span><span class="p">[</span><span class="s1">&#39;pressure&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">conditions</span><span class="p">[</span><span class="s1">&#39;temperature&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">conditions</span><span class="p">[</span><span class="s1">&#39;humidity&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">myTimes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">msmeta</span><span class="o">.</span><span class="n">timesforscan</span><span class="p">(</span><span class="n">scan</span><span class="p">)</span>
        
        <span class="c1"># Get the weather table.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># mytb is global tool instance already</span>
            <span class="n">mytb</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">msname</span><span class="o">+</span><span class="s1">&#39;/WEATHER&#39;</span><span class="p">)</span>  
        <span class="k">except</span><span class="p">:</span>
            <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s2">&quot;Could not open the WEATHER table for this ms, default returned.&quot;</span><span class="p">)</span>
            <span class="n">conditions</span><span class="p">[</span><span class="s1">&#39;pressure&#39;</span><span class="p">]</span><span class="o">=</span><span class="mf">563.0</span>
            <span class="n">conditions</span><span class="p">[</span><span class="s1">&#39;temperature&#39;</span><span class="p">]</span><span class="o">=</span><span class="mf">0.0</span> <span class="c1"># in deg C</span>
            <span class="n">conditions</span><span class="p">[</span><span class="s1">&#39;humidity&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">20.0</span>
            <span class="k">return</span><span class="p">([</span><span class="n">conditions</span><span class="p">,</span><span class="n">myTimes</span><span class="p">])</span>
        
        <span class="c1"># Get all weather information.</span>
        <span class="n">mjdsec</span> <span class="o">=</span> <span class="n">mytb</span><span class="o">.</span><span class="n">getcol</span><span class="p">(</span><span class="s1">&#39;TIME&#39;</span><span class="p">)</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">mjdsec</span><span class="p">)</span> <span class="c1"># sometimes slightly out of order, fix.</span>
        <span class="n">pressure</span> <span class="o">=</span> <span class="n">mytb</span><span class="o">.</span><span class="n">getcol</span><span class="p">(</span><span class="s1">&#39;PRESSURE&#39;</span><span class="p">)</span>
        <span class="n">relativeHumidity</span> <span class="o">=</span> <span class="n">mytb</span><span class="o">.</span><span class="n">getcol</span><span class="p">(</span><span class="s1">&#39;REL_HUMIDITY&#39;</span><span class="p">)</span>
        <span class="n">temperature</span> <span class="o">=</span> <span class="n">mytb</span><span class="o">.</span><span class="n">getcol</span><span class="p">(</span><span class="s1">&#39;TEMPERATURE&#39;</span><span class="p">)</span>
        <span class="c1"># If in units of Kelvin, convert to C</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">temperature</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="p">):</span>
            <span class="n">temperature</span> <span class="o">=</span> <span class="n">temperature</span><span class="o">-</span><span class="mf">273.15</span> 

        <span class="c1"># Apply correct ordering</span>
        <span class="n">mjdsec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mjdsec</span><span class="p">)[</span><span class="n">indices</span><span class="p">]</span>
        <span class="n">pressure</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pressure</span><span class="p">)[</span><span class="n">indices</span><span class="p">]</span>
        <span class="n">relativeHumidity</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">relativeHumidity</span><span class="p">)[</span><span class="n">indices</span><span class="p">]</span>
        <span class="n">temperature</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">temperature</span><span class="p">)[</span><span class="n">indices</span><span class="p">]</span>
        <span class="c1"># Grab weather station IDs.</span>
        <span class="k">if</span> <span class="s1">&#39;NS_WX_STATION_ID&#39;</span> <span class="ow">in</span> <span class="n">mytb</span><span class="o">.</span><span class="n">colnames</span><span class="p">():</span>
            <span class="n">stations</span> <span class="o">=</span> <span class="n">mytb</span><span class="o">.</span><span class="n">getcol</span><span class="p">(</span><span class="s1">&#39;NS_WX_STATION_ID&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">stations</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">mytb</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        
        <span class="c1"># Get the weather station names.</span>
        <span class="n">wsdict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">renormWeatherStationNames</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">wsdict</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">preferredStationID</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="c1"># Loop over weather stations, searching for the preferred.</span>
            <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">wsdict</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                <span class="k">if</span> <span class="n">wsdict</span><span class="p">[</span><span class="n">w</span><span class="p">]</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">preferredStation</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">preferredStationID</span> <span class="o">=</span> <span class="n">w</span>
            <span class="c1"># If preferred found, use only data from that one, otherwise use all.</span>
            <span class="k">if</span> <span class="n">preferredStationID</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s2">&quot;Preferred station (</span><span class="si">%s</span><span class="s2">) not found in this dataset. Using all.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">preferredStation</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">stations</span> <span class="o">==</span> <span class="n">preferredStationID</span><span class="p">)</span>
                <span class="n">mjdsec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mjdsec</span><span class="p">)[</span><span class="n">indices</span><span class="p">]</span>
                <span class="n">pressure</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pressure</span><span class="p">)[</span><span class="n">indices</span><span class="p">]</span>
                <span class="n">relativeHumidity</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">relativeHumidity</span><span class="p">)[</span><span class="n">indices</span><span class="p">]</span>
                <span class="n">temperature</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">temperature</span><span class="p">)[</span><span class="n">indices</span><span class="p">]</span>
                <span class="n">stations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">stations</span><span class="p">)[</span><span class="n">indices</span><span class="p">]</span>
    
        <span class="c1"># Find the overlap of weather measurement times and scan times</span>
        <span class="n">matches</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mjdsec</span><span class="o">&gt;=</span><span class="nb">min</span><span class="p">(</span><span class="n">myTimes</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> 
        <span class="n">matches2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mjdsec</span><span class="o">&lt;=</span><span class="nb">max</span><span class="p">(</span><span class="n">myTimes</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">noWeatherData</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">matches</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">matches2</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="c1"># Average the weather points enclosed by the scan time range.</span>
            <span class="n">selectedValues</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">matches</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">matches2</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
            <span class="c1"># If there was a either gap in the weather data, or an incredibly short scan duration</span>
            <span class="c1"># find the closest in time index.</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">selectedValues</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                <span class="n">selectedValues</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">renormfindClosestTime</span><span class="p">(</span><span class="n">mjdsec</span><span class="p">,</span> <span class="n">myTimes</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>  
        <span class="c1"># If all points are greater than myTime, take the first one.</span>
        <span class="k">elif</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">matches</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">):</span>
            <span class="n">selectedValues</span> <span class="o">=</span> <span class="n">matches</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># If all points are less than myTime, take the last one.</span>
        <span class="k">elif</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">matches2</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">):</span>
            <span class="n">selectedValues</span> <span class="o">=</span> <span class="n">matches2</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># If here, then the table has no weather data at all (7M?).</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">noWeatherData</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">noWeatherData</span><span class="p">):</span>
            <span class="n">conditions</span><span class="p">[</span><span class="s1">&#39;pressure&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">563.0</span>
            <span class="n">conditions</span><span class="p">[</span><span class="s1">&#39;temperature&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># Celsius is expected</span>
            <span class="n">conditions</span><span class="p">[</span><span class="s1">&#39;humidity&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">20.0</span>
            <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s2">&quot;WARNING: No weather data found in the WEATHER table!&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Separate the relevant index values.</span>
            <span class="n">selectPressure</span> <span class="o">=</span> <span class="n">pressure</span><span class="p">[</span><span class="n">selectedValues</span><span class="p">]</span>
            <span class="n">selectTemperature</span> <span class="o">=</span> <span class="n">temperature</span><span class="p">[</span><span class="n">selectedValues</span><span class="p">]</span>
            <span class="n">selectHumidity</span> <span class="o">=</span> <span class="n">relativeHumidity</span><span class="p">[</span><span class="n">selectedValues</span><span class="p">]</span>
            <span class="c1"># Check to make sure that there is at least one valid (non-zero) value.</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">selectPressure</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">mask</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;No valid weather data for timerange!&#39;</span><span class="p">)</span>
                <span class="n">conditions</span><span class="p">[</span><span class="s1">&#39;pressure&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">563.0</span>
                <span class="n">conditions</span><span class="p">[</span><span class="s1">&#39;temperature&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># Celsius is expected</span>
                <span class="n">conditions</span><span class="p">[</span><span class="s1">&#39;humidity&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">20.0</span>
            <span class="c1"># Find average value of each weather condition, using only valid entries.</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">conditions</span><span class="p">[</span><span class="s1">&#39;pressure&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">selectPressure</span><span class="p">[</span><span class="n">mask</span><span class="p">])</span>
                <span class="n">conditions</span><span class="p">[</span><span class="s1">&#39;temperature&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">selectTemperature</span><span class="p">[</span><span class="n">mask</span><span class="p">])</span>
                <span class="n">conditions</span><span class="p">[</span><span class="s1">&#39;humidity&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">selectHumidity</span><span class="p">[</span><span class="n">mask</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s2">&quot;  Pressure = </span><span class="si">%.2f</span><span class="s2"> mb&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">conditions</span><span class="p">[</span><span class="s1">&#39;pressure&#39;</span><span class="p">]))</span>
                    <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s2">&quot;  Temperature = </span><span class="si">%.2f</span><span class="s2"> C&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">conditions</span><span class="p">[</span><span class="s1">&#39;temperature&#39;</span><span class="p">]))</span>
                    <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s2">&quot;  Relative Humidity = </span><span class="si">%.2f</span><span class="s2"> </span><span class="si">%%</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">conditions</span><span class="p">[</span><span class="s1">&#39;humidity&#39;</span><span class="p">]))</span>

        <span class="k">return</span><span class="p">([</span><span class="n">conditions</span><span class="p">,</span><span class="n">myTimes</span><span class="p">])</span></div>



<div class="viewcode-block" id="ACreNorm.renormMedianPWV">
<a class="viewcode-back" href="../../../_autosummary/pipeline.extern.almarenorm_pl2023.ACreNorm.html#pipeline.h.tasks.restoredata.restoredata.ACreNorm.renormMedianPWV">[docs]</a>
    <span class="k">def</span> <span class="nf">renormMedianPWV</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">myTimes</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">99999999999</span><span class="p">],</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extracts the PWV measurements from the WVR on all antennas all times.  </span>
<span class="sd">        First, it tries to find the ASDM_CALWVR</span>
<span class="sd">        table in the ms.  If that fails, it then tries to find the </span>
<span class="sd">        ASDM_CALATMOSPHERE table in the ms.  </span>
<span class="sd">        Returns:</span>
<span class="sd">        The median PWV</span>
<span class="sd">        For further help and examples, see https://safe.nrao.edu/wiki/bin/view/ALMA/GetMedianPWV</span>
<span class="sd">        -- Todd Hunter - aU version</span>
<span class="sd">        -- Luke Maud - copied and stripped down for almarenorm to make independent of </span>
<span class="sd">        the analysis utilities</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pwvmean</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1">## actually is the median </span>
        <span class="k">if</span> <span class="p">(</span><span class="n">verbose</span><span class="p">):</span>
            <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s2">&quot;in renormMedianPWV with myTimes = &quot;</span><span class="p">,</span> <span class="n">myTimes</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">mytb</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">msname</span><span class="o">+</span><span class="s1">&#39;/ASDM_CALWVR&#39;</span><span class="p">)</span>
            <span class="n">pwvtime</span> <span class="o">=</span> <span class="n">mytb</span><span class="o">.</span><span class="n">getcol</span><span class="p">(</span><span class="s1">&#39;startValidTime&#39;</span><span class="p">)</span>  <span class="c1"># mjdsec</span>
            <span class="n">antenna</span> <span class="o">=</span> <span class="n">mytb</span><span class="o">.</span><span class="n">getcol</span><span class="p">(</span><span class="s1">&#39;antennaName&#39;</span><span class="p">)</span>
            <span class="n">pwv</span> <span class="o">=</span> <span class="n">mytb</span><span class="o">.</span><span class="n">getcol</span><span class="p">(</span><span class="s1">&#39;water&#39;</span><span class="p">)</span>
            <span class="n">mytb</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="c1"># if read but somehow nothing comes back</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pwv</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s2">&quot;Found no data in ASDM_CALWVR table&quot;</span><span class="p">)</span>
                <span class="n">pwv</span><span class="o">=</span><span class="mi">0</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">pwv</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">pwv</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">pwvtime</span><span class="p">,</span> <span class="n">antenna</span><span class="p">,</span> <span class="n">pwv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">renormPWVFromASDM_CALATMOSPHERE</span><span class="p">()</span>
                <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pwv</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                        <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s2">&quot;Found no data in ASDM_CALATMOSPHERE table&quot;</span><span class="p">)</span>
                    <span class="k">return</span> <span class="n">pwvmean</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="n">pwv</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># i.e. didnt get anything from above tables at all</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">pwv</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s2">&quot;Found no data in ASDM_CALWVR nor ASDM_CALATMOSPHERE tables&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">pwvmean</span>
        
        <span class="c1"># Data from before May 2016 may have all PWV values set to a default 1.0 rather </span>
        <span class="c1"># than a real value. Reject these as there is no real data to use.</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">i</span><span class="o">==</span><span class="mf">1.0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">pwv</span><span class="p">):</span>
            <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;All recorded entries of PWV are set equal to 1.0! No data available.&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">pwvmean</span>
 
        <span class="c1"># my times is hardcoded so should find something</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">matches</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pwvtime</span><span class="p">)</span><span class="o">&gt;</span><span class="n">myTimes</span><span class="p">[</span><span class="mi">0</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s2">&quot;Found no times &gt; </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">myTimes</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="k">return</span> <span class="n">pwvmean</span>

        <span class="c1"># for testing </span>
        <span class="c1">#casalog.post(&quot;%d matches = &quot; % (len(matches)), matches)</span>
        <span class="c1">#casalog.post(&quot;%d pwv = &quot; % (len(pwv)), pwv)</span>
        <span class="n">ptime</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pwvtime</span><span class="p">)[</span><span class="n">matches</span><span class="p">]</span>
        <span class="n">matchedpwv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pwv</span><span class="p">)[</span><span class="n">matches</span><span class="p">]</span>
        <span class="n">matches2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ptime</span><span class="o">&lt;=</span><span class="n">myTimes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># for testing </span>
        <span class="c1">#casalog.post(&quot;matchedpwv = %s&quot; % (matchedpwv))</span>
        <span class="c1">#casalog.post(&quot;pwv = %s&quot; % (pwv))</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">matches2</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">):</span>
            <span class="c1"># look for the value with the closest start time</span>
            <span class="n">mindiff</span> <span class="o">=</span> <span class="mf">1e12</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pwvtime</span><span class="p">)):</span>
                <span class="k">if</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">myTimes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">pwvtime</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">mindiff</span><span class="p">):</span>
                    <span class="n">mindiff</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">myTimes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">pwvtime</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="c1">#                pwvmean = pwv[i]*1000</span>
            <span class="n">matchedpwv</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pwvtime</span><span class="p">)):</span>
                <span class="k">if</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">myTimes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">pwvtime</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">-</span> <span class="n">mindiff</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1.0</span><span class="p">):</span>
                    <span class="n">matchedpwv</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pwv</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">pwvmean</span> <span class="o">=</span> <span class="mi">1000</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">matchedpwv</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">verbose</span><span class="p">):</span>
                <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s2">&quot;Taking the median of </span><span class="si">%d</span><span class="s2"> pwv measurements from all antennas = </span><span class="si">%.3f</span><span class="s2"> mm&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">matchedpwv</span><span class="p">),</span><span class="n">pwvmean</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pwvmean</span> <span class="o">=</span> <span class="mi">1000</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">matchedpwv</span><span class="p">[</span><span class="n">matches2</span><span class="p">])</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">verbose</span><span class="p">):</span>
                <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s2">&quot;Taking the median of </span><span class="si">%d</span><span class="s2"> pwv measurements from all antennas = </span><span class="si">%.3f</span><span class="s2"> mm&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">matches2</span><span class="p">),</span><span class="n">pwvmean</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">pwvmean</span></div>

        <span class="c1"># end of getMedianPWV</span>


<div class="viewcode-block" id="ACreNorm.renormPWVFromASDM_CALATMOSPHERE">
<a class="viewcode-back" href="../../../_autosummary/pipeline.extern.almarenorm_pl2023.ACreNorm.html#pipeline.h.tasks.restoredata.restoredata.ACreNorm.renormPWVFromASDM_CALATMOSPHERE">[docs]</a>
    <span class="k">def</span> <span class="nf">renormPWVFromASDM_CALATMOSPHERE</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reads the PWV via the water column of the ASDM_CALATMOSPHERE table in MS.</span>
<span class="sd">        - Todd Hunter - aU version</span>
<span class="sd">        - Luke Maud copied and edited for almarenorm so independent of analysisUtils</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">mytb</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">msname</span><span class="o">+</span><span class="s1">&#39;/ASDM_CALATMOSPHERE&#39;</span><span class="p">)</span>
            <span class="n">pwvtime</span> <span class="o">=</span> <span class="n">mytb</span><span class="o">.</span><span class="n">getcol</span><span class="p">(</span><span class="s1">&#39;startValidTime&#39;</span><span class="p">)</span>  <span class="c1"># mjdsec</span>
            <span class="n">antenna</span> <span class="o">=</span> <span class="n">mytb</span><span class="o">.</span><span class="n">getcol</span><span class="p">(</span><span class="s1">&#39;antennaName&#39;</span><span class="p">)</span>
            <span class="n">pwv</span> <span class="o">=</span> <span class="n">mytb</span><span class="o">.</span><span class="n">getcol</span><span class="p">(</span><span class="s1">&#39;water&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># There seem to be 2 identical entries per row, so take first one.</span>
            <span class="n">mytb</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">return</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span><span class="p">(</span><span class="n">pwvtime</span><span class="p">,</span> <span class="n">antenna</span><span class="p">,</span> <span class="n">pwv</span><span class="p">)</span></div>





<div class="viewcode-block" id="ACreNorm.renormWeatherStationNames">
<a class="viewcode-back" href="../../../_autosummary/pipeline.extern.almarenorm_pl2023.ACreNorm.html#pipeline.h.tasks.restoredata.restoredata.ACreNorm.renormWeatherStationNames">[docs]</a>
    <span class="k">def</span> <span class="nf">renormWeatherStationNames</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a dictionary keyed by ALMA weather station ID, with the value</span>
<span class="sd">        equal to the station name (e.g. &#39;WSTBn&#39;).</span>
<span class="sd">        vis: single measurement set</span>
<span class="sd">        -Todd Hunter - aU version</span>
<span class="sd">        -Luke Maud copied and modified/stripped down</span>
<span class="sd">        from analysisUtils to make almarenorm.py independent</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">prefix</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;WSTB&#39;</span><span class="p">,</span><span class="s1">&#39;Meteo&#39;</span><span class="p">,</span><span class="s1">&#39;OSF&#39;</span><span class="p">]</span>
        <span class="n">asdmStation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">msname</span><span class="o">+</span><span class="s1">&#39;/ASDM_STATION&#39;</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">mytb</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">asdmStation</span><span class="p">)</span>
            
            <span class="n">names</span> <span class="o">=</span> <span class="n">mytb</span><span class="o">.</span><span class="n">getcol</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">)</span>
            <span class="n">mydict</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">names</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">prefix</span><span class="p">:</span>
                    <span class="c1">#            casalog.post &quot;Checking if %s contains %s&quot; % (name.lower(),p.lower())</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">lower</span><span class="p">())</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">):</span>
                        <span class="n">mydict</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">name</span>
            <span class="n">mytb</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s2">&quot;This measurement set does not have an ASDM_STATION table.&quot;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="k">return</span><span class="p">(</span><span class="n">mydict</span><span class="p">)</span></div>

        
<div class="viewcode-block" id="ACreNorm.findNearest">
<a class="viewcode-back" href="../../../_autosummary/pipeline.extern.almarenorm_pl2023.ACreNorm.html#pipeline.h.tasks.restoredata.restoredata.ACreNorm.findNearest">[docs]</a>
    <span class="k">def</span> <span class="nf">findNearest</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">array</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Purpose: </span>
<span class="sd">            Given an array and a value that falls within that array, find</span>
<span class="sd">            the nearest value or index within the array to that value.</span>

<span class="sd">        Inputs:</span>
<span class="sd">            array : list of floats or ints</span>
<span class="sd">                An array for which to evaluate.</span>
<span class="sd">            value : float or int</span>
<span class="sd">                The value you wish to find the closest match to within </span>
<span class="sd">                the array.</span>
<span class="sd">            index : boolean : OPTIONAL</span>
<span class="sd">                If True, return the index location within array that is </span>
<span class="sd">                closest to the value. Otherwise, return the value of that</span>
<span class="sd">                index.</span>
<span class="sd">                Default: False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">array</span> <span class="o">-</span> <span class="n">value</span><span class="p">))</span><span class="o">.</span><span class="n">argmin</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">index</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">idx</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">array</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span></div>


    <span class="k">def</span> <span class="nf">renormfindClosestTime</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mytimes</span><span class="p">,</span> <span class="n">mytime</span><span class="p">):</span>
        <span class="n">myindex</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">mysep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">mytimes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">mytime</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">mytimes</span><span class="p">)):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">mytimes</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">-</span> <span class="n">mytime</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">mysep</span><span class="p">):</span>
                <span class="n">mysep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">mytimes</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">-</span> <span class="n">mytime</span><span class="p">)</span>
                <span class="n">myindex</span> <span class="o">=</span> <span class="n">m</span>
        <span class="k">return</span><span class="p">(</span><span class="n">myindex</span><span class="p">)</span>

    <span class="c1"># AL added - PIPE 1168 (2)</span>
<div class="viewcode-block" id="ACreNorm.convertPlotsToPDF">
<a class="viewcode-back" href="../../../_autosummary/pipeline.extern.almarenorm_pl2023.ACreNorm.html#pipeline.h.tasks.restoredata.restoredata.ACreNorm.convertPlotsToPDF">[docs]</a>
    <span class="k">def</span> <span class="nf">convertPlotsToPDF</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">spw</span><span class="p">,</span> <span class="n">include_summary</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">include_heuristics</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Super hacky way to create PDFs of created plots so that we can display them in the weblog.</span>
<span class="sd">        Simply calls the bash commands &quot;montage&quot; (to create super plots of pngs), &quot;convert&quot; (to</span>
<span class="sd">        then convert those super plots into pdfs), and &quot;pdfunite&quot; (to combine all pdfs into one).</span>

<span class="sd">        Imports: </span>
<span class="sd">            target : string</span>
<span class="sd">                Name of the target field that matches the filename target</span>
<span class="sd">            </span>
<span class="sd">            spw : str (or int, the type is forced)</span>
<span class="sd">                The spectral window of the files that need to be converted to a PDF.</span>
<span class="sd">            </span>
<span class="sd">            include_summary : boolean (OPTIONAL)</span>
<span class="sd">                If set to True, the summary plot averaging over all scans/fields will be included.</span>
<span class="sd">                Default: True</span>

<span class="sd">            include_heuristics : boolean (OPTIONAL)</span>
<span class="sd">                If set to True, the per antenna heuristics plots will be included in the PDFs.</span>
<span class="sd">                Default: False</span>

<span class="sd">        Output:</span>
<span class="sd">            The target/spw matched plots are montaged and transformed into a PDF and placed into the</span>
<span class="sd">            ./RN_plots directory. The name of the PDF is put into the self.rnpipestats dictionary. </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">glob</span>

        <span class="k">def</span> <span class="nf">diagnostic_sort</span><span class="p">(</span><span class="n">fn</span><span class="p">):</span>
            <span class="c1"># All files names are deterministic, we want to sort on the scan number, then on field number.</span>
            <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">fn</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;scan&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">int</span><span class="p">(</span><span class="n">fn</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;field&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>

        <span class="c1"># Defaults stolen from AU tools.</span>
        <span class="n">tile</span> <span class="o">=</span> <span class="s1">&#39;2x4&#39;</span>
        <span class="n">geometry</span> <span class="o">=</span> <span class="s1">&#39;1000x800+2+2&#39;</span>
        
        <span class="n">pngs</span> <span class="o">=</span> <span class="p">[]</span> 

        <span class="c1"># Create a list of PNGs starting with the summary plot</span>
        <span class="k">if</span> <span class="n">include_summary</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="s1">&#39;./RN_plots/&#39;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">msname</span><span class="o">+</span><span class="s1">&#39;_&#39;</span><span class="o">+</span><span class="n">target</span><span class="o">+</span><span class="s1">&#39;_spw&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">spw</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;_ReNormSpectra.png&#39;</span><span class="p">):</span>
                <span class="n">pngs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;./RN_plots/&#39;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">msname</span><span class="o">+</span><span class="s1">&#39;_&#39;</span><span class="o">+</span><span class="n">target</span><span class="o">+</span><span class="s1">&#39;_spw&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">spw</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;_ReNormSpectra.png&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;No summary PNG found! Has plotSpectra() been run? Exiting without creating PDF.&#39;</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">OSError</span><span class="p">(</span><span class="s1">&#39;No summary PNG found within &#39;</span><span class="o">+</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">(),</span><span class="s1">&#39;RN_plots&#39;</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;. Has plotSpectra() been run?&#39;</span><span class="p">)</span>

        <span class="c1"># Add the antenna diagnostic plots next</span>
        <span class="n">diag_pngs</span> <span class="o">=</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="s1">&#39;./RN_plots/&#39;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">msname</span><span class="o">+</span><span class="s1">&#39;_ReNormDiagnosticCheck_&#39;</span><span class="o">+</span><span class="n">target</span><span class="o">+</span><span class="s1">&#39;_spw&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">spw</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;_scan*_field*.png&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">diag_pngs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;No diagnostic PNGs found! Only the summary spectrum will be included.&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">diag_pngs</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">diagnostic_sort</span><span class="p">)</span> <span class="c1"># sort file names by scan number, then by field to get the right order</span>
            <span class="c1"># Add the diagnostic PNGs to the list</span>
            <span class="n">pngs</span> <span class="o">+=</span> <span class="n">diag_pngs</span>

        <span class="c1"># Add the outlier antenna plots</span>
        <span class="k">if</span> <span class="n">include_heuristics</span><span class="p">:</span>
            <span class="n">fields</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">msmeta</span><span class="o">.</span><span class="n">fieldsforintent</span><span class="p">(</span><span class="s1">&#39;*TARGET*&#39;</span><span class="p">),</span><span class="bp">self</span><span class="o">.</span><span class="n">msmeta</span><span class="o">.</span><span class="n">fieldsforname</span><span class="p">(</span><span class="n">target</span><span class="p">))</span>            
            <span class="n">ant_pngs</span> <span class="o">=</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="s1">&#39;./RN_plots/&#39;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">msname</span><span class="o">+</span><span class="s1">&#39;_ReNormHeuristicOutlierAnt_*_spw&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">spw</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;_scan*field&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">fields</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;*.png&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ant_pngs</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">ant_pngs</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
                <span class="n">pngs</span> <span class="o">+=</span> <span class="n">ant_pngs</span>

        <span class="c1"># Figure out how many pages are needed. We will create tiles of 2 columns x 4 rows</span>
        <span class="n">pages</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">ceil</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pngs</span><span class="p">)</span><span class="o">/</span><span class="mf">8.</span><span class="p">))</span> 
        <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">montaged_pngs</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># Keep the list of newly created montages</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">pages</span><span class="p">):</span>
            <span class="n">figs</span> <span class="o">=</span> <span class="n">pngs</span><span class="p">[</span><span class="n">j</span><span class="p">:</span><span class="n">j</span><span class="o">+</span><span class="mi">8</span><span class="p">]</span>
            <span class="n">figs</span> <span class="o">=</span> <span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">fig</span> <span class="k">for</span> <span class="n">fig</span> <span class="ow">in</span> <span class="n">figs</span><span class="p">])</span>
            <span class="n">j</span><span class="o">+=</span><span class="mi">8</span>
            <span class="n">montage</span> <span class="o">=</span> <span class="s1">&#39;./RN_plots/&#39;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">msname</span><span class="o">+</span><span class="s1">&#39;_ReNormDiagnosticCheck_&#39;</span><span class="o">+</span><span class="n">target</span><span class="o">+</span><span class="s1">&#39;_spw&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">spw</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;_montage_&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;.png&#39;</span>
            <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s1">&#39;montage -geometry &#39;</span><span class="o">+</span><span class="n">geometry</span><span class="o">+</span><span class="s1">&#39; -tile &#39;</span><span class="o">+</span><span class="n">tile</span><span class="o">+</span><span class="s1">&#39; &#39;</span><span class="o">+</span><span class="n">figs</span><span class="o">+</span><span class="s1">&#39; &#39;</span><span class="o">+</span><span class="n">montage</span><span class="p">)</span>
            <span class="n">montaged_pngs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">montage</span><span class="p">)</span>

        <span class="c1"># Now convert all the PNGs into PDFs</span>
        <span class="k">for</span> <span class="n">mfile</span> <span class="ow">in</span> <span class="n">montaged_pngs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="kn">from</span> <span class="nn">subprocess</span> <span class="kn">import</span> <span class="n">Popen</span>
                <span class="kn">from</span> <span class="nn">subprocess</span> <span class="kn">import</span> <span class="n">PIPE</span>
                <span class="n">proc</span> <span class="o">=</span> <span class="n">Popen</span><span class="p">([</span><span class="s1">&#39;which&#39;</span><span class="p">,</span><span class="s1">&#39;convert&#39;</span><span class="p">],</span> <span class="n">stdout</span><span class="o">=</span><span class="n">PIPE</span><span class="p">,</span> <span class="n">stderr</span><span class="o">=</span><span class="n">PIPE</span><span class="p">)</span>
                <span class="n">which_out</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="n">proc</span><span class="o">.</span><span class="n">communicate</span><span class="p">()</span>
                <span class="n">proc</span> <span class="o">=</span> <span class="n">Popen</span><span class="p">([</span><span class="s1">&#39;convert&#39;</span><span class="p">,</span><span class="s1">&#39;-version&#39;</span><span class="p">],</span> <span class="n">stdout</span><span class="o">=</span><span class="n">PIPE</span><span class="p">,</span> <span class="n">stderr</span><span class="o">=</span><span class="n">PIPE</span><span class="p">)</span>
                <span class="n">version_out</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="n">proc</span><span class="o">.</span><span class="n">communicate</span><span class="p">()</span>
                <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
                <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;Using ImageMagicks &quot;convert&quot; for png --&gt; pdf conversion located here:&#39;</span><span class="p">)</span>
                <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="n">which_out</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">))</span>
                <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
                <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="n">version_out</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">))</span>
                <span class="n">casalog</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
            <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s1">&#39;convert &#39;</span><span class="o">+</span><span class="n">mfile</span><span class="o">+</span><span class="s1">&#39; &#39;</span><span class="o">+</span><span class="n">mfile</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.png&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39;.pdf&#39;</span><span class="p">)</span>
        <span class="n">pdflist</span> <span class="o">=</span> <span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">fname</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.png&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39;.pdf&#39;</span> <span class="k">for</span> <span class="n">fname</span> <span class="ow">in</span> <span class="n">montaged_pngs</span><span class="p">])</span>

        <span class="c1"># Finally, create the summary PDF containing all the plots</span>
        <span class="n">outfile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">msname</span><span class="o">+</span><span class="s1">&#39;_ReNormDiagnosticCheck_&#39;</span><span class="o">+</span><span class="n">target</span><span class="o">+</span><span class="s1">&#39;_spw&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">spw</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;_summary.pdf&#39;</span>
        <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s1">&#39;pdfunite &#39;</span><span class="o">+</span><span class="n">pdflist</span><span class="o">+</span><span class="s1">&#39; ./RN_plots/&#39;</span><span class="o">+</span><span class="n">outfile</span><span class="p">)</span>

        <span class="c1"># Put the name of the new PDF into the self.rnpipestats dictionary.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rnpipestats</span><span class="p">[</span><span class="n">target</span><span class="p">][</span><span class="nb">str</span><span class="p">(</span><span class="n">spw</span><span class="p">)]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rnpipestats</span><span class="p">[</span><span class="n">target</span><span class="p">][</span><span class="nb">str</span><span class="p">(</span><span class="n">spw</span><span class="p">)][</span><span class="s1">&#39;pdf_summary&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">outfile</span></div>


    <span class="c1"># AL added - PIPE-1188</span>
<div class="viewcode-block" id="ACreNorm.getImageSBFreqs">
<a class="viewcode-back" href="../../../_autosummary/pipeline.extern.almarenorm_pl2023.ACreNorm.html#pipeline.h.tasks.restoredata.restoredata.ACreNorm.getImageSBFreqs">[docs]</a>
    <span class="k">def</span> <span class="nf">getImageSBFreqs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">spwin</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Purpose:</span>
<span class="sd">            Given the spectral window, find the LO frequency and return the frequencies of</span>
<span class="sd">            the image sideband. Specifically, return the inputs needed for ATMtrans() in </span>
<span class="sd">            order to properly show the atmospheric transmission for bands 9 and 10 where the</span>
<span class="sd">            image sideband atomospheric window also contributes to the spectral window. </span>

<span class="sd">        Inputs:</span>
<span class="sd">            spwin : int</span>
<span class="sd">                The spectral window for which the image sideband frequencies are needed.</span>

<span class="sd">        Outputs:</span>
<span class="sd">            fSB : numpy.array</span>
<span class="sd">                The frequencies of the image sideband. These will be properly arranged </span>
<span class="sd">                (i.e. they will be opposite in direction to the input spectral window </span>
<span class="sd">                frequencies). </span>

<span class="sd">            chansepSB : float</span>
<span class="sd">                The separation between channels (channel width).</span>

<span class="sd">            fCenterSB : float</span>
<span class="sd">                The mean frequency (center) of the image sideband.</span>
<span class="sd">                </span>
<span class="sd">            fWidthSB : float</span>
<span class="sd">                The total bandwidth of the image sideband (will be equal to the input</span>
<span class="sd">                spectral window). </span>
<span class="sd">        </span>
<span class="sd">        Note: This has been taken from Todd Hunter&#39;s AU tools, specifically au.interpretLOs,</span>
<span class="sd">              au.getLOs, and plotbandpass3.py - CalcAtmTranmission.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get the information we need from the MS table ASDM_RECEIVER which will give us</span>
        <span class="c1"># the spw numbers, the LOs, and the &quot;names&quot; (more like an intent) of the spws.</span>
        <span class="n">mytb</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">msname</span><span class="o">+</span><span class="s1">&#39;/ASDM_RECEIVER&#39;</span><span class="p">)</span>
        <span class="n">numLO</span> <span class="o">=</span> <span class="n">mytb</span><span class="o">.</span><span class="n">getcol</span><span class="p">(</span><span class="s1">&#39;numLO&#39;</span><span class="p">)</span>
        <span class="n">freqLO</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">spws</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">names</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">numLO</span><span class="p">)):</span>
            <span class="n">spw</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">mytb</span><span class="o">.</span><span class="n">getcell</span><span class="p">(</span><span class="s1">&#39;spectralWindowId&#39;</span><span class="p">,</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]))</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">spw</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">spws</span><span class="p">):</span>
                <span class="n">spws</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">spw</span><span class="p">)</span>
                <span class="n">freqLO</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mytb</span><span class="o">.</span><span class="n">getcell</span><span class="p">(</span><span class="s1">&#39;freqLO&#39;</span><span class="p">,</span><span class="n">i</span><span class="p">))</span>
                <span class="n">names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mytb</span><span class="o">.</span><span class="n">getcell</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span><span class="n">i</span><span class="p">))</span>
        <span class="n">mytb</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        
        <span class="c1"># We want to ignore the superfluous WVR windows and find the right index for our</span>
        <span class="c1"># input spectral window.</span>
        <span class="n">sawWVR</span><span class="o">=</span><span class="kc">False</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">spws</span><span class="p">)):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;WVR&#39;</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">):</span>
                <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">sawWVR</span><span class="p">):</span>
                    <span class="n">indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                    <span class="n">sawWVR</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

        <span class="c1"># This is quite clever (taken from Todd&#39;s bandpass3), the LO is the frequency that </span>
        <span class="c1"># is exactly between the spw and the image sideband. Therefore, </span>
        <span class="c1">#   2*(spw_freq - LO_freq) - spw_freq</span>
        <span class="c1">#   2 * spw_freq - 2 * LO_freq - spw_freq</span>
        <span class="c1">#   spw_freq - 2 * LO_freq</span>
        <span class="c1"># this results in each channel getting the correctly matched image sideband frequency</span>
        <span class="c1"># such that the array counts in the right direction which is opposite the input spectral</span>
        <span class="c1"># window. </span>
        <span class="n">fSB</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">freqLO</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="n">spwin</span><span class="p">]][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">msmeta</span><span class="o">.</span><span class="n">chanfreqs</span><span class="p">(</span><span class="n">spwin</span><span class="p">))</span><span class="o">*</span><span class="mf">1e-9</span>
        <span class="n">fCenterSB</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">fSB</span><span class="p">)</span>
        <span class="n">chansepSB</span> <span class="o">=</span> <span class="p">(</span><span class="n">fSB</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">fSB</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">fSB</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">fWidthSB</span> <span class="o">=</span> <span class="n">chansepSB</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">fSB</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">fSB</span><span class="p">,</span> <span class="n">chansepSB</span><span class="p">,</span> <span class="n">fCenterSB</span><span class="p">,</span> <span class="n">fWidthSB</span></div>
</div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020–2024, Pipeline Dev. Team.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>