

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>pipeline.h.tasks.common.viewflaggers &mdash; Pipeline unknown documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../../../_static/graphviz.css?v=4ae1632d" />
      <link rel="stylesheet" type="text/css" href="../../../../../_static/custom_theme.css?v=678032d9" />

  
      <script src="../../../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../../../_static/documentation_options.js?v=3f1b9271"></script>
      <script src="../../../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../../index.html" class="icon icon-home">
            Pipeline
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Pipeline Tasks</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../pipeline_tasks/pipeline_tasks.html">Pipeline Heuristics Tasks</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Pipeline Task (sphinx-autosummary)</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../_autosummary/pipeline.h.cli.html">pipeline.h.cli</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../_autosummary/pipeline.hif.cli.html">pipeline.hif.cli</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../_autosummary/pipeline.hifa.cli.html">pipeline.hifa.cli</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../_autosummary/pipeline.hifv.cli.html">pipeline.hifv.cli</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../_autosummary/pipeline.hsd.cli.html">pipeline.hsd.cli</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../_autosummary/pipeline.hsdn.cli.html">pipeline.hsdn.cli</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../_autosummary/pipeline.domain.html">pipeline.domain</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../_autosummary/pipeline.infrastructure.launcher.html">pipeline.infrastructure.launcher</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../_autosummary/pipeline.domain.html">pipeline.domain</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../_autosummary/pipeline.infrastructure.launcher.html">pipeline.infrastructure.launcher</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Pipeline Heuristics</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../heuristics/field_parameter.html">Field parameter</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../heuristics/FlaggingTasks.html">Pipeline Flagging Tasks</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Releases etc.</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../releases.html">Pipeline Releases</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../modular.html">Run the Pipeline in a Conda environment</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../dependencies.html">Dependencies of <cite>Pipeline</cite></a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Pipeline Basics</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../basics.html">pipeline.domain</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../basics.html#module-pipeline.infrastructure.launcher">pipeline.infrastructure.launcher</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Task Classes</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../task_classes.html">pipeline</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../task_classes.html#module-pipeline.hif.tasks">pipeline-l2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../task_classes.html#module-pipeline.hif">pipeline-l3</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../task_classes.html#pipeline-diagram">pipeline-diagram</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Developer Notes</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../develdocmd/ways_to_run_the_pipeline.html">Ways to run the Pipeline</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../develdocmd/comparing_pipeline_executions.html">Comparing pipeline executions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../develdocmd/building_the_pipeline.html">Building the pipeline</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../develdocmd/ALMA-Imaging-Workflow.html">ALMA interferometry imaging workflow</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../develdocmd/VLA-Imaging-Workflow.html">VLA interferometry imaging workflow</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../develdocmd/VLASS-SE-CONT-Imaging-Workflow.html">VLASS-SE-CONT imaging workflow</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../develdocmd/VLASS-SE-CUBE-Imaging-Workflow.html">VLASS-SE-CUBE imaging workflow</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../develdocmd/selfcal_workflow.html">VLASS Selfcal &amp; Restore workflows</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../develdocmd/pipeline_tests.html">Pipeline testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../develdocmd/DataType_Testing.html">DataType Testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../develdocmd/QA_scores.html">Pipeline Quality Assurance (QA) Score Class Design</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../develdocmd/DeveloperDocumentation.html">Pipeline developer documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../develdocmd/python3_conversion_notes.html">Python 3 conversion notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../develdocmd/recipes.html">Pipeline Recipes</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Examples Notes (from Jupyter Notebooks)</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../examples/test1.html">test</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Example Notes (from .rst)</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../examples/test2.html">Example 1</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../../index.html">Pipeline</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../../../index.html">Module code</a></li>
          <li class="breadcrumb-item"><a href="../../../../pipeline.html">pipeline</a></li>
      <li class="breadcrumb-item active">pipeline.h.tasks.common.viewflaggers</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for pipeline.h.tasks.common.viewflaggers</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">operator</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">import</span> <span class="nn">pipeline.infrastructure</span> <span class="k">as</span> <span class="nn">infrastructure</span>
<span class="kn">import</span> <span class="nn">pipeline.infrastructure.basetask</span> <span class="k">as</span> <span class="nn">basetask</span>
<span class="kn">import</span> <span class="nn">pipeline.infrastructure.exceptions</span> <span class="k">as</span> <span class="nn">exceptions</span>
<span class="kn">import</span> <span class="nn">pipeline.infrastructure.logging</span> <span class="k">as</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">pipeline.infrastructure.vdp</span> <span class="k">as</span> <span class="nn">vdp</span>
<span class="kn">from</span> <span class="nn">pipeline.h.tasks.common</span> <span class="kn">import</span> <span class="n">arrayflaggerbase</span>
<span class="kn">from</span> <span class="nn">pipeline.h.tasks.common</span> <span class="kn">import</span> <span class="n">flaggableviewresults</span>
<span class="kn">from</span> <span class="nn">pipeline.h.tasks.common</span> <span class="kn">import</span> <span class="n">ozone</span>
<span class="kn">from</span> <span class="nn">pipeline.infrastructure</span> <span class="kn">import</span> <span class="n">casa_tools</span>
<span class="kn">from</span> <span class="nn">pipeline.infrastructure.utils.utils</span> <span class="kn">import</span> <span class="n">find_ranges</span>

<span class="n">LOG</span> <span class="o">=</span> <span class="n">infrastructure</span><span class="o">.</span><span class="n">get_logger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_get_ant_id_to_name_dict</span><span class="p">(</span><span class="n">ms</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return dictionary with antenna ID mapped to antenna name.</span>
<span class="sd">    If no unique antenna name can be assigned to each antenna ID,</span>
<span class="sd">    then return empty dictionary.</span>

<span class="sd">    :param ms: MeasurementSet</span>
<span class="sd">    :return: dictionary</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Create an antenna id-to-name translation dictionary.</span>
    <span class="n">antenna_id_to_name</span> <span class="o">=</span> <span class="p">{</span><span class="n">ant</span><span class="o">.</span><span class="n">id</span><span class="p">:</span> <span class="n">ant</span><span class="o">.</span><span class="n">name</span>
                          <span class="k">for</span> <span class="n">ant</span> <span class="ow">in</span> <span class="n">ms</span><span class="o">.</span><span class="n">antennas</span>
                          <span class="k">if</span> <span class="n">ant</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">strip</span><span class="p">()}</span>

    <span class="c1"># Check that each antenna ID is represented by a unique non-empty</span>
    <span class="c1"># name, by testing that the unique set of antenna names is same</span>
    <span class="c1"># length as list of IDs. If not, then set the translation</span>
    <span class="c1"># dictionary to an empty dictionary (to revert back to flagging by ID.)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">antenna_id_to_name</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ms</span><span class="o">.</span><span class="n">antennas</span><span class="p">):</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;No unique name available for each antenna ID:&#39;</span>
                 <span class="s1">&#39; flagging by antenna ID instead of by name.&#39;</span><span class="p">)</span>
        <span class="n">antenna_id_to_name</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">return</span> <span class="n">antenna_id_to_name</span>


<span class="k">def</span> <span class="nf">_log_outlier</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Pipeline DEBUG messages are only logged to the terminal unless the</span>
<span class="sd">    CASA logging priority level is also lowered. This method will log</span>
<span class="sd">    the outlier message as well as record it in the CASA log, so it can</span>
<span class="sd">    be referenced afterwards.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">LOG</span><span class="o">.</span><span class="n">isEnabledFor</span><span class="p">(</span><span class="n">level</span><span class="p">):</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">level</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>
        <span class="c1"># Log outliers directly to CASA log (CAS-11313)</span>
        <span class="n">casa_tools</span><span class="o">.</span><span class="n">post_to_log</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>


<div class="viewcode-block" id="MatrixFlaggerInputs">
<a class="viewcode-back" href="../../../../../_apidoc/pipeline.h.tasks.common.html#pipeline.h.tasks.common.viewflaggers.MatrixFlaggerInputs">[docs]</a>
<span class="k">class</span> <span class="nc">MatrixFlaggerInputs</span><span class="p">(</span><span class="n">vdp</span><span class="o">.</span><span class="n">StandardInputs</span><span class="p">):</span>
    <span class="n">prepend</span> <span class="o">=</span> <span class="n">vdp</span><span class="o">.</span><span class="n">VisDependentProperty</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
    <span class="n">skip_fully_flagged</span> <span class="o">=</span> <span class="n">vdp</span><span class="o">.</span><span class="n">VisDependentProperty</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">use_antenna_names</span> <span class="o">=</span> <span class="n">vdp</span><span class="o">.</span><span class="n">VisDependentProperty</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">output_dir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">datatask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">viewtask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">flagsettertask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">rules</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">niter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">extendfields</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">extendbaseband</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">iter_datatask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">use_antenna_names</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">prepend</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">skip_fully_flagged</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">MatrixFlaggerInputs</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

        <span class="c1"># pipeline inputs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">context</span> <span class="o">=</span> <span class="n">context</span>
        <span class="c1"># vis must be set first, as other properties may depend on it</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vis</span> <span class="o">=</span> <span class="n">vis</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_dir</span> <span class="o">=</span> <span class="n">output_dir</span>

        <span class="c1"># solution parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">datatask</span> <span class="o">=</span> <span class="n">datatask</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extendbaseband</span> <span class="o">=</span> <span class="n">extendbaseband</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extendfields</span> <span class="o">=</span> <span class="n">extendfields</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flagsettertask</span> <span class="o">=</span> <span class="n">flagsettertask</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iter_datatask</span> <span class="o">=</span> <span class="n">iter_datatask</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">niter</span> <span class="o">=</span> <span class="n">niter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prepend</span> <span class="o">=</span> <span class="n">prepend</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rules</span> <span class="o">=</span> <span class="n">rules</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">skip_fully_flagged</span> <span class="o">=</span> <span class="n">skip_fully_flagged</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">use_antenna_names</span> <span class="o">=</span> <span class="n">use_antenna_names</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">viewtask</span> <span class="o">=</span> <span class="n">viewtask</span></div>



<div class="viewcode-block" id="MatrixFlaggerResults">
<a class="viewcode-back" href="../../../../../_apidoc/pipeline.h.tasks.common.html#pipeline.h.tasks.common.viewflaggers.MatrixFlaggerResults">[docs]</a>
<span class="k">class</span> <span class="nc">MatrixFlaggerResults</span><span class="p">(</span><span class="n">basetask</span><span class="o">.</span><span class="n">Results</span><span class="p">,</span>
                           <span class="n">flaggableviewresults</span><span class="o">.</span><span class="n">FlaggableViewResults</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct and return a new MatrixFlaggerResults.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">basetask</span><span class="o">.</span><span class="n">Results</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">flaggableviewresults</span><span class="o">.</span><span class="n">FlaggableViewResults</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">vis</span> <span class="o">=</span> <span class="n">vis</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dataresult</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">viewresult</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="MatrixFlaggerResults.merge_with_context">
<a class="viewcode-back" href="../../../../../_apidoc/pipeline.h.tasks.common.html#pipeline.h.tasks.common.viewflaggers.MatrixFlaggerResults.merge_with_context">[docs]</a>
    <span class="k">def</span> <span class="nf">merge_with_context</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
        <span class="k">pass</span></div>


    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="s1">&#39;MatrixFlaggerResults&#39;</span>
        <span class="k">return</span> <span class="n">s</span></div>



<div class="viewcode-block" id="MatrixFlagger">
<a class="viewcode-back" href="../../../../../_apidoc/pipeline.h.tasks.common.html#pipeline.h.tasks.common.viewflaggers.MatrixFlagger">[docs]</a>
<span class="k">class</span> <span class="nc">MatrixFlagger</span><span class="p">(</span><span class="n">basetask</span><span class="o">.</span><span class="n">StandardTaskTemplate</span><span class="p">):</span>
    <span class="n">Inputs</span> <span class="o">=</span> <span class="n">MatrixFlaggerInputs</span>

    <span class="n">flag_reason_index</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;max abs&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
                         <span class="s1">&#39;min abs&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
                         <span class="s1">&#39;nmedian&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
                         <span class="s1">&#39;outlier&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span>
                         <span class="s1">&#39;high outlier&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
                         <span class="s1">&#39;low outlier&#39;</span><span class="p">:</span> <span class="mi">6</span><span class="p">,</span>
                         <span class="s1">&#39;too many flags&#39;</span><span class="p">:</span> <span class="mi">7</span><span class="p">,</span>
                         <span class="s1">&#39;bad quadrant&#39;</span><span class="p">:</span> <span class="mi">8</span><span class="p">,</span>
                         <span class="s1">&#39;bad antenna&#39;</span><span class="p">:</span> <span class="mi">9</span><span class="p">,</span>
                         <span class="s1">&#39;too many entirely flagged&#39;</span><span class="p">:</span> <span class="mi">10</span><span class="p">}</span>
    <span class="n">flag_reason_key</span> <span class="o">=</span> <span class="p">{</span><span class="n">value</span><span class="p">:</span> <span class="n">key</span> <span class="k">for</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="ow">in</span> <span class="n">flag_reason_index</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

    <span class="c1"># override the inherited __init__ method so that references to the</span>
    <span class="c1"># task objects can be kept outside self.inputs. Later on self.inputs</span>
    <span class="c1"># will be replaced by a copy which breaks the connection between</span>
    <span class="c1"># its references to the tasks and the originals.</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span> <span class="o">=</span> <span class="n">inputs</span>

<div class="viewcode-block" id="MatrixFlagger.prepare">
<a class="viewcode-back" href="../../../../../_apidoc/pipeline.h.tasks.common.html#pipeline.h.tasks.common.viewflaggers.MatrixFlagger.prepare">[docs]</a>
    <span class="k">def</span> <span class="nf">prepare</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">inputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span>

        <span class="c1"># Initialize result.</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">MatrixFlaggerResults</span><span class="p">(</span><span class="n">vis</span><span class="o">=</span><span class="n">inputs</span><span class="o">.</span><span class="n">vis</span><span class="p">)</span>

        <span class="c1"># Expand flag commands to larger scope, if requested, by removing</span>
        <span class="c1"># selection in specified fields</span>
        <span class="k">if</span> <span class="n">inputs</span><span class="o">.</span><span class="n">extendfields</span><span class="p">:</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> flagcmds will be extended by removing selection in following fields: </span><span class="si">{}</span><span class="s2">&quot;</span>
                     <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">inputs</span><span class="o">.</span><span class="n">prepend</span><span class="p">,</span> <span class="n">inputs</span><span class="o">.</span><span class="n">extendfields</span><span class="p">))</span>

        <span class="c1"># Expand flag commands to include all spws in a baseband, if requested</span>
        <span class="k">if</span> <span class="n">inputs</span><span class="o">.</span><span class="n">extendbaseband</span><span class="p">:</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> flagcmds will be extended to include all spws within baseband.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">inputs</span><span class="o">.</span><span class="n">prepend</span><span class="p">))</span>

        <span class="c1"># Initialize flags, flag_reason, and iteration counter</span>
        <span class="n">flags</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">flag_reason_plane</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">newflags</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">counter</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">include_before</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">dataresult</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">viewresult</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Start iterative flagging</span>
        <span class="k">while</span> <span class="n">counter</span> <span class="o">&lt;=</span> <span class="n">inputs</span><span class="o">.</span><span class="n">niter</span><span class="p">:</span>

            <span class="c1"># Run the data task if needed</span>
            <span class="k">if</span> <span class="n">counter</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># Always run data task on first iteration</span>
                <span class="n">dataresult</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_executor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">inputs</span><span class="o">.</span><span class="n">datatask</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">inputs</span><span class="o">.</span><span class="n">iter_datatask</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="c1"># If requested to re-run datatask on iteration, then</span>
                <span class="c1"># run the flag-setting task which modifies the data</span>
                <span class="c1"># and then re-run the data task</span>

                <span class="c1"># If no &quot;before summary&quot; was done, include this in the flag</span>
                <span class="c1"># setting task</span>
                <span class="k">if</span> <span class="n">include_before</span><span class="p">:</span>
                    <span class="n">stats_before</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_flags</span><span class="p">(</span><span class="n">newflags</span><span class="p">,</span>
                                                     <span class="n">summarize_before</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="n">include_before</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_flags</span><span class="p">(</span><span class="n">newflags</span><span class="p">)</span>

                <span class="n">dataresult</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_executor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">inputs</span><span class="o">.</span><span class="n">datatask</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># If not iterating the datatask, the previous</span>
                <span class="c1"># data result will be re-used, but marked here as no</span>
                <span class="c1"># longer new.</span>
                <span class="n">dataresult</span><span class="o">.</span><span class="n">new</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="c1"># Create flagging view</span>
            <span class="n">viewresult</span> <span class="o">=</span> <span class="n">inputs</span><span class="o">.</span><span class="n">viewtask</span><span class="p">(</span><span class="n">dataresult</span><span class="p">)</span>

            <span class="c1"># If a view could be created, continue with flagging</span>
            <span class="k">if</span> <span class="n">viewresult</span><span class="o">.</span><span class="n">descriptions</span><span class="p">():</span>

                <span class="c1"># Import the views from viewtask into the final result</span>
                <span class="n">result</span><span class="o">.</span><span class="n">importfrom</span><span class="p">(</span><span class="n">viewresult</span><span class="p">)</span>

                <span class="c1"># Flag the view</span>
                <span class="n">newflags</span><span class="p">,</span> <span class="n">newflags_reason</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flag_view</span><span class="p">(</span><span class="n">viewresult</span><span class="p">,</span> <span class="n">inputs</span><span class="o">.</span><span class="n">rules</span><span class="p">)</span>

                <span class="c1"># Report how many flags were found in this iteration and</span>
                <span class="c1"># stop iteration if no new flags were found</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">newflags</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># If no new flags are found, report as a log message</span>
                    <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{0}{1}</span><span class="s2"> iteration </span><span class="si">{2}</span><span class="s2"> raised </span><span class="si">{3}</span><span class="s2"> flagging commands&quot;</span>
                             <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">inputs</span><span class="o">.</span><span class="n">prepend</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">inputs</span><span class="o">.</span><span class="n">vis</span><span class="p">),</span> <span class="n">counter</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">newflags</span><span class="p">)))</span>
                    <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Report newly found flags (CAS-7336: show as info message instead of warning).</span>
                    <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{0}{1}</span><span class="s2"> iteration </span><span class="si">{2}</span><span class="s2"> raised </span><span class="si">{3}</span><span class="s2"> flagging commands&quot;</span>
                             <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">inputs</span><span class="o">.</span><span class="n">prepend</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">inputs</span><span class="o">.</span><span class="n">vis</span><span class="p">),</span> <span class="n">counter</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">newflags</span><span class="p">)))</span>

                <span class="c1"># Accumulate new flags and flag reasons</span>
                <span class="n">flags</span> <span class="o">+=</span> <span class="n">newflags</span>
                <span class="k">for</span> <span class="n">description</span> <span class="ow">in</span> <span class="n">newflags_reason</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">description</span> <span class="ow">in</span> <span class="n">flag_reason_plane</span><span class="p">:</span>
                        <span class="n">flag_reason_plane</span><span class="p">[</span><span class="n">description</span><span class="p">][</span><span class="n">newflags_reason</span><span class="p">[</span><span class="n">description</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> \
                            <span class="n">newflags_reason</span><span class="p">[</span><span class="n">description</span><span class="p">][</span><span class="n">newflags_reason</span><span class="p">[</span><span class="n">description</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">flag_reason_plane</span><span class="p">[</span><span class="n">description</span><span class="p">]</span> <span class="o">=</span> <span class="n">newflags_reason</span><span class="p">[</span><span class="n">description</span><span class="p">]</span>

                <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># If no view could be created, exit the iteration</span>
                <span class="n">LOG</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;No flagging view was created!&#39;</span><span class="p">)</span>
                <span class="k">break</span>

        <span class="c1"># Create final set of flags by removing duplicates from our accumulated</span>
        <span class="c1"># flags</span>
        <span class="n">flags</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">flags</span><span class="p">))</span>

        <span class="c1"># If flags were found...</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">flags</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>

            <span class="c1"># If newflags were found on last iteration loop, we need to still</span>
            <span class="c1"># set these.</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">newflags</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>

                <span class="c1"># If datatask needs to be iterated...</span>
                <span class="k">if</span> <span class="n">inputs</span><span class="o">.</span><span class="n">iter_datatask</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>

                    <span class="c1"># First set the new flags that were found on the last</span>
                    <span class="c1"># iteration. If the &quot;before&quot; summary was not yet created,</span>
                    <span class="c1"># then include this here; always include the &quot;after&quot;</span>
                    <span class="c1"># summary.</span>
                    <span class="k">if</span> <span class="n">include_before</span><span class="p">:</span>
                        <span class="c1"># Set flags, and include &quot;before&quot; and &quot;after&quot; summary.</span>
                        <span class="n">stats_before</span><span class="p">,</span> <span class="n">stats_after</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_flags</span><span class="p">(</span>
                            <span class="n">newflags</span><span class="p">,</span> <span class="n">summarize_before</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                            <span class="n">summarize_after</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># Set flags, and include &quot;after&quot; summary</span>
                        <span class="n">_</span><span class="p">,</span> <span class="n">stats_after</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_flags</span><span class="p">(</span>
                            <span class="n">newflags</span><span class="p">,</span> <span class="n">summarize_after</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

                    <span class="c1"># After setting the latest flags, re-run the data task.</span>
                    <span class="n">dataresult</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_executor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">inputs</span><span class="o">.</span><span class="n">datatask</span><span class="p">)</span>

                <span class="c1"># If the datatask did not need to be iterated, then no flags</span>
                <span class="c1"># were set yet and no &quot;before&quot; summary was performed yet, so</span>
                <span class="c1"># set all flags and include both &quot;before&quot; and &quot;after&quot; summary.</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">stats_before</span><span class="p">,</span> <span class="n">stats_after</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_flags</span><span class="p">(</span>
                        <span class="n">flags</span><span class="p">,</span> <span class="n">summarize_before</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">summarize_after</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

                <span class="c1"># Create final post-flagging view</span>
                <span class="n">viewresult</span> <span class="o">=</span> <span class="n">inputs</span><span class="o">.</span><span class="n">viewtask</span><span class="p">(</span><span class="n">dataresult</span><span class="p">)</span>

                <span class="c1"># Import the post-flagging view into the final result</span>
                <span class="n">result</span><span class="o">.</span><span class="n">importfrom</span><span class="p">(</span><span class="n">viewresult</span><span class="p">)</span>

            <span class="c1"># If flags were found, but no newflags were found on last iteration</span>
            <span class="c1"># then the dataresult is already up-to-date, and all that is needed</span>
            <span class="c1"># is to ensure the flags are set, and that summaries are created.</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># If datatask needs to be iterated, then the &quot;before&quot; summary has</span>
                <span class="c1"># already been done, and the flags have already been set, so only</span>
                <span class="c1"># need to do an &quot;after&quot; summary.</span>
                <span class="k">if</span> <span class="n">inputs</span><span class="o">.</span><span class="n">iter_datatask</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="n">_</span><span class="p">,</span> <span class="n">stats_after</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_flags</span><span class="p">([],</span> <span class="n">summarize_after</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="c1"># If the datatask did not need to be iterated, then no flags</span>
                <span class="c1"># were set yet and no &quot;before&quot; summary was performed yet,</span>
                <span class="c1"># so set all flags and include both &quot;before&quot; and &quot;after&quot; summary.</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">stats_before</span><span class="p">,</span> <span class="n">stats_after</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_flags</span><span class="p">(</span>
                        <span class="n">flags</span><span class="p">,</span> <span class="n">summarize_before</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">summarize_after</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="c1"># Store the final set of flags in the final result</span>
            <span class="n">result</span><span class="o">.</span><span class="n">addflags</span><span class="p">(</span><span class="n">flags</span><span class="p">)</span>

            <span class="c1"># Store the flag reasons in the last (i.e. post-flagging) view in</span>
            <span class="c1"># the final result</span>
            <span class="n">result</span><span class="o">.</span><span class="n">add_flag_reason_plane</span><span class="p">(</span><span class="n">flag_reason_plane</span><span class="p">,</span>
                                         <span class="bp">self</span><span class="o">.</span><span class="n">flag_reason_key</span><span class="p">)</span>

        <span class="c1"># if no flags were found at all</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Run a single flagging summary and use the result as both the &quot;before&quot;</span>
            <span class="c1"># and &quot;after&quot; summary.</span>
            <span class="n">stats_before</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_flags</span><span class="p">(</span><span class="n">flags</span><span class="p">,</span> <span class="n">summarize_before</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">stats_after</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">stats_before</span><span class="p">)</span>

        <span class="c1"># Store in the final result the name of the measurement set or caltable</span>
        <span class="c1"># to which any potentially found flags would need to be applied to.</span>
        <span class="n">result</span><span class="o">.</span><span class="n">table</span> <span class="o">=</span> <span class="n">inputs</span><span class="o">.</span><span class="n">flagsettertask</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">table</span>

        <span class="c1"># Store in the final result the final data task result and the final</span>
        <span class="c1"># view task result.</span>
        <span class="n">result</span><span class="o">.</span><span class="n">dataresult</span> <span class="o">=</span> <span class="n">dataresult</span>
        <span class="n">result</span><span class="o">.</span><span class="n">viewresult</span> <span class="o">=</span> <span class="n">viewresult</span>

        <span class="c1"># Store the flagging summaries in the final result</span>
        <span class="n">result</span><span class="o">.</span><span class="n">summaries</span> <span class="o">=</span> <span class="p">[</span><span class="n">stats_before</span><span class="p">,</span> <span class="n">stats_after</span><span class="p">]</span>

        <span class="c1"># Sort the final list of flagging commands.</span>
        <span class="n">result</span><span class="o">.</span><span class="n">sort_flagcmds</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="MatrixFlagger.analyse">
<a class="viewcode-back" href="../../../../../_apidoc/pipeline.h.tasks.common.html#pipeline.h.tasks.common.viewflaggers.MatrixFlagger.analyse">[docs]</a>
    <span class="k">def</span> <span class="nf">analyse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="MatrixFlagger.flag_view">
<a class="viewcode-back" href="../../../../../_apidoc/pipeline.h.tasks.common.html#pipeline.h.tasks.common.viewflaggers.MatrixFlagger.flag_view">[docs]</a>
    <span class="k">def</span> <span class="nf">flag_view</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">view</span><span class="p">,</span> <span class="n">rules</span><span class="p">):</span>
        <span class="n">newflags</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">newflags_reason</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">descriptionlist</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">view</span><span class="o">.</span><span class="n">descriptions</span><span class="p">())</span>
        <span class="k">for</span> <span class="n">description</span> <span class="ow">in</span> <span class="n">descriptionlist</span><span class="p">:</span>
            <span class="n">image</span> <span class="o">=</span> <span class="n">view</span><span class="o">.</span><span class="n">last</span><span class="p">(</span><span class="n">description</span><span class="p">)</span>
            <span class="c1"># get flags for this view according to the rules</span>
            <span class="n">theseflags</span><span class="p">,</span> <span class="n">this_flag_reason_plane</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_flags</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">rules</span><span class="p">)</span>

            <span class="c1"># update flagging record</span>
            <span class="n">newflags</span> <span class="o">+=</span> <span class="n">theseflags</span>
            <span class="n">newflags_reason</span><span class="p">[</span><span class="n">description</span><span class="p">]</span> <span class="o">=</span> <span class="n">this_flag_reason_plane</span>

        <span class="k">return</span> <span class="n">newflags</span><span class="p">,</span> <span class="n">newflags_reason</span></div>


<div class="viewcode-block" id="MatrixFlagger.set_flags">
<a class="viewcode-back" href="../../../../../_apidoc/pipeline.h.tasks.common.html#pipeline.h.tasks.common.viewflaggers.MatrixFlagger.set_flags">[docs]</a>
    <span class="k">def</span> <span class="nf">set_flags</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">summarize_before</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">summarize_after</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="c1"># Initialize flag commands.</span>
        <span class="n">allflagcmds</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Add the &quot;before&quot; summary to the flagging commands.</span>
        <span class="k">if</span> <span class="n">summarize_before</span><span class="p">:</span>
            <span class="n">allflagcmds</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;mode=&#39;summary&#39; name=&#39;before&#39;&quot;</span><span class="p">]</span>

        <span class="c1"># Add the flagging commands.</span>
        <span class="n">allflagcmds</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">flags</span><span class="p">)</span>

        <span class="c1"># Add the &quot;before&quot; summary to the flagging commands.</span>
        <span class="k">if</span> <span class="n">summarize_after</span><span class="p">:</span>
            <span class="n">allflagcmds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;mode=&#39;summary&#39; name=&#39;after&#39;&quot;</span><span class="p">)</span>

        <span class="c1"># Update flag setting task with all flagging commands.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">flagsettertask</span><span class="o">.</span><span class="n">flags_to_set</span><span class="p">(</span><span class="n">allflagcmds</span><span class="p">)</span>

        <span class="c1"># Run flag setting task</span>
        <span class="n">flagsetterresult</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_executor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">flagsettertask</span><span class="p">)</span>

        <span class="c1"># Initialize &quot;before&quot; and/or &quot;after&quot; summaries.</span>
        <span class="n">stats_before</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">stats_after</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># If the flagsetter returned results from the CASA flag data task,</span>
        <span class="c1"># then proceed to extract &quot;before&quot; and/or &quot;after&quot; flagging summaries;</span>
        <span class="c1"># if no &quot;real&quot; flagsetter results were returned (e.g. by</span>
        <span class="c1"># WvrgcalFlagSetter), then there will have been no real flagging</span>
        <span class="c1"># summaries created, in which case empty summaries are returned.</span>
        <span class="k">if</span> <span class="n">flagsetterresult</span><span class="o">.</span><span class="n">results</span><span class="p">:</span>
            <span class="c1"># CAS-10407: if MPI version of flagdata failed and returned invalid</span>
            <span class="c1"># results, then raise an exception.</span>
            <span class="k">if</span> <span class="n">flagsetterresult</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">exceptions</span><span class="o">.</span><span class="n">PipelineException</span><span class="p">(</span><span class="s2">&quot;Results from flagdata are empty, cannot continue.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">all</span><span class="p">([</span><span class="s1">&#39;report&#39;</span> <span class="ow">in</span> <span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">flagsetterresult</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">]]):</span>
                <span class="c1"># Go through dictionary of reports.</span>
                <span class="k">for</span> <span class="n">report</span> <span class="ow">in</span> <span class="n">flagsetterresult</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">flagsetterresult</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">report</span><span class="p">][</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;before&#39;</span><span class="p">:</span>
                        <span class="n">stats_before</span> <span class="o">=</span> <span class="n">flagsetterresult</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">report</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">flagsetterresult</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">report</span><span class="p">][</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;after&#39;</span><span class="p">:</span>
                        <span class="n">stats_after</span> <span class="o">=</span> <span class="n">flagsetterresult</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">report</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Go through single report.</span>
                <span class="k">if</span> <span class="n">flagsetterresult</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;before&#39;</span><span class="p">:</span>
                    <span class="n">stats_before</span> <span class="o">=</span> <span class="n">flagsetterresult</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">flagsetterresult</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;after&#39;</span><span class="p">:</span>
                    <span class="n">stats_after</span> <span class="o">=</span> <span class="n">flagsetterresult</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">stats_before</span><span class="p">,</span> <span class="n">stats_after</span></div>


<div class="viewcode-block" id="MatrixFlagger.make_flag_rules">
<a class="viewcode-back" href="../../../../../_apidoc/pipeline.h.tasks.common.html#pipeline.h.tasks.common.viewflaggers.MatrixFlagger.make_flag_rules">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">make_flag_rules</span><span class="p">(</span>
            <span class="n">flag_hilo</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fhl_limit</span><span class="o">=</span><span class="mf">5.0</span><span class="p">,</span> <span class="n">fhl_minsample</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
            <span class="n">flag_hi</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fhi_limit</span><span class="o">=</span><span class="mf">5.0</span><span class="p">,</span> <span class="n">fhi_minsample</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
            <span class="n">flag_lo</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">flo_limit</span><span class="o">=</span><span class="mf">5.0</span><span class="p">,</span> <span class="n">flo_minsample</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
            <span class="n">flag_tmf1</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">tmf1_axis</span><span class="o">=</span><span class="s1">&#39;Time&#39;</span><span class="p">,</span> <span class="n">tmf1_limit</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
            <span class="n">tmf1_excess_limit</span><span class="o">=</span><span class="mi">10000000</span><span class="p">,</span>
            <span class="n">flag_tmf2</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">tmf2_axis</span><span class="o">=</span><span class="s1">&#39;Time&#39;</span><span class="p">,</span> <span class="n">tmf2_limit</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
            <span class="n">tmf2_excess_limit</span><span class="o">=</span><span class="mi">10000000</span><span class="p">,</span>
            <span class="n">flag_tmef1</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">tmef1_axis</span><span class="o">=</span><span class="s1">&#39;Antenna1&#39;</span><span class="p">,</span> <span class="n">tmef1_limit</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
            <span class="n">flag_nmedian</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fnm_lo_limit</span><span class="o">=</span><span class="mf">0.7</span><span class="p">,</span> <span class="n">fnm_hi_limit</span><span class="o">=</span><span class="mf">1.3</span><span class="p">,</span>
            <span class="n">flag_maxabs</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fmax_limit</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
            <span class="n">flag_minabs</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fmin_limit</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
            <span class="n">flag_bad_quadrant</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fbq_hilo_limit</span><span class="o">=</span><span class="mf">7.0</span><span class="p">,</span>
            <span class="n">fbq_antenna_frac_limit</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">fbq_baseline_frac_limit</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
            <span class="n">flag_bad_antenna</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fba_lo_limit</span><span class="o">=</span><span class="mf">7.0</span><span class="p">,</span>
            <span class="n">fba_frac_limit</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">fba_number_limit</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">fba_minsample</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate a list of flagging rules from a set of flagging parameters.</span>
<span class="sd">        Added detailed docs here.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Construct rules from flag properties. If niter is set to curtail</span>
        <span class="c1"># the flagging loop then the order that the rules are applied</span>
        <span class="c1"># can be important. For example, &#39;too many flags&#39; should run after</span>
        <span class="c1"># the other rules, &#39;bad quadrant&#39; or &#39;bad antenna&#39; should be run</span>
        <span class="c1"># before the others.</span>
        <span class="n">rules</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">flag_bad_quadrant</span><span class="p">:</span>
            <span class="n">rules</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s1">&#39;bad quadrant&#39;</span><span class="p">,</span> <span class="s1">&#39;hilo_limit&#39;</span><span class="p">:</span> <span class="n">fbq_hilo_limit</span><span class="p">,</span>
                          <span class="s1">&#39;frac_limit&#39;</span><span class="p">:</span> <span class="n">fbq_antenna_frac_limit</span><span class="p">,</span>
                          <span class="s1">&#39;baseline_frac_limit&#39;</span><span class="p">:</span> <span class="n">fbq_baseline_frac_limit</span><span class="p">})</span>
        <span class="k">if</span> <span class="n">flag_bad_antenna</span><span class="p">:</span>
            <span class="n">rules</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s1">&#39;bad antenna&#39;</span><span class="p">,</span> <span class="s1">&#39;lo_limit&#39;</span><span class="p">:</span> <span class="n">fba_lo_limit</span><span class="p">,</span>
                          <span class="s1">&#39;frac_limit&#39;</span><span class="p">:</span> <span class="n">fba_frac_limit</span><span class="p">,</span>
                          <span class="s1">&#39;number_limit&#39;</span><span class="p">:</span> <span class="n">fba_number_limit</span><span class="p">,</span>
                          <span class="s1">&#39;minsample&#39;</span><span class="p">:</span> <span class="n">fba_minsample</span><span class="p">})</span>
        <span class="k">if</span> <span class="n">flag_maxabs</span><span class="p">:</span>
            <span class="n">rules</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s1">&#39;max abs&#39;</span><span class="p">,</span> <span class="s1">&#39;limit&#39;</span><span class="p">:</span> <span class="n">fmax_limit</span><span class="p">})</span>
        <span class="k">if</span> <span class="n">flag_minabs</span><span class="p">:</span>
            <span class="n">rules</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s1">&#39;min abs&#39;</span><span class="p">,</span> <span class="s1">&#39;limit&#39;</span><span class="p">:</span> <span class="n">fmin_limit</span><span class="p">})</span>
        <span class="k">if</span> <span class="n">flag_nmedian</span><span class="p">:</span>
            <span class="n">rules</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s1">&#39;nmedian&#39;</span><span class="p">,</span> <span class="s1">&#39;lo_limit&#39;</span><span class="p">:</span> <span class="n">fnm_lo_limit</span><span class="p">,</span>
                          <span class="s1">&#39;hi_limit&#39;</span><span class="p">:</span> <span class="n">fnm_hi_limit</span><span class="p">})</span>
        <span class="k">if</span> <span class="n">flag_hilo</span><span class="p">:</span>
            <span class="n">rules</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s1">&#39;outlier&#39;</span><span class="p">,</span> <span class="s1">&#39;limit&#39;</span><span class="p">:</span> <span class="n">fhl_limit</span><span class="p">,</span>
                          <span class="s1">&#39;minsample&#39;</span><span class="p">:</span> <span class="n">fhl_minsample</span><span class="p">})</span>
        <span class="k">if</span> <span class="n">flag_hi</span><span class="p">:</span>
            <span class="n">rules</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s1">&#39;high outlier&#39;</span><span class="p">,</span> <span class="s1">&#39;limit&#39;</span><span class="p">:</span> <span class="n">fhi_limit</span><span class="p">,</span>
                          <span class="s1">&#39;minsample&#39;</span><span class="p">:</span> <span class="n">fhi_minsample</span><span class="p">})</span>
        <span class="k">if</span> <span class="n">flag_lo</span><span class="p">:</span>
            <span class="n">rules</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s1">&#39;low outlier&#39;</span><span class="p">,</span> <span class="s1">&#39;limit&#39;</span><span class="p">:</span> <span class="n">flo_limit</span><span class="p">,</span>
                          <span class="s1">&#39;minsample&#39;</span><span class="p">:</span> <span class="n">flo_minsample</span><span class="p">})</span>
        <span class="k">if</span> <span class="n">flag_tmf1</span><span class="p">:</span>
            <span class="n">rules</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s1">&#39;too many flags&#39;</span><span class="p">,</span>
                          <span class="s1">&#39;axis&#39;</span><span class="p">:</span> <span class="nb">str</span><span class="o">.</span><span class="n">upper</span><span class="p">(</span><span class="n">tmf1_axis</span><span class="p">),</span>
                          <span class="s1">&#39;limit&#39;</span><span class="p">:</span> <span class="n">tmf1_limit</span><span class="p">,</span>
                          <span class="s1">&#39;excess limit&#39;</span><span class="p">:</span> <span class="n">tmf1_excess_limit</span><span class="p">})</span>
        <span class="k">if</span> <span class="n">flag_tmf2</span><span class="p">:</span>
            <span class="n">rules</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s1">&#39;too many flags&#39;</span><span class="p">,</span>
                          <span class="s1">&#39;axis&#39;</span><span class="p">:</span> <span class="nb">str</span><span class="o">.</span><span class="n">upper</span><span class="p">(</span><span class="n">tmf2_axis</span><span class="p">),</span>
                          <span class="s1">&#39;limit&#39;</span><span class="p">:</span> <span class="n">tmf2_limit</span><span class="p">,</span>
                          <span class="s1">&#39;excess limit&#39;</span><span class="p">:</span> <span class="n">tmf2_excess_limit</span><span class="p">})</span>
        <span class="k">if</span> <span class="n">flag_tmef1</span><span class="p">:</span>
            <span class="n">rules</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s1">&#39;too many entirely flagged&#39;</span><span class="p">,</span>
                          <span class="s1">&#39;axis&#39;</span><span class="p">:</span> <span class="nb">str</span><span class="o">.</span><span class="n">upper</span><span class="p">(</span><span class="n">tmef1_axis</span><span class="p">),</span>
                          <span class="s1">&#39;limit&#39;</span><span class="p">:</span> <span class="n">tmef1_limit</span><span class="p">})</span>

        <span class="k">return</span> <span class="n">rules</span></div>


<div class="viewcode-block" id="MatrixFlagger.generate_flags">
<a class="viewcode-back" href="../../../../../_apidoc/pipeline.h.tasks.common.html#pipeline.h.tasks.common.viewflaggers.MatrixFlagger.generate_flags">[docs]</a>
    <span class="k">def</span> <span class="nf">generate_flags</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">matrix</span><span class="p">,</span> <span class="n">rules</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the statistics of a matrix and flag the data according</span>
<span class="sd">        to a list of specified rules.</span>

<span class="sd">        Keyword arguments:</span>
<span class="sd">        matrix - ImageResult object containing data to be flagged.</span>
<span class="sd">        rules - Rules to be applied.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Get the attributes - ensure all arrays are numpy arrays</span>
        <span class="c1"># as some subsequent processing depends on numpy array indexing</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">matrix</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
        <span class="n">flag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">matrix</span><span class="o">.</span><span class="n">flag</span><span class="p">)</span>
        <span class="n">nodata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">matrix</span><span class="o">.</span><span class="n">nodata</span><span class="p">)</span>
        <span class="n">xtitle</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">name</span>
        <span class="n">xdata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">matrix</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
        <span class="n">ytitle</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">name</span>
        <span class="n">ydata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">matrix</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
        <span class="n">spw</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">.</span><span class="n">spw</span>
        <span class="n">table</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">.</span><span class="n">filename</span>
        <span class="n">pol</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">.</span><span class="n">pol</span>
        <span class="n">antenna</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">.</span><span class="n">ant</span>

        <span class="c1"># Initialize flags</span>
        <span class="n">newflags</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">flag_reason</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">flag</span><span class="p">),</span> <span class="nb">int</span><span class="p">)</span>

        <span class="c1"># If there is no valid (non-flagged) data, then return early.</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">flag</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">skip_fully_flagged</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">newflags</span><span class="p">,</span> <span class="n">flag_reason</span>

        <span class="c1"># If requested to use antenna names instead of IDs antenna,</span>
        <span class="c1"># create an id-to-name translation and check to make sure this</span>
        <span class="c1"># would result in unique non-empty names for all IDs, otherwise</span>
        <span class="c1"># revert back to flagging by ID</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">use_antenna_names</span><span class="p">:</span>
            <span class="n">antenna_id_to_name</span> <span class="o">=</span> <span class="n">_get_ant_id_to_name_dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">ms</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">antenna_id_to_name</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># If requested, expand current spw to all spws within the same</span>
        <span class="c1"># baseband, thus changing spw from an integer to a list of integers</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">extendbaseband</span><span class="p">:</span>
            <span class="n">ms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">observing_run</span><span class="o">.</span><span class="n">get_ms</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">vis</span><span class="p">)</span>
            <span class="n">baseband</span> <span class="o">=</span> <span class="n">ms</span><span class="o">.</span><span class="n">get_spectral_window</span><span class="p">(</span><span class="n">spw</span><span class="p">)</span><span class="o">.</span><span class="n">baseband</span>
            <span class="n">spw</span> <span class="o">=</span> <span class="p">[</span><span class="n">spw</span><span class="o">.</span><span class="n">id</span> <span class="k">for</span> <span class="n">spw</span> <span class="ow">in</span> <span class="n">ms</span><span class="o">.</span><span class="n">get_spectral_windows</span><span class="p">()</span>
                   <span class="k">if</span> <span class="n">spw</span><span class="o">.</span><span class="n">baseband</span> <span class="o">==</span> <span class="n">baseband</span><span class="p">]</span>

        <span class="c1"># Calculate statistics for valid (non-flagged) data.</span>
        <span class="n">valid_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">flag</span><span class="p">)]</span>
        <span class="n">nvalid</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">valid_data</span><span class="p">)</span>
        <span class="n">data_median</span><span class="p">,</span> <span class="n">data_mad</span> <span class="o">=</span> <span class="n">arrayflaggerbase</span><span class="o">.</span><span class="n">median_and_mad</span><span class="p">(</span><span class="n">valid_data</span><span class="p">)</span>

        <span class="c1"># Index arrays</span>
        <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>

        <span class="c1"># flag data according to each rule in turn</span>
        <span class="k">for</span> <span class="n">rule</span> <span class="ow">in</span> <span class="n">rules</span><span class="p">:</span>
            <span class="n">rulename</span> <span class="o">=</span> <span class="n">rule</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">rulename</span> <span class="o">==</span> <span class="s1">&#39;outlier&#39;</span><span class="p">:</span>

                <span class="c1"># Stop evaluating rule if sample is too small.</span>
                <span class="k">if</span> <span class="n">nvalid</span> <span class="o">&lt;</span> <span class="n">rule</span><span class="p">[</span><span class="s1">&#39;minsample&#39;</span><span class="p">]:</span>
                    <span class="k">continue</span>

                <span class="c1"># Check limits.</span>
                <span class="n">mad_max</span> <span class="o">=</span> <span class="n">rule</span><span class="p">[</span><span class="s1">&#39;limit&#39;</span><span class="p">]</span>

                <span class="c1"># Create masked array with flagged data masked.</span>
                <span class="n">data_masked</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">data</span> <span class="o">-</span> <span class="n">data_median</span><span class="p">),</span> <span class="n">mask</span><span class="o">=</span><span class="n">flag</span><span class="p">)</span>

                <span class="c1"># Create new masked array from masked array with outliers</span>
                <span class="c1"># masked. This should avoid performing a comparison with</span>
                <span class="c1"># flagged data that could include NaNs (that would cause a</span>
                <span class="c1"># RuntimeWarning).</span>
                <span class="n">outlier_threshold</span> <span class="o">=</span> <span class="n">mad_max</span> <span class="o">*</span> <span class="n">data_mad</span>
                <span class="n">data_masked</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_greater</span><span class="p">(</span><span class="n">data_masked</span><span class="p">,</span> <span class="n">outlier_threshold</span><span class="p">)</span>

                <span class="c1"># Get indices to flag as the masked elements that were not</span>
                <span class="c1"># already flagged, i.e. the newly masked elements.</span>
                <span class="n">new_flag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">getmask</span><span class="p">(</span><span class="n">data_masked</span><span class="p">),</span>
                                          <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">flag</span><span class="p">))</span>

                <span class="c1"># No flagged data.</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">new_flag</span><span class="p">):</span>
                    <span class="k">continue</span>

                <span class="c1"># PIPE-344: If the flagged channels fall within ozone lines, then ignore these outliers</span>
                <span class="c1"># (but still display a notification message that no action was taken)</span>
                <span class="n">ozone_channels</span> <span class="o">=</span> <span class="n">ozone</span><span class="o">.</span><span class="n">get_ozone_channels_for_spw</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">ms</span><span class="p">,</span> <span class="n">spw</span><span class="p">)</span>
                <span class="n">new_flag_unfiltered</span> <span class="o">=</span> <span class="n">new_flag</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">new_flag</span><span class="p">[</span><span class="n">ozone_channels</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">rejected_flagging_all_baselines</span> <span class="o">=</span> <span class="n">new_flag</span> <span class="o">!=</span> <span class="n">new_flag_unfiltered</span>

                <span class="c1"># If the view is for a specific set of antennas, then include these in the warning</span>
                <span class="k">if</span> <span class="n">antenna</span><span class="p">:</span>
                    <span class="n">ants_as_str</span> <span class="o">=</span> <span class="s2">&quot;, ant </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">antenna</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ants_as_str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">rejected_flagging_all_baselines</span><span class="p">):</span>
                    <span class="c1"># collapse the array of rejected flags from num_channels*num_baselines to num_channels*num_antennas</span>
                    <span class="n">nchan</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">nant</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                    <span class="n">rejected_flagging</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">rejected_flagging_all_baselines</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">nchan</span><span class="p">,</span> <span class="n">nant</span><span class="p">,</span> <span class="n">nant</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">rejected_flagging_all_baselines</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">nchan</span><span class="p">,</span> <span class="n">nant</span><span class="p">,</span> <span class="n">nant</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span>

                    <span class="c1"># compressed (human-readable) list of channels in which at least one antenna was affected</span>
                    <span class="n">rejected_channel_ranges</span> <span class="o">=</span> <span class="n">find_ranges</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">rejected_flagging</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))[</span><span class="mi">0</span><span class="p">])</span>

                    <span class="c1"># list of affected antennas (those for which flagging was rejected in at least one channel)</span>
                    <span class="n">rejected_antenna_names</span> <span class="o">=</span> <span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span>
                        <span class="p">(</span><span class="n">antenna_id_to_name</span><span class="p">[</span><span class="n">ant</span><span class="p">]</span> <span class="k">if</span> <span class="n">antenna_id_to_name</span> <span class="k">else</span> <span class="nb">str</span><span class="p">(</span><span class="n">ant</span><span class="p">))</span>
                        <span class="k">for</span> <span class="n">ant</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">rejected_flagging</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="p">])</span>

                    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Outliers provisionally found with flagging rule &#39;</span><span class="si">{}</span><span class="s2">&#39; for </span><span class="si">{}</span><span class="s2">, spw </span><span class="si">{}</span><span class="s2">, pol </span><span class="si">{}{}</span><span class="s2">, channel </span><span class="si">{}</span><span class="s2">, &quot;</span>
                           <span class="s2">&quot;antenna </span><span class="si">{}</span><span class="s2">, were not flagged because they overlap with known atmospheric ozone lines&quot;</span>
                           <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">rulename</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">table</span><span class="p">),</span> <span class="n">spw</span><span class="p">,</span> <span class="n">pol</span><span class="p">,</span> <span class="n">ants_as_str</span><span class="p">,</span>
                                     <span class="n">rejected_channel_ranges</span><span class="p">,</span> <span class="n">rejected_antenna_names</span><span class="p">))</span>

                    <span class="c1"># add a message at the &quot;attention&quot; level, creating a notification banner in the weblog</span>
                    <span class="n">_log_outlier</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">ATTENTION</span><span class="p">)</span>

                <span class="c1"># check again if any outliers remained after excluding those within ozone lines</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">new_flag</span><span class="p">):</span>
                    <span class="k">continue</span>

                <span class="c1"># Log a debug message with outliers.</span>
                <span class="n">outliers_as_str</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">sorted</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">ol</span><span class="p">)</span> <span class="k">for</span> <span class="n">ol</span> <span class="ow">in</span> <span class="n">data_masked</span><span class="p">[</span><span class="n">new_flag</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Outliers found with flagging rule &#39;</span><span class="si">{}</span><span class="s2">&#39; for </span><span class="si">{}</span><span class="s2">, spw </span><span class="si">{}</span><span class="s2">, pol </span><span class="si">{}{}</span><span class="s2">.</span><span class="se">\n</span><span class="s2">&quot;</span>
                       <span class="s2">&quot;Data: median = </span><span class="si">{}</span><span class="s2">, MAD = </span><span class="si">{}</span><span class="s2">. Max MAD threshold = </span><span class="si">{}</span><span class="s2">, corresponding to </span><span class="si">{}</span><span class="s2">.</span><span class="se">\n</span><span class="s2">&quot;</span>
                       <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> outlier(s) found (highest to lowest): </span><span class="si">{}</span><span class="s2">&quot;</span>
                       <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">rulename</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">table</span><span class="p">),</span> <span class="n">spw</span><span class="p">,</span> <span class="n">pol</span><span class="p">,</span> <span class="n">ants_as_str</span><span class="p">,</span> <span class="n">data_median</span><span class="p">,</span> <span class="n">data_mad</span><span class="p">,</span>
                                 <span class="n">mad_max</span><span class="p">,</span> <span class="n">outlier_threshold</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_masked</span><span class="p">[</span><span class="n">new_flag</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">),</span> <span class="n">outliers_as_str</span><span class="p">))</span>
                <span class="n">_log_outlier</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

                <span class="n">i2flag</span> <span class="o">=</span> <span class="n">i</span><span class="p">[</span><span class="n">new_flag</span><span class="p">]</span>
                <span class="n">j2flag</span> <span class="o">=</span> <span class="n">j</span><span class="p">[</span><span class="n">new_flag</span><span class="p">]</span>

                <span class="c1"># Add new flag command to flag data underlying the view.</span>
                <span class="k">for</span> <span class="n">flagcoord</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">xdata</span><span class="p">[</span><span class="n">i2flag</span><span class="p">],</span> <span class="n">ydata</span><span class="p">[</span><span class="n">j2flag</span><span class="p">]):</span>
                    <span class="n">newflags</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arrayflaggerbase</span><span class="o">.</span><span class="n">FlagCmd</span><span class="p">(</span>
                        <span class="n">reason</span><span class="o">=</span><span class="s1">&#39;outlier&#39;</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="n">table</span><span class="p">,</span> <span class="n">rulename</span><span class="o">=</span><span class="n">rulename</span><span class="p">,</span> <span class="n">spw</span><span class="o">=</span><span class="n">spw</span><span class="p">,</span> <span class="n">antenna</span><span class="o">=</span><span class="n">antenna</span><span class="p">,</span>
                        <span class="n">axisnames</span><span class="o">=</span><span class="p">[</span><span class="n">xtitle</span><span class="p">,</span> <span class="n">ytitle</span><span class="p">],</span> <span class="n">flagcoords</span><span class="o">=</span><span class="n">flagcoord</span><span class="p">,</span> <span class="n">pol</span><span class="o">=</span><span class="n">pol</span><span class="p">,</span>
                        <span class="n">extendfields</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">extendfields</span><span class="p">,</span> <span class="n">antenna_id_to_name</span><span class="o">=</span><span class="n">antenna_id_to_name</span><span class="p">))</span>

                <span class="c1"># Flag the view, for any subsequent rules being evaluated.</span>
                <span class="n">flag</span><span class="p">[</span><span class="n">i2flag</span><span class="p">,</span> <span class="n">j2flag</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">flag_reason</span><span class="p">[</span><span class="n">i2flag</span><span class="p">,</span> <span class="n">j2flag</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flag_reason_index</span><span class="p">[</span><span class="n">rulename</span><span class="p">]</span>

            <span class="k">elif</span> <span class="n">rulename</span> <span class="o">==</span> <span class="s1">&#39;low outlier&#39;</span><span class="p">:</span>

                <span class="c1"># Stop evaluating rule if sample is too small.</span>
                <span class="k">if</span> <span class="n">nvalid</span> <span class="o">&lt;</span> <span class="n">rule</span><span class="p">[</span><span class="s1">&#39;minsample&#39;</span><span class="p">]:</span>
                    <span class="k">continue</span>

                <span class="c1"># Check limits.</span>
                <span class="n">mad_max</span> <span class="o">=</span> <span class="n">rule</span><span class="p">[</span><span class="s1">&#39;limit&#39;</span><span class="p">]</span>

                <span class="c1"># Create masked array with flagged data masked.</span>
                <span class="n">data_masked</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data_median</span> <span class="o">-</span> <span class="n">data</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">flag</span><span class="p">)</span>

                <span class="c1"># Create new masked array from masked array with outliers</span>
                <span class="c1"># masked. This should avoid performing a comparison with</span>
                <span class="c1"># flagged data that could include NaNs (that would cause a</span>
                <span class="c1"># RuntimeWarning).</span>
                <span class="n">outlier_threshold</span> <span class="o">=</span> <span class="n">mad_max</span> <span class="o">*</span> <span class="n">data_mad</span>
                <span class="n">data_masked</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_greater</span><span class="p">(</span><span class="n">data_masked</span><span class="p">,</span> <span class="n">outlier_threshold</span><span class="p">)</span>

                <span class="c1"># Get indices to flag as the masked elements that were not</span>
                <span class="c1"># already flagged, i.e. the newly masked elements.</span>
                <span class="n">new_flag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">getmask</span><span class="p">(</span><span class="n">data_masked</span><span class="p">),</span>
                                          <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">flag</span><span class="p">))</span>

                <span class="c1"># No flagged data.</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">new_flag</span><span class="p">):</span>
                    <span class="k">continue</span>

                <span class="c1"># Log a debug message with outliers.</span>
                <span class="n">outliers_as_str</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">sorted</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">ol</span><span class="p">)</span> <span class="k">for</span> <span class="n">ol</span> <span class="ow">in</span> <span class="n">data_masked</span><span class="p">[</span><span class="n">new_flag</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Outliers found with flagging rule &#39;</span><span class="si">{}</span><span class="s2">&#39; for </span><span class="si">{}</span><span class="s2">, spw </span><span class="si">{}</span><span class="s2">, pol </span><span class="si">{}</span><span class="s2">.</span><span class="se">\n</span><span class="s2">&quot;</span>
                       <span class="s2">&quot;Data: median = </span><span class="si">{}</span><span class="s2">, MAD = </span><span class="si">{}</span><span class="s2">. Max MAD threshold = </span><span class="si">{}</span><span class="s2">, corresponding to </span><span class="si">{}</span><span class="s2">.</span><span class="se">\n</span><span class="s2">&quot;</span>
                       <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> outlier(s) found (highest to lowest): </span><span class="si">{}</span><span class="s2">&quot;</span>
                       <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">rulename</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">table</span><span class="p">),</span> <span class="n">spw</span><span class="p">,</span> <span class="n">pol</span><span class="p">,</span> <span class="n">data_median</span><span class="p">,</span> <span class="n">data_mad</span><span class="p">,</span> <span class="n">mad_max</span><span class="p">,</span>
                                 <span class="n">outlier_threshold</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_masked</span><span class="p">[</span><span class="n">new_flag</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">),</span> <span class="n">outliers_as_str</span><span class="p">))</span>
                <span class="n">_log_outlier</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

                <span class="n">i2flag</span> <span class="o">=</span> <span class="n">i</span><span class="p">[</span><span class="n">new_flag</span><span class="p">]</span>
                <span class="n">j2flag</span> <span class="o">=</span> <span class="n">j</span><span class="p">[</span><span class="n">new_flag</span><span class="p">]</span>

                <span class="c1"># Add new flag commands to flag data underlying the view.</span>
                <span class="k">for</span> <span class="n">flagcoord</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">xdata</span><span class="p">[</span><span class="n">i2flag</span><span class="p">],</span> <span class="n">ydata</span><span class="p">[</span><span class="n">j2flag</span><span class="p">]):</span>
                    <span class="n">newflags</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arrayflaggerbase</span><span class="o">.</span><span class="n">FlagCmd</span><span class="p">(</span>
                        <span class="n">reason</span><span class="o">=</span><span class="s1">&#39;low_outlier&#39;</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="n">table</span><span class="p">,</span> <span class="n">rulename</span><span class="o">=</span><span class="n">rulename</span><span class="p">,</span> <span class="n">spw</span><span class="o">=</span><span class="n">spw</span><span class="p">,</span> <span class="n">antenna</span><span class="o">=</span><span class="n">antenna</span><span class="p">,</span>
                        <span class="n">axisnames</span><span class="o">=</span><span class="p">[</span><span class="n">xtitle</span><span class="p">,</span> <span class="n">ytitle</span><span class="p">],</span> <span class="n">flagcoords</span><span class="o">=</span><span class="n">flagcoord</span><span class="p">,</span> <span class="n">pol</span><span class="o">=</span><span class="n">pol</span><span class="p">,</span>
                        <span class="n">extendfields</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">extendfields</span><span class="p">,</span> <span class="n">antenna_id_to_name</span><span class="o">=</span><span class="n">antenna_id_to_name</span><span class="p">))</span>

                <span class="c1"># Flag the view, for any subsequent rules being evaluated.</span>
                <span class="n">flag</span><span class="p">[</span><span class="n">i2flag</span><span class="p">,</span> <span class="n">j2flag</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">flag_reason</span><span class="p">[</span><span class="n">i2flag</span><span class="p">,</span> <span class="n">j2flag</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flag_reason_index</span><span class="p">[</span><span class="n">rulename</span><span class="p">]</span>

            <span class="k">elif</span> <span class="n">rulename</span> <span class="o">==</span> <span class="s1">&#39;high outlier&#39;</span><span class="p">:</span>

                <span class="c1"># Stop evaluating rule if sample is too small.</span>
                <span class="k">if</span> <span class="n">nvalid</span> <span class="o">&lt;</span> <span class="n">rule</span><span class="p">[</span><span class="s1">&#39;minsample&#39;</span><span class="p">]:</span>
                    <span class="k">continue</span>

                <span class="c1"># Get threshold limit.</span>
                <span class="n">mad_max</span> <span class="o">=</span> <span class="n">rule</span><span class="p">[</span><span class="s1">&#39;limit&#39;</span><span class="p">]</span>

                <span class="c1"># Create masked array with flagged data masked.</span>
                <span class="n">data_masked</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span> <span class="o">-</span> <span class="n">data_median</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">flag</span><span class="p">)</span>

                <span class="c1"># Create new masked array from masked array with outliers</span>
                <span class="c1"># masked. This should avoid performing a comparison with</span>
                <span class="c1"># flagged data that could include NaNs (that would cause a</span>
                <span class="c1"># RuntimeWarning).</span>
                <span class="n">outlier_threshold</span> <span class="o">=</span> <span class="n">mad_max</span> <span class="o">*</span> <span class="n">data_mad</span>
                <span class="n">data_masked</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_greater</span><span class="p">(</span><span class="n">data_masked</span><span class="p">,</span> <span class="n">outlier_threshold</span><span class="p">)</span>

                <span class="c1"># Get indices to flag as the masked elements that were not</span>
                <span class="c1"># already flagged, i.e. the newly masked elements.</span>
                <span class="n">new_flag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">getmask</span><span class="p">(</span><span class="n">data_masked</span><span class="p">),</span>
                                          <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">flag</span><span class="p">))</span>

                <span class="c1"># No flags</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">new_flag</span><span class="p">):</span>
                    <span class="k">continue</span>

                <span class="c1"># Log a debug message with outliers.</span>
                <span class="n">outliers_as_str</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">sorted</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">ol</span><span class="p">)</span> <span class="k">for</span> <span class="n">ol</span> <span class="ow">in</span> <span class="n">data_masked</span><span class="p">[</span><span class="n">new_flag</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Outliers found with flagging rule &#39;</span><span class="si">{}</span><span class="s2">&#39; for </span><span class="si">{}</span><span class="s2">, spw </span><span class="si">{}</span><span class="s2">, pol </span><span class="si">{}</span><span class="s2">.</span><span class="se">\n</span><span class="s2">&quot;</span>
                       <span class="s2">&quot;Data: median = </span><span class="si">{}</span><span class="s2">, MAD = </span><span class="si">{}</span><span class="s2">. Max MAD threshold = </span><span class="si">{}</span><span class="s2">, corresponding to </span><span class="si">{}</span><span class="s2">.</span><span class="se">\n</span><span class="s2">&quot;</span>
                       <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> outlier(s) found (highest to lowest): </span><span class="si">{}</span><span class="s2">&quot;</span>
                       <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">rulename</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">table</span><span class="p">),</span> <span class="n">spw</span><span class="p">,</span> <span class="n">pol</span><span class="p">,</span> <span class="n">data_median</span><span class="p">,</span> <span class="n">data_mad</span><span class="p">,</span> <span class="n">mad_max</span><span class="p">,</span>
                                 <span class="n">outlier_threshold</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_masked</span><span class="p">[</span><span class="n">new_flag</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">),</span> <span class="n">outliers_as_str</span><span class="p">))</span>
                <span class="n">_log_outlier</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

                <span class="n">i2flag</span> <span class="o">=</span> <span class="n">i</span><span class="p">[</span><span class="n">new_flag</span><span class="p">]</span>
                <span class="n">j2flag</span> <span class="o">=</span> <span class="n">j</span><span class="p">[</span><span class="n">new_flag</span><span class="p">]</span>

                <span class="c1"># Add new flag commands to flag data underlying the view.</span>
                <span class="k">for</span> <span class="n">flagcoord</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">xdata</span><span class="p">[</span><span class="n">i2flag</span><span class="p">],</span> <span class="n">ydata</span><span class="p">[</span><span class="n">j2flag</span><span class="p">]):</span>
                    <span class="n">newflags</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arrayflaggerbase</span><span class="o">.</span><span class="n">FlagCmd</span><span class="p">(</span>
                        <span class="n">reason</span><span class="o">=</span><span class="s1">&#39;high_outlier&#39;</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="n">table</span><span class="p">,</span> <span class="n">rulename</span><span class="o">=</span><span class="n">rulename</span><span class="p">,</span> <span class="n">spw</span><span class="o">=</span><span class="n">spw</span><span class="p">,</span> <span class="n">antenna</span><span class="o">=</span><span class="n">antenna</span><span class="p">,</span>
                        <span class="n">axisnames</span><span class="o">=</span><span class="p">[</span><span class="n">xtitle</span><span class="p">,</span> <span class="n">ytitle</span><span class="p">],</span> <span class="n">flagcoords</span><span class="o">=</span><span class="n">flagcoord</span><span class="p">,</span> <span class="n">pol</span><span class="o">=</span><span class="n">pol</span><span class="p">,</span>
                        <span class="n">extendfields</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">extendfields</span><span class="p">,</span> <span class="n">antenna_id_to_name</span><span class="o">=</span><span class="n">antenna_id_to_name</span><span class="p">))</span>

                <span class="c1"># Flag the view, for any subsequent rules being evaluated.</span>
                <span class="n">flag</span><span class="p">[</span><span class="n">i2flag</span><span class="p">,</span> <span class="n">j2flag</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">flag_reason</span><span class="p">[</span><span class="n">i2flag</span><span class="p">,</span> <span class="n">j2flag</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flag_reason_index</span><span class="p">[</span><span class="n">rulename</span><span class="p">]</span>

            <span class="k">elif</span> <span class="n">rulename</span> <span class="o">==</span> <span class="s1">&#39;min abs&#39;</span><span class="p">:</span>

                <span class="c1"># Stop evaluating rule if all data is flagged.</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">flag</span><span class="p">):</span>
                    <span class="k">continue</span>

                <span class="c1"># Check limits.</span>
                <span class="n">limit</span> <span class="o">=</span> <span class="n">rule</span><span class="p">[</span><span class="s1">&#39;limit&#39;</span><span class="p">]</span>

                <span class="c1"># Create masked array with flagged data masked.</span>
                <span class="n">data_masked</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">mask</span><span class="o">=</span><span class="n">flag</span><span class="p">)</span>

                <span class="c1"># Create new masked array from masked array with outliers</span>
                <span class="c1"># masked. This should avoid performing a comparison with</span>
                <span class="c1"># flagged data that could include NaNs (that would cause a</span>
                <span class="c1"># RuntimeWarning).</span>
                <span class="n">data_masked</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_less</span><span class="p">(</span><span class="n">data_masked</span><span class="p">,</span> <span class="n">limit</span><span class="p">)</span>

                <span class="c1"># Get indices to flag as the masked elements that were not</span>
                <span class="c1"># already flagged, i.e. the newly masked elements.</span>
                <span class="n">new_flag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">getmask</span><span class="p">(</span><span class="n">data_masked</span><span class="p">),</span>
                                          <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">flag</span><span class="p">))</span>

                <span class="c1"># No flags</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">new_flag</span><span class="p">):</span>
                    <span class="k">continue</span>

                <span class="c1"># Log a debug message with outliers.</span>
                <span class="n">outliers_as_str</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">sorted</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">ol</span><span class="p">)</span> <span class="k">for</span> <span class="n">ol</span> <span class="ow">in</span> <span class="n">data_masked</span><span class="p">[</span><span class="n">new_flag</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">]))</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Outliers found with flagging rule &#39;</span><span class="si">{}</span><span class="s2">&#39; for </span><span class="si">{}</span><span class="s2">, spw </span><span class="si">{}</span><span class="s2">, pol </span><span class="si">{}</span><span class="s2">.</span><span class="se">\n</span><span class="s2">&quot;</span>
                       <span class="s2">&quot;Minimum threshold = </span><span class="si">{}</span><span class="s2">.</span><span class="se">\n</span><span class="s2">&quot;</span>
                       <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> outlier(s) found (lowest to highest): </span><span class="si">{}</span><span class="s2">&quot;</span>
                       <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">rulename</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">table</span><span class="p">),</span> <span class="n">spw</span><span class="p">,</span> <span class="n">pol</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span>
                                 <span class="nb">len</span><span class="p">(</span><span class="n">data_masked</span><span class="p">[</span><span class="n">new_flag</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">),</span> <span class="n">outliers_as_str</span><span class="p">))</span>
                <span class="n">_log_outlier</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

                <span class="n">i2flag</span> <span class="o">=</span> <span class="n">i</span><span class="p">[</span><span class="n">new_flag</span><span class="p">]</span>
                <span class="n">j2flag</span> <span class="o">=</span> <span class="n">j</span><span class="p">[</span><span class="n">new_flag</span><span class="p">]</span>

                <span class="c1"># Add new flag commands to flag data underlying the view.</span>
                <span class="k">for</span> <span class="n">flagcoord</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">xdata</span><span class="p">[</span><span class="n">i2flag</span><span class="p">],</span> <span class="n">ydata</span><span class="p">[</span><span class="n">j2flag</span><span class="p">]):</span>
                    <span class="n">newflags</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arrayflaggerbase</span><span class="o">.</span><span class="n">FlagCmd</span><span class="p">(</span>
                        <span class="n">reason</span><span class="o">=</span><span class="s1">&#39;min_abs&#39;</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="n">table</span><span class="p">,</span> <span class="n">rulename</span><span class="o">=</span><span class="n">rulename</span><span class="p">,</span> <span class="n">spw</span><span class="o">=</span><span class="n">spw</span><span class="p">,</span> <span class="n">antenna</span><span class="o">=</span><span class="n">antenna</span><span class="p">,</span>
                        <span class="n">axisnames</span><span class="o">=</span><span class="p">[</span><span class="n">xtitle</span><span class="p">,</span> <span class="n">ytitle</span><span class="p">],</span> <span class="n">flagcoords</span><span class="o">=</span><span class="n">flagcoord</span><span class="p">,</span> <span class="n">pol</span><span class="o">=</span><span class="n">pol</span><span class="p">,</span>
                        <span class="n">extendfields</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">extendfields</span><span class="p">,</span> <span class="n">antenna_id_to_name</span><span class="o">=</span><span class="n">antenna_id_to_name</span><span class="p">))</span>

                <span class="c1"># Flag the view, for any subsequent rules being evaluated.</span>
                <span class="n">flag</span><span class="p">[</span><span class="n">i2flag</span><span class="p">,</span> <span class="n">j2flag</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">flag_reason</span><span class="p">[</span><span class="n">i2flag</span><span class="p">,</span> <span class="n">j2flag</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flag_reason_index</span><span class="p">[</span><span class="n">rulename</span><span class="p">]</span>

            <span class="k">elif</span> <span class="n">rulename</span> <span class="o">==</span> <span class="s1">&#39;max abs&#39;</span><span class="p">:</span>

                <span class="c1"># Stop evaluating rule if all data is flagged.</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">flag</span><span class="p">):</span>
                    <span class="k">continue</span>

                <span class="c1"># Check limits.</span>
                <span class="n">limit</span> <span class="o">=</span> <span class="n">rule</span><span class="p">[</span><span class="s1">&#39;limit&#39;</span><span class="p">]</span>

                <span class="c1"># Create masked array with flagged data masked.</span>
                <span class="n">data_masked</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">mask</span><span class="o">=</span><span class="n">flag</span><span class="p">)</span>

                <span class="c1"># Create new masked array from masked array with outliers</span>
                <span class="c1"># masked. This should avoid performing a comparison with</span>
                <span class="c1"># flagged data that could include NaNs (that would cause a</span>
                <span class="c1"># RuntimeWarning).</span>
                <span class="n">data_masked</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_greater</span><span class="p">(</span><span class="n">data_masked</span><span class="p">,</span> <span class="n">limit</span><span class="p">)</span>

                <span class="c1"># Get indices to flag as the masked elements that were not</span>
                <span class="c1"># already flagged, i.e. the newly masked elements.</span>
                <span class="n">new_flag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">getmask</span><span class="p">(</span><span class="n">data_masked</span><span class="p">),</span>
                                          <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">flag</span><span class="p">))</span>

                <span class="c1"># No flags</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">new_flag</span><span class="p">):</span>
                    <span class="k">continue</span>

                <span class="c1"># Log a debug message with outliers.</span>
                <span class="n">outliers_as_str</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">sorted</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">ol</span><span class="p">)</span> <span class="k">for</span> <span class="n">ol</span> <span class="ow">in</span> <span class="n">data_masked</span><span class="p">[</span><span class="n">new_flag</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Outliers found with flagging rule &#39;</span><span class="si">{}</span><span class="s2">&#39; for </span><span class="si">{}</span><span class="s2">, spw </span><span class="si">{}</span><span class="s2">, pol </span><span class="si">{}</span><span class="s2">.</span><span class="se">\n</span><span class="s2">&quot;</span>
                       <span class="s2">&quot;Maximum threshold = </span><span class="si">{}</span><span class="s2">.</span><span class="se">\n</span><span class="s2">&quot;</span>
                       <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> outlier(s) found (highest to lowest): </span><span class="si">{}</span><span class="s2">&quot;</span>
                       <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">rulename</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">table</span><span class="p">),</span> <span class="n">spw</span><span class="p">,</span> <span class="n">pol</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span>
                                 <span class="nb">len</span><span class="p">(</span><span class="n">data_masked</span><span class="p">[</span><span class="n">new_flag</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">),</span> <span class="n">outliers_as_str</span><span class="p">))</span>
                <span class="n">_log_outlier</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

                <span class="n">i2flag</span> <span class="o">=</span> <span class="n">i</span><span class="p">[</span><span class="n">new_flag</span><span class="p">]</span>
                <span class="n">j2flag</span> <span class="o">=</span> <span class="n">j</span><span class="p">[</span><span class="n">new_flag</span><span class="p">]</span>

                <span class="c1"># Add new flag commands to flag data underlying the view.</span>
                <span class="k">for</span> <span class="n">flagcoord</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">xdata</span><span class="p">[</span><span class="n">i2flag</span><span class="p">],</span> <span class="n">ydata</span><span class="p">[</span><span class="n">j2flag</span><span class="p">]):</span>
                    <span class="n">newflags</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arrayflaggerbase</span><span class="o">.</span><span class="n">FlagCmd</span><span class="p">(</span>
                        <span class="n">reason</span><span class="o">=</span><span class="s1">&#39;max_abs&#39;</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="n">table</span><span class="p">,</span> <span class="n">rulename</span><span class="o">=</span><span class="n">rulename</span><span class="p">,</span>  <span class="n">spw</span><span class="o">=</span><span class="n">spw</span><span class="p">,</span> <span class="n">antenna</span><span class="o">=</span><span class="n">antenna</span><span class="p">,</span>
                        <span class="n">axisnames</span><span class="o">=</span><span class="p">[</span><span class="n">xtitle</span><span class="p">,</span> <span class="n">ytitle</span><span class="p">],</span> <span class="n">flagcoords</span><span class="o">=</span><span class="n">flagcoord</span><span class="p">,</span> <span class="n">pol</span><span class="o">=</span><span class="n">pol</span><span class="p">,</span>
                        <span class="n">extendfields</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">extendfields</span><span class="p">,</span> <span class="n">antenna_id_to_name</span><span class="o">=</span><span class="n">antenna_id_to_name</span><span class="p">))</span>

                <span class="c1"># Flag the view, for any subsequent rules being evaluated.</span>
                <span class="n">flag</span><span class="p">[</span><span class="n">i2flag</span><span class="p">,</span> <span class="n">j2flag</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">flag_reason</span><span class="p">[</span><span class="n">i2flag</span><span class="p">,</span> <span class="n">j2flag</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flag_reason_index</span><span class="p">[</span><span class="n">rulename</span><span class="p">]</span>

            <span class="k">elif</span> <span class="n">rulename</span> <span class="o">==</span> <span class="s1">&#39;too many flags&#39;</span><span class="p">:</span>

                <span class="c1"># Stop evaluating rule if all data is flagged.</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">flag</span><span class="p">):</span>
                    <span class="k">continue</span>

                <span class="n">maxfraction</span> <span class="o">=</span> <span class="n">rule</span><span class="p">[</span><span class="s1">&#39;limit&#39;</span><span class="p">]</span>
                <span class="n">maxexcessflags</span> <span class="o">=</span> <span class="n">rule</span><span class="p">[</span><span class="s1">&#39;excess limit&#39;</span><span class="p">]</span>
                <span class="n">axis</span> <span class="o">=</span> <span class="n">rule</span><span class="p">[</span><span class="s1">&#39;axis&#39;</span><span class="p">]</span>
                <span class="n">axis</span> <span class="o">=</span> <span class="n">axis</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>

                <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="n">xtitle</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">():</span>

                    <span class="c1"># Compute median number flagged</span>
                    <span class="n">num_flagged</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">data</span><span class="p">)[</span><span class="mi">1</span><span class="p">]],</span> <span class="nb">int</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">iy</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ydata</span><span class="p">)):</span>
                        <span class="n">num_flagged</span><span class="p">[</span><span class="n">iy</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">[:,</span> <span class="n">iy</span><span class="p">][</span><span class="n">flag</span><span class="p">[:,</span> <span class="n">iy</span><span class="p">]])</span>
                    <span class="n">median_num_flagged</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">num_flagged</span><span class="p">)</span>

                    <span class="c1"># look along x axis</span>
                    <span class="k">for</span> <span class="n">iy</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ydata</span><span class="p">)):</span>
                        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">flag</span><span class="p">[:,</span> <span class="n">iy</span><span class="p">]):</span>
                            <span class="k">continue</span>

                        <span class="c1"># Compute fraction flagged</span>
                        <span class="n">len_data</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">xdata</span><span class="p">)</span>
                        <span class="n">len_no_data</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">[:,</span> <span class="n">iy</span><span class="p">][</span><span class="n">nodata</span><span class="p">[:,</span> <span class="n">iy</span><span class="p">]])</span>
                        <span class="n">len_flagged</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">[:,</span> <span class="n">iy</span><span class="p">][</span><span class="n">flag</span><span class="p">[:,</span> <span class="n">iy</span><span class="p">]])</span>
                        <span class="n">fractionflagged</span> <span class="o">=</span> <span class="p">(</span>
                          <span class="nb">float</span><span class="p">(</span><span class="n">len_flagged</span> <span class="o">-</span> <span class="n">len_no_data</span><span class="p">)</span> <span class="o">/</span>
                          <span class="nb">float</span><span class="p">(</span><span class="n">len_data</span> <span class="o">-</span> <span class="n">len_no_data</span><span class="p">))</span>
                        <span class="k">if</span> <span class="n">fractionflagged</span> <span class="o">&gt;</span> <span class="n">maxfraction</span><span class="p">:</span>
                            <span class="n">i2flag</span> <span class="o">=</span> <span class="n">i</span><span class="p">[:,</span> <span class="n">iy</span><span class="p">][</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">flag</span><span class="p">[:,</span> <span class="n">iy</span><span class="p">])]</span>
                            <span class="n">j2flag</span> <span class="o">=</span> <span class="n">j</span><span class="p">[:,</span> <span class="n">iy</span><span class="p">][</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">flag</span><span class="p">[:,</span> <span class="n">iy</span><span class="p">])]</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">i2flag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="nb">int</span><span class="p">)</span>
                            <span class="n">j2flag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="nb">int</span><span class="p">)</span>

                        <span class="c1"># likewise for maxexcessflags</span>
                        <span class="k">if</span> <span class="n">len_flagged</span> <span class="o">&gt;</span> <span class="n">median_num_flagged</span> <span class="o">+</span> <span class="n">maxexcessflags</span><span class="p">:</span>
                            <span class="n">i2flag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">i2flag</span><span class="p">,</span> <span class="n">i</span><span class="p">[:,</span> <span class="n">iy</span><span class="p">][</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">flag</span><span class="p">[:,</span> <span class="n">iy</span><span class="p">])]))</span>
                            <span class="n">j2flag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">j2flag</span><span class="p">,</span> <span class="n">j</span><span class="p">[:,</span> <span class="n">iy</span><span class="p">][</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">flag</span><span class="p">[:,</span> <span class="n">iy</span><span class="p">])]))</span>

                        <span class="c1"># If row did not have too many flags, skip row.</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">i2flag</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="k">continue</span>

                        <span class="c1"># Log a debug message about outliers.</span>
                        <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Outliers found with flagging rule &#39;</span><span class="si">{}</span><span class="s2">&#39; for </span><span class="si">{}</span><span class="s2">, spw </span><span class="si">{}</span><span class="s2">, pol </span><span class="si">{}</span><span class="s2">.</span><span class="se">\n</span><span class="s2">&quot;</span>
                               <span class="s2">&quot;Max fraction threshold </span><span class="si">{}</span><span class="s2">; max nr excess flags above median nr of flags </span><span class="si">{}</span><span class="s2">.</span><span class="se">\n</span><span class="s2">&quot;</span>
                               <span class="s2">&quot;Data: medium nr flagged </span><span class="si">{}</span><span class="s2">.</span><span class="se">\n</span><span class="s2">&quot;</span>
                               <span class="s2">&quot;For row </span><span class="si">{}</span><span class="s2">, number flagged = </span><span class="si">{}</span><span class="s2">, fraction flagged = </span><span class="si">{}</span><span class="s2">, exceeding thresholds; &quot;</span>
                               <span class="s2">&quot; entire row will be flagged.&quot;</span>
                               <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">rulename</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">table</span><span class="p">),</span> <span class="n">spw</span><span class="p">,</span> <span class="n">pol</span><span class="p">,</span> <span class="n">maxfraction</span><span class="p">,</span> <span class="n">maxexcessflags</span><span class="p">,</span>
                                         <span class="n">median_num_flagged</span><span class="p">,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">len_flagged</span><span class="p">,</span> <span class="n">fractionflagged</span><span class="p">))</span>
                        <span class="n">_log_outlier</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

                        <span class="c1"># Add new flag commands to flag data underlying</span>
                        <span class="c1"># the view.</span>
                        <span class="k">for</span> <span class="n">flagcoord</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">xdata</span><span class="p">[</span><span class="n">i2flag</span><span class="p">],</span> <span class="n">ydata</span><span class="p">[</span><span class="n">j2flag</span><span class="p">]):</span>
                            <span class="n">newflags</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arrayflaggerbase</span><span class="o">.</span><span class="n">FlagCmd</span><span class="p">(</span>
                                <span class="n">reason</span><span class="o">=</span><span class="s1">&#39;too_many_flags&#39;</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="n">table</span><span class="p">,</span> <span class="n">rulename</span><span class="o">=</span><span class="n">rulename</span><span class="p">,</span> <span class="n">spw</span><span class="o">=</span><span class="n">spw</span><span class="p">,</span> <span class="n">antenna</span><span class="o">=</span><span class="n">antenna</span><span class="p">,</span>
                                <span class="n">axisnames</span><span class="o">=</span><span class="p">[</span><span class="n">xtitle</span><span class="p">,</span> <span class="n">ytitle</span><span class="p">],</span> <span class="n">flagcoords</span><span class="o">=</span><span class="n">flagcoord</span><span class="p">,</span> <span class="n">pol</span><span class="o">=</span><span class="n">pol</span><span class="p">,</span>
                                <span class="n">extendfields</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">extendfields</span><span class="p">,</span> <span class="n">antenna_id_to_name</span><span class="o">=</span><span class="n">antenna_id_to_name</span><span class="p">))</span>

                        <span class="c1"># Flag the view, for any subsequent rules being evaluated.</span>
                        <span class="n">flag</span><span class="p">[</span><span class="n">i2flag</span><span class="p">,</span> <span class="n">j2flag</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="n">flag_reason</span><span class="p">[</span><span class="n">i2flag</span><span class="p">,</span> <span class="n">j2flag</span><span class="p">]</span> <span class="o">=</span>\
                            <span class="bp">self</span><span class="o">.</span><span class="n">flag_reason_index</span><span class="p">[</span><span class="n">rulename</span><span class="p">]</span>

                <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="n">ytitle</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">():</span>

                    <span class="c1"># Compute median number flagged</span>
                    <span class="n">num_flagged</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">data</span><span class="p">)[</span><span class="mi">0</span><span class="p">]],</span> <span class="nb">int</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">ix</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">xdata</span><span class="p">)):</span>
                        <span class="n">num_flagged</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="p">:][</span><span class="n">flag</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="p">:]])</span>
                    <span class="n">median_num_flagged</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">num_flagged</span><span class="p">)</span>

                    <span class="c1"># look along y axis</span>
                    <span class="k">for</span> <span class="n">ix</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">xdata</span><span class="p">)):</span>
                        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">flag</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="p">:]):</span>
                            <span class="k">continue</span>

                        <span class="n">len_data</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ydata</span><span class="p">)</span>
                        <span class="n">len_no_data</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="p">:][</span><span class="n">nodata</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="p">:]])</span>
                        <span class="n">len_flagged</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="p">:][</span><span class="n">flag</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="p">:]])</span>
                        <span class="n">fractionflagged</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="nb">float</span><span class="p">(</span><span class="n">len_flagged</span> <span class="o">-</span> <span class="n">len_no_data</span><span class="p">)</span> <span class="o">/</span>
                            <span class="nb">float</span><span class="p">(</span><span class="n">len_data</span> <span class="o">-</span> <span class="n">len_no_data</span><span class="p">))</span>
                        <span class="k">if</span> <span class="n">fractionflagged</span> <span class="o">&gt;</span> <span class="n">maxfraction</span><span class="p">:</span>
                            <span class="n">i2flag</span> <span class="o">=</span> <span class="n">i</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="p">:][</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">flag</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="p">:])]</span>
                            <span class="n">j2flag</span> <span class="o">=</span> <span class="n">j</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="p">:][</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">flag</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="p">:])]</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">i2flag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="nb">int</span><span class="p">)</span>
                            <span class="n">j2flag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="nb">int</span><span class="p">)</span>

                        <span class="n">len_flagged</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="p">:][</span><span class="n">flag</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="p">:]])</span>
                        <span class="k">if</span> <span class="n">len_flagged</span> <span class="o">&gt;</span> <span class="n">median_num_flagged</span> <span class="o">+</span> <span class="n">maxexcessflags</span><span class="p">:</span>
                            <span class="n">i2flag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">i2flag</span><span class="p">,</span> <span class="n">i</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="p">:][</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">flag</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="p">:])]))</span>
                            <span class="n">j2flag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">j2flag</span><span class="p">,</span> <span class="n">j</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="p">:][</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">flag</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="p">:])]))</span>

                        <span class="c1"># If no column had too many flags, skip column.</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">i2flag</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="k">continue</span>

                        <span class="c1"># Log a debug message about outliers.</span>
                        <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Outliers found with flagging rule &#39;</span><span class="si">{}</span><span class="s2">&#39; for </span><span class="si">{}</span><span class="s2">, spw </span><span class="si">{}</span><span class="s2">, pol </span><span class="si">{}</span><span class="s2">.</span><span class="se">\n</span><span class="s2">&quot;</span>
                               <span class="s2">&quot;Max fraction threshold </span><span class="si">{}</span><span class="s2">; max nr excess flags above median nr of flags </span><span class="si">{}</span><span class="s2">.</span><span class="se">\n</span><span class="s2">&quot;</span>
                               <span class="s2">&quot;Data: medium nr flagged </span><span class="si">{}</span><span class="s2">.</span><span class="se">\n</span><span class="s2">&quot;</span>
                               <span class="s2">&quot;For column </span><span class="si">{}</span><span class="s2">, number flagged = </span><span class="si">{}</span><span class="s2">, fraction flagged = </span><span class="si">{}</span><span class="s2">, exceeding thresholds; &quot;</span>
                               <span class="s2">&quot; entire column will be flagged.&quot;</span>
                               <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">rulename</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">table</span><span class="p">),</span> <span class="n">spw</span><span class="p">,</span> <span class="n">pol</span><span class="p">,</span> <span class="n">maxfraction</span><span class="p">,</span> <span class="n">maxexcessflags</span><span class="p">,</span>
                                         <span class="n">median_num_flagged</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="n">len_flagged</span><span class="p">,</span> <span class="n">fractionflagged</span><span class="p">))</span>
                        <span class="n">_log_outlier</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

                        <span class="c1"># Add new flag commands to flag data underlying</span>
                        <span class="c1"># the view.</span>
                        <span class="k">for</span> <span class="n">flagcoord</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">xdata</span><span class="p">[</span><span class="n">i2flag</span><span class="p">],</span> <span class="n">ydata</span><span class="p">[</span><span class="n">j2flag</span><span class="p">]):</span>
                            <span class="n">newflags</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arrayflaggerbase</span><span class="o">.</span><span class="n">FlagCmd</span><span class="p">(</span>
                                <span class="n">reason</span><span class="o">=</span><span class="s1">&#39;too_many_flags&#39;</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="n">table</span><span class="p">,</span> <span class="n">rulename</span><span class="o">=</span><span class="n">rulename</span><span class="p">,</span> <span class="n">spw</span><span class="o">=</span><span class="n">spw</span><span class="p">,</span> <span class="n">antenna</span><span class="o">=</span><span class="n">antenna</span><span class="p">,</span>
                                <span class="n">axisnames</span><span class="o">=</span><span class="p">[</span><span class="n">xtitle</span><span class="p">,</span> <span class="n">ytitle</span><span class="p">],</span> <span class="n">flagcoords</span><span class="o">=</span><span class="n">flagcoord</span><span class="p">,</span> <span class="n">pol</span><span class="o">=</span><span class="n">pol</span><span class="p">,</span>
                                <span class="n">extendfields</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">extendfields</span><span class="p">,</span> <span class="n">antenna_id_to_name</span><span class="o">=</span><span class="n">antenna_id_to_name</span><span class="p">))</span>

                        <span class="c1"># Flag the view, for any subsequent rules being evaluated.</span>
                        <span class="n">flag</span><span class="p">[</span><span class="n">i2flag</span><span class="p">,</span> <span class="n">j2flag</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="n">flag_reason</span><span class="p">[</span><span class="n">i2flag</span><span class="p">,</span> <span class="n">j2flag</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flag_reason_index</span><span class="p">[</span><span class="n">rulename</span><span class="p">]</span>

            <span class="k">elif</span> <span class="n">rulename</span> <span class="o">==</span> <span class="s1">&#39;too many entirely flagged&#39;</span><span class="p">:</span>

                <span class="c1"># Stop evaluating rule if all data is flagged, unless</span>
                <span class="c1"># explicitly overridden.</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">flag</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">skip_fully_flagged</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="n">maxfraction</span> <span class="o">=</span> <span class="n">rule</span><span class="p">[</span><span class="s1">&#39;limit&#39;</span><span class="p">]</span>
                <span class="n">axis</span> <span class="o">=</span> <span class="n">rule</span><span class="p">[</span><span class="s1">&#39;axis&#39;</span><span class="p">]</span>
                <span class="n">axis</span> <span class="o">=</span> <span class="n">axis</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>

                <span class="c1"># if flagging for each element on x-axis (i.e. evaluate column by column)</span>
                <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="n">xtitle</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">():</span>

                    <span class="c1"># Determine fraction of columns that are entirely flagged</span>
                    <span class="n">frac_ef</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">flag</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">flag</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

                    <span class="c1"># If the fraction of &quot;entirely flagged&quot; columns exceeds the limit, then</span>
                    <span class="c1"># all non-flagged data will need to be flagged.</span>
                    <span class="k">if</span> <span class="n">frac_ef</span> <span class="o">&gt;=</span> <span class="n">maxfraction</span><span class="p">:</span>

                        <span class="c1"># Indices to flag are all those that are currently not flagged</span>
                        <span class="n">i2flag</span> <span class="o">=</span> <span class="n">i</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">flag</span><span class="p">)]</span>
                        <span class="n">j2flag</span> <span class="o">=</span> <span class="n">j</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">flag</span><span class="p">)]</span>

                        <span class="c1"># PIPE-566: if the entire view was already flagged,</span>
                        <span class="c1"># potentially because no valid data were available in</span>
                        <span class="c1"># caltable, then create an explicit flagging command</span>
                        <span class="c1"># for the flagged columns; depending on &quot;table&quot; input</span>
                        <span class="c1"># parameter of the flagsetter task, this will either</span>
                        <span class="c1"># re-flag the same data (unnecessary, but harmless), or</span>
                        <span class="c1"># it may be used to flag the underlying data in the MS.</span>
                        <span class="k">if</span> <span class="n">frac_ef</span> <span class="o">==</span> <span class="mf">1.0</span><span class="p">:</span>
                            <span class="n">i2flag</span> <span class="o">=</span> <span class="n">i</span><span class="p">[</span><span class="n">flag</span><span class="p">]</span>
                            <span class="n">j2flag</span> <span class="o">=</span> <span class="n">j</span><span class="p">[</span><span class="n">flag</span><span class="p">]</span>

                        <span class="c1"># Log a debug message about outliers.</span>
                        <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Outliers found with flagging rule &#39;</span><span class="si">{}</span><span class="s2">&#39; for </span><span class="si">{}</span><span class="s2">, spw </span><span class="si">{}</span><span class="s2">, pol </span><span class="si">{}</span><span class="s2">.</span><span class="se">\n</span><span class="s2">&quot;</span>
                               <span class="s2">&quot;Threshold for entirely flagged columns: </span><span class="si">{}</span><span class="s2">.</span><span class="se">\n</span><span class="s2">&quot;</span>
                               <span class="s2">&quot;Fraction of entirely flagged columns </span><span class="si">{}</span><span class="s2"> reached or exceeded threshold, entire view will&quot;</span>
                               <span class="s2">&quot; be flagged.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">rulename</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">table</span><span class="p">),</span> <span class="n">spw</span><span class="p">,</span> <span class="n">pol</span><span class="p">,</span> <span class="n">maxfraction</span><span class="p">,</span> <span class="n">frac_ef</span><span class="p">))</span>
                        <span class="n">_log_outlier</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

                        <span class="c1"># Add new flag commands to flag data underlying the view.</span>
                        <span class="k">for</span> <span class="n">flagcoord</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">xdata</span><span class="p">[</span><span class="n">i2flag</span><span class="p">],</span> <span class="n">ydata</span><span class="p">[</span><span class="n">j2flag</span><span class="p">]):</span>
                            <span class="n">newflags</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arrayflaggerbase</span><span class="o">.</span><span class="n">FlagCmd</span><span class="p">(</span>
                                <span class="n">reason</span><span class="o">=</span><span class="s1">&#39;too_many_flags&#39;</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="n">table</span><span class="p">,</span> <span class="n">rulename</span><span class="o">=</span><span class="n">rulename</span><span class="p">,</span>  <span class="n">spw</span><span class="o">=</span><span class="n">spw</span><span class="p">,</span> <span class="n">antenna</span><span class="o">=</span><span class="n">antenna</span><span class="p">,</span>
                                <span class="n">axisnames</span><span class="o">=</span><span class="p">[</span><span class="n">xtitle</span><span class="p">,</span> <span class="n">ytitle</span><span class="p">],</span> <span class="n">flagcoords</span><span class="o">=</span><span class="n">flagcoord</span><span class="p">,</span> <span class="n">pol</span><span class="o">=</span><span class="n">pol</span><span class="p">,</span>
                                <span class="n">extendfields</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">extendfields</span><span class="p">,</span> <span class="n">antenna_id_to_name</span><span class="o">=</span><span class="n">antenna_id_to_name</span><span class="p">))</span>

                        <span class="c1"># Flag the view, for any subsequent rules being evaluated.</span>
                        <span class="n">flag</span><span class="p">[</span><span class="n">i2flag</span><span class="p">,</span> <span class="n">j2flag</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="n">flag_reason</span><span class="p">[</span><span class="n">i2flag</span><span class="p">,</span> <span class="n">j2flag</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flag_reason_index</span><span class="p">[</span><span class="n">rulename</span><span class="p">]</span>

            <span class="k">elif</span> <span class="n">rulename</span> <span class="o">==</span> <span class="s1">&#39;nmedian&#39;</span><span class="p">:</span>

                <span class="c1"># Stop evaluating rule if all data is flagged.</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">flag</span><span class="p">):</span>
                    <span class="k">continue</span>

                <span class="c1"># Check limits.</span>
                <span class="n">lo_limit</span> <span class="o">=</span> <span class="n">rule</span><span class="p">[</span><span class="s1">&#39;lo_limit&#39;</span><span class="p">]</span>
                <span class="n">hi_limit</span> <span class="o">=</span> <span class="n">rule</span><span class="p">[</span><span class="s1">&#39;hi_limit&#39;</span><span class="p">]</span>

                <span class="c1"># Create masked array with flagged data masked.</span>
                <span class="n">data_masked</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">flag</span><span class="p">)</span>

                <span class="c1"># Create new masked array from masked array with outliers</span>
                <span class="c1"># masked. This should avoid performing a comparison with</span>
                <span class="c1"># flagged data that could include NaNs (that would cause a</span>
                <span class="c1"># RuntimeWarning).</span>
                <span class="n">outlier_high_threshold</span> <span class="o">=</span> <span class="n">hi_limit</span> <span class="o">*</span> <span class="n">data_median</span>
                <span class="n">outlier_low_threshold</span> <span class="o">=</span> <span class="n">lo_limit</span> <span class="o">*</span> <span class="n">data_median</span>
                <span class="n">data_masked</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_greater</span><span class="p">(</span><span class="n">data_masked</span><span class="p">,</span> <span class="n">outlier_high_threshold</span><span class="p">)</span>
                <span class="n">data_masked</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_less</span><span class="p">(</span><span class="n">data_masked</span><span class="p">,</span> <span class="n">outlier_low_threshold</span><span class="p">)</span>

                <span class="c1"># Get indices to flag as the masked elements that were not</span>
                <span class="c1"># already flagged, i.e. the newly masked elements.</span>
                <span class="n">new_flag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">getmask</span><span class="p">(</span><span class="n">data_masked</span><span class="p">),</span>
                                          <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">flag</span><span class="p">))</span>

                <span class="c1"># No flags</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">new_flag</span><span class="p">):</span>
                    <span class="k">continue</span>

                <span class="c1"># Log a debug message with outliers.</span>
                <span class="n">outliers_as_str</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">sorted</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">ol</span><span class="p">)</span> <span class="k">for</span> <span class="n">ol</span> <span class="ow">in</span> <span class="n">data_masked</span><span class="p">[</span><span class="n">new_flag</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">]))</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Outliers found with flagging rule &#39;</span><span class="si">{}</span><span class="s2">&#39; for </span><span class="si">{}</span><span class="s2">, spw </span><span class="si">{}</span><span class="s2">, pol </span><span class="si">{}</span><span class="s2">.</span><span class="se">\n</span><span class="s2">&quot;</span>
                       <span class="s2">&quot;Data: median = </span><span class="si">{}</span><span class="s2">. Low, high nmedian thresholds = </span><span class="si">{}</span><span class="s2">, </span><span class="si">{}</span><span class="s2">, corresponding to </span><span class="si">{}</span><span class="s2">, </span><span class="si">{}</span><span class="s2">.</span><span class="se">\n</span><span class="s2">&quot;</span>
                       <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> outlier(s) found (lowest to highest): </span><span class="si">{}</span><span class="s2">&quot;</span>
                       <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">rulename</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">table</span><span class="p">),</span> <span class="n">spw</span><span class="p">,</span> <span class="n">pol</span><span class="p">,</span> <span class="n">data_median</span><span class="p">,</span> <span class="n">lo_limit</span><span class="p">,</span>
                                 <span class="n">hi_limit</span><span class="p">,</span> <span class="n">outlier_low_threshold</span><span class="p">,</span> <span class="n">outlier_high_threshold</span><span class="p">,</span>
                                 <span class="nb">len</span><span class="p">(</span><span class="n">data_masked</span><span class="p">[</span><span class="n">new_flag</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">),</span> <span class="n">outliers_as_str</span><span class="p">))</span>
                <span class="n">_log_outlier</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

                <span class="n">i2flag</span> <span class="o">=</span> <span class="n">i</span><span class="p">[</span><span class="n">new_flag</span><span class="p">]</span>
                <span class="n">j2flag</span> <span class="o">=</span> <span class="n">j</span><span class="p">[</span><span class="n">new_flag</span><span class="p">]</span>

                <span class="c1"># Add new flag commands to flag the data underlying the view.</span>
                <span class="k">for</span> <span class="n">flagcoord</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">xdata</span><span class="p">[</span><span class="n">i2flag</span><span class="p">],</span> <span class="n">ydata</span><span class="p">[</span><span class="n">j2flag</span><span class="p">]):</span>
                    <span class="n">newflags</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arrayflaggerbase</span><span class="o">.</span><span class="n">FlagCmd</span><span class="p">(</span>
                        <span class="n">reason</span><span class="o">=</span><span class="s1">&#39;nmedian&#39;</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="n">table</span><span class="p">,</span> <span class="n">rulename</span><span class="o">=</span><span class="n">rulename</span><span class="p">,</span> <span class="n">spw</span><span class="o">=</span><span class="n">spw</span><span class="p">,</span> <span class="n">antenna</span><span class="o">=</span><span class="n">antenna</span><span class="p">,</span>
                        <span class="n">axisnames</span><span class="o">=</span><span class="p">[</span><span class="n">xtitle</span><span class="p">,</span> <span class="n">ytitle</span><span class="p">],</span> <span class="n">flagcoords</span><span class="o">=</span><span class="n">flagcoord</span><span class="p">,</span> <span class="n">pol</span><span class="o">=</span><span class="n">pol</span><span class="p">,</span>
                        <span class="n">extendfields</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">extendfields</span><span class="p">,</span> <span class="n">antenna_id_to_name</span><span class="o">=</span><span class="n">antenna_id_to_name</span><span class="p">))</span>

                <span class="c1"># Flag the view, for any subsequent rules being evaluated.</span>
                <span class="n">flag</span><span class="p">[</span><span class="n">i2flag</span><span class="p">,</span> <span class="n">j2flag</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">flag_reason</span><span class="p">[</span><span class="n">i2flag</span><span class="p">,</span> <span class="n">j2flag</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flag_reason_index</span><span class="p">[</span><span class="n">rulename</span><span class="p">]</span>

            <span class="k">elif</span> <span class="n">rulename</span> <span class="o">==</span> <span class="s1">&#39;bad antenna&#39;</span><span class="p">:</span>
                <span class="c1"># this test should be run before the others as it depends on no other</span>
                <span class="c1"># flags having been set by other rules before it</span>
                <span class="c1"># (because the number of unflagged points on entry are part of the test)</span>

                <span class="c1"># Stop evaluating rule if all data is flagged or if the x-axis is not for antenna.</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">flag</span><span class="p">)</span> <span class="ow">or</span> <span class="s1">&#39;ANTENNA&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">xtitle</span><span class="o">.</span><span class="n">upper</span><span class="p">():</span>
                    <span class="k">continue</span>

                <span class="c1"># Check limits.</span>
                <span class="n">mad_max</span> <span class="o">=</span> <span class="n">rule</span><span class="p">[</span><span class="s1">&#39;lo_limit&#39;</span><span class="p">]</span>
                <span class="n">frac_limit</span> <span class="o">=</span> <span class="n">rule</span><span class="p">[</span><span class="s1">&#39;frac_limit&#39;</span><span class="p">]</span>
                <span class="n">number_limit</span> <span class="o">=</span> <span class="n">rule</span><span class="p">[</span><span class="s1">&#39;number_limit&#39;</span><span class="p">]</span>
                <span class="n">minsample</span> <span class="o">=</span> <span class="n">rule</span><span class="p">[</span><span class="s1">&#39;minsample&#39;</span><span class="p">]</span>

                <span class="c1"># For every antenna on the x-axis...</span>
                <span class="k">for</span> <span class="n">iant</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">flag</span><span class="p">)[</span><span class="mi">0</span><span class="p">]):</span>
                    <span class="c1"># For current antenna, create references to the</span>
                    <span class="c1"># corresponding column in data, flag, and flag_reason.</span>
                    <span class="n">ant_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">iant</span><span class="p">,</span> <span class="p">:]</span>
                    <span class="n">ant_flag</span> <span class="o">=</span> <span class="n">flag</span><span class="p">[</span><span class="n">iant</span><span class="p">,</span> <span class="p">:]</span>
                    <span class="n">ant_flag_reason</span> <span class="o">=</span> <span class="n">flag_reason</span><span class="p">[</span><span class="n">iant</span><span class="p">,</span> <span class="p">:]</span>

                    <span class="c1"># Identify valid (non-flagged) data.</span>
                    <span class="n">valid_ant_data</span> <span class="o">=</span> <span class="n">ant_data</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">ant_flag</span><span class="p">)]</span>

                    <span class="c1"># If the sample of unflagged datapoints is smaller than</span>
                    <span class="c1"># the minimum threshold, skip this antenna.</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">valid_ant_data</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">minsample</span><span class="p">:</span>
                        <span class="k">continue</span>

                    <span class="c1"># Create masked array with flagged data masked.</span>
                    <span class="n">ant_data_masked</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data_median</span> <span class="o">-</span> <span class="n">ant_data</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">ant_flag</span><span class="p">)</span>

                    <span class="c1"># Create new masked array from masked array with outliers</span>
                    <span class="c1"># masked. This should avoid performing a comparison with</span>
                    <span class="c1"># flagged data that could include NaNs (that would cause a</span>
                    <span class="c1"># RuntimeWarning).</span>
                    <span class="n">outlier_threshold</span> <span class="o">=</span> <span class="n">mad_max</span> <span class="o">*</span> <span class="n">data_mad</span>
                    <span class="n">ant_data_masked</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_greater</span><span class="p">(</span><span class="n">ant_data_masked</span><span class="p">,</span> <span class="n">outlier_threshold</span><span class="p">)</span>

                    <span class="c1"># Get indices to flag as the masked elements that were not</span>
                    <span class="c1"># already flagged, i.e. the newly masked elements.</span>
                    <span class="n">new_flag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">getmask</span><span class="p">(</span><span class="n">ant_data_masked</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">ant_flag</span><span class="p">))</span>

                    <span class="c1"># If no low outliers were found, skip this antenna.</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">new_flag</span><span class="p">):</span>
                        <span class="k">continue</span>

                    <span class="n">j2flag_lo</span> <span class="o">=</span> <span class="n">j</span><span class="p">[</span><span class="n">iant</span><span class="p">,</span> <span class="p">:][</span><span class="n">new_flag</span><span class="p">]</span>

                    <span class="c1"># Determine number of points found to be low outliers that</span>
                    <span class="c1"># were not previously flagged.</span>
                    <span class="n">nflags</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">j2flag_lo</span><span class="p">)</span>

                    <span class="c1"># Determine fraction of newly found low outliers over</span>
                    <span class="c1"># total number of data points in current antenna data</span>
                    <span class="c1"># selection.</span>
                    <span class="n">flagsfrac</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">nflags</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">ant_flag</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>

                    <span class="c1"># If the number of newly found low outliers equals-or-exceeds</span>
                    <span class="c1"># a minimum threshold number, and the fraction of newly</span>
                    <span class="c1"># found flags exceeds a minimum threshold fraction, then</span>
                    <span class="c1"># proceed with actually generating flagging commands.</span>
                    <span class="k">if</span> <span class="n">nflags</span> <span class="o">&gt;=</span> <span class="n">number_limit</span> <span class="ow">or</span> <span class="n">flagsfrac</span> <span class="o">&gt;</span> <span class="n">frac_limit</span><span class="p">:</span>

                        <span class="c1"># If we get here, then a sufficient number and</span>
                        <span class="c1"># fraction of low outliers were identified for</span>
                        <span class="c1"># the current antenna, such that the antenna is</span>
                        <span class="c1"># considered &quot;bad&quot; and should be flagged entirely.</span>

                        <span class="c1"># In this case, the low outlier data points are</span>
                        <span class="c1"># explicitly flagged as &quot;low outlier&quot;, while the</span>
                        <span class="c1"># remaining non-flagged data points for this antenna</span>
                        <span class="c1"># are flagged as &quot;bad antenna&quot;.</span>

                        <span class="c1"># For current antenna data selection, flag the points</span>
                        <span class="c1"># that were identified to be low outliers and not</span>
                        <span class="c1"># already flagged, and set corresponding flag reason.</span>
                        <span class="n">ant_flag</span><span class="p">[</span><span class="n">j2flag_lo</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="n">ant_flag_reason</span><span class="p">[</span><span class="n">j2flag_lo</span><span class="p">]</span> <span class="o">=</span>\
                            <span class="bp">self</span><span class="o">.</span><span class="n">flag_reason_index</span><span class="p">[</span><span class="s1">&#39;low outlier&#39;</span><span class="p">]</span>

                        <span class="c1"># Log a debug message with outliers.</span>
                        <span class="n">outliers_as_str</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">sorted</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">ol</span><span class="p">)</span> <span class="k">for</span> <span class="n">ol</span> <span class="ow">in</span> <span class="n">ant_data_masked</span><span class="p">[</span><span class="n">new_flag</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">]))</span>
                        <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Outliers found with flagging rule &#39;</span><span class="si">{}</span><span class="s2">&#39; for </span><span class="si">{}</span><span class="s2">, spw </span><span class="si">{}</span><span class="s2">, pol </span><span class="si">{}</span><span class="s2">.</span><span class="se">\n</span><span class="s2">&quot;</span>
                               <span class="s2">&quot;Data: median = </span><span class="si">{}</span><span class="s2">, MAD = </span><span class="si">{}</span><span class="s2">. Max MAD threshold = </span><span class="si">{}</span><span class="s2">, corresponding to </span><span class="si">{}</span><span class="s2">.</span><span class="se">\n</span><span class="s2">&quot;</span>
                               <span class="s2">&quot;For antenna </span><span class="si">{}</span><span class="s2">: </span><span class="si">{}</span><span class="s2"> low outlier(s) found, representing </span><span class="si">{}</span><span class="s2"> fraction of its data&quot;</span>
                               <span class="s2">&quot; points, which is above number threshold (</span><span class="si">{}</span><span class="s2">) for number and/or above fraction&quot;</span>
                               <span class="s2">&quot; threshold (</span><span class="si">{}</span><span class="s2">); flagging these data points for antenna </span><span class="si">{}</span><span class="s2"> as low outliers: </span><span class="si">{}</span><span class="s2">.&quot;</span>
                               <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">rulename</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">table</span><span class="p">),</span> <span class="n">spw</span><span class="p">,</span> <span class="n">pol</span><span class="p">,</span> <span class="n">data_median</span><span class="p">,</span> <span class="n">data_mad</span><span class="p">,</span>
                                         <span class="n">mad_max</span><span class="p">,</span> <span class="n">outlier_threshold</span><span class="p">,</span> <span class="n">iant</span><span class="p">,</span> <span class="n">nflags</span><span class="p">,</span> <span class="n">flagsfrac</span><span class="p">,</span> <span class="n">number_limit</span><span class="p">,</span>
                                         <span class="n">frac_limit</span><span class="p">,</span> <span class="n">iant</span><span class="p">,</span> <span class="n">outliers_as_str</span><span class="p">))</span>
                        <span class="n">_log_outlier</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

                        <span class="c1"># Create a flagging command that flags these</span>
                        <span class="c1"># low outliers in the data.</span>
                        <span class="k">for</span> <span class="n">flagcoord</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">xdata</span><span class="p">[[</span><span class="n">iant</span><span class="p">]],</span> <span class="n">ydata</span><span class="p">[</span><span class="n">j2flag_lo</span><span class="p">]):</span>
                            <span class="n">newflags</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arrayflaggerbase</span><span class="o">.</span><span class="n">FlagCmd</span><span class="p">(</span>
                                <span class="n">reason</span><span class="o">=</span><span class="s1">&#39;low outlier&#39;</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="n">table</span><span class="p">,</span> <span class="n">rulename</span><span class="o">=</span><span class="s1">&#39;low outlier&#39;</span><span class="p">,</span> <span class="n">spw</span><span class="o">=</span><span class="n">spw</span><span class="p">,</span> <span class="n">antenna</span><span class="o">=</span><span class="n">antenna</span><span class="p">,</span>
                                <span class="n">axisnames</span><span class="o">=</span><span class="p">[</span><span class="n">xtitle</span><span class="p">,</span> <span class="n">ytitle</span><span class="p">],</span> <span class="n">flagcoords</span><span class="o">=</span><span class="n">flagcoord</span><span class="p">,</span> <span class="n">pol</span><span class="o">=</span><span class="n">pol</span><span class="p">,</span>
                                <span class="n">extendfields</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">extendfields</span><span class="p">,</span> <span class="n">antenna_id_to_name</span><span class="o">=</span><span class="n">antenna_id_to_name</span><span class="p">))</span>

                        <span class="c1"># For current antenna data selection, identify the</span>
                        <span class="c1"># remaining non-flagged data points.</span>
                        <span class="n">j2flag_bad</span> <span class="o">=</span> <span class="n">j</span><span class="p">[</span><span class="n">iant</span><span class="p">,</span> <span class="p">:][</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">ant_flag</span><span class="p">)]</span>

                        <span class="c1"># Flag the remaining non-flagged data points as</span>
                        <span class="c1"># &quot;bad antenna&quot;; these are references to original view</span>
                        <span class="c1"># which is thus updated for any subsequent rules being evaluated.</span>
                        <span class="n">ant_flag</span><span class="p">[</span><span class="n">j2flag_bad</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="n">ant_flag_reason</span><span class="p">[</span><span class="n">j2flag_bad</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flag_reason_index</span><span class="p">[</span><span class="s1">&#39;bad antenna&#39;</span><span class="p">]</span>

                        <span class="c1"># Log a debug message for this antenna.</span>
                        <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Flagging remaining data points for antenna </span><span class="si">{}</span><span class="s2"> as &#39;bad antenna&#39;.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">iant</span><span class="p">))</span>

                        <span class="c1"># Create a flagging command that flags the remaining</span>
                        <span class="c1"># data points as &quot;bad antenna&quot;.</span>
                        <span class="k">for</span> <span class="n">flagcoord</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">xdata</span><span class="p">[[</span><span class="n">iant</span><span class="p">]],</span> <span class="n">ydata</span><span class="p">[</span><span class="n">j2flag_bad</span><span class="p">]):</span>
                            <span class="n">newflags</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arrayflaggerbase</span><span class="o">.</span><span class="n">FlagCmd</span><span class="p">(</span>
                                <span class="n">reason</span><span class="o">=</span><span class="s1">&#39;bad antenna&#39;</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="n">table</span><span class="p">,</span> <span class="n">rulename</span><span class="o">=</span><span class="s1">&#39;bad antenna&#39;</span><span class="p">,</span> <span class="n">spw</span><span class="o">=</span><span class="n">spw</span><span class="p">,</span> <span class="n">antenna</span><span class="o">=</span><span class="n">antenna</span><span class="p">,</span>
                                <span class="n">axisnames</span><span class="o">=</span><span class="p">[</span><span class="n">xtitle</span><span class="p">,</span> <span class="n">ytitle</span><span class="p">],</span> <span class="n">flagcoords</span><span class="o">=</span><span class="n">flagcoord</span><span class="p">,</span> <span class="n">pol</span><span class="o">=</span><span class="n">pol</span><span class="p">,</span>
                                <span class="n">extendfields</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">extendfields</span><span class="p">,</span> <span class="n">antenna_id_to_name</span><span class="o">=</span><span class="n">antenna_id_to_name</span><span class="p">))</span>

            <span class="k">elif</span> <span class="n">rulename</span> <span class="o">==</span> <span class="s1">&#39;bad quadrant&#39;</span><span class="p">:</span>
                <span class="c1"># this test should be run before the others as it depends on no other</span>
                <span class="c1"># flags having been set by other rules before it</span>
                <span class="c1"># (because the number of unflagged points on entry are part of the test)</span>

                <span class="c1"># a quadrant is one quarter of the extent of the x-axis</span>

                <span class="c1"># Stop evaluating rule if all data is flagged.</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">flag</span><span class="p">):</span>
                    <span class="k">continue</span>

                <span class="c1"># Check limits.</span>
                <span class="n">hilo_limit</span> <span class="o">=</span> <span class="n">rule</span><span class="p">[</span><span class="s1">&#39;hilo_limit&#39;</span><span class="p">]</span>
                <span class="n">frac_limit</span> <span class="o">=</span> <span class="n">rule</span><span class="p">[</span><span class="s1">&#39;frac_limit&#39;</span><span class="p">]</span>
                <span class="n">baseline_frac_limit</span> <span class="o">=</span> <span class="n">rule</span><span class="p">[</span><span class="s1">&#39;baseline_frac_limit&#39;</span><span class="p">]</span>

                <span class="c1"># find outlier flags first</span>
                <span class="c1"># Create masked array with flagged data masked.</span>
                <span class="n">data_masked</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">data</span> <span class="o">-</span> <span class="n">data_median</span><span class="p">),</span> <span class="n">mask</span><span class="o">=</span><span class="n">flag</span><span class="p">)</span>

                <span class="c1"># Create new masked array from masked array with outliers</span>
                <span class="c1"># masked. This should avoid performing a comparison with</span>
                <span class="c1"># flagged data that could include NaNs (that would cause a</span>
                <span class="c1"># RuntimeWarning).</span>
                <span class="n">data_masked</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_greater</span><span class="p">(</span><span class="n">data_masked</span><span class="p">,</span> <span class="n">hilo_limit</span> <span class="o">*</span> <span class="n">data_mad</span><span class="p">)</span>

                <span class="c1"># Get indices to flag as the masked elements that were not</span>
                <span class="c1"># already flagged, i.e. the newly masked elements.</span>
                <span class="n">provisional_new_flag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">data_masked</span><span class="o">.</span><span class="n">mask</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">flag</span><span class="p">))</span>

                <span class="c1"># No flagged data.</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">provisional_new_flag</span><span class="p">):</span>
                    <span class="k">continue</span>

                <span class="c1"># PIPE-344: If the flagged channels fall within ozone lines, then ignore (filter out) these outliers;</span>
                <span class="c1"># store the &quot;unfiltered&quot; provisional list of flags and later compare it with the &quot;filtered&quot; one</span>
                <span class="c1"># in which ozone lines are removed, in order to show a notification message when such removal</span>
                <span class="c1"># affects the outcome of the &quot;bad quadrant&quot; rule (at this moment, it is not yet known</span>
                <span class="c1"># whether a flagging would happen, because it depends on all baselines for a given antenna).</span>
                <span class="n">ozone_channels</span> <span class="o">=</span> <span class="n">ozone</span><span class="o">.</span><span class="n">get_ozone_channels_for_spw</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">ms</span><span class="p">,</span> <span class="n">spw</span><span class="p">)</span>
                <span class="n">provisional_new_flag_unfiltered</span> <span class="o">=</span> <span class="n">provisional_new_flag</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">provisional_new_flag</span><span class="p">[</span><span class="n">ozone_channels</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

                <span class="c1"># check again if any outliers remained after excluding those within ozone lines</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">provisional_new_flag</span><span class="p">):</span>
                    <span class="k">continue</span>

                <span class="c1"># store the previous flagging state in &#39;previous_flag&#39;,</span>
                <span class="c1"># then examine the provisional new flags one antenna and quadrant at a time,</span>
                <span class="c1"># checking if the fraction of new flags in all baselines involving this antenna</span>
                <span class="c1"># is above threshold (frac_limit) or if this fraction in individual baselines</span>
                <span class="c1"># is above another threshold (baseline_frac_limit).</span>
                <span class="c1"># If so, flag the entire quadrant for this antenna or for individual baseline.</span>
                <span class="n">previous_flag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">flag</span><span class="p">)</span>

                <span class="c1"># look for bad antenna/quadrants in view copy</span>
                <span class="n">data_shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
                <span class="n">nchan</span> <span class="o">=</span> <span class="n">data_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">nbaseline</span> <span class="o">=</span> <span class="n">data_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">nant</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">nbaseline</span><span class="p">))</span>

                <span class="n">quadrant</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">nchan</span><span class="o">//</span><span class="mi">4</span><span class="p">],</span>
                    <span class="p">[</span><span class="n">nchan</span><span class="o">//</span><span class="mi">4</span><span class="p">,</span> <span class="n">nchan</span><span class="o">//</span><span class="mi">2</span><span class="p">],</span>
                    <span class="p">[</span><span class="n">nchan</span><span class="o">//</span><span class="mi">2</span><span class="p">,</span> <span class="n">nchan</span><span class="o">*</span><span class="mi">3</span><span class="o">//</span><span class="mi">4</span><span class="p">],</span>
                    <span class="p">[</span><span class="n">nchan</span><span class="o">*</span><span class="mi">3</span><span class="o">//</span><span class="mi">4</span><span class="p">,</span> <span class="n">nchan</span><span class="p">],</span>
                <span class="p">]</span>
                <span class="n">rejected_flagging</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nchan</span><span class="p">,</span> <span class="n">nant</span><span class="p">),</span> <span class="nb">bool</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">ant</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nant</span><span class="p">):</span>
                    <span class="c1"># baselines involving this antenna</span>
                    <span class="n">baselines</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">baseline</span>
                                          <span class="k">for</span> <span class="n">baseline</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nbaseline</span><span class="p">)</span>
                                          <span class="k">if</span> <span class="p">(</span><span class="n">ant</span><span class="o">*</span><span class="n">nant</span> <span class="o">&lt;=</span> <span class="n">baseline</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">ant</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">nant</span><span class="p">)</span>
                                          <span class="ow">or</span> <span class="p">(</span><span class="n">baseline</span> <span class="o">%</span> <span class="n">nant</span> <span class="o">==</span> <span class="n">ant</span><span class="p">)])</span>

                    <span class="k">for</span> <span class="n">iquad</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
                        <span class="c1"># first check all baselines involving this antenna in this quadrant,</span>
                        <span class="c1"># examining the ratio of the number of provisional new flags</span>
                        <span class="c1"># to the number of previously unflagged channels</span>
                        <span class="n">quad_slice</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">quadrant</span><span class="p">[</span><span class="n">iquad</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">quadrant</span><span class="p">[</span><span class="n">iquad</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
                        <span class="n">num_provisional_new_flag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span>
                            <span class="n">provisional_new_flag</span><span class="p">[</span><span class="n">quad_slice</span><span class="p">,</span> <span class="n">baselines</span><span class="p">])</span>
                        <span class="n">num_provisional_new_flag_unfiltered</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span>
                            <span class="n">provisional_new_flag_unfiltered</span><span class="p">[</span><span class="n">quad_slice</span><span class="p">,</span> <span class="n">baselines</span><span class="p">])</span>
                        <span class="n">num_previous_unflagged</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span>
                            <span class="n">previous_flag</span><span class="p">[</span><span class="n">quad_slice</span><span class="p">,</span> <span class="n">baselines</span><span class="p">]))</span>
                        <span class="k">if</span> <span class="n">num_previous_unflagged</span><span class="p">:</span>
                            <span class="n">frac</span> <span class="o">=</span> <span class="n">num_provisional_new_flag</span> <span class="o">*</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">num_previous_unflagged</span>
                            <span class="n">frac_unfiltered</span> <span class="o">=</span> <span class="n">num_provisional_new_flag_unfiltered</span> <span class="o">*</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">num_previous_unflagged</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">frac</span> <span class="o">=</span> <span class="n">frac_unfiltered</span> <span class="o">=</span> <span class="mf">0.0</span>

                        <span class="k">if</span> <span class="n">frac</span> <span class="o">&gt;</span> <span class="n">frac_limit</span><span class="p">:</span>
                            <span class="c1"># Add new flag commands to flag the data underlying the view.</span>
                            <span class="c1"># These will flag the entire quadrant/antenna.</span>
                            <span class="c1"># If the quadrant is not bad, then any provisional outlier points</span>
                            <span class="c1"># found earlier will not be flagged.</span>
                            <span class="n">flagcoords</span> <span class="o">=</span> <span class="p">[]</span>
                            <span class="n">channels_to_flag</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">quadrant</span><span class="p">[</span><span class="n">iquad</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">quadrant</span><span class="p">[</span><span class="n">iquad</span><span class="p">][</span><span class="mi">1</span><span class="p">]))</span>
                            <span class="k">for</span> <span class="n">chan</span> <span class="ow">in</span> <span class="n">channels_to_flag</span><span class="p">:</span>
                                <span class="n">flagcoords</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">chan</span><span class="p">,</span> <span class="n">ant</span><span class="p">))</span>

                            <span class="c1"># Log a debug message with outliers.</span>
                            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Outliers found with flagging rule &#39;</span><span class="si">{}</span><span class="s2">&#39; for </span><span class="si">{}</span><span class="s2">, spw </span><span class="si">{}</span><span class="s2">, pol </span><span class="si">{}</span><span class="s2">.</span><span class="se">\n</span><span class="s2">&quot;</span>
                                   <span class="s2">&quot;Threshold for maximum number of outliers per channel quadrant per antenna: </span><span class="si">{}</span><span class="s2">.</span><span class="se">\n</span><span class="s2">&quot;</span>
                                   <span class="s2">&quot;For antenna </span><span class="si">{}</span><span class="s2">, channels quadrant </span><span class="si">{}</span><span class="s2">: fraction outliers = </span><span class="si">{}</span><span class="s2">, exceeding &quot;</span>
                                   <span class="s2">&quot;threshold =&gt; entire quadrant will be flagged.&quot;</span>
                                   <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">rulename</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">table</span><span class="p">),</span> <span class="n">spw</span><span class="p">,</span> <span class="n">pol</span><span class="p">,</span> <span class="n">frac_limit</span><span class="p">,</span> <span class="n">ant</span><span class="p">,</span> <span class="n">iquad</span><span class="p">,</span> <span class="n">frac</span><span class="p">))</span>
                            <span class="n">_log_outlier</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

                            <span class="k">for</span> <span class="n">flagcoord</span> <span class="ow">in</span> <span class="n">flagcoords</span><span class="p">:</span>
                                <span class="n">newflags</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arrayflaggerbase</span><span class="o">.</span><span class="n">FlagCmd</span><span class="p">(</span>
                                    <span class="n">reason</span><span class="o">=</span><span class="s1">&#39;bad quadrant&#39;</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="n">table</span><span class="p">,</span> <span class="n">rulename</span><span class="o">=</span><span class="n">rulename</span><span class="p">,</span> <span class="n">spw</span><span class="o">=</span><span class="n">spw</span><span class="p">,</span>
                                    <span class="n">antenna</span><span class="o">=</span><span class="n">antenna</span><span class="p">,</span> <span class="n">axisnames</span><span class="o">=</span><span class="p">[</span><span class="n">xtitle</span><span class="p">,</span> <span class="n">ytitle</span><span class="p">],</span> <span class="n">flagcoords</span><span class="o">=</span><span class="n">flagcoord</span><span class="p">,</span> <span class="n">pol</span><span class="o">=</span><span class="n">pol</span><span class="p">,</span>
                                    <span class="n">extendfields</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">extendfields</span><span class="p">,</span> <span class="n">antenna_id_to_name</span><span class="o">=</span><span class="n">antenna_id_to_name</span><span class="p">))</span>

                            <span class="c1"># update flagging view with &#39;bad quadrant&#39; flags</span>
                            <span class="n">where</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">previous_flag</span><span class="p">[</span><span class="n">quad_slice</span><span class="p">,</span> <span class="n">baselines</span><span class="p">])</span>
                            <span class="n">i2flag</span> <span class="o">=</span> <span class="n">i</span><span class="p">[</span><span class="n">quad_slice</span><span class="p">,</span> <span class="n">baselines</span><span class="p">][</span><span class="n">where</span><span class="p">]</span>
                            <span class="n">j2flag</span> <span class="o">=</span> <span class="n">j</span><span class="p">[</span><span class="n">quad_slice</span><span class="p">,</span> <span class="n">baselines</span><span class="p">][</span><span class="n">where</span><span class="p">]</span>
                            <span class="n">flag</span><span class="p">[</span><span class="n">i2flag</span><span class="p">,</span> <span class="n">j2flag</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                            <span class="n">flag_reason</span><span class="p">[</span><span class="n">i2flag</span><span class="p">,</span> <span class="n">j2flag</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flag_reason_index</span><span class="p">[</span><span class="s1">&#39;bad quadrant&#39;</span><span class="p">]</span>

                            <span class="c1"># whole antenna/quadrant flagged, no need to check individual baselines</span>
                            <span class="k">continue</span>

                        <span class="k">elif</span> <span class="n">frac_unfiltered</span> <span class="o">&gt;</span> <span class="n">frac_limit</span><span class="p">:</span>
                            <span class="c1"># fraction of provisional new flags is below the threshold,</span>
                            <span class="c1"># but had ozone lines not been rejected, it would have been above the threshold:</span>
                            <span class="c1"># in this case, collect the information about channel/antenna pairs that were removed from</span>
                            <span class="c1"># the flagging list add a notification message after all such cases have been identified.</span>

                            <span class="c1"># determine indices of channels in this quadrant and antenna</span>
                            <span class="c1"># that were initially flagged but subsequently removed from the flagging list</span>
                            <span class="n">rejected_channels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
                                <span class="n">ozone_channels</span><span class="p">[</span><span class="n">quad_slice</span><span class="p">],</span>
                                <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span>
                                    <span class="n">provisional_new_flag_unfiltered</span><span class="p">[</span><span class="n">quad_slice</span><span class="p">,</span> <span class="n">baselines</span><span class="p">]</span> <span class="o">!=</span>
                                    <span class="n">provisional_new_flag</span><span class="p">[</span><span class="n">quad_slice</span><span class="p">,</span> <span class="n">baselines</span><span class="p">],</span>
                                    <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>

                            <span class="c1"># mark up these channels in the overall table, adding a correct offset for the quadrant</span>
                            <span class="n">rejected_flagging</span><span class="p">[</span><span class="n">rejected_channels</span> <span class="o">+</span> <span class="n">quadrant</span><span class="p">[</span><span class="n">iquad</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">ant</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

                        <span class="c1"># if the entire antenna was not flagged, look for individual bad baselines in this quadrant</span>
                        <span class="k">for</span> <span class="n">baseline</span> <span class="ow">in</span> <span class="n">baselines</span><span class="p">:</span>
                            <span class="n">num_provisional_new_flag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span>
                                <span class="n">provisional_new_flag</span><span class="p">[</span><span class="n">quad_slice</span><span class="p">,</span> <span class="n">baseline</span><span class="p">])</span>
                            <span class="n">num_provisional_new_flag_unfiltered</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span>
                                <span class="n">provisional_new_flag_unfiltered</span><span class="p">[</span><span class="n">quad_slice</span><span class="p">,</span> <span class="n">baseline</span><span class="p">])</span>
                            <span class="n">num_previous_unflagged</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span>
                                <span class="n">previous_flag</span><span class="p">[</span><span class="n">quad_slice</span><span class="p">,</span> <span class="n">baseline</span><span class="p">]))</span>
                            <span class="k">if</span> <span class="n">num_previous_unflagged</span><span class="p">:</span>
                                <span class="n">frac</span> <span class="o">=</span> <span class="n">num_provisional_new_flag</span> <span class="o">*</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">num_previous_unflagged</span>
                                <span class="n">frac_unfiltered</span> <span class="o">=</span> <span class="n">num_provisional_new_flag_unfiltered</span> <span class="o">*</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">num_previous_unflagged</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">frac</span> <span class="o">=</span> <span class="n">frac_unfiltered</span> <span class="o">=</span> <span class="mf">0.0</span>

                            <span class="k">if</span> <span class="n">frac</span> <span class="o">&gt;</span> <span class="n">baseline_frac_limit</span><span class="p">:</span>
                                <span class="c1"># Add new flag commands to flag the data underlying the view.</span>
                                <span class="c1"># These will flag the entire quadrant/baseline.</span>
                                <span class="c1"># If the quadrant is not bad, then any provisional outlier points</span>
                                <span class="c1"># found earlier will not be flagged.</span>
                                <span class="n">flagcoords</span> <span class="o">=</span> <span class="p">[]</span>
                                <span class="k">for</span> <span class="n">chan</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">quadrant</span><span class="p">[</span><span class="n">iquad</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">quadrant</span><span class="p">[</span><span class="n">iquad</span><span class="p">][</span><span class="mi">1</span><span class="p">]):</span>
                                    <span class="n">flagcoords</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">chan</span><span class="p">,</span> <span class="n">ydata</span><span class="p">[</span><span class="n">baseline</span><span class="p">]))</span>

                                <span class="c1"># Log a debug message with outliers.</span>
                                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Outliers found with flagging rule &#39;</span><span class="si">{}</span><span class="s2">&#39; for </span><span class="si">{}</span><span class="s2">, spw </span><span class="si">{}</span><span class="s2">, pol </span><span class="si">{}</span><span class="s2">.</span><span class="se">\n</span><span class="s2">&quot;</span>
                                       <span class="s2">&quot;Threshold for maximum number of outliers per channel quadrant per baseline:&quot;</span>
                                       <span class="s2">&quot; </span><span class="si">{}</span><span class="s2">.</span><span class="se">\n</span><span class="s2">&quot;</span>
                                       <span class="s2">&quot;For baseline </span><span class="si">{}</span><span class="s2">, channels quadrant </span><span class="si">{}</span><span class="s2">: fraction outliers = </span><span class="si">{}</span><span class="s2">, exceeding &quot;</span>
                                       <span class="s2">&quot;threshold =&gt; entire quadrant will be flagged.&quot;</span>
                                       <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">rulename</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">table</span><span class="p">),</span> <span class="n">spw</span><span class="p">,</span> <span class="n">pol</span><span class="p">,</span> <span class="n">baseline_frac_limit</span><span class="p">,</span>
                                                 <span class="n">baseline</span><span class="p">,</span> <span class="n">iquad</span><span class="p">,</span> <span class="n">frac</span><span class="p">))</span>
                                <span class="n">_log_outlier</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

                                <span class="k">for</span> <span class="n">flagcoord</span> <span class="ow">in</span> <span class="n">flagcoords</span><span class="p">:</span>
                                    <span class="n">newflags</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arrayflaggerbase</span><span class="o">.</span><span class="n">FlagCmd</span><span class="p">(</span>
                                        <span class="n">reason</span><span class="o">=</span><span class="s1">&#39;bad quadrant&#39;</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="n">table</span><span class="p">,</span> <span class="n">rulename</span><span class="o">=</span><span class="n">rulename</span><span class="p">,</span> <span class="n">spw</span><span class="o">=</span><span class="n">spw</span><span class="p">,</span>
                                        <span class="n">antenna</span><span class="o">=</span><span class="n">antenna</span><span class="p">,</span> <span class="n">axisnames</span><span class="o">=</span><span class="p">[</span><span class="n">xtitle</span><span class="p">,</span> <span class="n">ytitle</span><span class="p">],</span> <span class="n">flagcoords</span><span class="o">=</span><span class="n">flagcoord</span><span class="p">,</span> <span class="n">pol</span><span class="o">=</span><span class="n">pol</span><span class="p">,</span>
                                        <span class="n">extendfields</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">extendfields</span><span class="p">,</span> <span class="n">antenna_id_to_name</span><span class="o">=</span><span class="n">antenna_id_to_name</span><span class="p">))</span>

                                <span class="c1"># update flagging view with &#39;bad quadrant&#39; flags</span>
                                <span class="n">where</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">previous_flag</span><span class="p">[</span><span class="n">quad_slice</span><span class="p">,</span> <span class="n">baseline</span><span class="p">])</span>
                                <span class="n">i2flag</span> <span class="o">=</span> <span class="n">i</span><span class="p">[</span><span class="n">quad_slice</span><span class="p">,</span> <span class="n">baseline</span><span class="p">][</span><span class="n">where</span><span class="p">]</span>
                                <span class="n">j2flag</span> <span class="o">=</span> <span class="n">j</span><span class="p">[</span><span class="n">quad_slice</span><span class="p">,</span> <span class="n">baseline</span><span class="p">][</span><span class="n">where</span><span class="p">]</span>
                                <span class="n">flag</span><span class="p">[</span><span class="n">i2flag</span><span class="p">,</span> <span class="n">j2flag</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                                <span class="n">flag_reason</span><span class="p">[</span><span class="n">i2flag</span><span class="p">,</span> <span class="n">j2flag</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flag_reason_index</span><span class="p">[</span><span class="s1">&#39;bad quadrant&#39;</span><span class="p">]</span>

                            <span class="k">elif</span> <span class="n">frac_unfiltered</span> <span class="o">&gt;</span> <span class="n">baseline_frac_limit</span><span class="p">:</span>
                                <span class="c1"># determine which channels were initially flagged but subsequently rejected</span>
                                <span class="n">rejected_channels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
                                    <span class="n">ozone_channels</span><span class="p">[</span><span class="n">quad_slice</span><span class="p">],</span>
                                    <span class="n">provisional_new_flag_unfiltered</span><span class="p">[</span><span class="n">quad_slice</span><span class="p">,</span> <span class="n">baseline</span><span class="p">]</span> <span class="o">!=</span>
                                    <span class="n">provisional_new_flag</span><span class="p">[</span><span class="n">quad_slice</span><span class="p">,</span> <span class="n">baseline</span><span class="p">]))[</span><span class="mi">0</span><span class="p">]</span>

                                <span class="c1"># mark up these channels in the overall table, adding a correct offset for the quadrant</span>
                                <span class="c1"># (do not memorize the individual baselines, but only the antenna index)</span>
                                <span class="n">rejected_flagging</span><span class="p">[</span><span class="n">rejected_channels</span> <span class="o">+</span> <span class="n">quadrant</span><span class="p">[</span><span class="n">iquad</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">ant</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

                <span class="c1"># PIPE-344: add a notification message if the bad_quadrant flagging was rejected due to ozone lines.</span>
                <span class="c1"># do not report all possible channel/antenna combinations, but only the 1d projections of this 2d matrix</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">rejected_flagging</span><span class="p">):</span>
                    <span class="c1"># compressed (human-readable) list of channels in which at least one antenna was affected</span>
                    <span class="n">rejected_channel_ranges</span> <span class="o">=</span> <span class="n">find_ranges</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">rejected_flagging</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))[</span><span class="mi">0</span><span class="p">])</span>

                    <span class="c1"># list of affected antennas (those for which flagging was rejected in at least one channel)</span>
                    <span class="n">rejected_antenna_names</span> <span class="o">=</span> <span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span>
                        <span class="p">(</span><span class="n">antenna_id_to_name</span><span class="p">[</span><span class="n">ant</span><span class="p">]</span> <span class="k">if</span> <span class="n">antenna_id_to_name</span> <span class="k">else</span> <span class="nb">str</span><span class="p">(</span><span class="n">ant</span><span class="p">))</span>
                        <span class="k">for</span> <span class="n">ant</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">rejected_flagging</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="p">])</span>

                    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Outliers provisionally found with flagging rule &#39;</span><span class="si">{}</span><span class="s2">&#39; for </span><span class="si">{}</span><span class="s2">, spw </span><span class="si">{}</span><span class="s2">, pol </span><span class="si">{}</span><span class="s2">, channel </span><span class="si">{}</span><span class="s2">, &quot;</span>
                           <span class="s2">&quot;antenna </span><span class="si">{}</span><span class="s2">, were not flagged because they overlap with known atmospheric ozone lines&quot;</span>
                           <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">rulename</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">table</span><span class="p">),</span> <span class="n">spw</span><span class="p">,</span> <span class="n">pol</span><span class="p">,</span>
                                     <span class="n">rejected_channel_ranges</span><span class="p">,</span> <span class="n">rejected_antenna_names</span><span class="p">))</span>
                    <span class="n">_log_outlier</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">ATTENTION</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s1">&#39;bad rule: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">rule</span><span class="p">)</span>

        <span class="c1"># consolidate flagcmds that specify individual channels into fewer flagcmds that specify ranges</span>
        <span class="n">newflags</span> <span class="o">=</span> <span class="n">arrayflaggerbase</span><span class="o">.</span><span class="n">consolidate_flagcmd_channels</span><span class="p">(</span><span class="n">newflags</span><span class="p">,</span> <span class="n">antenna_id_to_name</span><span class="o">=</span><span class="n">antenna_id_to_name</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">newflags</span><span class="p">,</span> <span class="n">flag_reason</span></div>
</div>



<div class="viewcode-block" id="VectorFlaggerInputs">
<a class="viewcode-back" href="../../../../../_apidoc/pipeline.h.tasks.common.html#pipeline.h.tasks.common.viewflaggers.VectorFlaggerInputs">[docs]</a>
<span class="k">class</span> <span class="nc">VectorFlaggerInputs</span><span class="p">(</span><span class="n">vdp</span><span class="o">.</span><span class="n">StandardInputs</span><span class="p">):</span>
    <span class="n">prepend</span> <span class="o">=</span> <span class="n">vdp</span><span class="o">.</span><span class="n">VisDependentProperty</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
    <span class="n">use_antenna_names</span> <span class="o">=</span> <span class="n">vdp</span><span class="o">.</span><span class="n">VisDependentProperty</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">output_dir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">datatask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">viewtask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">flagsettertask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">rules</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">niter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">iter_datatask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">use_antenna_names</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">prepend</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">VectorFlaggerInputs</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

        <span class="c1"># pipeline inputs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">context</span> <span class="o">=</span> <span class="n">context</span>
        <span class="c1"># vis must be set first, as other properties may depend on it</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vis</span> <span class="o">=</span> <span class="n">vis</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_dir</span> <span class="o">=</span> <span class="n">output_dir</span>

        <span class="c1"># solution parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">datatask</span> <span class="o">=</span> <span class="n">datatask</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flagsettertask</span> <span class="o">=</span> <span class="n">flagsettertask</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iter_datatask</span> <span class="o">=</span> <span class="n">iter_datatask</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">niter</span> <span class="o">=</span> <span class="n">niter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prepend</span> <span class="o">=</span> <span class="n">prepend</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rules</span> <span class="o">=</span> <span class="n">rules</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">use_antenna_names</span> <span class="o">=</span> <span class="n">use_antenna_names</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">viewtask</span> <span class="o">=</span> <span class="n">viewtask</span></div>



<div class="viewcode-block" id="VectorFlaggerResults">
<a class="viewcode-back" href="../../../../../_apidoc/pipeline.h.tasks.common.html#pipeline.h.tasks.common.viewflaggers.VectorFlaggerResults">[docs]</a>
<span class="k">class</span> <span class="nc">VectorFlaggerResults</span><span class="p">(</span><span class="n">basetask</span><span class="o">.</span><span class="n">Results</span><span class="p">,</span> <span class="n">flaggableviewresults</span><span class="o">.</span><span class="n">FlaggableViewResults</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct and return a new VectorFlaggerResults.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">basetask</span><span class="o">.</span><span class="n">Results</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">flaggableviewresults</span><span class="o">.</span><span class="n">FlaggableViewResults</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">vis</span> <span class="o">=</span> <span class="n">vis</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dataresult</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">viewresult</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="VectorFlaggerResults.merge_with_context">
<a class="viewcode-back" href="../../../../../_apidoc/pipeline.h.tasks.common.html#pipeline.h.tasks.common.viewflaggers.VectorFlaggerResults.merge_with_context">[docs]</a>
    <span class="k">def</span> <span class="nf">merge_with_context</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
        <span class="k">pass</span></div>


    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="s1">&#39;VectorFlaggerResults&#39;</span>
        <span class="k">return</span> <span class="n">s</span></div>



<div class="viewcode-block" id="VectorFlagger">
<a class="viewcode-back" href="../../../../../_apidoc/pipeline.h.tasks.common.html#pipeline.h.tasks.common.viewflaggers.VectorFlagger">[docs]</a>
<span class="k">class</span> <span class="nc">VectorFlagger</span><span class="p">(</span><span class="n">basetask</span><span class="o">.</span><span class="n">StandardTaskTemplate</span><span class="p">):</span>
    <span class="n">Inputs</span> <span class="o">=</span> <span class="n">VectorFlaggerInputs</span>

    <span class="c1"># override the inherited __init__ method so that references to the</span>
    <span class="c1"># task objects can be kept outside self.inputs. Later on self.inputs</span>
    <span class="c1"># will be replaced by a copy which breaks the connection between</span>
    <span class="c1"># its references to the tasks and the originals.</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span> <span class="o">=</span> <span class="n">inputs</span>

<div class="viewcode-block" id="VectorFlagger.prepare">
<a class="viewcode-back" href="../../../../../_apidoc/pipeline.h.tasks.common.html#pipeline.h.tasks.common.viewflaggers.VectorFlagger.prepare">[docs]</a>
    <span class="k">def</span> <span class="nf">prepare</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">inputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span>

        <span class="c1"># Initialize result.</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">VectorFlaggerResults</span><span class="p">()</span>

        <span class="c1"># Initialize flags and iteration counter</span>
        <span class="n">flags</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">newflags</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">counter</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">include_before</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">dataresult</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">viewresult</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Start iterative flagging</span>
        <span class="k">while</span> <span class="n">counter</span> <span class="o">&lt;=</span> <span class="n">inputs</span><span class="o">.</span><span class="n">niter</span><span class="p">:</span>

            <span class="c1"># Run the data task if needed</span>
            <span class="k">if</span> <span class="n">counter</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># Always run data task on first iteration</span>
                <span class="n">dataresult</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_executor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">datatask</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">inputs</span><span class="o">.</span><span class="n">iter_datatask</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="c1"># If requested to re-run datatask on iteration, then</span>
                <span class="c1"># run the flag-setting task which modifies the data</span>
                <span class="c1"># and then re-run the data task</span>

                <span class="c1"># If no &quot;before summary&quot; was done, include this in the flag setting task</span>
                <span class="k">if</span> <span class="n">include_before</span><span class="p">:</span>
                    <span class="n">stats_before</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_flags</span><span class="p">(</span><span class="n">newflags</span><span class="p">,</span> <span class="n">summarize_before</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="n">include_before</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_flags</span><span class="p">(</span><span class="n">newflags</span><span class="p">)</span>

                <span class="n">dataresult</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_executor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">inputs</span><span class="o">.</span><span class="n">datatask</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># If not iterating the datatask, the previous</span>
                <span class="c1"># data result will be re-used, but marked here as no</span>
                <span class="c1"># longer new.</span>
                <span class="n">dataresult</span><span class="o">.</span><span class="n">new</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="c1"># Create flagging view</span>
            <span class="n">viewresult</span> <span class="o">=</span> <span class="n">inputs</span><span class="o">.</span><span class="n">viewtask</span><span class="p">(</span><span class="n">dataresult</span><span class="p">)</span>

            <span class="c1"># If a view could be created, continue with flagging</span>
            <span class="k">if</span> <span class="n">viewresult</span><span class="o">.</span><span class="n">descriptions</span><span class="p">():</span>

                <span class="c1"># Import the views from viewtask into the final result</span>
                <span class="n">result</span><span class="o">.</span><span class="n">importfrom</span><span class="p">(</span><span class="n">viewresult</span><span class="p">)</span>

                <span class="c1"># Flag the view</span>
                <span class="n">newflags</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flag_view</span><span class="p">(</span><span class="n">viewresult</span><span class="p">)</span>

                <span class="c1"># Report how many flags were found in this iteration and</span>
                <span class="c1"># stop iteration if no new flags were found</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">newflags</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># If no new flags are found, report as a log message</span>
                    <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{0}{1}</span><span class="s2"> iteration </span><span class="si">{2}</span><span class="s2"> raised </span><span class="si">{3}</span><span class="s2"> flagging commands&quot;</span>
                             <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">inputs</span><span class="o">.</span><span class="n">prepend</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">inputs</span><span class="o">.</span><span class="n">vis</span><span class="p">),</span> <span class="n">counter</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">newflags</span><span class="p">)))</span>
                    <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Report newly found flags (CAS-7336: show as info message instead of warning).</span>
                    <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{0}{1}</span><span class="s2"> iteration </span><span class="si">{2}</span><span class="s2"> raised </span><span class="si">{3}</span><span class="s2"> flagging commands&quot;</span>
                             <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">inputs</span><span class="o">.</span><span class="n">prepend</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">inputs</span><span class="o">.</span><span class="n">vis</span><span class="p">),</span> <span class="n">counter</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">newflags</span><span class="p">)))</span>

                <span class="c1"># Accumulate new flags</span>
                <span class="n">flags</span> <span class="o">+=</span> <span class="n">newflags</span>

                <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># If no view could be created, exit the iteration</span>
                <span class="n">LOG</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;No flagging view was created!&#39;</span><span class="p">)</span>
                <span class="k">break</span>

        <span class="c1"># Create final set of flags by removing duplicates from our accumulated flags</span>
        <span class="n">flags</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">flags</span><span class="p">))</span>

        <span class="c1"># If flags were found...</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">flags</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>

            <span class="c1"># If newflags were found on last iteration loop, we need to still set</span>
            <span class="c1"># these.</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">newflags</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>

                <span class="c1"># If datatask needs to be iterated...</span>
                <span class="k">if</span> <span class="n">inputs</span><span class="o">.</span><span class="n">iter_datatask</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>

                    <span class="c1"># First set the new flags that were found on the last</span>
                    <span class="c1"># iteration. If the &quot;before&quot; summary was not yet created,</span>
                    <span class="c1"># then include this here; always include the &quot;after&quot;</span>
                    <span class="c1"># summary.</span>
                    <span class="k">if</span> <span class="n">include_before</span><span class="p">:</span>
                        <span class="c1"># Set flags, and include &quot;before&quot; and &quot;after&quot; summary.</span>
                        <span class="n">stats_before</span><span class="p">,</span> <span class="n">stats_after</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_flags</span><span class="p">(</span>
                            <span class="n">newflags</span><span class="p">,</span> <span class="n">summarize_before</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">summarize_after</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># Set flags, and include &quot;after&quot; summary</span>
                        <span class="n">_</span><span class="p">,</span> <span class="n">stats_after</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_flags</span><span class="p">(</span>
                            <span class="n">newflags</span><span class="p">,</span> <span class="n">summarize_after</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

                    <span class="c1"># After setting the latest flags, re-run the data task.</span>
                    <span class="n">dataresult</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_executor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">inputs</span><span class="o">.</span><span class="n">datatask</span><span class="p">)</span>

                <span class="c1"># If the datatask did not need to be iterated, then no flags</span>
                <span class="c1"># were set yet and no &quot;before&quot; summary was performed yet, so</span>
                <span class="c1"># set all flags and include both &quot;before&quot; and &quot;after&quot; summary.</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">stats_before</span><span class="p">,</span> <span class="n">stats_after</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_flags</span><span class="p">(</span>
                        <span class="n">flags</span><span class="p">,</span> <span class="n">summarize_before</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">summarize_after</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

                <span class="c1"># Create final post-flagging view</span>
                <span class="n">viewresult</span> <span class="o">=</span> <span class="n">inputs</span><span class="o">.</span><span class="n">viewtask</span><span class="p">(</span><span class="n">dataresult</span><span class="p">)</span>

                <span class="c1"># Import the post-flagging view into the final result</span>
                <span class="n">result</span><span class="o">.</span><span class="n">importfrom</span><span class="p">(</span><span class="n">viewresult</span><span class="p">)</span>

            <span class="c1"># If flags were found, but no newflags were found on last iteration</span>
            <span class="c1"># then the dataresult is already up-to-date, and all that is needed</span>
            <span class="c1"># is to ensure the flags are set, and that summaries are created.</span>
            <span class="k">else</span><span class="p">:</span>

                <span class="c1"># If datatask needs to be iterated, then the &quot;before&quot; summary has</span>
                <span class="c1"># already been done, and the flags have already been set, so only</span>
                <span class="c1"># need to do an &quot;after&quot; summary.</span>
                <span class="k">if</span> <span class="n">inputs</span><span class="o">.</span><span class="n">iter_datatask</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="n">_</span><span class="p">,</span> <span class="n">stats_after</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_flags</span><span class="p">([],</span> <span class="n">summarize_after</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="c1"># If the datatask did not need to be iterated, then no flags</span>
                <span class="c1"># were set yet and no &quot;before&quot; summary was performed yet,</span>
                <span class="c1"># so set all flags and include both &quot;before&quot; and &quot;after&quot; summary.</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">stats_before</span><span class="p">,</span> <span class="n">stats_after</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_flags</span><span class="p">(</span>
                        <span class="n">flags</span><span class="p">,</span> <span class="n">summarize_before</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">summarize_after</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="c1"># Store the final set of flags in the final result</span>
            <span class="n">result</span><span class="o">.</span><span class="n">addflags</span><span class="p">(</span><span class="n">flags</span><span class="p">)</span>

        <span class="c1"># if no flags were found at all</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Run a single flagging summary and use the result as both the &quot;before&quot;</span>
            <span class="c1"># and &quot;after&quot; summary.</span>
            <span class="n">stats_before</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_flags</span><span class="p">(</span><span class="n">flags</span><span class="p">,</span> <span class="n">summarize_before</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">stats_after</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">stats_before</span><span class="p">)</span>

        <span class="c1"># Store in the final result the name of the measurement set or caltable</span>
        <span class="c1"># to which any potentially found flags would need to be applied to.</span>
        <span class="n">result</span><span class="o">.</span><span class="n">table</span> <span class="o">=</span> <span class="n">inputs</span><span class="o">.</span><span class="n">flagsettertask</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">table</span>

        <span class="c1"># Store in the final result the final data task result and the final</span>
        <span class="c1"># view task result.</span>
        <span class="n">result</span><span class="o">.</span><span class="n">dataresult</span> <span class="o">=</span> <span class="n">dataresult</span>
        <span class="n">result</span><span class="o">.</span><span class="n">viewresult</span> <span class="o">=</span> <span class="n">viewresult</span>

        <span class="c1"># Store the flagging summaries in the final result</span>
        <span class="n">result</span><span class="o">.</span><span class="n">summaries</span> <span class="o">=</span> <span class="p">[</span><span class="n">stats_before</span><span class="p">,</span> <span class="n">stats_after</span><span class="p">]</span>

        <span class="c1"># Sort the final list of flagging commands.</span>
        <span class="n">result</span><span class="o">.</span><span class="n">sort_flagcmds</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="VectorFlagger.analyse">
<a class="viewcode-back" href="../../../../../_apidoc/pipeline.h.tasks.common.html#pipeline.h.tasks.common.viewflaggers.VectorFlagger.analyse">[docs]</a>
    <span class="k">def</span> <span class="nf">analyse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="VectorFlagger.flag_view">
<a class="viewcode-back" href="../../../../../_apidoc/pipeline.h.tasks.common.html#pipeline.h.tasks.common.viewflaggers.VectorFlagger.flag_view">[docs]</a>
    <span class="k">def</span> <span class="nf">flag_view</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">view</span><span class="p">):</span>
        <span class="n">newflags</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">descriptionlist</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">view</span><span class="o">.</span><span class="n">descriptions</span><span class="p">())</span>
        <span class="k">for</span> <span class="n">description</span> <span class="ow">in</span> <span class="n">descriptionlist</span><span class="p">:</span>
            <span class="n">image</span> <span class="o">=</span> <span class="n">view</span><span class="o">.</span><span class="n">last</span><span class="p">(</span><span class="n">description</span><span class="p">)</span>
            <span class="c1"># get flags for this view according to the rules</span>
            <span class="n">newflags</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_flags</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">newflags</span></div>


<div class="viewcode-block" id="VectorFlagger.set_flags">
<a class="viewcode-back" href="../../../../../_apidoc/pipeline.h.tasks.common.html#pipeline.h.tasks.common.viewflaggers.VectorFlagger.set_flags">[docs]</a>
    <span class="k">def</span> <span class="nf">set_flags</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">summarize_before</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">summarize_after</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="c1"># Initialize flagging summaries</span>
        <span class="n">allflagcmds</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Add the &quot;before&quot; summary to the flagging commands</span>
        <span class="k">if</span> <span class="n">summarize_before</span><span class="p">:</span>
            <span class="n">allflagcmds</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;mode=&#39;summary&#39; name=&#39;before&#39;&quot;</span><span class="p">]</span>

        <span class="c1"># Add the flagging commands</span>
        <span class="n">allflagcmds</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">flags</span><span class="p">)</span>

        <span class="c1"># Add the &quot;before&quot; summary to the flagging commands</span>
        <span class="k">if</span> <span class="n">summarize_after</span><span class="p">:</span>
            <span class="n">allflagcmds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;mode=&#39;summary&#39; name=&#39;after&#39;&quot;</span><span class="p">)</span>

        <span class="c1"># Update flag setting task with all flagging commands</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">flagsettertask</span><span class="o">.</span><span class="n">flags_to_set</span><span class="p">(</span><span class="n">allflagcmds</span><span class="p">)</span>

        <span class="c1"># Run flag setting task</span>
        <span class="n">flagsetterresult</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_executor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">flagsettertask</span><span class="p">)</span>

        <span class="c1"># Initialize &quot;before&quot; and/or &quot;after&quot; summaries. If &quot;real&quot; flagsetter</span>
        <span class="c1"># results are returned (e.g. by WvrgcalFlagSetter), then there will</span>
        <span class="c1"># have been no real flagging summaries created, in which case empty</span>
        <span class="c1"># dictionaries will be returned as empty flagging summaries.</span>
        <span class="n">stats_before</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">stats_after</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># If the flagsetter returned results from the CASA flag data task,</span>
        <span class="c1"># then proceed to extract &quot;before&quot; and/or &quot;after&quot; flagging summaries.</span>
        <span class="k">if</span> <span class="n">flagsetterresult</span><span class="o">.</span><span class="n">results</span><span class="p">:</span>
            <span class="c1"># CAS-10407: if MPI version of flagdata failed and returned invalid</span>
            <span class="c1"># results, then raise an exception.</span>
            <span class="k">if</span> <span class="n">flagsetterresult</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">exceptions</span><span class="o">.</span><span class="n">PipelineException</span><span class="p">(</span><span class="s2">&quot;Results from flagdata are empty, cannot continue.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">all</span><span class="p">([</span><span class="s1">&#39;report&#39;</span> <span class="ow">in</span> <span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">flagsetterresult</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">]]):</span>
                <span class="c1"># Go through dictionary of reports...</span>
                <span class="k">for</span> <span class="n">report</span> <span class="ow">in</span> <span class="n">flagsetterresult</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">flagsetterresult</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">report</span><span class="p">][</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;before&#39;</span><span class="p">:</span>
                        <span class="n">stats_before</span> <span class="o">=</span> <span class="n">flagsetterresult</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">report</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">flagsetterresult</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">report</span><span class="p">][</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;after&#39;</span><span class="p">:</span>
                        <span class="n">stats_after</span> <span class="o">=</span> <span class="n">flagsetterresult</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">report</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Go through single report.</span>
                <span class="k">if</span> <span class="n">flagsetterresult</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;before&#39;</span><span class="p">:</span>
                    <span class="n">stats_before</span> <span class="o">=</span> <span class="n">flagsetterresult</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">flagsetterresult</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;after&#39;</span><span class="p">:</span>
                    <span class="n">stats_after</span> <span class="o">=</span> <span class="n">flagsetterresult</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">stats_before</span><span class="p">,</span> <span class="n">stats_after</span></div>


<div class="viewcode-block" id="VectorFlagger.make_flag_rules">
<a class="viewcode-back" href="../../../../../_apidoc/pipeline.h.tasks.common.html#pipeline.h.tasks.common.viewflaggers.VectorFlagger.make_flag_rules">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">make_flag_rules</span><span class="p">(</span>
            <span class="n">flag_edges</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">edge_limit</span><span class="o">=</span><span class="mf">2.0</span><span class="p">,</span>
            <span class="n">flag_minabs</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fmin_limit</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
            <span class="n">flag_nmedian</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fnm_lo_limit</span><span class="o">=</span><span class="mf">0.7</span><span class="p">,</span> <span class="n">fnm_hi_limit</span><span class="o">=</span><span class="mf">1.3</span><span class="p">,</span>
            <span class="n">flag_hilo</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fhl_limit</span><span class="o">=</span><span class="mf">5.0</span><span class="p">,</span> <span class="n">fhl_minsample</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
            <span class="n">flag_sharps</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sharps_limit</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span>
            <span class="n">flag_diffmad</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">diffmad_limit</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">diffmad_nchan_limit</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
            <span class="n">flag_tmf</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tmf_frac_limit</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">tmf_nchan_limit</span><span class="o">=</span><span class="mi">4</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate a list of flagging rules from a set of flagging parameters.</span>
<span class="sd">        Added detailed docs here.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Construct rules from flag properties</span>
        <span class="n">rules</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">flag_edges</span><span class="p">:</span>
            <span class="n">rules</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s1">&#39;edges&#39;</span><span class="p">,</span> <span class="s1">&#39;limit&#39;</span><span class="p">:</span> <span class="n">edge_limit</span><span class="p">})</span>
        <span class="k">if</span> <span class="n">flag_minabs</span><span class="p">:</span>
            <span class="n">rules</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s1">&#39;min abs&#39;</span><span class="p">,</span> <span class="s1">&#39;limit&#39;</span><span class="p">:</span> <span class="n">fmin_limit</span><span class="p">})</span>
        <span class="k">if</span> <span class="n">flag_nmedian</span><span class="p">:</span>
            <span class="n">rules</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s1">&#39;nmedian&#39;</span><span class="p">,</span> <span class="s1">&#39;lo_limit&#39;</span><span class="p">:</span> <span class="n">fnm_lo_limit</span><span class="p">,</span> <span class="s1">&#39;hi_limit&#39;</span><span class="p">:</span> <span class="n">fnm_hi_limit</span><span class="p">})</span>
        <span class="k">if</span> <span class="n">flag_hilo</span><span class="p">:</span>
            <span class="n">rules</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s1">&#39;outlier&#39;</span><span class="p">,</span> <span class="s1">&#39;limit&#39;</span><span class="p">:</span> <span class="n">fhl_limit</span><span class="p">,</span> <span class="s1">&#39;minsample&#39;</span><span class="p">:</span> <span class="n">fhl_minsample</span><span class="p">})</span>
        <span class="k">if</span> <span class="n">flag_sharps</span><span class="p">:</span>
            <span class="n">rules</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s1">&#39;sharps&#39;</span><span class="p">,</span> <span class="s1">&#39;limit&#39;</span><span class="p">:</span> <span class="n">sharps_limit</span><span class="p">})</span>
        <span class="k">if</span> <span class="n">flag_diffmad</span><span class="p">:</span>
            <span class="n">rules</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s1">&#39;diffmad&#39;</span><span class="p">,</span> <span class="s1">&#39;limit&#39;</span><span class="p">:</span> <span class="n">diffmad_limit</span><span class="p">,</span> <span class="s1">&#39;nchan_limit&#39;</span><span class="p">:</span> <span class="n">diffmad_nchan_limit</span><span class="p">})</span>
        <span class="k">if</span> <span class="n">flag_tmf</span><span class="p">:</span>
            <span class="n">rules</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s1">&#39;tmf&#39;</span><span class="p">,</span> <span class="s1">&#39;frac_limit&#39;</span><span class="p">:</span> <span class="n">tmf_frac_limit</span><span class="p">,</span> <span class="s1">&#39;nchan_limit&#39;</span><span class="p">:</span> <span class="n">tmf_nchan_limit</span><span class="p">})</span>

        <span class="k">return</span> <span class="n">rules</span></div>


<div class="viewcode-block" id="VectorFlagger.generate_flags">
<a class="viewcode-back" href="../../../../../_apidoc/pipeline.h.tasks.common.html#pipeline.h.tasks.common.viewflaggers.VectorFlagger.generate_flags">[docs]</a>
    <span class="k">def</span> <span class="nf">generate_flags</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vector</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the statistics of a vector and flag the data according</span>
<span class="sd">        to a list of specified rules.</span>

<span class="sd">        Keyword arguments:</span>
<span class="sd">        vector - SpectrumResult object containing data to be flagged.</span>
<span class="sd">        rules - Rules to be applied.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Get the attributes - ensure all arrays are numpy arrays</span>
        <span class="c1"># as some subsequent processing depends on numpy array indexing</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">vector</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
        <span class="n">flag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">vector</span><span class="o">.</span><span class="n">flag</span><span class="p">)</span>
        <span class="n">spw</span> <span class="o">=</span> <span class="n">vector</span><span class="o">.</span><span class="n">spw</span>
        <span class="n">pol</span> <span class="o">=</span> <span class="n">vector</span><span class="o">.</span><span class="n">pol</span>
        <span class="n">antenna</span> <span class="o">=</span> <span class="n">vector</span><span class="o">.</span><span class="n">ant</span>
        <span class="k">if</span> <span class="n">antenna</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># deal with antenna id not name</span>
            <span class="n">antenna</span> <span class="o">=</span> <span class="n">antenna</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">table</span> <span class="o">=</span> <span class="n">vector</span><span class="o">.</span><span class="n">filename</span>

        <span class="c1"># Initialize flags</span>
        <span class="n">newflags</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># If there is no valid (non-flagged) data, then return early.</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">flag</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">newflags</span>

        <span class="c1"># If requested to use antenna names instead of IDs antenna,</span>
        <span class="c1"># create an id-to-name translation and check to make sure this</span>
        <span class="c1"># would result in unique non-empty names for all IDs, otherwise</span>
        <span class="c1"># revert back to flagging by ID</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">use_antenna_names</span><span class="p">:</span>
            <span class="n">antenna_id_to_name</span> <span class="o">=</span> <span class="n">_get_ant_id_to_name_dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">ms</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">antenna_id_to_name</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># any flags found will apply to this subset of the data</span>
        <span class="n">axisnames</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">flagcoords</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">antenna</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axisnames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;ANTENNA1&#39;</span><span class="p">)</span>
            <span class="n">flagcoords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">antenna</span><span class="p">)</span>
        <span class="n">axisnames</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;channels&#39;</span><span class="p">]</span>

        <span class="c1"># Identify valid (non-flagged) data.</span>
        <span class="n">valid_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">flag</span><span class="p">)]</span>

        <span class="c1"># Calculate statistics for valid data.</span>
        <span class="n">data_median</span><span class="p">,</span> <span class="n">data_mad</span> <span class="o">=</span> <span class="n">arrayflaggerbase</span><span class="o">.</span><span class="n">median_and_mad</span><span class="p">(</span><span class="n">valid_data</span><span class="p">)</span>

        <span class="c1"># Create channel array.</span>
        <span class="n">nchannels</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">channels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nchannels</span><span class="p">)</span>

        <span class="c1"># flag data according to each rule in turn</span>
        <span class="k">for</span> <span class="n">rule</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">rules</span><span class="p">:</span>
            <span class="n">rulename</span> <span class="o">=</span> <span class="n">rule</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">rulename</span> <span class="o">==</span> <span class="s1">&#39;edges&#39;</span><span class="p">:</span>

                <span class="c1"># Stop evaluating rule if all data is flagged.</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">flag</span><span class="p">):</span>
                    <span class="k">continue</span>

                <span class="c1"># Get limits.</span>
                <span class="n">limit</span> <span class="o">=</span> <span class="n">rule</span><span class="p">[</span><span class="s1">&#39;limit&#39;</span><span class="p">]</span>

                <span class="c1"># find left edge</span>
                <span class="n">left_edge</span> <span class="o">=</span> <span class="n">VectorFlagger</span><span class="o">.</span><span class="n">_find_small_diff</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">flag</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span> <span class="n">vector</span><span class="o">.</span><span class="n">description</span><span class="p">)</span>

                <span class="c1"># and right edge</span>
                <span class="n">reverse_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">reverse_flag</span> <span class="o">=</span> <span class="n">flag</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">right_edge</span> <span class="o">=</span> <span class="n">VectorFlagger</span><span class="o">.</span><span class="n">_find_small_diff</span><span class="p">(</span><span class="n">reverse_data</span><span class="p">,</span> <span class="n">reverse_flag</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span> <span class="n">vector</span><span class="o">.</span><span class="n">description</span><span class="p">)</span>

                <span class="c1"># flag the &#39;view&#39;, for any subsequent rules being evaluated.</span>
                <span class="n">flag</span><span class="p">[:</span><span class="n">left_edge</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">if</span> <span class="n">right_edge</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">flag</span><span class="p">[</span><span class="o">-</span><span class="n">right_edge</span><span class="p">:]</span> <span class="o">=</span> <span class="kc">True</span>

                <span class="c1"># now compose a description of the flagging required on</span>
                <span class="c1"># the MS</span>
                <span class="n">channels_flagged</span> <span class="o">=</span> <span class="n">channels</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">channels</span> <span class="o">&lt;</span> <span class="n">left_edge</span><span class="p">,</span> <span class="n">channels</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">nchannels</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">right_edge</span><span class="p">))]</span>
                <span class="n">flagcoords</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">channels_flagged</span><span class="p">)]</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">channels_flagged</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># Log a debug message with outliers.</span>
                    <span class="n">flagged_as_str</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">ol</span><span class="p">)</span> <span class="k">for</span> <span class="n">ol</span> <span class="ow">in</span> <span class="n">channels_flagged</span><span class="p">])</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Outliers found with flagging rule &#39;</span><span class="si">{}</span><span class="s2">&#39; for </span><span class="si">{}</span><span class="s2">, spw </span><span class="si">{}</span><span class="s2">, pol </span><span class="si">{}</span><span class="s2">.</span><span class="se">\n</span><span class="s2">&quot;</span>
                           <span class="s2">&quot;The following </span><span class="si">{}</span><span class="s2"> edge channels were flagged: </span><span class="si">{}</span><span class="s2">&quot;</span>
                           <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">rulename</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">table</span><span class="p">),</span> <span class="n">spw</span><span class="p">,</span> <span class="n">pol</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">channels_flagged</span><span class="p">),</span>
                                     <span class="n">flagged_as_str</span><span class="p">))</span>
                    <span class="n">_log_outlier</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

                    <span class="c1"># Add new flag command to flag data underlying the</span>
                    <span class="c1"># view.</span>
                    <span class="n">newflags</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arrayflaggerbase</span><span class="o">.</span><span class="n">FlagCmd</span><span class="p">(</span>
                        <span class="n">reason</span><span class="o">=</span><span class="s1">&#39;edges&#39;</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="n">table</span><span class="p">,</span> <span class="n">rulename</span><span class="o">=</span><span class="n">rulename</span><span class="p">,</span> <span class="n">spw</span><span class="o">=</span><span class="n">spw</span><span class="p">,</span> <span class="n">axisnames</span><span class="o">=</span><span class="n">axisnames</span><span class="p">,</span>
                        <span class="n">flagcoords</span><span class="o">=</span><span class="n">flagcoords</span><span class="p">,</span> <span class="n">antenna_id_to_name</span><span class="o">=</span><span class="n">antenna_id_to_name</span><span class="p">))</span>

            <span class="k">elif</span> <span class="n">rulename</span> <span class="o">==</span> <span class="s1">&#39;min abs&#39;</span><span class="p">:</span>

                <span class="c1"># Stop evaluating rule if all data is flagged.</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">flag</span><span class="p">):</span>
                    <span class="k">continue</span>

                <span class="c1"># Get limits.</span>
                <span class="n">limit</span> <span class="o">=</span> <span class="n">rule</span><span class="p">[</span><span class="s1">&#39;limit&#39;</span><span class="p">]</span>

                <span class="c1"># Create masked array with flagged data masked.</span>
                <span class="n">data_masked</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">mask</span><span class="o">=</span><span class="n">flag</span><span class="p">)</span>

                <span class="c1"># Create new masked array from masked array with outliers</span>
                <span class="c1"># masked. This should avoid performing a comparison with</span>
                <span class="c1"># flagged data that could include NaNs (that would cause a</span>
                <span class="c1"># RuntimeWarning).</span>
                <span class="n">data_masked</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_less</span><span class="p">(</span><span class="n">data_masked</span><span class="p">,</span> <span class="n">limit</span><span class="p">)</span>

                <span class="c1"># Get indices to flag as the masked elements that were not</span>
                <span class="c1"># already flagged, i.e. the newly masked elements.</span>
                <span class="n">ind2flag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">getmask</span><span class="p">(</span><span class="n">data_masked</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">flag</span><span class="p">))</span>

                <span class="c1"># No flags</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">ind2flag</span><span class="p">):</span>
                    <span class="k">continue</span>

                <span class="c1"># flag the &#39;view&#39;, for any subsequent rules being evaluated.</span>
                <span class="n">flag</span><span class="p">[</span><span class="n">ind2flag</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

                <span class="c1"># now compose a description of the flagging required on</span>
                <span class="c1"># the MS</span>
                <span class="n">channels_flagged</span> <span class="o">=</span> <span class="n">channels</span><span class="p">[</span><span class="n">ind2flag</span><span class="p">]</span>
                <span class="n">flagcoords</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">channels_flagged</span><span class="p">)]</span>

                <span class="c1"># Log a debug message with outliers.</span>
                <span class="n">outliers_as_str</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">sorted</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">ol</span><span class="p">)</span> <span class="k">for</span> <span class="n">ol</span> <span class="ow">in</span> <span class="n">data_masked</span><span class="p">[</span><span class="n">ind2flag</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">]))</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Outliers found with flagging rule &#39;</span><span class="si">{}</span><span class="s2">&#39; for </span><span class="si">{}</span><span class="s2">, spw </span><span class="si">{}</span><span class="s2">, pol </span><span class="si">{}</span><span class="s2">.</span><span class="se">\n</span><span class="s2">&quot;</span>
                       <span class="s2">&quot;Minimum threshold = </span><span class="si">{}</span><span class="s2">.</span><span class="se">\n</span><span class="s2">&quot;</span>
                       <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> outlier(s) found (lowest to highest): </span><span class="si">{}</span><span class="s2">&quot;</span>
                       <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">rulename</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">table</span><span class="p">),</span> <span class="n">spw</span><span class="p">,</span> <span class="n">pol</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span>
                                 <span class="nb">len</span><span class="p">(</span><span class="n">data_masked</span><span class="p">[</span><span class="n">ind2flag</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">),</span> <span class="n">outliers_as_str</span><span class="p">))</span>
                <span class="n">_log_outlier</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

                <span class="c1"># Add new flag command to flag data underlying the</span>
                <span class="c1"># view.</span>
                <span class="n">newflags</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arrayflaggerbase</span><span class="o">.</span><span class="n">FlagCmd</span><span class="p">(</span>
                    <span class="n">reason</span><span class="o">=</span><span class="s1">&#39;min_abs&#39;</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="n">table</span><span class="p">,</span> <span class="n">rulename</span><span class="o">=</span><span class="n">rulename</span><span class="p">,</span> <span class="n">spw</span><span class="o">=</span><span class="n">spw</span><span class="p">,</span> <span class="n">axisnames</span><span class="o">=</span><span class="n">axisnames</span><span class="p">,</span>
                    <span class="n">flagcoords</span><span class="o">=</span><span class="n">flagcoords</span><span class="p">,</span> <span class="n">antenna_id_to_name</span><span class="o">=</span><span class="n">antenna_id_to_name</span><span class="p">))</span>

            <span class="k">elif</span> <span class="n">rulename</span> <span class="o">==</span> <span class="s1">&#39;nmedian&#39;</span><span class="p">:</span>

                <span class="c1"># Stop evaluating rule if all data is flagged.</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">flag</span><span class="p">):</span>
                    <span class="k">continue</span>

                <span class="c1"># Get limits.</span>
                <span class="n">lo_limit</span> <span class="o">=</span> <span class="n">rule</span><span class="p">[</span><span class="s1">&#39;lo_limit&#39;</span><span class="p">]</span>
                <span class="n">hi_limit</span> <span class="o">=</span> <span class="n">rule</span><span class="p">[</span><span class="s1">&#39;hi_limit&#39;</span><span class="p">]</span>

                <span class="c1"># Create masked array with flagged data masked.</span>
                <span class="n">data_masked</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">flag</span><span class="p">)</span>

                <span class="c1"># Create new masked array from masked array with outliers</span>
                <span class="c1"># masked. This should avoid performing a comparison with</span>
                <span class="c1"># flagged data that could include NaNs (that would cause a</span>
                <span class="c1"># RuntimeWarning).</span>
                <span class="n">outlier_high_threshold</span> <span class="o">=</span> <span class="n">hi_limit</span> <span class="o">*</span> <span class="n">data_median</span>
                <span class="n">outlier_low_threshold</span> <span class="o">=</span> <span class="n">lo_limit</span> <span class="o">*</span> <span class="n">data_median</span>
                <span class="n">data_masked</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_greater</span><span class="p">(</span><span class="n">data_masked</span><span class="p">,</span> <span class="n">outlier_high_threshold</span><span class="p">)</span>
                <span class="n">data_masked</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_less</span><span class="p">(</span><span class="n">data_masked</span><span class="p">,</span> <span class="n">outlier_low_threshold</span><span class="p">)</span>

                <span class="c1"># Get indices to flag as the masked elements that were not</span>
                <span class="c1"># already flagged, i.e. the newly masked elements.</span>
                <span class="n">ind2flag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">getmask</span><span class="p">(</span><span class="n">data_masked</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">flag</span><span class="p">))</span>

                <span class="c1"># No flags</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">ind2flag</span><span class="p">):</span>
                    <span class="k">continue</span>

                <span class="c1"># flag the &#39;view&#39;, for any subsequent rules being evaluated.</span>
                <span class="n">flag</span><span class="p">[</span><span class="n">ind2flag</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

                <span class="c1"># now compose a description of the flagging required on</span>
                <span class="c1"># the MS</span>
                <span class="n">channels_flagged</span> <span class="o">=</span> <span class="n">channels</span><span class="p">[</span><span class="n">ind2flag</span><span class="p">]</span>
                <span class="n">flagcoords</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">channels_flagged</span><span class="p">)]</span>

                <span class="c1"># Log a debug message with outliers.</span>
                <span class="n">outliers_as_str</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">sorted</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">ol</span><span class="p">)</span> <span class="k">for</span> <span class="n">ol</span> <span class="ow">in</span> <span class="n">data_masked</span><span class="p">[</span><span class="n">ind2flag</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">]))</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Outliers found with flagging rule &#39;</span><span class="si">{}</span><span class="s2">&#39; for </span><span class="si">{}</span><span class="s2">, spw </span><span class="si">{}</span><span class="s2">, pol </span><span class="si">{}</span><span class="s2">.</span><span class="se">\n</span><span class="s2">&quot;</span>
                       <span class="s2">&quot;Data: median = </span><span class="si">{}</span><span class="s2">. Low, high nmedian thresholds = </span><span class="si">{}</span><span class="s2">, </span><span class="si">{}</span><span class="s2">, corresponding to </span><span class="si">{}</span><span class="s2">, </span><span class="si">{}</span><span class="s2">.</span><span class="se">\n</span><span class="s2">&quot;</span>
                       <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> outlier(s) found (lowest to highest): </span><span class="si">{}</span><span class="s2">&quot;</span>
                       <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">rulename</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">table</span><span class="p">),</span> <span class="n">spw</span><span class="p">,</span> <span class="n">pol</span><span class="p">,</span> <span class="n">data_median</span><span class="p">,</span> <span class="n">lo_limit</span><span class="p">,</span>
                                 <span class="n">hi_limit</span><span class="p">,</span> <span class="n">outlier_low_threshold</span><span class="p">,</span> <span class="n">outlier_high_threshold</span><span class="p">,</span>
                                 <span class="nb">len</span><span class="p">(</span><span class="n">data_masked</span><span class="p">[</span><span class="n">ind2flag</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">),</span> <span class="n">outliers_as_str</span><span class="p">))</span>
                <span class="n">_log_outlier</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

                <span class="c1"># Add new flag command to flag data underlying the</span>
                <span class="c1"># view.</span>
                <span class="n">newflags</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arrayflaggerbase</span><span class="o">.</span><span class="n">FlagCmd</span><span class="p">(</span>
                    <span class="n">reason</span><span class="o">=</span><span class="s1">&#39;nmedian&#39;</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="n">table</span><span class="p">,</span> <span class="n">rulename</span><span class="o">=</span><span class="n">rulename</span><span class="p">,</span> <span class="n">spw</span><span class="o">=</span><span class="n">spw</span><span class="p">,</span> <span class="n">axisnames</span><span class="o">=</span><span class="n">axisnames</span><span class="p">,</span>
                    <span class="n">flagcoords</span><span class="o">=</span><span class="n">flagcoords</span><span class="p">,</span> <span class="n">antenna_id_to_name</span><span class="o">=</span><span class="n">antenna_id_to_name</span><span class="p">))</span>

            <span class="k">elif</span> <span class="n">rulename</span> <span class="o">==</span> <span class="s1">&#39;outlier&#39;</span><span class="p">:</span>

                <span class="n">minsample</span> <span class="o">=</span> <span class="n">rule</span><span class="p">[</span><span class="s1">&#39;minsample&#39;</span><span class="p">]</span>

                <span class="c1"># Stop evaluating rule if sample is too small.</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">valid_data</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">minsample</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="c1"># Get limits.</span>
                <span class="n">limit</span> <span class="o">=</span> <span class="n">rule</span><span class="p">[</span><span class="s1">&#39;limit&#39;</span><span class="p">]</span>

                <span class="c1"># Create masked array with flagged data masked.</span>
                <span class="n">data_masked</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">data</span> <span class="o">-</span> <span class="n">data_median</span><span class="p">),</span> <span class="n">mask</span><span class="o">=</span><span class="n">flag</span><span class="p">)</span>

                <span class="c1"># Create new masked array from masked array with outliers</span>
                <span class="c1"># masked. This should avoid performing a comparison with</span>
                <span class="c1"># flagged data that could include NaNs (that would cause a</span>
                <span class="c1"># RuntimeWarning).</span>
                <span class="n">outlier_threshold</span> <span class="o">=</span> <span class="n">limit</span> <span class="o">*</span> <span class="n">data_mad</span>
                <span class="n">data_masked</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_greater</span><span class="p">(</span><span class="n">data_masked</span><span class="p">,</span> <span class="n">outlier_threshold</span><span class="p">)</span>

                <span class="c1"># Get indices to flag as the masked elements that were not</span>
                <span class="c1"># already flagged, i.e. the newly masked elements.</span>
                <span class="n">ind2flag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">getmask</span><span class="p">(</span><span class="n">data_masked</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">flag</span><span class="p">))</span>

                <span class="c1"># No flags</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">ind2flag</span><span class="p">):</span>
                    <span class="k">continue</span>

                <span class="c1"># flag the &#39;view&#39;, for any subsequent rules being evaluated.</span>
                <span class="n">flag</span><span class="p">[</span><span class="n">ind2flag</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

                <span class="c1"># now compose a description of the flagging required on</span>
                <span class="c1"># the MS</span>
                <span class="n">channels_flagged</span> <span class="o">=</span> <span class="n">channels</span><span class="p">[</span><span class="n">ind2flag</span><span class="p">]</span>
                <span class="n">flagcoords</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">channels_flagged</span><span class="p">)]</span>

                <span class="c1"># Log a debug message with outliers.</span>
                <span class="n">outliers_as_str</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">sorted</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">ol</span><span class="p">)</span> <span class="k">for</span> <span class="n">ol</span> <span class="ow">in</span> <span class="n">data_masked</span><span class="p">[</span><span class="n">ind2flag</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">]))</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Outliers found with flagging rule &#39;</span><span class="si">{}</span><span class="s2">&#39; for </span><span class="si">{}</span><span class="s2">, spw </span><span class="si">{}</span><span class="s2">, pol </span><span class="si">{}</span><span class="s2">.</span><span class="se">\n</span><span class="s2">&quot;</span>
                       <span class="s2">&quot;Data: median = </span><span class="si">{}</span><span class="s2">, MAD = </span><span class="si">{}</span><span class="s2">. Max MAD threshold = </span><span class="si">{}</span><span class="s2">, corresponding to </span><span class="si">{}</span><span class="s2">.</span><span class="se">\n</span><span class="s2">&quot;</span>
                       <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> outlier(s) found (lowest to highest): </span><span class="si">{}</span><span class="s2">&quot;</span>
                       <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">rulename</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">table</span><span class="p">),</span> <span class="n">spw</span><span class="p">,</span> <span class="n">pol</span><span class="p">,</span> <span class="n">data_median</span><span class="p">,</span> <span class="n">data_mad</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span>
                                 <span class="n">outlier_threshold</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">channels_flagged</span><span class="p">),</span> <span class="n">outliers_as_str</span><span class="p">))</span>
                <span class="n">_log_outlier</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

                <span class="c1"># Add new flag command to flag data underlying the</span>
                <span class="c1"># view.</span>
                <span class="n">newflags</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arrayflaggerbase</span><span class="o">.</span><span class="n">FlagCmd</span><span class="p">(</span>
                    <span class="n">reason</span><span class="o">=</span><span class="s1">&#39;outlier&#39;</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="n">table</span><span class="p">,</span> <span class="n">rulename</span><span class="o">=</span><span class="n">rulename</span><span class="p">,</span> <span class="n">spw</span><span class="o">=</span><span class="n">spw</span><span class="p">,</span> <span class="n">pol</span><span class="o">=</span><span class="n">pol</span><span class="p">,</span> <span class="n">antenna</span><span class="o">=</span><span class="n">antenna</span><span class="p">,</span>
                    <span class="n">axisnames</span><span class="o">=</span><span class="n">axisnames</span><span class="p">,</span> <span class="n">flagcoords</span><span class="o">=</span><span class="n">flagcoords</span><span class="p">,</span> <span class="n">antenna_id_to_name</span><span class="o">=</span><span class="n">antenna_id_to_name</span><span class="p">))</span>

            <span class="k">elif</span> <span class="n">rulename</span> <span class="o">==</span> <span class="s1">&#39;sharps&#39;</span><span class="p">:</span>

                <span class="c1"># Stop evaluating rule if all data is flagged.</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">flag</span><span class="p">):</span>
                    <span class="k">continue</span>

                <span class="c1"># Get limits.</span>
                <span class="n">limit</span> <span class="o">=</span> <span class="n">rule</span><span class="p">[</span><span class="s1">&#39;limit&#39;</span><span class="p">]</span>

                <span class="c1"># Compute channel-to-channel difference, and corresponding flag array.</span>
                <span class="n">diff</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">data</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">diff_flag</span> <span class="o">=</span> <span class="p">(</span><span class="n">flag</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">|</span> <span class="n">flag</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

                <span class="c1"># flag channels whose slope is greater than the</span>
                <span class="c1"># limit for a &#39;sharp feature&#39;</span>
                <span class="n">newflag</span> <span class="o">=</span> <span class="p">(</span><span class="n">diff</span> <span class="o">&gt;</span> <span class="n">limit</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">diff_flag</span><span class="p">)</span>

                <span class="c1"># If no new flags were found, stop evaluating; otherwise,</span>
                <span class="c1"># retrieve the ozone line exclusion array.</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">newflag</span><span class="p">):</span>
                    <span class="k">continue</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ozone_channels</span> <span class="o">=</span> <span class="n">ozone</span><span class="o">.</span><span class="n">get_ozone_channels_for_spw</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">ms</span><span class="p">,</span> <span class="n">spw</span><span class="p">)</span>

                <span class="c1"># Prepare string for antenna.</span>
                <span class="n">ant_msg</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
                <span class="k">if</span> <span class="n">antenna</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">ant_msg</span> <span class="o">=</span> <span class="s2">&quot;ant </span><span class="si">{}</span><span class="s2"> (</span><span class="si">{}</span><span class="s2">), &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">antenna</span><span class="p">,</span> <span class="n">antenna_id_to_name</span><span class="p">[</span><span class="n">antenna</span><span class="p">])</span>

                <span class="c1"># now broaden the flags until the diff falls below</span>
                <span class="c1"># 2 times the median diff, to catch the wings of</span>
                <span class="c1"># sharp features</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">diff_flag</span> <span class="o">|</span> <span class="n">newflag</span><span class="p">)]):</span>
                    <span class="n">median_diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">diff</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">diff_flag</span> <span class="o">|</span> <span class="n">newflag</span><span class="p">)])</span>
                    <span class="n">median_flag</span> <span class="o">=</span> <span class="p">((</span><span class="n">diff</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">median_diff</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">diff_flag</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">median_flag</span> <span class="o">=</span> <span class="n">newflag</span>

                <span class="n">start</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">median_flag</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="n">median_flag</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                        <span class="n">end</span> <span class="o">=</span> <span class="n">i</span>
                        <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">start</span> <span class="o">=</span> <span class="n">i</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="c1"># have found start and end of a block</span>
                            <span class="c1"># of contiguous True flags. Does the</span>
                            <span class="c1"># block contain a sharp feature? If</span>
                            <span class="c1"># so broaden the sharp feature flags</span>
                            <span class="c1"># to include the whole block</span>
                            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">newflag</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]):</span>
                                <span class="n">newflag</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                            <span class="n">start</span> <span class="o">=</span> <span class="kc">None</span>

                <span class="c1"># Convert new channels-to-flag based on difference array to channels-to-flag within</span>
                <span class="c1"># the original array.</span>
                <span class="n">flag_chan</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">newflag</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="nb">bool</span><span class="p">)</span>
                <span class="n">flag_chan</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">newflag</span>
                <span class="n">flag_chan</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="p">(</span><span class="n">flag_chan</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">|</span> <span class="n">newflag</span><span class="p">)</span>

                <span class="c1"># CAS-12242: reject sharps that could be due to ozone lines.</span>
                <span class="c1"># Find ranges of contiguous channels among new channels-to-flag.</span>
                <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">flag_chan</span><span class="p">)[</span><span class="mi">0</span><span class="p">]),</span> <span class="k">lambda</span> <span class="n">i_x</span><span class="p">:</span> <span class="n">i_x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">i_x</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                    <span class="n">rng</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">itemgetter</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">g</span><span class="p">))</span>
                    <span class="c1"># Check if single channel or range of channels overlaps with known ozone lines. If so, then</span>
                    <span class="c1"># mark that channel (or range of channels) as no longer newly flagged, and log a message.</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rng</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">ozone_channels</span><span class="p">[</span><span class="n">rng</span><span class="p">[</span><span class="mi">0</span><span class="p">]]:</span>
                            <span class="n">flag_chan</span><span class="p">[</span><span class="n">rng</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">False</span>
                            <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Rejected potential outlier found with flagging rule &#39;</span><span class="si">{}</span><span class="s2">&#39; for </span><span class="si">{}</span><span class="s2">, </span><span class="si">{}</span><span class="s2">&quot;</span>
                                     <span class="s2">&quot;spw </span><span class="si">{}</span><span class="s2">, pol </span><span class="si">{}</span><span class="s2">, channel </span><span class="si">{}</span><span class="s2">, since this channel overlaps with an atmospheric &quot;</span>
                                     <span class="s2">&quot;ozone line.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">rulename</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">table</span><span class="p">),</span> <span class="n">ant_msg</span><span class="p">,</span> <span class="n">spw</span><span class="p">,</span> <span class="n">pol</span><span class="p">,</span> <span class="n">rng</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">ozone_channels</span><span class="p">[</span><span class="n">rng</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">rng</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">]):</span>
                            <span class="n">flag_chan</span><span class="p">[</span><span class="n">rng</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">rng</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
                            <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Rejected potential outlier found with flagging rule &#39;</span><span class="si">{}</span><span class="s2">&#39; for </span><span class="si">{}</span><span class="s2">, </span><span class="si">{}</span><span class="s2">&quot;</span>
                                     <span class="s2">&quot;spw </span><span class="si">{}</span><span class="s2">, pol </span><span class="si">{}</span><span class="s2">, channels </span><span class="si">{}</span><span class="s2">-</span><span class="si">{}</span><span class="s2">, since one or more of these &quot;</span>
                                     <span class="s2">&quot;channels overlaps with an atmospheric ozone line.&quot;</span>
                                     <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">rulename</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">table</span><span class="p">),</span> <span class="n">ant_msg</span><span class="p">,</span> <span class="n">spw</span><span class="p">,</span> <span class="n">pol</span><span class="p">,</span> <span class="n">rng</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">rng</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>

                <span class="c1"># flag the &#39;view&#39;, for any subsequent rules being evaluated.</span>
                <span class="n">flag</span><span class="p">[</span><span class="n">flag_chan</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

                <span class="c1"># now compose a description of the flagging required on</span>
                <span class="c1"># the MS</span>
                <span class="n">channels_flagged</span> <span class="o">=</span> <span class="n">channels</span><span class="p">[</span><span class="n">flag_chan</span><span class="p">]</span>
                <span class="n">flagcoords</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">channels_flagged</span><span class="p">)]</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">channels_flagged</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># Log a debug message with outliers.</span>
                    <span class="n">flagged_as_str</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">ol</span><span class="p">)</span> <span class="k">for</span> <span class="n">ol</span> <span class="ow">in</span> <span class="n">channels_flagged</span><span class="p">])</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Outliers found with flagging rule &#39;</span><span class="si">{}</span><span class="s2">&#39; for </span><span class="si">{}</span><span class="s2">, </span><span class="si">{}</span><span class="s2">spw </span><span class="si">{}</span><span class="s2">, pol </span><span class="si">{}</span><span class="s2">.</span><span class="se">\n</span><span class="s2">&quot;</span>
                           <span class="s2">&quot;Sharp feature limit: </span><span class="si">{}</span><span class="s2">.</span><span class="se">\n</span><span class="s2">&quot;</span>
                           <span class="s2">&quot;The following </span><span class="si">{}</span><span class="s2"> channels will be flagged: </span><span class="si">{}</span><span class="s2">&quot;</span>
                           <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">rulename</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">table</span><span class="p">),</span> <span class="n">ant_msg</span><span class="p">,</span> <span class="n">spw</span><span class="p">,</span> <span class="n">pol</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span>
                                     <span class="nb">len</span><span class="p">(</span><span class="n">channels_flagged</span><span class="p">),</span> <span class="n">flagged_as_str</span><span class="p">))</span>
                    <span class="n">_log_outlier</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

                    <span class="c1"># Add new flag command to flag data underlying the</span>
                    <span class="c1"># view.</span>
                    <span class="n">newflags</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arrayflaggerbase</span><span class="o">.</span><span class="n">FlagCmd</span><span class="p">(</span>
                        <span class="n">reason</span><span class="o">=</span><span class="s1">&#39;sharps&#39;</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="n">table</span><span class="p">,</span> <span class="n">rulename</span><span class="o">=</span><span class="n">rulename</span><span class="p">,</span> <span class="n">spw</span><span class="o">=</span><span class="n">spw</span><span class="p">,</span> <span class="n">antenna</span><span class="o">=</span><span class="n">antenna</span><span class="p">,</span>
                        <span class="n">axisnames</span><span class="o">=</span><span class="n">axisnames</span><span class="p">,</span> <span class="n">flagcoords</span><span class="o">=</span><span class="n">flagcoords</span><span class="p">,</span> <span class="n">antenna_id_to_name</span><span class="o">=</span><span class="n">antenna_id_to_name</span><span class="p">))</span>

            <span class="k">elif</span> <span class="n">rulename</span> <span class="o">==</span> <span class="s1">&#39;diffmad&#39;</span><span class="p">:</span>

                <span class="c1"># Stop evaluating rule if all data is flagged.</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">flag</span><span class="p">):</span>
                    <span class="k">continue</span>

                <span class="c1"># Get limits.</span>
                <span class="n">limit</span> <span class="o">=</span> <span class="n">rule</span><span class="p">[</span><span class="s1">&#39;limit&#39;</span><span class="p">]</span>
                <span class="n">nchan_limit</span> <span class="o">=</span> <span class="n">rule</span><span class="p">[</span><span class="s1">&#39;nchan_limit&#39;</span><span class="p">]</span>

                <span class="c1"># Compute channel-to-channel difference (and associated median</span>
                <span class="c1"># and MAD), and corresponding flag array.</span>
                <span class="n">diff</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">data</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">diff_flag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">flag</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">flag</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">median_diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">diff</span><span class="p">[</span><span class="n">diff_flag</span> <span class="o">==</span> <span class="mi">0</span><span class="p">])</span>
                <span class="n">mad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">diff</span><span class="p">[</span><span class="n">diff_flag</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">median_diff</span><span class="p">))</span>

                <span class="c1"># first, flag channels further from the median than</span>
                <span class="c1"># limit * MAD</span>
                <span class="n">newflag</span> <span class="o">=</span> <span class="p">((</span><span class="nb">abs</span><span class="p">(</span><span class="n">diff</span><span class="o">-</span><span class="n">median_diff</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">limit</span><span class="o">*</span><span class="n">mad</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">diff_flag</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>

                <span class="c1"># second, flag all channels if more than nchan_limit</span>
                <span class="c1"># were flagged by the first stage</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">newflag</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">nchan_limit</span><span class="p">:</span>
                    <span class="n">newflag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">diff</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span>

                <span class="c1"># set channels flagged</span>
                <span class="n">flag_chan</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">newflag</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="nb">bool</span><span class="p">)</span>
                <span class="n">flag_chan</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">newflag</span>
                <span class="n">flag_chan</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">flag_chan</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">newflag</span><span class="p">)</span>

                <span class="c1"># flag the &#39;view&#39;, for any subsequent rules being evaluated.</span>
                <span class="n">flag</span><span class="p">[</span><span class="n">flag_chan</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

                <span class="c1"># now compose a description of the flagging required on</span>
                <span class="c1"># the MS</span>
                <span class="n">channels_flagged</span> <span class="o">=</span> <span class="n">channels</span><span class="p">[</span><span class="n">flag_chan</span><span class="p">]</span>
                <span class="n">flagcoords</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">channels_flagged</span><span class="p">)]</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">channels_flagged</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># Log a debug message with outliers.</span>
                    <span class="n">flagged_as_str</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">ol</span><span class="p">)</span> <span class="k">for</span> <span class="n">ol</span> <span class="ow">in</span> <span class="n">channels_flagged</span><span class="p">])</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Outliers found with flagging rule &#39;</span><span class="si">{}</span><span class="s2">&#39; for </span><span class="si">{}</span><span class="s2">, spw </span><span class="si">{}</span><span class="s2">, pol </span><span class="si">{}</span><span class="s2">.</span><span class="se">\n</span><span class="s2">&quot;</span>
                           <span class="s2">&quot;The following </span><span class="si">{}</span><span class="s2"> channels were flagged: </span><span class="si">{}</span><span class="s2">&quot;</span>
                           <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">rulename</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">table</span><span class="p">),</span> <span class="n">spw</span><span class="p">,</span> <span class="n">pol</span><span class="p">,</span>
                                     <span class="nb">len</span><span class="p">(</span><span class="n">channels_flagged</span><span class="p">),</span> <span class="n">flagged_as_str</span><span class="p">))</span>
                    <span class="n">_log_outlier</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

                    <span class="c1"># Add new flag command to flag data underlying the</span>
                    <span class="c1"># view.</span>
                    <span class="n">newflags</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arrayflaggerbase</span><span class="o">.</span><span class="n">FlagCmd</span><span class="p">(</span>
                        <span class="n">reason</span><span class="o">=</span><span class="s1">&#39;diffmad&#39;</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="n">table</span><span class="p">,</span> <span class="n">rulename</span><span class="o">=</span><span class="n">rulename</span><span class="p">,</span> <span class="n">spw</span><span class="o">=</span><span class="n">spw</span><span class="p">,</span> <span class="n">pol</span><span class="o">=</span><span class="n">pol</span><span class="p">,</span> <span class="n">antenna</span><span class="o">=</span><span class="n">antenna</span><span class="p">,</span>
                        <span class="n">axisnames</span><span class="o">=</span><span class="n">axisnames</span><span class="p">,</span> <span class="n">flagcoords</span><span class="o">=</span><span class="n">flagcoords</span><span class="p">,</span> <span class="n">antenna_id_to_name</span><span class="o">=</span><span class="n">antenna_id_to_name</span><span class="p">))</span>

            <span class="k">elif</span> <span class="n">rulename</span> <span class="o">==</span> <span class="s1">&#39;tmf&#39;</span><span class="p">:</span>

                <span class="c1"># Stop evaluating rule if all data is flagged.</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">flag</span><span class="p">):</span>
                    <span class="k">continue</span>

                <span class="c1"># Get limits.</span>
                <span class="n">frac_limit</span> <span class="o">=</span> <span class="n">rule</span><span class="p">[</span><span class="s1">&#39;frac_limit&#39;</span><span class="p">]</span>
                <span class="n">nchan_limit</span> <span class="o">=</span> <span class="n">rule</span><span class="p">[</span><span class="s1">&#39;nchan_limit&#39;</span><span class="p">]</span>

                <span class="c1"># flag all channels if fraction already flagged</span>
                <span class="c1"># is greater than tmf_limit of total</span>
                <span class="k">if</span> <span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">flag</span><span class="p">))</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">frac_limit</span> <span class="ow">or</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">flag</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">nchan_limit</span><span class="p">):</span>

                    <span class="n">newflag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">flag</span><span class="p">)</span>

                    <span class="c1"># flag the &#39;view&#39;, for any subsequent rules being evaluated.</span>
                    <span class="n">flag</span><span class="p">[</span><span class="n">newflag</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

                    <span class="c1"># now compose a description of the flagging required on</span>
                    <span class="c1"># the MS</span>
                    <span class="n">channels_flagged</span> <span class="o">=</span> <span class="n">channels</span><span class="p">[</span><span class="n">newflag</span><span class="p">]</span>
                    <span class="n">flagcoords</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">channels_flagged</span><span class="p">)]</span>

                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">channels_flagged</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="c1"># Log a debug message with outliers.</span>
                        <span class="n">flagged_as_str</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">ol</span><span class="p">)</span> <span class="k">for</span> <span class="n">ol</span> <span class="ow">in</span> <span class="n">channels_flagged</span><span class="p">])</span>
                        <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Outliers found with flagging rule &#39;</span><span class="si">{}</span><span class="s2">&#39; for </span><span class="si">{}</span><span class="s2">, spw </span><span class="si">{}</span><span class="s2">, pol </span><span class="si">{}</span><span class="s2">.</span><span class="se">\n</span><span class="s2">&quot;</span>
                               <span class="s2">&quot;Limit on fraction channels flagged before all channels are flagged: </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span>
                               <span class="s2">&quot;Limit on number channels flagged before all channels are flagged: </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span>
                               <span class="s2">&quot;The following </span><span class="si">{}</span><span class="s2"> channels were flagged: </span><span class="si">{}</span><span class="s2">&quot;</span>
                               <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">rulename</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">table</span><span class="p">),</span> <span class="n">spw</span><span class="p">,</span> <span class="n">pol</span><span class="p">,</span> <span class="n">frac_limit</span><span class="p">,</span>
                                         <span class="n">nchan_limit</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">channels_flagged</span><span class="p">),</span> <span class="n">flagged_as_str</span><span class="p">))</span>
                        <span class="n">_log_outlier</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

                        <span class="c1"># Add new flag command to flag data underlying the</span>
                        <span class="c1"># view.</span>
                        <span class="n">newflags</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arrayflaggerbase</span><span class="o">.</span><span class="n">FlagCmd</span><span class="p">(</span>
                            <span class="n">reason</span><span class="o">=</span><span class="s1">&#39;tmf&#39;</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="n">table</span><span class="p">,</span> <span class="n">rulename</span><span class="o">=</span><span class="n">rulename</span><span class="p">,</span> <span class="n">spw</span><span class="o">=</span><span class="n">spw</span><span class="p">,</span> <span class="n">pol</span><span class="o">=</span><span class="n">pol</span><span class="p">,</span> <span class="n">antenna</span><span class="o">=</span><span class="n">antenna</span><span class="p">,</span>
                            <span class="n">axisnames</span><span class="o">=</span><span class="n">axisnames</span><span class="p">,</span> <span class="n">flagcoords</span><span class="o">=</span><span class="n">flagcoords</span><span class="p">,</span> <span class="n">antenna_id_to_name</span><span class="o">=</span><span class="n">antenna_id_to_name</span><span class="p">))</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s1">&#39;bad rule: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">rule</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">newflags</span></div>


    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_find_noise_edge</span><span class="p">(</span><span class="n">mad</span><span class="p">,</span> <span class="n">flag</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the index in the mad array where the noise first</span>
<span class="sd">        dips below the median value.</span>

<span class="sd">        Keyword arguments:</span>
<span class="sd">        mad    -- The noise array to be examined.</span>
<span class="sd">        flag   -- Array whose elements are True where mad is invalid.</span>

<span class="sd">        The index of the first point where the noise dips below twice the median</span>
<span class="sd">        for the first half of the spectrum. Looking at half the spectrum</span>
<span class="sd">        handles the case where the spectrum is a composite of 2 subbands,</span>
<span class="sd">        with different noise levels; it&#39;s a fudge in that some spectra may</span>
<span class="sd">        be composed of more than 2 subbands.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">noise_edge</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">nchan</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">mad</span><span class="p">)</span>
        <span class="n">median_mad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">mad</span><span class="p">[:</span><span class="n">nchan</span><span class="o">//</span><span class="mi">4</span><span class="p">][</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">flag</span><span class="p">[:</span><span class="n">nchan</span><span class="o">//</span><span class="mi">4</span><span class="p">])])</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nchan</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">flag</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">and</span> <span class="n">mad</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">median_mad</span><span class="p">:</span>
                <span class="n">noise_edge</span> <span class="o">=</span> <span class="n">i</span>
                <span class="k">break</span>

        <span class="k">return</span> <span class="n">noise_edge</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_find_small_diff</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">flag</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="mf">2.0</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="s1">&#39;unknown&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the index in the first quarter of the data array where the</span>
<span class="sd">        point to point difference first falls below a threshold, where</span>
<span class="sd">        the threshold is defined as the &quot;limit&quot; * the median point-to-point</span>
<span class="sd">        difference.</span>

<span class="sd">        Keyword arguments:</span>
<span class="sd">        data -- The data array to be examined.</span>
<span class="sd">        flag -- Array whose elements are True where list_data is bad.</span>
<span class="sd">        limit -- Multiple of median value where the &#39;edge&#39; will be set.</span>

<span class="sd">        Returns:</span>
<span class="sd">        The index of the first point where the point to point difference</span>
<span class="sd">        first falls below &#39;limit&#39; times the median value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">nchan</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">good_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:</span><span class="n">nchan</span><span class="o">//</span><span class="mi">4</span><span class="p">][</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">flag</span><span class="p">[:</span><span class="n">nchan</span><span class="o">//</span><span class="mi">4</span><span class="p">])]</span>
        <span class="n">good_data_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nchan</span><span class="o">//</span><span class="mi">4</span><span class="p">)[</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">flag</span><span class="p">[:</span><span class="n">nchan</span><span class="o">//</span><span class="mi">4</span><span class="p">])]</span>
        <span class="n">good_data_diff</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">good_data</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">good_data</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">median_diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">good_data_diff</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">diff</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">good_data_diff</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">diff</span> <span class="o">&lt;</span> <span class="n">limit</span> <span class="o">*</span> <span class="n">median_diff</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">good_data_index</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">break</span>

        <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;edge finder failed for:</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">description</span><span class="p">)</span>
            <span class="c1"># flag one edge channel - sole purpose of this is to ensure</span>
            <span class="c1"># that a plot is made in the weblog so that the problem</span>
            <span class="c1"># can be understood</span>
            <span class="n">result</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">result</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 20202024, Pipeline Dev. Team.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>