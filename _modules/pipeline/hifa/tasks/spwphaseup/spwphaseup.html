

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>pipeline.hifa.tasks.spwphaseup.spwphaseup &mdash; Pipeline 
 (2025.1.1.56) 2025.1.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../../../_static/mystnb.8ecb98da25f57f5357bf6f572d296f466b2cfe2517ffebfabe82451661e28f02.css" />
      <link rel="stylesheet" type="text/css" href="../../../../../_static/graphviz.css?v=4ae1632d" />
      <link rel="stylesheet" type="text/css" href="../../../../../_static/sphinx_astrorefs.css?v=4d4a2fdb" />
      <link rel="stylesheet" type="text/css" href="../../../../../_static/copybutton.css?v=76b2166b" />
      <link rel="stylesheet" type="text/css" href="../../../../../_static/custom_theme.css?v=047bd54c" />

  
    <link rel="shortcut icon" href="../../../../../_static/favicon-16x16.png"/>
      <script src="../../../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../../../_static/documentation_options.js?v=e72a64b0"></script>
      <script src="../../../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="../../../../../_static/clipboard.min.js?v=a7894cd8"></script>
      <script src="../../../../../_static/copybutton.js?v=0729d509"></script>
      <script type="module" src="https://cdn.jsdelivr.net/npm/mermaid@11.12.1/dist/mermaid.esm.min.mjs"></script>
      <script type="module" src="https://cdn.jsdelivr.net/npm/@mermaid-js/layout-elk@0.2.0/dist/mermaid-layout-elk.esm.min.mjs"></script>
      <script type="module">import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@11.12.1/dist/mermaid.esm.min.mjs";import elkLayouts from "https://cdn.jsdelivr.net/npm/@mermaid-js/layout-elk@0.2.0/dist/mermaid-layout-elk.esm.min.mjs";mermaid.registerLayoutLoaders(elkLayouts);mermaid.initialize({startOnLoad:false});</script>
      <script src="https://cdn.jsdelivr.net/npm/d3@7.9.0/dist/d3.min.js"></script>
      <script type="module">import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@11.12.1/dist/mermaid.esm.min.mjs";

const defaultStyle = document.createElement('style');
defaultStyle.textContent = `pre.mermaid {
    /* Same as .mermaid-container > pre */
    display: block;
    width: 100%;
}

pre.mermaid > svg {
    /* Same as .mermaid-container > pre > svg */
    height: 500px;
    width: 100%;
    max-width: 100% !important;
}
`;
document.head.appendChild(defaultStyle);

const fullscreenStyle = document.createElement('style');
fullscreenStyle.textContent = `.mermaid-container {
    display: flex;
    flex-direction: row;
    width: 100%;
}

.mermaid-container > pre {
    display: block;
    width: 100%;
}

.mermaid-container > pre > svg {
    height: 500px;
    width: 100%;
    max-width: 100% !important;
}

.mermaid-fullscreen-btn {
    width: 28px;
    height: 28px;
    background: rgba(255, 255, 255, 0.95);
    border: 1px solid rgba(0, 0, 0, 0.3);
    border-radius: 4px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s;
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
    font-size: 14px;
    line-height: 1;
    padding: 0;
    color: #333;
}

.mermaid-fullscreen-btn:hover {
    opacity: 100% !important;
    background: rgba(255, 255, 255, 1);
    box-shadow: 0 3px 10px rgba(0, 0, 0, 0.3);
    transform: scale(1.1);
}

.mermaid-fullscreen-btn.dark-theme {
    background: rgba(50, 50, 50, 0.95);
    border: 1px solid rgba(255, 255, 255, 0.3);
    color: #e0e0e0;
}

.mermaid-fullscreen-btn.dark-theme:hover {
    background: rgba(60, 60, 60, 1);
    box-shadow: 0 3px 10px rgba(255, 255, 255, 0.2);
}

.mermaid-fullscreen-modal {
    display: none;
    position: fixed !important;
    top: 0 !important;
    left: 0 !important;
    width: 95vw;
    height: 100vh;
    background: rgba(255, 255, 255, 0.98);
    z-index: 9999;
    padding: 20px;
    overflow: auto;
}

.mermaid-fullscreen-modal.dark-theme {
    background: rgba(0, 0, 0, 0.98);
}

.mermaid-fullscreen-modal.active {
    display: flex;
    align-items: center;
    justify-content: center;
}

.mermaid-container-fullscreen {
    position: relative;
    width: 95vw;
    height: 90vh;
    max-width: 95vw;
    max-height: 90vh;
    background: white;
    border-radius: 8px;
    padding: 20px;
    box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
    overflow: auto;
    display: flex;
    align-items: center;
    justify-content: center;
}

.mermaid-container-fullscreen.dark-theme {
    background: #1a1a1a;
    box-shadow: 0 10px 40px rgba(0, 0, 0, 0.8);
}

.mermaid-container-fullscreen pre.mermaid {
    width: 100%;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
}

.mermaid-container-fullscreen .mermaid svg {
    height: 100% !important;
    width: 100% !important;
    cursor: grab;
}

.mermaid-fullscreen-close {
    position: fixed !important;
    top: 20px !important;
    right: 20px !important;
    width: 40px;
    height: 40px;
    background: rgba(255, 255, 255, 0.95);
    border: 1px solid rgba(0, 0, 0, 0.2);
    border-radius: 50%;
    cursor: pointer;
    z-index: 10000;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    transition: all 0.2s;
    font-size: 24px;
    line-height: 1;
    color: #333;
}

.mermaid-fullscreen-close:hover {
    background: white;
    box-shadow: 0 6px 16px rgba(0, 0, 0, 0.4);
    transform: scale(1.1);
}

.mermaid-fullscreen-close.dark-theme {
    background: rgba(50, 50, 50, 0.95);
    border: 1px solid rgba(255, 255, 255, 0.2);
    color: #e0e0e0;
}

.mermaid-fullscreen-close.dark-theme:hover {
    background: rgba(60, 60, 60, 1);
    box-shadow: 0 6px 16px rgba(255, 255, 255, 0.2);
}

.mermaid-fullscreen-modal .mermaid-fullscreen-btn {
    display: none !important;
}`;
document.head.appendChild(fullscreenStyle);

// Detect if page has dark background
const isDarkTheme = () => {
    const bgColor = window.getComputedStyle(document.body).backgroundColor;
    const match = bgColor.match(/rgb\((\d+),\s*(\d+),\s*(\d+)/);
    if (match) {
        const r = parseInt(match[1]);
        const g = parseInt(match[2]);
        const b = parseInt(match[3]);
        const brightness = (r * 299 + g * 587 + b * 114) / 1000;
        return brightness < 128;
    }
    return false;
};

const load = async () => {
    await mermaid.run();

    const all_mermaids = document.querySelectorAll(".mermaid");
    const mermaids_processed = document.querySelectorAll(".mermaid[data-processed='true']");

    if ("True" === "True") {
        const mermaids_to_add_zoom = -1 === -1 ? all_mermaids.length : -1;
        if(mermaids_to_add_zoom > 0) {
            var svgs = d3.selectAll(".mermaid svg");
            if(all_mermaids.length !== mermaids_processed.length) {
                setTimeout(load, 200);
                return;
            } else if(svgs.size() !== mermaids_to_add_zoom) {
                setTimeout(load, 200);
                return;
            } else {
                svgs.each(function() {
                    var svg = d3.select(this);
                    svg.html("<g class='wrapper'>" + svg.html() + "</g>");
                    var inner = svg.select("g");
                    var zoom = d3.zoom().on("zoom", function(event) {
                        inner.attr("transform", event.transform);
                    });
                    svg.call(zoom);
                });
            }
        }
    } else if(all_mermaids.length !== mermaids_processed.length) {
        // Wait for mermaid to process all diagrams
        setTimeout(load, 200);
        return;
    }

    const darkTheme = isDarkTheme();

    // Stop here if not adding fullscreen capability
    if ("True" !== "True") return;

    const modal = document.createElement('div');
    modal.className = 'mermaid-fullscreen-modal' + (darkTheme ? ' dark-theme' : '');
    modal.setAttribute('role', 'dialog');
    modal.setAttribute('aria-modal', 'true');
    modal.setAttribute('aria-label', 'Fullscreen diagram viewer');
    modal.innerHTML = `
        <button class="mermaid-fullscreen-close${darkTheme ? ' dark-theme' : ''}" aria-label="Close fullscreen">✕</button>
        <div class="mermaid-container-fullscreen${darkTheme ? ' dark-theme' : ''}"></div>
    `;
    document.body.appendChild(modal);

    const modalContent = modal.querySelector('.mermaid-container-fullscreen');
    const closeBtn = modal.querySelector('.mermaid-fullscreen-close');

    let previousScrollOffset = [window.scrollX, window.scrollY];

    const closeModal = () => {
        modal.classList.remove('active');
        modalContent.innerHTML = '';
        document.body.style.overflow = ''
        window.scrollTo({left: previousScrollOffset[0], top: previousScrollOffset[1], behavior: 'instant'});
    };

    closeBtn.addEventListener('click', closeModal);
    modal.addEventListener('click', (e) => {
        if (e.target === modal) closeModal();
    });
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && modal.classList.contains('active')) {
            closeModal();
        }
    });

    const allButtons = [];

    document.querySelectorAll('.mermaid').forEach((mermaidDiv) => {
        if (mermaidDiv.parentNode.classList.contains('mermaid-container') ||
            mermaidDiv.closest('.mermaid-fullscreen-modal')) {
            return;
        }

        const container = document.createElement('div');
        container.className = 'mermaid-container';
        mermaidDiv.parentNode.insertBefore(container, mermaidDiv);
        container.appendChild(mermaidDiv);

        const fullscreenBtn = document.createElement('button');
        fullscreenBtn.className = 'mermaid-fullscreen-btn' + (darkTheme ? ' dark-theme' : '');
        fullscreenBtn.setAttribute('aria-label', 'View diagram in fullscreen');
        fullscreenBtn.textContent = '⛶';
        fullscreenBtn.style.opacity = '50%';

        // Calculate dynamic position based on diagram's margin and padding
        const diagramStyle = window.getComputedStyle(mermaidDiv);
        const marginTop = parseFloat(diagramStyle.marginTop) || 0;
        const marginRight = parseFloat(diagramStyle.marginRight) || 0;
        const paddingTop = parseFloat(diagramStyle.paddingTop) || 0;
        const paddingRight = parseFloat(diagramStyle.paddingRight) || 0;
        fullscreenBtn.style.top = `${marginTop + paddingTop + 4}px`;
        fullscreenBtn.style.right = `${marginRight + paddingRight + 4}px`;

        fullscreenBtn.addEventListener('click', () => {
            previousScrollOffset = [window.scroll, window.scrollY];
            const clone = mermaidDiv.cloneNode(true);
            modalContent.innerHTML = '';
            modalContent.appendChild(clone);

            const svg = clone.querySelector('svg');
            if (svg) {
                svg.removeAttribute('width');
                svg.removeAttribute('height');
                svg.style.width = '100%';
                svg.style.height = 'auto';
                svg.style.maxWidth = '100%';
                svg.style.sdisplay = 'block';

                if ("True" === "True") {
                    setTimeout(() => {
                        const g = svg.querySelector('g');
                        if (g) {
                            var svgD3 = d3.select(svg);
                            svgD3.html("<g class='wrapper'>" + svgD3.html() + "</g>");
                            var inner = svgD3.select("g");
                            var zoom = d3.zoom().on("zoom", function(event) {
                                inner.attr("transform", event.transform);
                            });
                            svgD3.call(zoom);
                        }
                    }, 100);
                }
            }

            modal.classList.add('active');
            document.body.style.overflow = 'hidden';
        });

        container.appendChild(fullscreenBtn);
        allButtons.push(fullscreenBtn);
    });

    // Update theme classes when theme changes
    const updateTheme = () => {
        const dark = isDarkTheme();
        allButtons.forEach(btn => {
            if (dark) {
                btn.classList.add('dark-theme');
            } else {
                btn.classList.remove('dark-theme');
            }
        });
        if (dark) {
            modal.classList.add('dark-theme');
            modalContent.classList.add('dark-theme');
            closeBtn.classList.add('dark-theme');
        } else {
            modal.classList.remove('dark-theme');
            modalContent.classList.remove('dark-theme');
            closeBtn.classList.remove('dark-theme');
        }
    };

    // Watch for theme changes
    const observer = new MutationObserver(updateTheme);
    observer.observe(document.documentElement, {
        attributes: true,
        attributeFilter: ['class', 'style', 'data-theme']
    });
    observer.observe(document.body, {
        attributes: true,
        attributeFilter: ['class', 'style']
    });
};

window.addEventListener("load", load);
</script>
    <script src="../../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: gray" >

          
          
          <a href="../../../../../index.html" class="icon icon-home">
            Pipeline 
 (2025.1.1.56)
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Basics</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../develdocmd/ways_to_run_the_pipeline.html">Ways to run the Pipeline</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../develdocmd/recipes.html">Pipeline Recipes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../dependencies.html">Dependencies of <code class="docutils literal notranslate"><span class="pre">Pipeline</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../releases.html">Releases</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../timeline.html">Roadmap &amp; Branching Strategy</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../apisummary.html">Full APIs (autosummary)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../apisummary.html#pipeline-tasks-autosummary">Pipeline Tasks (autosummary)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../apisummary.html#pipeline-domain-context-autosummary">Pipeline domain/context (autosummary)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../apisummary.html#pipeline-domain-infrastructure-modules-automodapi">Pipeline domain/infrastructure modules (automodapi)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../apisummary.html#pipeline-h-tasks-modules-autmodapi"><code class="docutils literal notranslate"><span class="pre">pipeline.h*.tasks</span></code> modules (autmodapi)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../apisummary.html#inheritance-diagrams-for-pipeline-task-inputs-results-classes">Inheritance Diagrams for Pipeline <code class="docutils literal notranslate"><span class="pre">Task</span></code>/<code class="docutils literal notranslate"><span class="pre">Inputs</span></code>/<code class="docutils literal notranslate"><span class="pre">Results</span></code> Classes</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Developer Notes</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../develdocmd/ALMA-Imaging-Workflow.html">ALMA interferometry imaging workflow</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../develdocmd/VLA-Imaging-Workflow.html">VLA interferometry imaging workflow</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../develdocmd/VLASS-SE-CONT-Imaging-Workflow.html">VLASS-SE-CONT imaging workflow</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../develdocmd/VLASS-SE-CUBE-Imaging-Workflow.html">VLASS-SE-CUBE imaging workflow</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../develdocmd/selfcal_workflow.html">VLASS Selfcal &amp; Restore workflows</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../develdocmd/comparing_pipeline_executions.html">Comparing pipeline executions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../develdocmd/building_the_pipeline.html">Building the pipeline</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../modular.html">Run the Pipeline in a Conda environment</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../develdocmd/pipeline_tests.html">Pipeline testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../develdocmd/DataType_Testing.html">DataType Testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../develdocmd/QA_scores.html">Pipeline Quality Assurance (QA) Score Class Design</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../develdocmd/DeveloperDocumentation.html">Pipeline developer documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../develdocmd/python3_conversion_notes.html">Python 3 conversion notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../heuristics/field_parameter.html">Field parameter</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../heuristics/FlaggingTasks.html">Pipeline Flagging Tasks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../notebooks/context.html">Pipeline Context and Domain Objects</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../notebooks/tier0dask.html">“Tier0” Parallelization with Dask/Futures</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: gray" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../../index.html">Pipeline 
 (2025.1.1.56)</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../../../index.html">Module code</a></li>
          <li class="breadcrumb-item"><a href="../../../../pipeline.html">pipeline</a></li>
      <li class="breadcrumb-item active">pipeline.hifa.tasks.spwphaseup.spwphaseup</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for pipeline.hifa.tasks.spwphaseup.spwphaseup</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span><span class="w"> </span><span class="nn">copy</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">dataclasses</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">os</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">traceback</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">dataclasses</span><span class="w"> </span><span class="kn">import</span> <span class="n">dataclass</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Set</span><span class="p">,</span> <span class="n">Tuple</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">pipeline.infrastructure</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">infrastructure</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pipeline.infrastructure.basetask</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">basetask</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pipeline.infrastructure.callibrary</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">callibrary</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pipeline.infrastructure.utils</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">utils</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pipeline.infrastructure.vdp</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">vdp</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pipeline.domain</span><span class="w"> </span><span class="kn">import</span> <span class="n">SpectralWindow</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pipeline.domain.measurementset</span><span class="w"> </span><span class="kn">import</span> <span class="n">MeasurementSet</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pipeline.h.tasks.common</span><span class="w"> </span><span class="kn">import</span> <span class="n">commonhelpermethods</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pipeline.hif.tasks.gaincal</span><span class="w"> </span><span class="kn">import</span> <span class="n">gtypegaincal</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pipeline.hif.tasks.gaincal.common</span><span class="w"> </span><span class="kn">import</span> <span class="n">GaincalResults</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pipeline.hif.tasks.gaincal.gtypegaincal</span><span class="w"> </span><span class="kn">import</span> <span class="n">GTypeGaincalInputs</span><span class="p">,</span> <span class="n">GTypeGaincal</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pipeline.hifa.heuristics.phasemetrics</span><span class="w"> </span><span class="kn">import</span> <span class="n">PhaseStabilityHeuristics</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pipeline.hifa.heuristics.phasespwmap</span><span class="w"> </span><span class="kn">import</span> <span class="n">IntentField</span><span class="p">,</span> <span class="n">SpwMapping</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pipeline.hifa.heuristics.phasespwmap</span><span class="w"> </span><span class="kn">import</span> <span class="n">combine_spwmap</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pipeline.hifa.heuristics.phasespwmap</span><span class="w"> </span><span class="kn">import</span> <span class="n">simple_n2wspwmap</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pipeline.hifa.heuristics.phasespwmap</span><span class="w"> </span><span class="kn">import</span> <span class="n">snr_n2wspwmap</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pipeline.hifa.heuristics.phasespwmap</span><span class="w"> </span><span class="kn">import</span> <span class="n">update_spwmap_for_band_to_band</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pipeline.hifa.tasks.fluxscale.qa</span><span class="w"> </span><span class="kn">import</span> <span class="n">CaltableWrapperFactory</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pipeline.hifa.tasks.gaincalsnr</span><span class="w"> </span><span class="kn">import</span> <span class="n">gaincalsnr</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pipeline.infrastructure</span><span class="w"> </span><span class="kn">import</span> <span class="n">casa_tools</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pipeline.infrastructure</span><span class="w"> </span><span class="kn">import</span> <span class="n">task_registry</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pipeline.infrastructure.utils.math</span><span class="w"> </span><span class="kn">import</span> <span class="n">round_half_up</span>

<span class="n">LOG</span> <span class="o">=</span> <span class="n">infrastructure</span><span class="o">.</span><span class="n">get_logger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s1">&#39;SpwPhaseupInputs&#39;</span><span class="p">,</span>
    <span class="s1">&#39;SpwPhaseup&#39;</span><span class="p">,</span>
    <span class="s1">&#39;SpwPhaseupResults&#39;</span>
<span class="p">]</span>

<span class="n">WEAK_CALIBRATOR_INTENTS</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;CHECK&#39;</span><span class="p">,</span> <span class="s1">&#39;PHASE&#39;</span><span class="p">}</span>

<span class="c1"># Estimated SNR threshold for spw above which a gaintable will be generated. Equivalent</span>
<span class="c1"># to X in PIPE-2505 spec. Setting to -1 forces gaintable SNR estimation for all SPWs.</span>
<span class="n">LOW_SNR_THRESHOLD</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

<span class="c1"># Multiplier applied to catalogue SNRs for their subsequent use in heuristics.</span>
<span class="c1"># Equivalent to Y in PIPE-2505 spec.</span>
<span class="n">CATALOGUE_SNR_MULTIPLIER</span> <span class="o">=</span> <span class="mf">0.75</span>

<span class="c1"># Multiplier applied to gaintable SNRs for their subsequent use in heuristics.</span>
<span class="c1"># Equivalent to Z in PIPE-2505 spec.</span>
<span class="n">GAINTABLE_SNR_MULTIPLIER</span> <span class="o">=</span> <span class="mf">1.0</span>


<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">SNRTestResult</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Data structure to store the results of SNR tests.</span>

<span class="sd">    This class encapsulates the results of Signal-to-Noise Ratio (SNR) calculations for multiple</span>
<span class="sd">    spectral window (SpW) IDs. It tracks which SpWs have valid SNR results, the list of SNR values,</span>
<span class="sd">    and associated metadata such as reference and integration times.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    spw_ids : list[int]</span>
<span class="sd">        List of spectral window (SpW) IDs for which SNR was derived.</span>
<span class="sd">    snr_values : list[float | None]</span>
<span class="sd">        List of derived SNR values, where None represents missing or undefined SNR.</span>
<span class="sd">    is_good_snr : list[bool | None]</span>
<span class="sd">        List of boolean values indicating whether the derived SNR is above a predefined threshold</span>
<span class="sd">        (considered good). None represents missing evaluation.</span>
<span class="sd">    reference_times : list[float | None]</span>
<span class="sd">        List specifying reference times in minutes, where None represents missing data.</span>
<span class="sd">    integration_times : list[float | None]</span>
<span class="sd">        List specifying integration times in minutes, where None represents missing data.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">spw_ids</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="n">dataclasses</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="nb">list</span><span class="p">)</span>
    <span class="n">snr_values</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span> <span class="o">|</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="n">dataclasses</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="nb">list</span><span class="p">)</span>
    <span class="n">is_good_snr</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="n">dataclasses</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="nb">list</span><span class="p">)</span>
    <span class="n">reference_times</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span> <span class="o">|</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="n">dataclasses</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="nb">list</span><span class="p">)</span>
    <span class="n">integration_times</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span> <span class="o">|</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="n">dataclasses</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="nb">list</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">has_no_snrs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Indicates whether there are no SNRs available.</span>

<span class="sd">        This property checks the inverse state of another attribute to determine if no</span>
<span class="sd">        SNRs are present.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: True if there are no SNRs, False otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_snrs</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">has_snrs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks if the object has non-empty and non-None SNR (Signal-to-Noise Ratio)</span>
<span class="sd">        values.</span>

<span class="sd">        Returns</span>
<span class="sd">            bool: True if there are SNR values and at least one of them is not None,</span>
<span class="sd">                otherwise False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">snr_values</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">any</span><span class="p">(</span><span class="n">snr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">snr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">snr_values</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">has_all_snrs_greater_than</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">snr_limit</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determines if all SNR (Signal-to-Noise Ratio) values are greater than a specified limit.</span>

<span class="sd">        Returns a boolean indicating whether all defined SNR values in the list are greater</span>
<span class="sd">        than or equal to the provided limit. If the list of SNR values is empty, the method</span>
<span class="sd">        returns `False`.</span>

<span class="sd">        Args:</span>
<span class="sd">            snr_limit: A floating-point number representing the minimum threshold</span>
<span class="sd">                       for the SNR values.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: True if all SNR values are greater than or equal to the limit,</span>
<span class="sd">                    False otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_snrs</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="n">snr</span> <span class="o">&gt;=</span> <span class="n">snr_limit</span> <span class="k">for</span> <span class="n">snr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">snr_values</span><span class="p">)</span>


<span class="k">class</span><span class="w"> </span><span class="nc">SpwPhaseupInputs</span><span class="p">(</span><span class="n">gtypegaincal</span><span class="o">.</span><span class="n">GTypeGaincalInputs</span><span class="p">):</span>
    <span class="c1"># Spw mapping mode heuristics, options are:</span>
    <span class="c1">#  &#39;auto&#39;: apply SNR-based heuristics to determine which type of spw</span>
    <span class="c1">#          mapping / combination is appropriate.</span>
    <span class="c1">#  &#39;combine&#39;: force use of combined spw mapping</span>
    <span class="c1">#  &#39;simple&#39;: force use of simple narrow-to-wide spw mapping.</span>
    <span class="c1">#  &#39;default&#39;: use the standard mapping, mapping each spw to itself.</span>
    <span class="n">hm_spwmapmode</span> <span class="o">=</span> <span class="n">vdp</span><span class="o">.</span><span class="n">VisDependentProperty</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">)</span>

    <span class="nd">@hm_spwmapmode</span><span class="o">.</span><span class="n">convert</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">hm_spwmapmode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="n">allowed</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="s1">&#39;combine&#39;</span><span class="p">,</span> <span class="s1">&#39;simple&#39;</span><span class="p">,</span> <span class="s1">&#39;default&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">allowed</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">((</span><span class="s1">&#39;</span><span class="si">{!r}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">allowed</span><span class="p">))</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Value not in allowed value set (</span><span class="si">{!s}</span><span class="s1">): </span><span class="si">{!r}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">value</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">value</span>

    <span class="c1"># Fraction of bandwidth to ignore on each edge of a spectral window</span>
    <span class="c1"># for SNR assessment.</span>
    <span class="n">bwedgefrac</span> <span class="o">=</span> <span class="n">vdp</span><span class="o">.</span><span class="n">VisDependentProperty</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="mf">0.03125</span><span class="p">)</span>

    <span class="c1"># Maximum fraction of data that can be flagged for an antenna before that</span>
    <span class="c1"># antenna is considered &quot;flagged&quot; and no longer considered in SNR</span>
    <span class="c1"># estimation.</span>
    <span class="n">maxfracflagged</span> <span class="o">=</span> <span class="n">vdp</span><span class="o">.</span><span class="n">VisDependentProperty</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="mf">0.90</span><span class="p">)</span>

    <span class="c1"># Maximum narrow bandwidth.</span>
    <span class="n">maxnarrowbw</span> <span class="o">=</span> <span class="n">vdp</span><span class="o">.</span><span class="n">VisDependentProperty</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="s1">&#39;300MHz&#39;</span><span class="p">)</span>

    <span class="c1"># Width of spw must be larger than minfracmaxbw * maximum bandwidth for</span>
    <span class="c1"># a spw to be a match.</span>
    <span class="n">minfracmaxbw</span> <span class="o">=</span> <span class="n">vdp</span><span class="o">.</span><span class="n">VisDependentProperty</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="mf">0.8</span><span class="p">)</span>

    <span class="c1"># Phase SNR threshold to use in spw mapping assessment to derive the optimal</span>
    <span class="c1"># solution interval (scan-time based).</span>
    <span class="n">phasesnr</span> <span class="o">=</span> <span class="n">vdp</span><span class="o">.</span><span class="n">VisDependentProperty</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="mf">32.0</span><span class="p">)</span>

    <span class="c1"># Phase SNR threshold to use in spw mapping assessment to derive the optimal</span>
    <span class="c1"># solution interval w.r.t. bright calibrators bandpass and differential</span>
    <span class="c1"># gain (integration-time based).</span>
    <span class="n">intphasesnr</span> <span class="o">=</span> <span class="n">vdp</span><span class="o">.</span><span class="n">VisDependentProperty</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="mf">5.0</span><span class="p">)</span>

    <span class="c1"># Phase SNR threshold to use in spw mapping assessment to derive the optimal</span>
    <span class="c1"># solution interval w.r.t. bright calibrator fields that cover the amplitude</span>
    <span class="c1"># calibrator intent.</span>
    <span class="n">intphasesnrmin</span> <span class="o">=</span> <span class="n">vdp</span><span class="o">.</span><span class="n">VisDependentProperty</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="mf">3.0</span><span class="p">)</span>

    <span class="c1"># Maximum phase-up solution interval.</span>
    <span class="n">phaseupmaxsolint</span> <span class="o">=</span> <span class="n">vdp</span><span class="o">.</span><span class="n">VisDependentProperty</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="mf">60.0</span><span class="p">)</span>

    <span class="c1"># Toggle to select whether to restrict spw matching to the same baseband.</span>
    <span class="n">samebb</span> <span class="o">=</span> <span class="n">vdp</span><span class="o">.</span><span class="n">VisDependentProperty</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Antenna flagging heuristics parameter</span>
    <span class="n">hm_nantennas</span> <span class="o">=</span> <span class="n">vdp</span><span class="o">.</span><span class="n">VisDependentProperty</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">)</span>

    <span class="nd">@hm_nantennas</span><span class="o">.</span><span class="n">convert</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">hm_nantennas</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="n">allowed</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="s1">&#39;unflagged&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">allowed</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">((</span><span class="s1">&#39;</span><span class="si">{!r}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">allowed</span><span class="p">))</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Value not in allowed value set (</span><span class="si">{!s}</span><span class="s1">): </span><span class="si">{!r}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">value</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">value</span>

    <span class="c1"># Allow user to set custom filename for the phase offsets caltable.</span>
    <span class="n">caltable</span> <span class="o">=</span> <span class="n">vdp</span><span class="o">.</span><span class="n">VisDependentProperty</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

    <span class="c1"># Intent to use in data selection for computing phase offsets caltable.</span>
    <span class="n">intent</span> <span class="o">=</span> <span class="n">vdp</span><span class="o">.</span><span class="n">VisDependentProperty</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="s1">&#39;BANDPASS&#39;</span><span class="p">)</span>

    <span class="c1"># PIPE-629: parameter to unregister existing phaseup tables before appending to callibrary</span>
    <span class="n">unregister_existing</span> <span class="o">=</span> <span class="n">vdp</span><span class="o">.</span><span class="n">VisDependentProperty</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="c1"># docstring and type hints: supplements hifa_spwphaseup</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">vis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">output_dir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">caltable</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">intent</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">hm_spwmapmode</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">phasesnr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">intphasesnr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">intphasesnrmin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">phaseupmaxsolint</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bwedgefrac</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">hm_nantennas</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">maxfracflagged</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">maxnarrowbw</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">minfracmaxbw</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">samebb</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">unregister_existing</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">parameters</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize Inputs.</span>

<span class="sd">        Args:</span>
<span class="sd">            context: Pipeline context object containing state information.</span>

<span class="sd">            vis: The list of input MeasurementSets. Defaults to the list of</span>
<span class="sd">                MeasurementSets specified in the pipeline context.</span>

<span class="sd">                Example: ``vis=[&#39;M82A.ms&#39;, &#39;M82B.ms&#39;]``</span>

<span class="sd">            output_dir: Output directory.</span>
<span class="sd">                Defaults to None, which corresponds to the current working directory.</span>

<span class="sd">            caltable: The list of output calibration tables. Defaults to the standard</span>
<span class="sd">                pipeline naming convention.</span>

<span class="sd">                Example: ``caltable=[&#39;M82.gcal&#39;, &#39;M82B.gcal&#39;]``</span>

<span class="sd">            intent: A string containing a comma delimited list of intents against</span>
<span class="sd">                which the selected fields are matched. Defaults to the BANDPASS</span>
<span class="sd">                observations.</span>

<span class="sd">                Example: ``intent=&#39;PHASE&#39;``</span>

<span class="sd">            hm_spwmapmode: The spectral window mapping mode. The options are: &#39;auto&#39;,</span>
<span class="sd">                &#39;combine&#39;, &#39;simple&#39;, and &#39;default&#39;. In &#39;auto&#39; mode hifa_spwphaseup</span>
<span class="sd">                estimates the SNR of the phase calibrator observations and uses these</span>
<span class="sd">                estimates to choose between &#39;combine&#39; mode (low SNR) and &#39;default&#39; mode</span>
<span class="sd">                (high SNR). In combine mode all spectral windows are combined and mapped to</span>
<span class="sd">                one spectral window. In &#39;simple&#39; mode narrow spectral windows are mapped to</span>
<span class="sd">                wider ones using an algorithm defined by &#39;maxnarrowbw&#39;, &#39;minfracmaxbw&#39;, and</span>
<span class="sd">                &#39;samebb&#39;. In &#39;default&#39; mode the spectral window map defaults to the</span>
<span class="sd">                standard one to one mapping.</span>

<span class="sd">                Example:`` hm_spwmapmode=&#39;combine&#39;``</span>

<span class="sd">            phasesnr: The required phase gaincal solution signal-to-noise.</span>

<span class="sd">                Example: ``phasesnr=20.0``</span>

<span class="sd">            intphasesnr: The required solint=&#39;int&#39; phase gaincal solution signal-to-noise.</span>

<span class="sd">                Example: ``intphasesnr=4.0``</span>

<span class="sd">            intphasesnrmin: The required solint=&#39;int&#39; phase gaincal solution</span>
<span class="sd">                signal-to-noise for fields that cover the AMPLITUDE calibrator</span>
<span class="sd">                intent.</span>

<span class="sd">                Example: ``intphasesnrmin=3.0``</span>

<span class="sd">            phaseupmaxsolint: Maximum phase correction solution interval (in</span>
<span class="sd">                seconds) allowed in very low-SNR cases. Used only when</span>
<span class="sd">                ``hm_spwmapmode`` = &#39;auto&#39; or &#39;combine&#39;.</span>

<span class="sd">                Example: ``phaseupmaxsolint=60.0``</span>

<span class="sd">            bwedgefrac: The fraction of the bandwidth edges that is flagged.</span>

<span class="sd">                Example: ``bwedgefrac=0.0``</span>

<span class="sd">            hm_nantennas: The heuristics for determines the number of antennas to use</span>
<span class="sd">                in the signal-to-noise estimate. The options are &#39;all&#39; and &#39;unflagged&#39;.</span>
<span class="sd">                The &#39;unflagged&#39; options is not currently supported.</span>

<span class="sd">                Example: ``hm_nantennas=&#39;unflagged&#39;``</span>

<span class="sd">            maxfracflagged: The maximum fraction of an antenna that can be flagged</span>
<span class="sd">                before it is excluded from the signal-to-noise estimate.</span>

<span class="sd">                Example: ``maxfracflagged=0.80``</span>

<span class="sd">            maxnarrowbw: The maximum bandwidth defining narrow spectral windows. Values</span>
<span class="sd">                must be in CASA compatible frequency units.</span>

<span class="sd">                Example: ``maxnarrowbw=&#39;&#39;``</span>

<span class="sd">            minfracmaxbw: The minimum fraction of the maximum bandwidth in the set of</span>
<span class="sd">                spws to use for matching.</span>

<span class="sd">                Example: ``minfracmaxbw=0.75``</span>

<span class="sd">            samebb: Match within the same baseband if possible.</span>

<span class="sd">                Example: ``samebb=False``</span>

<span class="sd">            unregister_existing: Unregister previous spwphaseup calibrations from the pipeline context</span>
<span class="sd">                before registering the new calibrations from this task.</span>

<span class="sd">            field: The list of field names or field ids for which phase offset solutions</span>
<span class="sd">                are to be computed. Defaults to all fields with the default intent.</span>

<span class="sd">                Example: ``field=&#39;3C279&#39;``, ``field=&#39;3C279, M82&#39;``</span>

<span class="sd">            spw: The list of spectral windows and channels for which gain solutions are</span>
<span class="sd">                computed. Defaults to all the science spectral windows.</span>

<span class="sd">                Example: ``spw=&#39;13,15&#39;``</span>

<span class="sd">            combine: Data axes to combine for solving. Options are ``&#39;&#39;``, ``&#39;scan&#39;``, ``&#39;spw&#39;``,</span>
<span class="sd">                ``&#39;field&#39;`` or any comma-separated combination.</span>

<span class="sd">                Example: ``combine=&#39;&#39;``</span>

<span class="sd">            refant: Reference antenna name(s) in priority order. Defaults to most recent</span>
<span class="sd">                values set in the pipeline context.  If no reference antenna is defined in</span>
<span class="sd">                the pipeline context the CASA defaults are used.</span>

<span class="sd">                Example: ``refant=&#39;DV01&#39;``, ``refant=&#39;DV05,DV07&#39;``</span>

<span class="sd">            minblperant: Minimum number of baselines required per antenna for each solve.</span>
<span class="sd">                Antennas with fewer baselines are excluded from solutions.</span>

<span class="sd">                Example: ``minblperant=2``</span>

<span class="sd">            minsnr: Solutions below this SNR are rejected.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">vis</span><span class="o">=</span><span class="n">vis</span><span class="p">,</span> <span class="n">output_dir</span><span class="o">=</span><span class="n">output_dir</span><span class="p">,</span> <span class="o">**</span><span class="n">parameters</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">caltable</span> <span class="o">=</span> <span class="n">caltable</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">intent</span> <span class="o">=</span> <span class="n">intent</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hm_spwmapmode</span> <span class="o">=</span> <span class="n">hm_spwmapmode</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">phasesnr</span> <span class="o">=</span> <span class="n">phasesnr</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">intphasesnr</span> <span class="o">=</span> <span class="n">intphasesnr</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">intphasesnrmin</span> <span class="o">=</span> <span class="n">intphasesnrmin</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">phaseupmaxsolint</span> <span class="o">=</span> <span class="n">phaseupmaxsolint</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bwedgefrac</span> <span class="o">=</span> <span class="n">bwedgefrac</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hm_nantennas</span> <span class="o">=</span> <span class="n">hm_nantennas</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">maxfracflagged</span> <span class="o">=</span> <span class="n">maxfracflagged</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">maxnarrowbw</span> <span class="o">=</span> <span class="n">maxnarrowbw</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">minfracmaxbw</span> <span class="o">=</span> <span class="n">minfracmaxbw</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">samebb</span> <span class="o">=</span> <span class="n">samebb</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unregister_existing</span> <span class="o">=</span> <span class="n">unregister_existing</span>


<div class="viewcode-block" id="SpwPhaseup">
<a class="viewcode-back" href="../../../../../_automodapi/pipeline.hifa.tasks.SpwPhaseup.html#pipeline.hifa.tasks.SpwPhaseup">[docs]</a>
<span class="nd">@task_registry</span><span class="o">.</span><span class="n">set_equivalent_casa_task</span><span class="p">(</span><span class="s1">&#39;hifa_spwphaseup&#39;</span><span class="p">)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">SpwPhaseup</span><span class="p">(</span><span class="n">gtypegaincal</span><span class="o">.</span><span class="n">GTypeGaincal</span><span class="p">):</span>
    <span class="n">Inputs</span> <span class="o">=</span> <span class="n">SpwPhaseupInputs</span>

<div class="viewcode-block" id="SpwPhaseup.prepare">
<a class="viewcode-back" href="../../../../../_automodapi/pipeline.hifa.tasks.SpwPhaseup.html#pipeline.hifa.tasks.SpwPhaseup.prepare">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">prepare</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">parameters</span><span class="p">):</span>
        <span class="c1"># Simplify the inputs</span>
        <span class="n">inputs</span><span class="p">:</span> <span class="n">SpwPhaseupInputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span>

        <span class="c1"># Intents to derive separate SpW mappings for:</span>
        <span class="n">spwmap_intents</span> <span class="o">=</span> <span class="s1">&#39;AMPLITUDE,BANDPASS,CHECK,DIFFGAINREF,DIFFGAINSRC,PHASE&#39;</span>

        <span class="c1"># Do not derive separate SpW mappings for fields that also cover any of</span>
        <span class="c1"># these calibrator intents:</span>
        <span class="n">exclude_intents</span> <span class="o">=</span> <span class="s1">&#39;POLARIZATION,POLANGLE,POLLEAKAGE&#39;</span>

        <span class="c1"># PIPE-629: if requested, unregister old spwphaseup calibrations from</span>
        <span class="c1"># local copy of context, to stop these from being pre-applied during</span>
        <span class="c1"># this stage.</span>
        <span class="k">if</span> <span class="n">inputs</span><span class="o">.</span><span class="n">unregister_existing</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_unregister_spwphaseup</span><span class="p">()</span>

        <span class="c1"># Derive the mapping from phase fields to target/check fields.</span>
        <span class="n">phasecal_mapping</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_derive_phase_to_target_check_mapping</span><span class="p">(</span><span class="n">inputs</span><span class="o">.</span><span class="n">ms</span><span class="p">)</span>

        <span class="c1"># Derive the optimal spectral window maps.</span>
        <span class="n">spwmaps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_derive_spwmaps</span><span class="p">(</span><span class="n">spwmap_intents</span><span class="p">,</span> <span class="n">exclude_intents</span><span class="p">)</span>

        <span class="c1"># Compute the spw-to-spw phase offsets (historically misnamed as the</span>
        <span class="c1"># &quot;phaseup&quot;) caltable and accept into local context.</span>
        <span class="n">phaseupresult</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_do_phaseup</span><span class="p">()</span>

        <span class="c1"># Compute diagnostic phase caltables for all calibrator fields with SpW</span>
        <span class="c1"># mappings, with the spw-to-spw phase offset corrections included in</span>
        <span class="c1"># pre-apply.</span>
        <span class="n">diag_phase_results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_do_diagnostic_phasecal</span><span class="p">(</span><span class="n">spwmaps</span><span class="p">)</span>

        <span class="c1"># Compute what SNR is achieved for PHASE fields after the SpW phase-up</span>
        <span class="c1"># correction.</span>
        <span class="n">snr_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_median_snr</span><span class="p">(</span><span class="n">diag_phase_results</span><span class="p">)</span>

        <span class="c1"># Do the decoherence assessment</span>
        <span class="n">phaserms_results</span><span class="p">,</span> <span class="n">phaserms_cycletime</span><span class="p">,</span> <span class="n">phaserms_totaltime</span><span class="p">,</span> <span class="n">phaserms_antout</span> \
            <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_do_decoherence_assessment</span><span class="p">()</span>

        <span class="c1"># Create the results object.</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">SpwPhaseupResults</span><span class="p">(</span><span class="n">vis</span><span class="o">=</span><span class="n">inputs</span><span class="o">.</span><span class="n">vis</span><span class="p">,</span> <span class="n">phasecal_mapping</span><span class="o">=</span><span class="n">phasecal_mapping</span><span class="p">,</span> <span class="n">phaseup_result</span><span class="o">=</span><span class="n">phaseupresult</span><span class="p">,</span>
                                   <span class="n">snr_info</span><span class="o">=</span><span class="n">snr_info</span><span class="p">,</span> <span class="n">spwmaps</span><span class="o">=</span><span class="n">spwmaps</span><span class="p">,</span> <span class="n">unregister_existing</span><span class="o">=</span><span class="n">inputs</span><span class="o">.</span><span class="n">unregister_existing</span><span class="p">,</span>
                                   <span class="n">phaserms_totaltime</span><span class="o">=</span><span class="n">phaserms_totaltime</span><span class="p">,</span> <span class="n">phaserms_cycletime</span><span class="o">=</span><span class="n">phaserms_cycletime</span><span class="p">,</span>
                                   <span class="n">phaserms_results</span><span class="o">=</span><span class="n">phaserms_results</span><span class="p">,</span> <span class="n">phaserms_antout</span><span class="o">=</span><span class="n">phaserms_antout</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="SpwPhaseup.analyse">
<a class="viewcode-back" href="../../../../../_automodapi/pipeline.hifa.tasks.SpwPhaseup.html#pipeline.hifa.tasks.SpwPhaseup.analyse">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">analyse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="p">):</span>
        <span class="c1"># The caltable portion of the result is treated as if it were any other</span>
        <span class="c1"># calibration result. With no best caltable to find, our task is simply</span>
        <span class="c1"># to set the one caltable as the best result.</span>

        <span class="c1"># double-check that the caltable was actually generated</span>
        <span class="n">on_disk</span> <span class="o">=</span> <span class="p">[</span><span class="n">ca</span> <span class="k">for</span> <span class="n">ca</span> <span class="ow">in</span> <span class="n">result</span><span class="o">.</span><span class="n">phaseup_result</span><span class="o">.</span><span class="n">pool</span> <span class="k">if</span> <span class="n">ca</span><span class="o">.</span><span class="n">exists</span><span class="p">()]</span>
        <span class="n">result</span><span class="o">.</span><span class="n">phaseup_result</span><span class="o">.</span><span class="n">final</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">on_disk</span>

        <span class="n">missing</span> <span class="o">=</span> <span class="p">[</span><span class="n">ca</span> <span class="k">for</span> <span class="n">ca</span> <span class="ow">in</span> <span class="n">result</span><span class="o">.</span><span class="n">phaseup_result</span><span class="o">.</span><span class="n">pool</span> <span class="k">if</span> <span class="n">ca</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">on_disk</span><span class="p">]</span>
        <span class="n">result</span><span class="o">.</span><span class="n">phaseup_result</span><span class="o">.</span><span class="n">error</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="n">result</span><span class="o">.</span><span class="n">phaseup_result</span><span class="o">.</span><span class="n">error</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">missing</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">result</span></div>


    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_derive_phase_to_target_check_mapping</span><span class="p">(</span><span class="n">ms</span><span class="p">:</span> <span class="n">MeasurementSet</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Set</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Derive mapping between PHASE calibrator fields (by name) and</span>
<span class="sd">        corresponding fields (by name) with TARGET / CHECK intent that these</span>
<span class="sd">        PHASE calibrators should calibrate.</span>

<span class="sd">        PIPE-1154: This heuristic is intended for ALMA observing, and assumes</span>
<span class="sd">        that the first scan of a TARGET / CHECK field is always preceded by a</span>
<span class="sd">        scan of the corresponding PHASE calibrator. This method further assumes</span>
<span class="sd">        that scan IDs increase sequentially with observing time.</span>

<span class="sd">        Args:</span>
<span class="sd">            ms: MeasurementSet to derive mapping for.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Dictionary of PHASE field names (key) and set of names of</span>
<span class="sd">            corresponding TARGET/CHECK fields (value).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get the PHASE field names.</span>
        <span class="n">phase_fields</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">ms</span><span class="o">.</span><span class="n">get_fields</span><span class="p">(</span><span class="n">intent</span><span class="o">=</span><span class="s1">&#39;PHASE&#39;</span><span class="p">)]</span>

        <span class="c1"># Initialize the mapping for each PHASE calibrator field.</span>
        <span class="n">mapping</span> <span class="o">=</span> <span class="p">{</span><span class="n">f</span><span class="p">:</span> <span class="nb">set</span><span class="p">()</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">phase_fields</span><span class="p">}</span>

        <span class="c1"># Get IDs of PHASE intent scans.</span>
        <span class="n">phase_scan_ids</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">id</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">ms</span><span class="o">.</span><span class="n">get_scans</span><span class="p">(</span><span class="n">scan_intent</span><span class="o">=</span><span class="s1">&#39;PHASE&#39;</span><span class="p">)]</span>

        <span class="k">for</span> <span class="n">intent</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;CHECK&#39;</span><span class="p">,</span> <span class="s1">&#39;TARGET&#39;</span><span class="p">]:</span>
            <span class="c1"># Get field names for current intent.</span>
            <span class="n">fields</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">ms</span><span class="o">.</span><span class="n">get_fields</span><span class="p">(</span><span class="n">intent</span><span class="o">=</span><span class="n">intent</span><span class="p">)]</span>

            <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">fields</span><span class="p">:</span>
                <span class="c1"># Get ID of first scan for current field with current intent.</span>
                <span class="n">first_scan_id</span> <span class="o">=</span> <span class="n">ms</span><span class="o">.</span><span class="n">get_scans</span><span class="p">(</span><span class="n">field</span><span class="o">=</span><span class="n">field</span><span class="p">,</span> <span class="n">scan_intent</span><span class="o">=</span><span class="n">intent</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">id</span>

                <span class="c1"># PIPE-1154: in standard ALMA observing, each first scan of a</span>
                <span class="c1"># field with TARGET or CHECK intent should be preceded by a</span>
                <span class="c1"># scan of its corresponding PHASE calibrator.</span>
                <span class="c1"># Identify PHASE intent scans that preceded the first scan.</span>
                <span class="n">preceding_phase_scan_ids</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">phase_scan_ids</span> <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">first_scan_id</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">preceding_phase_scan_ids</span><span class="p">:</span>
                    <span class="c1"># Pick nearest in time PHASE intent scan as the match, and</span>
                    <span class="c1"># identify name of corresponding field.</span>
                    <span class="n">matching_phase_scan_id</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">preceding_phase_scan_ids</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Identify PHASE intent scans that followed the first scan.</span>
                    <span class="n">following_phase_scan_ids</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">phase_scan_ids</span> <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">first_scan_id</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">following_phase_scan_ids</span><span class="p">:</span>
                        <span class="c1"># As a fall-back, pick nearest in time PHASE intent</span>
                        <span class="c1"># scan after first field scan, but raise warning.</span>
                        <span class="n">matching_phase_scan_id</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">following_phase_scan_ids</span><span class="p">)</span>
                        <span class="n">LOG</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ms</span><span class="o">.</span><span class="n">basename</span><span class="si">}</span><span class="s2">: no PHASE scans found prior to the first scan for field </span><span class="si">{</span><span class="n">field</span><span class="si">}</span><span class="s2">&quot;</span>
                                    <span class="sa">f</span><span class="s2">&quot; (</span><span class="si">{</span><span class="n">intent</span><span class="si">}</span><span class="s2">), will match nearest PHASE scan that was taken after.&quot;</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">matching_phase_scan_id</span> <span class="o">=</span> <span class="kc">None</span>
                        <span class="n">LOG</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ms</span><span class="o">.</span><span class="n">basename</span><span class="si">}</span><span class="s2">: no PHASE scans found prior or after first scan for field </span><span class="si">{</span><span class="n">field</span><span class="si">}</span><span class="s2">&quot;</span>
                                    <span class="sa">f</span><span class="s2">&quot; (</span><span class="si">{</span><span class="n">intent</span><span class="si">}</span><span class="s2">).&quot;</span><span class="p">)</span>

                <span class="c1"># If a matching PHASE scan was found, then update mapping to</span>
                <span class="c1"># link the corresponding PHASE field to current field.</span>
                <span class="k">if</span> <span class="n">matching_phase_scan_id</span><span class="p">:</span>
                    <span class="n">matching_phase_field</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">ms</span><span class="o">.</span><span class="n">get_scans</span><span class="p">(</span><span class="n">scan_id</span><span class="o">=</span><span class="n">matching_phase_scan_id</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">fields</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">mapping</span><span class="p">[</span><span class="n">matching_phase_field</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">field</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">mapping</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_derive_spwmaps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spwmap_intents</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">exclude_intents</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="n">IntentField</span><span class="p">,</span> <span class="n">SpwMapping</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute separate optimal spectral window mapping for each field</span>
<span class="sd">        covering one of the intents specified by &quot;spwmap_intents&quot;, unless the</span>
<span class="sd">        field is already covered by a calibrator intent specified in</span>
<span class="sd">        &quot;exclude_intents&quot;.</span>

<span class="sd">        Args:</span>
<span class="sd">            spwmap_intents: intents to derive separate SpW mappings for.</span>
<span class="sd">            exclude_intents: do not derive separate SpW mappings for fields</span>
<span class="sd">                that also cover any of these calibrator intents.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Dictionary with (Intent, Field) combinations as keys and</span>
<span class="sd">            corresponding spectral window mapping as values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Simplify the inputs</span>
        <span class="n">inputs</span><span class="p">:</span> <span class="n">SpwPhaseupInputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span>

        <span class="c1"># Report which spw mapping heuristics mode is being used.</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The spw mapping mode for </span><span class="si">{</span><span class="n">inputs</span><span class="o">.</span><span class="n">ms</span><span class="o">.</span><span class="n">basename</span><span class="si">}</span><span class="s2"> is </span><span class="se">\&quot;</span><span class="si">{</span><span class="n">inputs</span><span class="o">.</span><span class="n">hm_spwmapmode</span><span class="si">}</span><span class="se">\&quot;</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Initialize collection of spectral window maps and corresponding</span>
        <span class="c1"># SNR info.</span>
        <span class="n">spwmaps</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># Identify the combinations of intent and fields for which to derive a</span>
        <span class="c1"># separate spwmap.</span>
        <span class="n">intent_field_to_assess</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_intent_field</span><span class="p">(</span><span class="n">inputs</span><span class="o">.</span><span class="n">ms</span><span class="p">,</span> <span class="n">intents</span><span class="o">=</span><span class="n">spwmap_intents</span><span class="p">,</span>
                                                        <span class="n">exclude_intents</span><span class="o">=</span><span class="n">exclude_intents</span><span class="p">)</span>

        <span class="c1"># Run derivation of spwmap for each intent, field combination.</span>
        <span class="k">for</span> <span class="n">intent</span><span class="p">,</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">intent_field_to_assess</span><span class="p">:</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Deriving optimal spw mapping for </span><span class="si">{</span><span class="n">inputs</span><span class="o">.</span><span class="n">ms</span><span class="o">.</span><span class="n">basename</span><span class="si">}</span><span class="s1">, intent=</span><span class="si">{</span><span class="n">intent</span><span class="si">}</span><span class="s1">, field=</span><span class="si">{</span><span class="n">field</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">spwmaps</span><span class="p">[</span><span class="n">IntentField</span><span class="p">(</span><span class="n">intent</span><span class="p">,</span> <span class="n">field</span><span class="p">)]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_derive_spwmap_for_intent_field</span><span class="p">(</span><span class="n">intent</span><span class="p">,</span> <span class="n">field</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">spwmaps</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_derive_spwmap_for_intent_field</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">intent</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">field</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SpwMapping</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Derive optimal spectral window mapping for specified intent and field.</span>

<span class="sd">        Args:</span>
<span class="sd">            intent: intent for which to derive SpW mapping.</span>
<span class="sd">            field: field for which to derive SpW mapping.</span>

<span class="sd">        Returns:</span>
<span class="sd">            SpwMapping object, representing the spectral window mapping.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Simplify the inputs</span>
        <span class="n">inputs</span><span class="p">:</span> <span class="n">SpwPhaseupInputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span>
        <span class="n">quanta</span> <span class="o">=</span> <span class="n">casa_tools</span><span class="o">.</span><span class="n">quanta</span>

        <span class="c1"># PIPE-2499: restrict analysis to the science SpWs for current intent.</span>
        <span class="n">spws</span> <span class="o">=</span> <span class="n">inputs</span><span class="o">.</span><span class="n">ms</span><span class="o">.</span><span class="n">get_spectral_windows</span><span class="p">(</span><span class="n">task_arg</span><span class="o">=</span><span class="n">inputs</span><span class="o">.</span><span class="n">spw</span><span class="p">,</span> <span class="n">intent</span><span class="o">=</span><span class="n">intent</span><span class="p">)</span>

        <span class="c1"># Initialize default values for some of the task outputs, that may not</span>
        <span class="c1"># get updated further down depending on path through heuristics.</span>
        <span class="n">solint</span> <span class="o">=</span> <span class="s1">&#39;int&#39;</span>
        <span class="n">gaintype</span> <span class="o">=</span> <span class="s1">&#39;G&#39;</span>
        <span class="n">combine</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">spwmap</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># i.e. each SpW is mapped to itself.</span>
        <span class="c1"># SNR tests are omitted for &#39;simple&#39; or &#39;default&#39; mapping, so populate a</span>
        <span class="c1"># default SNRTestResult instance to provide a common interface for methods calls</span>
        <span class="c1"># that operate on instances and instance properties</span>
        <span class="n">snr_test_result</span> <span class="o">=</span> <span class="n">SNRTestResult</span><span class="p">()</span>
        <span class="c1"># snr_test_result will be modified in place, so create another instance to hold</span>
        <span class="c1"># catalogue SNRs</span>
        <span class="n">calc_snr_result</span> <span class="o">=</span> <span class="n">SNRTestResult</span><span class="p">()</span>
        <span class="c1"># The list of combined SpW SNRs is empty; only updated if SpW</span>
        <span class="c1"># combination is necessary; needed for SNR info shown in task weblog.</span>
        <span class="n">combined_snrs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">calc_combined_snrs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># By default, set the SNR-threshold-used based on intent. Within this</span>
        <span class="c1"># task, this threshold is only used (and can be further tweaked) if an</span>
        <span class="c1"># SNR-based optimal solint gets computed. But even if the latter does</span>
        <span class="c1"># not happen (for example because the SNR test returns no results, so no</span>
        <span class="c1"># SNR-based solint can be computed), this default threshold is still</span>
        <span class="c1"># used in QA scoring and reported in the task weblog.</span>
        <span class="n">snr_thr_used</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_snr_limit_for_intent</span><span class="p">(</span><span class="n">intent</span><span class="p">)</span>

        <span class="c1"># PIPE-1436: if there is only one SpW, then no SpW re-mapping can be</span>
        <span class="c1"># done. In this case, just run the SNR test, and compute an optimal</span>
        <span class="c1"># solint and gaintype if SNRs are available (PIPE-2499).</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">spws</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">inputs</span><span class="o">.</span><span class="n">ms</span><span class="o">.</span><span class="n">basename</span><span class="si">}</span><span class="s2">, intent=</span><span class="si">{</span><span class="n">intent</span><span class="si">}</span><span class="s2">, field=</span><span class="si">{</span><span class="n">field</span><span class="si">}</span><span class="s2">: only 1 science SpW found, so using&quot;</span>
                     <span class="sa">f</span><span class="s2">&quot; standard SpW map for this data selection.&quot;</span><span class="p">)</span>

            <span class="c1"># Run a task to estimate the gaincal SNR for given intent, field,</span>
            <span class="c1"># and spectral windows.</span>
            <span class="n">snr_test_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_do_snrtest</span><span class="p">(</span><span class="n">intent</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">spws</span><span class="p">)</span>
            <span class="n">calc_snr_result</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">snr_test_result</span><span class="p">)</span>

            <span class="c1"># Additionally, compute the SNRs empirically using a gain caltable</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_compute_snr_from_gaincal</span><span class="p">(</span><span class="n">snr_test_result</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">intent</span><span class="p">)</span>

            <span class="c1"># No SNR estimates available, so stick with default values.</span>
            <span class="k">if</span> <span class="n">snr_test_result</span><span class="o">.</span><span class="n">has_no_snrs</span><span class="p">:</span>
                <span class="n">LOG</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">inputs</span><span class="o">.</span><span class="n">ms</span><span class="o">.</span><span class="n">basename</span><span class="si">}</span><span class="s2">, intent=</span><span class="si">{</span><span class="n">intent</span><span class="si">}</span><span class="s2">, field=</span><span class="si">{</span><span class="n">field</span><span class="si">}</span><span class="s2">: no SNR estimates for any SpWs,&quot;</span>
                            <span class="sa">f</span><span class="s2">&quot; setting gaincal solint to </span><span class="si">{</span><span class="n">solint</span><span class="si">}</span><span class="s2"> and gaintype to </span><span class="si">{</span><span class="n">gaintype</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Compute the optimal solint and gaintype based on estimated SNR.</span>
                <span class="n">solint</span><span class="p">,</span> <span class="n">gaintype</span><span class="p">,</span> <span class="n">snr_thr_used</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_solint</span><span class="p">(</span>
                    <span class="n">spwids</span><span class="o">=</span><span class="n">snr_test_result</span><span class="o">.</span><span class="n">spw_ids</span><span class="p">,</span>
                    <span class="n">snrs</span><span class="o">=</span><span class="n">snr_test_result</span><span class="o">.</span><span class="n">snr_values</span><span class="p">,</span>
                    <span class="n">ref_times</span><span class="o">=</span><span class="n">snr_test_result</span><span class="o">.</span><span class="n">reference_times</span><span class="p">,</span>
                    <span class="n">int_times</span><span class="o">=</span><span class="n">snr_test_result</span><span class="o">.</span><span class="n">integration_times</span><span class="p">,</span>
                    <span class="n">intent</span><span class="o">=</span><span class="n">intent</span><span class="p">,</span>
                    <span class="n">mappingmode</span><span class="o">=</span><span class="s1">&#39;single&#39;</span>
                <span class="p">)</span>

        <span class="c1"># If there are multiple SpWs, then continue with computing the SpW</span>
        <span class="c1"># optimal map according to the rules defined by each mapping mode.</span>
        <span class="c1">#</span>
        <span class="c1"># PIPE-2499: for the &quot;hm_spwmapmode=auto&quot; spw mapping mode (default),</span>
        <span class="c1"># run the SNR test and use the outcome to decide on optimal values for</span>
        <span class="c1"># spw mapping, solint, gaintype, and combine.</span>
        <span class="k">elif</span> <span class="n">inputs</span><span class="o">.</span><span class="n">hm_spwmapmode</span> <span class="o">==</span> <span class="s1">&#39;auto&#39;</span><span class="p">:</span>
            <span class="c1"># Run a task to estimate the gaincal SNR for given intent, field,</span>
            <span class="c1"># and spectral windows.</span>
            <span class="n">snr_test_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_do_snrtest</span><span class="p">(</span><span class="n">intent</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">spws</span><span class="p">)</span>
            <span class="n">calc_snr_result</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">snr_test_result</span><span class="p">)</span>

            <span class="c1"># Additionally, compute the SNRs empirically using a gain caltable</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_compute_snr_from_gaincal</span><span class="p">(</span><span class="n">snr_test_result</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">intent</span><span class="p">)</span>

            <span class="c1"># PIPE-2499: set SNR limit to use in the derivation of any</span>
            <span class="c1"># subsequent SNR-based narrow-to-wide SpW mapping.</span>
            <span class="n">snrlimit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_snr_limit_for_intent</span><span class="p">(</span><span class="n">intent</span><span class="p">)</span>

            <span class="c1"># No SNR estimates available, default to simple narrow-to-wide SpW</span>
            <span class="c1"># mapping and stick to default values.</span>
            <span class="k">if</span> <span class="n">snr_test_result</span><span class="o">.</span><span class="n">has_no_snrs</span><span class="p">:</span>
                <span class="n">spwmap</span> <span class="o">=</span> <span class="n">simple_n2wspwmap</span><span class="p">(</span><span class="n">spws</span><span class="p">,</span> <span class="n">inputs</span><span class="o">.</span><span class="n">maxnarrowbw</span><span class="p">,</span> <span class="n">inputs</span><span class="o">.</span><span class="n">minfracmaxbw</span><span class="p">,</span> <span class="n">inputs</span><span class="o">.</span><span class="n">samebb</span><span class="p">)</span>
                <span class="n">LOG</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">inputs</span><span class="o">.</span><span class="n">ms</span><span class="o">.</span><span class="n">basename</span><span class="si">}</span><span class="s2">, intent=</span><span class="si">{</span><span class="n">intent</span><span class="si">}</span><span class="s2">, field=</span><span class="si">{</span><span class="n">field</span><span class="si">}</span><span class="s2">: no SNR estimates available for&quot;</span>
                            <span class="sa">f</span><span class="s2">&quot; any SpWs, will force simple narrow-to-wide spw mapping </span><span class="si">{</span><span class="n">spwmap</span><span class="si">}</span><span class="s2">, with solint=</span><span class="si">{</span><span class="n">solint</span><span class="si">}</span><span class="s2">&quot;</span>
                            <span class="sa">f</span><span class="s2">&quot; and gaintype=</span><span class="si">{</span><span class="n">gaintype</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>

            <span class="c1"># PIPE-2499: all SpWs have good SNR estimates: in this case, check</span>
            <span class="c1"># whether the optimal solint is &#39;int&#39; and if so use that + the</span>
            <span class="c1"># standard (empty) SpW mapping (i.e. each SpW mapped to itself).</span>
            <span class="k">elif</span> <span class="n">snr_test_result</span><span class="o">.</span><span class="n">has_all_snrs_greater_than</span><span class="p">(</span><span class="n">snrlimit</span><span class="p">):</span>
                <span class="c1"># Compute the optimal solint and gaintype based on estimated</span>
                <span class="c1"># SNR, while assuming no SpW-remapping mode.</span>
                <span class="n">solint</span><span class="p">,</span> <span class="n">gaintype</span><span class="p">,</span> <span class="n">snr_thr_used</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_solint</span><span class="p">(</span>
                    <span class="n">spwids</span><span class="o">=</span><span class="n">snr_test_result</span><span class="o">.</span><span class="n">spw_ids</span><span class="p">,</span>
                    <span class="n">snrs</span><span class="o">=</span><span class="n">snr_test_result</span><span class="o">.</span><span class="n">snr_values</span><span class="p">,</span>
                    <span class="n">ref_times</span><span class="o">=</span><span class="n">snr_test_result</span><span class="o">.</span><span class="n">reference_times</span><span class="p">,</span>
                    <span class="n">int_times</span><span class="o">=</span><span class="n">snr_test_result</span><span class="o">.</span><span class="n">integration_times</span><span class="p">,</span>
                    <span class="n">intent</span><span class="o">=</span><span class="n">intent</span><span class="p">,</span>
                    <span class="n">mappingmode</span><span class="o">=</span><span class="s1">&#39;single&#39;</span>
                <span class="p">)</span>

                <span class="c1"># If the optimal solint is &#39;int&#39;, then proceed with this, and</span>
                <span class="c1"># the default of no SpW mapping.</span>
                <span class="k">if</span> <span class="n">solint</span> <span class="o">==</span> <span class="s1">&#39;int&#39;</span><span class="p">:</span>
                    <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">inputs</span><span class="o">.</span><span class="n">ms</span><span class="o">.</span><span class="n">basename</span><span class="si">}</span><span class="s2">, intent=</span><span class="si">{</span><span class="n">intent</span><span class="si">}</span><span class="s2">, field=</span><span class="si">{</span><span class="n">field</span><span class="si">}</span><span class="s2">: high SNR estimates found for all&quot;</span>
                             <span class="sa">f</span><span class="s2">&quot; spws and optimal solint=&#39;int&#39;, so will use default spw mapping </span><span class="si">{</span><span class="n">spwmap</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
                <span class="c1"># If the optimal solint is higher than &#39;int&#39;, then first</span>
                <span class="c1"># consider using SpW re-mapping after all, as SpW mapping is</span>
                <span class="c1"># preferable over time averaging. First check whether a simple</span>
                <span class="c1"># narrow-to-side SpW mapping with a customized SNR limit (based</span>
                <span class="c1"># on optimal solint) would result in a good mapping; if so, use</span>
                <span class="c1"># that, otherwise use SpW combination (and re-compute the</span>
                <span class="c1"># optimal solint in both outcomes).</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">inputs</span><span class="o">.</span><span class="n">ms</span><span class="o">.</span><span class="n">basename</span><span class="si">}</span><span class="s2">, intent=</span><span class="si">{</span><span class="n">intent</span><span class="si">}</span><span class="s2">, field=</span><span class="si">{</span><span class="n">field</span><span class="si">}</span><span class="s2">: high SNR estimates found for all&quot;</span>
                             <span class="sa">f</span><span class="s2">&quot; spws, but optimal solint is larger than &#39;int&#39;, so will consider spw mapping or&quot;</span>
                             <span class="sa">f</span><span class="s2">&quot; combination.&quot;</span><span class="p">)</span>

                    <span class="c1"># Scale the SNR limit based on the optimal solint and the</span>
                    <span class="c1"># integration time (converted to seconds).</span>
                    <span class="n">integration_time_in_secs</span> <span class="o">=</span> <span class="n">snr_test_result</span><span class="o">.</span><span class="n">integration_times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mf">60.0</span>
                    <span class="n">snrlimit_scaled</span> <span class="o">=</span> <span class="n">snrlimit</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">quanta</span><span class="o">.</span><span class="n">quantity</span><span class="p">(</span><span class="n">solint</span><span class="p">)[</span><span class="s1">&#39;value&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="n">integration_time_in_secs</span><span class="p">)</span>

                    <span class="c1"># Compute an SNR-based narrow-to-wide SpW mapping with the</span>
                    <span class="c1"># scaled SNR limit.</span>
                    <span class="n">goodmap</span><span class="p">,</span> <span class="n">spwmap</span> <span class="o">=</span> <span class="n">snr_n2wspwmap</span><span class="p">(</span><span class="n">spws</span><span class="p">,</span> <span class="n">snr_test_result</span><span class="o">.</span><span class="n">snr_values</span><span class="p">,</span> <span class="n">snrlimit_scaled</span><span class="p">)</span>

                    <span class="c1"># If the SNR-based mapping with the new SNR limit gave a</span>
                    <span class="c1"># good match for all spws, then proceed to use this, and</span>
                    <span class="c1"># re-compute the optimal solint and gaintype assuming the</span>
                    <span class="c1"># &quot;mapping&quot; mode.</span>
                    <span class="k">if</span> <span class="n">goodmap</span><span class="p">:</span>
                        <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">inputs</span><span class="o">.</span><span class="n">ms</span><span class="o">.</span><span class="n">basename</span><span class="si">}</span><span class="s2">, intent=</span><span class="si">{</span><span class="n">intent</span><span class="si">}</span><span class="s2">, field=</span><span class="si">{</span><span class="n">field</span><span class="si">}</span><span class="s2">: found good match for all spws&quot;</span>
                                 <span class="sa">f</span><span class="s2">&quot; using spw map </span><span class="si">{</span><span class="n">spwmap</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
                        <span class="n">solint</span><span class="p">,</span> <span class="n">gaintype</span><span class="p">,</span> <span class="n">snr_thr_used</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_solint</span><span class="p">(</span>
                            <span class="n">spwids</span><span class="o">=</span><span class="n">snr_test_result</span><span class="o">.</span><span class="n">spw_ids</span><span class="p">,</span>
                            <span class="n">snrs</span><span class="o">=</span><span class="n">snr_test_result</span><span class="o">.</span><span class="n">snr_values</span><span class="p">,</span>
                            <span class="n">ref_times</span><span class="o">=</span><span class="n">snr_test_result</span><span class="o">.</span><span class="n">reference_times</span><span class="p">,</span>
                            <span class="n">int_times</span><span class="o">=</span><span class="n">snr_test_result</span><span class="o">.</span><span class="n">integration_times</span><span class="p">,</span>
                            <span class="n">intent</span><span class="o">=</span><span class="n">intent</span><span class="p">,</span>
                            <span class="n">mappingmode</span><span class="o">=</span><span class="s1">&#39;mapping&#39;</span>
                        <span class="p">)</span>

                    <span class="c1"># Otherwise, proceed with SpW combination instead of SpW</span>
                    <span class="c1"># mapping, and re-compute the optimal solint and gaintype</span>
                    <span class="c1"># assuming &quot;combine&quot; mode.</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">LOG</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">inputs</span><span class="o">.</span><span class="n">ms</span><span class="o">.</span><span class="n">basename</span><span class="si">}</span><span class="s2">, intent=</span><span class="si">{</span><span class="n">intent</span><span class="si">}</span><span class="s2">, field=</span><span class="si">{</span><span class="n">field</span><span class="si">}</span><span class="s2">: unable to find good match&quot;</span>
                                    <span class="sa">f</span><span class="s2">&quot; for all spws using spw mapping, so will force combined spw mapping.&quot;</span><span class="p">)</span>

                        <span class="c1"># Create a spw mapping for combining spws.</span>
                        <span class="n">spwmap</span> <span class="o">=</span> <span class="n">combine_spwmap</span><span class="p">(</span><span class="n">spws</span><span class="p">)</span>
                        <span class="n">combine</span> <span class="o">=</span> <span class="kc">True</span>

                        <span class="c1"># Re-compute the optimal solint and gaintype based on</span>
                        <span class="c1"># estimated SNR, while assuming SpW combination mode,</span>
                        <span class="c1"># and compute the expected combined SpW SNRs.</span>
                        <span class="n">solint</span><span class="p">,</span> <span class="n">gaintype</span><span class="p">,</span> <span class="n">snr_thr_used</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_solint</span><span class="p">(</span>
                            <span class="n">spwids</span><span class="o">=</span><span class="n">snr_test_result</span><span class="o">.</span><span class="n">spw_ids</span><span class="p">,</span>
                            <span class="n">snrs</span><span class="o">=</span><span class="n">snr_test_result</span><span class="o">.</span><span class="n">snr_values</span><span class="p">,</span>
                            <span class="n">ref_times</span><span class="o">=</span><span class="n">snr_test_result</span><span class="o">.</span><span class="n">reference_times</span><span class="p">,</span>
                            <span class="n">int_times</span><span class="o">=</span><span class="n">snr_test_result</span><span class="o">.</span><span class="n">integration_times</span><span class="p">,</span>
                            <span class="n">intent</span><span class="o">=</span><span class="n">intent</span><span class="p">,</span>
                            <span class="n">mappingmode</span><span class="o">=</span><span class="s1">&#39;combine&#39;</span>
                        <span class="p">)</span>
                        <span class="n">combined_snrs</span><span class="p">,</span> <span class="n">calc_combined_snrs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_combined_snrs</span><span class="p">(</span>
                            <span class="n">snr_test_result</span><span class="p">,</span>
                            <span class="n">calc_snr_result</span><span class="p">,</span>
                            <span class="n">spwmap</span>
                        <span class="p">)</span>

            <span class="c1"># No spws have good SNR values, so force combined spw mapping.</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">snr_test_result</span><span class="o">.</span><span class="n">is_good_snr</span><span class="p">):</span>
                <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">inputs</span><span class="o">.</span><span class="n">ms</span><span class="o">.</span><span class="n">basename</span><span class="si">}</span><span class="s2">, intent=</span><span class="si">{</span><span class="n">intent</span><span class="si">}</span><span class="s2">, field=</span><span class="si">{</span><span class="n">field</span><span class="si">}</span><span class="s2">: no spws have good enough SNR, so will&quot;</span>
                         <span class="sa">f</span><span class="s2">&quot; force combined spw mapping.&quot;</span><span class="p">)</span>

                <span class="c1"># Report spws for which no SNR estimate was available.</span>
                <span class="k">if</span> <span class="kc">None</span> <span class="ow">in</span> <span class="n">snr_test_result</span><span class="o">.</span><span class="n">is_good_snr</span><span class="p">:</span>
                    <span class="n">LOG</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">inputs</span><span class="o">.</span><span class="n">ms</span><span class="o">.</span><span class="n">basename</span><span class="si">}</span><span class="s2">, intent=</span><span class="si">{</span><span class="n">intent</span><span class="si">}</span><span class="s2">, field=</span><span class="si">{</span><span class="n">field</span><span class="si">}</span><span class="s2">: spws without SNR measurements &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="p">[</span><span class="n">spwid</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">spwid</span><span class="p">,</span><span class="w"> </span><span class="n">goodsnr</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="nb">zip</span><span class="p">(</span><span class="n">snr_test_result</span><span class="o">.</span><span class="n">spw_ids</span><span class="p">,</span><span class="w"> </span><span class="n">snr_test_result</span><span class="o">.</span><span class="n">is_good_snr</span><span class="p">)</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">goodsnr</span><span class="w"> </span><span class="ow">is</span><span class="w"> </span><span class="kc">None</span><span class="p">]</span><span class="si">}</span><span class="s2">.&quot;</span>
                    <span class="p">)</span>

                <span class="c1"># Create a spw mapping for combining spws.</span>
                <span class="n">spwmap</span> <span class="o">=</span> <span class="n">combine_spwmap</span><span class="p">(</span><span class="n">spws</span><span class="p">)</span>
                <span class="n">combine</span> <span class="o">=</span> <span class="kc">True</span>

                <span class="c1"># Re-compute the optimal solint and gaintype based on estimated</span>
                <span class="c1"># SNR, while assuming SpW combination mode, and compute the</span>
                <span class="c1"># expected combined SpW SNRs.</span>
                <span class="n">solint</span><span class="p">,</span> <span class="n">gaintype</span><span class="p">,</span> <span class="n">snr_thr_used</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_solint</span><span class="p">(</span>
                    <span class="n">spwids</span><span class="o">=</span><span class="n">snr_test_result</span><span class="o">.</span><span class="n">spw_ids</span><span class="p">,</span>
                    <span class="n">snrs</span><span class="o">=</span><span class="n">snr_test_result</span><span class="o">.</span><span class="n">snr_values</span><span class="p">,</span>
                    <span class="n">ref_times</span><span class="o">=</span><span class="n">snr_test_result</span><span class="o">.</span><span class="n">reference_times</span><span class="p">,</span>
                    <span class="n">int_times</span><span class="o">=</span><span class="n">snr_test_result</span><span class="o">.</span><span class="n">integration_times</span><span class="p">,</span>
                    <span class="n">intent</span><span class="o">=</span><span class="n">intent</span><span class="p">,</span>
                    <span class="n">mappingmode</span><span class="o">=</span><span class="s1">&#39;combine&#39;</span>
                <span class="p">)</span>
                <span class="n">combined_snrs</span><span class="p">,</span> <span class="n">calc_combined_snrs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_combined_snrs</span><span class="p">(</span>
                    <span class="n">snr_test_result</span><span class="p">,</span>
                    <span class="n">calc_snr_result</span><span class="p">,</span>
                    <span class="n">spwmap</span>
                <span class="p">)</span>

            <span class="c1"># If some, but not all, spws have good SNR values, then try to use</span>
            <span class="c1"># an SNR-based approach first, but fall back to combined spw mapping</span>
            <span class="c1"># if necessary.</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">inputs</span><span class="o">.</span><span class="n">ms</span><span class="o">.</span><span class="n">basename</span><span class="si">}</span><span class="s2">, intent=</span><span class="si">{</span><span class="n">intent</span><span class="si">}</span><span class="s2">, field=</span><span class="si">{</span><span class="n">field</span><span class="si">}</span><span class="s2">: some spws have low SNR, so will&quot;</span>
                         <span class="sa">f</span><span class="s2">&quot; consider spw mapping or combination.&quot;</span><span class="p">)</span>

                <span class="c1"># Report spws for which no SNR estimate was available.</span>
                <span class="k">if</span> <span class="kc">None</span> <span class="ow">in</span> <span class="n">snr_test_result</span><span class="o">.</span><span class="n">is_good_snr</span><span class="p">:</span>
                    <span class="n">LOG</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">inputs</span><span class="o">.</span><span class="n">ms</span><span class="o">.</span><span class="n">basename</span><span class="si">}</span><span class="s2">, intent=</span><span class="si">{</span><span class="n">intent</span><span class="si">}</span><span class="s2">, field=</span><span class="si">{</span><span class="n">field</span><span class="si">}</span><span class="s2">: spws without SNR measurements &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="p">[</span><span class="n">spwid</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">spwid</span><span class="p">,</span><span class="w"> </span><span class="n">goodsnr</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="nb">zip</span><span class="p">(</span><span class="n">snr_test_result</span><span class="o">.</span><span class="n">spw_ids</span><span class="p">,</span><span class="w"> </span><span class="n">snr_test_result</span><span class="o">.</span><span class="n">is_good_snr</span><span class="p">)</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">goodsnr</span><span class="w"> </span><span class="ow">is</span><span class="w"> </span><span class="kc">None</span><span class="p">]</span><span class="si">}</span><span class="s2">.&quot;</span>
                    <span class="p">)</span>

                <span class="c1"># Compute the SNR-based narrow-to-wide (low-SNR to high-SNR) SpW</span>
                <span class="c1"># mapping.</span>
                <span class="n">goodmap</span><span class="p">,</span> <span class="n">spwmap</span> <span class="o">=</span> <span class="n">snr_n2wspwmap</span><span class="p">(</span><span class="n">spws</span><span class="p">,</span> <span class="n">snr_test_result</span><span class="o">.</span><span class="n">snr_values</span><span class="p">,</span> <span class="n">snrlimit</span><span class="p">)</span>

                <span class="c1"># If the SNR-based mapping gave a good match for all spws, then</span>
                <span class="c1"># proceed to use this, and re-compute the optimal solint and</span>
                <span class="c1"># gaintype assuming the &quot;mapping&quot; mode.</span>
                <span class="k">if</span> <span class="n">goodmap</span><span class="p">:</span>
                    <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Using spw map </span><span class="si">{</span><span class="n">spwmap</span><span class="si">}</span><span class="s1"> for </span><span class="si">{</span><span class="n">inputs</span><span class="o">.</span><span class="n">ms</span><span class="o">.</span><span class="n">basename</span><span class="si">}</span><span class="s1">, intent=</span><span class="si">{</span><span class="n">intent</span><span class="si">}</span><span class="s1">, field=</span><span class="si">{</span><span class="n">field</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                    <span class="n">solint</span><span class="p">,</span> <span class="n">gaintype</span><span class="p">,</span> <span class="n">snr_thr_used</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_solint</span><span class="p">(</span>
                        <span class="n">spwids</span><span class="o">=</span><span class="n">snr_test_result</span><span class="o">.</span><span class="n">spw_ids</span><span class="p">,</span>
                        <span class="n">snrs</span><span class="o">=</span><span class="n">snr_test_result</span><span class="o">.</span><span class="n">snr_values</span><span class="p">,</span>
                        <span class="n">ref_times</span><span class="o">=</span><span class="n">snr_test_result</span><span class="o">.</span><span class="n">reference_times</span><span class="p">,</span>
                        <span class="n">int_times</span><span class="o">=</span><span class="n">snr_test_result</span><span class="o">.</span><span class="n">integration_times</span><span class="p">,</span>
                        <span class="n">intent</span><span class="o">=</span><span class="n">intent</span><span class="p">,</span>
                        <span class="n">mappingmode</span><span class="o">=</span><span class="s1">&#39;mapping&#39;</span>
                    <span class="p">)</span>

                <span class="c1"># Otherwise, proceed with SpW combination instead of SpW</span>
                <span class="c1"># mapping, and re-compute the optimal solint and gaintype</span>
                <span class="c1"># assuming &quot;combine&quot; mode.</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">LOG</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">inputs</span><span class="o">.</span><span class="n">ms</span><span class="o">.</span><span class="n">basename</span><span class="si">}</span><span class="s2">, intent=</span><span class="si">{</span><span class="n">intent</span><span class="si">}</span><span class="s2">, field=</span><span class="si">{</span><span class="n">field</span><span class="si">}</span><span class="s2">: unable to find good match&quot;</span>
                                <span class="sa">f</span><span class="s2">&quot; for all spws using spw mapping, so will force combined spw mapping.&quot;</span><span class="p">)</span>

                    <span class="c1"># Create a spw mapping for combining spws.</span>
                    <span class="n">spwmap</span> <span class="o">=</span> <span class="n">combine_spwmap</span><span class="p">(</span><span class="n">spws</span><span class="p">)</span>
                    <span class="n">combine</span> <span class="o">=</span> <span class="kc">True</span>

                    <span class="c1"># Re-compute the optimal solint and gaintype based on</span>
                    <span class="c1"># estimated SNR, while assuming SpW combination mode,</span>
                    <span class="c1"># and compute the expected combined SpW SNRs.</span>
                    <span class="n">solint</span><span class="p">,</span> <span class="n">gaintype</span><span class="p">,</span> <span class="n">snr_thr_used</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_solint</span><span class="p">(</span>
                        <span class="n">spwids</span><span class="o">=</span><span class="n">snr_test_result</span><span class="o">.</span><span class="n">spw_ids</span><span class="p">,</span>
                        <span class="n">snrs</span><span class="o">=</span><span class="n">snr_test_result</span><span class="o">.</span><span class="n">snr_values</span><span class="p">,</span>
                        <span class="n">ref_times</span><span class="o">=</span><span class="n">snr_test_result</span><span class="o">.</span><span class="n">reference_times</span><span class="p">,</span>
                        <span class="n">int_times</span><span class="o">=</span><span class="n">snr_test_result</span><span class="o">.</span><span class="n">integration_times</span><span class="p">,</span>
                        <span class="n">intent</span><span class="o">=</span><span class="n">intent</span><span class="p">,</span>
                        <span class="n">mappingmode</span><span class="o">=</span><span class="s1">&#39;combine&#39;</span>
                    <span class="p">)</span>
                    <span class="n">combined_snrs</span><span class="p">,</span> <span class="n">calc_combined_snrs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_combined_snrs</span><span class="p">(</span>
                        <span class="n">snr_test_result</span><span class="p">,</span>
                        <span class="n">calc_snr_result</span><span class="p">,</span>
                        <span class="n">spwmap</span>
                    <span class="p">)</span>

        <span class="c1"># For the &quot;hm_spwmapmode=combine&quot; spw mapping mode, force the use of</span>
        <span class="c1"># SpW combination. PIPE-2499: still attempt to find optimal values for</span>
        <span class="c1"># solint and gaintype.</span>
        <span class="k">elif</span> <span class="n">inputs</span><span class="o">.</span><span class="n">hm_spwmapmode</span> <span class="o">==</span> <span class="s1">&#39;combine&#39;</span><span class="p">:</span>
            <span class="c1"># Create a spw mapping for combining spws.</span>
            <span class="n">spwmap</span> <span class="o">=</span> <span class="n">combine_spwmap</span><span class="p">(</span><span class="n">spws</span><span class="p">)</span>
            <span class="n">combine</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">inputs</span><span class="o">.</span><span class="n">ms</span><span class="o">.</span><span class="n">basename</span><span class="si">}</span><span class="s2">, intent=</span><span class="si">{</span><span class="n">intent</span><span class="si">}</span><span class="s2">, field=</span><span class="si">{</span><span class="n">field</span><span class="si">}</span><span class="s2">: using combined spw mapping </span><span class="si">{</span><span class="n">spwmap</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>

            <span class="c1"># Run a task to estimate the gaincal SNR for given intent, field,</span>
            <span class="c1"># and spectral windows.</span>
            <span class="n">snr_test_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_do_snrtest</span><span class="p">(</span><span class="n">intent</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">spws</span><span class="p">)</span>
            <span class="n">calc_snr_result</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">snr_test_result</span><span class="p">)</span>

            <span class="c1"># Additionally, compute the SNRs empirically using a gain caltable</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_compute_snr_from_gaincal</span><span class="p">(</span><span class="n">snr_test_result</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">intent</span><span class="p">)</span>

            <span class="c1"># If no SNR estimates are available then set solint based on intent.</span>
            <span class="k">if</span> <span class="n">snr_test_result</span><span class="o">.</span><span class="n">has_no_snrs</span><span class="p">:</span>
                <span class="c1"># For CHECK and PHASE intent, override the solint to a quarter</span>
                <span class="c1"># of the scan (exposure) time, and set gaintype to T.</span>
                <span class="k">if</span> <span class="n">intent</span> <span class="ow">in</span> <span class="n">WEAK_CALIBRATOR_INTENTS</span><span class="p">:</span>
                    <span class="n">integration_time_in_secs</span> <span class="o">=</span> <span class="n">snr_test_result</span><span class="o">.</span><span class="n">integration_times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mf">60.0</span>
                    <span class="n">solint</span> <span class="o">=</span> <span class="n">quanta</span><span class="o">.</span><span class="n">tos</span><span class="p">(</span><span class="n">quanta</span><span class="o">.</span><span class="n">quantity</span><span class="p">(</span><span class="n">integration_time_in_secs</span> <span class="o">/</span> <span class="mf">4.</span><span class="p">,</span> <span class="s1">&#39;s&#39;</span><span class="p">),</span> <span class="mi">3</span><span class="p">)</span>
                    <span class="n">gaintype</span> <span class="o">=</span> <span class="s2">&quot;T&quot;</span>
                    <span class="n">LOG</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">inputs</span><span class="o">.</span><span class="n">ms</span><span class="o">.</span><span class="n">basename</span><span class="si">}</span><span class="s2">, intent=</span><span class="si">{</span><span class="n">intent</span><span class="si">}</span><span class="s2">, field=</span><span class="si">{</span><span class="n">field</span><span class="si">}</span><span class="s2">: no SNR estimates available for&quot;</span>
                                <span class="sa">f</span><span class="s2">&quot; any SpWs, setting solint to 1/4 scan time and gaintype=</span><span class="si">{</span><span class="n">gaintype</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
                <span class="c1"># For all other intents, stick to the default values for solint</span>
                <span class="c1"># and gaintype.</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">LOG</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">inputs</span><span class="o">.</span><span class="n">ms</span><span class="o">.</span><span class="n">basename</span><span class="si">}</span><span class="s2">, intent=</span><span class="si">{</span><span class="n">intent</span><span class="si">}</span><span class="s2">, field=</span><span class="si">{</span><span class="n">field</span><span class="si">}</span><span class="s2">: no SNR estimates available for&quot;</span>
                                <span class="sa">f</span><span class="s2">&quot; any SpWs, setting solint=</span><span class="si">{</span><span class="n">solint</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
            <span class="c1"># Otherwise, compute the optimal solint and gaintype based on</span>
            <span class="c1"># estimated SNR assuming SpW combination mode, and compute expected</span>
            <span class="c1"># combined SpW SNRs.</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">solint</span><span class="p">,</span> <span class="n">gaintype</span><span class="p">,</span> <span class="n">snr_thr_used</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_solint</span><span class="p">(</span>
                    <span class="n">spwids</span><span class="o">=</span><span class="n">snr_test_result</span><span class="o">.</span><span class="n">spw_ids</span><span class="p">,</span>
                    <span class="n">snrs</span><span class="o">=</span><span class="n">snr_test_result</span><span class="o">.</span><span class="n">snr_values</span><span class="p">,</span>
                    <span class="n">ref_times</span><span class="o">=</span><span class="n">snr_test_result</span><span class="o">.</span><span class="n">reference_times</span><span class="p">,</span>
                    <span class="n">int_times</span><span class="o">=</span><span class="n">snr_test_result</span><span class="o">.</span><span class="n">integration_times</span><span class="p">,</span>
                    <span class="n">intent</span><span class="o">=</span><span class="n">intent</span><span class="p">,</span>
                    <span class="n">mappingmode</span><span class="o">=</span><span class="s1">&#39;combine&#39;</span>
                <span class="p">)</span>
                <span class="n">combined_snrs</span><span class="p">,</span> <span class="n">calc_combined_snrs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_combined_snrs</span><span class="p">(</span>
                    <span class="n">snr_test_result</span><span class="p">,</span>
                    <span class="n">calc_snr_result</span><span class="p">,</span>
                    <span class="n">spwmap</span>
                <span class="p">)</span>

        <span class="c1"># For the &quot;hm_spwmapmode=simple&quot; spw mapping mode, force the use of a</span>
        <span class="c1"># simple narrow-to-wide spw map.</span>
        <span class="k">elif</span> <span class="n">inputs</span><span class="o">.</span><span class="n">hm_spwmapmode</span> <span class="o">==</span> <span class="s1">&#39;simple&#39;</span><span class="p">:</span>
            <span class="n">spwmap</span> <span class="o">=</span> <span class="n">simple_n2wspwmap</span><span class="p">(</span><span class="n">spws</span><span class="p">,</span> <span class="n">inputs</span><span class="o">.</span><span class="n">maxnarrowbw</span><span class="p">,</span> <span class="n">inputs</span><span class="o">.</span><span class="n">minfracmaxbw</span><span class="p">,</span> <span class="n">inputs</span><span class="o">.</span><span class="n">samebb</span><span class="p">)</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">inputs</span><span class="o">.</span><span class="n">ms</span><span class="o">.</span><span class="n">basename</span><span class="si">}</span><span class="s2">, intent=</span><span class="si">{</span><span class="n">intent</span><span class="si">}</span><span class="s2">, field=</span><span class="si">{</span><span class="n">field</span><span class="si">}</span><span class="s2">: using simple narrow-to-wide spw mapping&quot;</span>
                     <span class="sa">f</span><span class="s2">&quot; </span><span class="si">{</span><span class="n">spwmap</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>

        <span class="c1"># Otherwise, for the remaining case of the hm_spwmapmode=&#39;default&#39;</span>
        <span class="c1"># mapping mode, force the use of a standard (no) empty spw map (i.e.</span>
        <span class="c1"># map each SpW to itself).</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">inputs</span><span class="o">.</span><span class="n">ms</span><span class="o">.</span><span class="n">basename</span><span class="si">}</span><span class="s2">, intent=</span><span class="si">{</span><span class="n">intent</span><span class="si">}</span><span class="s2">, field=</span><span class="si">{</span><span class="n">field</span><span class="si">}</span><span class="s2">: using standard SpW map </span><span class="si">{</span><span class="n">spwmap</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>

        <span class="c1"># Report final choice of solint, gaintype, combine, and spwmap.</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">inputs</span><span class="o">.</span><span class="n">ms</span><span class="o">.</span><span class="n">basename</span><span class="si">}</span><span class="s2">, intent </span><span class="si">{</span><span class="n">intent</span><span class="si">}</span><span class="s2">, field </span><span class="si">{</span><span class="n">field</span><span class="si">}</span><span class="s2">: the phase-up steps in subsequent&quot;</span>
                 <span class="sa">f</span><span class="s2">&quot; Pipeline stages will use solint=</span><span class="si">{</span><span class="n">solint</span><span class="si">}</span><span class="s2">, gaintype=</span><span class="si">{</span><span class="n">gaintype</span><span class="si">}</span><span class="s2">, combine=</span><span class="si">{</span><span class="n">combine</span><span class="si">}</span><span class="s2">, and&quot;</span>
                 <span class="sa">f</span><span class="s2">&quot; spwmap=</span><span class="si">{</span><span class="n">spwmap</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>

        <span class="c1"># PIPE-2059: for the PHASE calibrator in a BandToBand MS, adjust the</span>
        <span class="c1"># newly derived optimal SpW mapping to ensure that diffgain on-source</span>
        <span class="c1"># SpWs are remapped to an associated diffgain reference SpW.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">ms</span><span class="o">.</span><span class="n">is_band_to_band</span> <span class="ow">and</span> <span class="n">intent</span> <span class="o">==</span> <span class="s1">&#39;PHASE&#39;</span><span class="p">:</span>
            <span class="n">dg_refspws</span> <span class="o">=</span> <span class="n">inputs</span><span class="o">.</span><span class="n">ms</span><span class="o">.</span><span class="n">get_spectral_windows</span><span class="p">(</span><span class="n">task_arg</span><span class="o">=</span><span class="n">inputs</span><span class="o">.</span><span class="n">spw</span><span class="p">,</span> <span class="n">intent</span><span class="o">=</span><span class="s1">&#39;DIFFGAINREF&#39;</span><span class="p">)</span>
            <span class="n">dg_srcspws</span> <span class="o">=</span> <span class="n">inputs</span><span class="o">.</span><span class="n">ms</span><span class="o">.</span><span class="n">get_spectral_windows</span><span class="p">(</span><span class="n">task_arg</span><span class="o">=</span><span class="n">inputs</span><span class="o">.</span><span class="n">spw</span><span class="p">,</span> <span class="n">intent</span><span class="o">=</span><span class="s1">&#39;DIFFGAINSRC&#39;</span><span class="p">)</span>
            <span class="n">spwmap</span> <span class="o">=</span> <span class="n">update_spwmap_for_band_to_band</span><span class="p">(</span><span class="n">spwmap</span><span class="p">,</span> <span class="n">dg_refspws</span><span class="p">,</span> <span class="n">dg_srcspws</span><span class="p">)</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">inputs</span><span class="o">.</span><span class="n">ms</span><span class="o">.</span><span class="n">basename</span><span class="si">}</span><span class="s2">, intent </span><span class="si">{</span><span class="n">intent</span><span class="si">}</span><span class="s2">, field </span><span class="si">{</span><span class="n">field</span><span class="si">}</span><span class="s2">: this is the phase calibrator for a&quot;</span>
                     <span class="sa">f</span><span class="s2">&quot; band-to-band dataset, updated spw map to </span><span class="si">{</span><span class="n">spwmap</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>

        <span class="c1"># Collect SNR info.</span>
        <span class="n">snr_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_snr_info</span><span class="p">(</span><span class="n">snr_test_result</span><span class="p">,</span> <span class="n">combined_snrs</span><span class="p">)</span>

        <span class="c1"># transform estimated SNRs into same structure for easier handling in renderer</span>
        <span class="n">calc_snr_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_snr_info</span><span class="p">(</span><span class="n">calc_snr_result</span><span class="p">,</span> <span class="n">calc_combined_snrs</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">SpwMapping</span><span class="p">(</span><span class="n">combine</span><span class="p">,</span> <span class="n">spwmap</span><span class="p">,</span> <span class="n">snr_info</span><span class="p">,</span> <span class="n">snr_thr_used</span><span class="p">,</span> <span class="n">solint</span><span class="p">,</span> <span class="n">gaintype</span><span class="p">,</span> <span class="n">calc_snr_info</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_do_snrtest</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">intent</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">field</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">spws</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">SpectralWindow</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">SNRTestResult</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Run gaincal SNR task to perform SNR test for specified intent and</span>
<span class="sd">        field.</span>

<span class="sd">        Args:</span>
<span class="sd">            intent: intent for which to perform SNR test.</span>
<span class="sd">            field: field for which to perform SNR test.</span>
<span class="sd">            spws: list of spectral window objects for which to perform SNR test.</span>

<span class="sd">        Returns:</span>
<span class="sd">            SnrTestResult that characterises the results of the gaincal SNR test</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Simplify inputs.</span>
        <span class="n">inputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span>

        <span class="n">task_args</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;output_dir&#39;</span><span class="p">:</span> <span class="n">inputs</span><span class="o">.</span><span class="n">output_dir</span><span class="p">,</span>
            <span class="s1">&#39;vis&#39;</span><span class="p">:</span> <span class="n">inputs</span><span class="o">.</span><span class="n">vis</span><span class="p">,</span>
            <span class="s1">&#39;field&#39;</span><span class="p">:</span> <span class="n">field</span><span class="p">,</span>
            <span class="s1">&#39;intent&#39;</span><span class="p">:</span> <span class="n">intent</span><span class="p">,</span>
            <span class="s1">&#39;spw&#39;</span><span class="p">:</span> <span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">spw</span><span class="o">.</span><span class="n">id</span><span class="p">)</span> <span class="k">for</span> <span class="n">spw</span> <span class="ow">in</span> <span class="n">spws</span><span class="p">),</span>
            <span class="s1">&#39;bwedgefrac&#39;</span><span class="p">:</span> <span class="n">inputs</span><span class="o">.</span><span class="n">bwedgefrac</span><span class="p">,</span>
            <span class="s1">&#39;hm_nantennas&#39;</span><span class="p">:</span> <span class="n">inputs</span><span class="o">.</span><span class="n">hm_nantennas</span><span class="p">,</span>
            <span class="s1">&#39;maxfracflagged&#39;</span><span class="p">:</span> <span class="n">inputs</span><span class="o">.</span><span class="n">maxfracflagged</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="n">task_inputs</span> <span class="o">=</span> <span class="n">gaincalsnr</span><span class="o">.</span><span class="n">GaincalSnrInputs</span><span class="p">(</span><span class="n">inputs</span><span class="o">.</span><span class="n">context</span><span class="p">,</span> <span class="o">**</span><span class="n">task_args</span><span class="p">)</span>
        <span class="n">gaincalsnr_task</span> <span class="o">=</span> <span class="n">gaincalsnr</span><span class="o">.</span><span class="n">GaincalSnr</span><span class="p">(</span><span class="n">task_inputs</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_executor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">gaincalsnr_task</span><span class="p">)</span>

        <span class="c1"># PIPE-2499: based on the intent being analysed, set whether to use</span>
        <span class="c1"># &quot;scan time&quot; or &quot;integration time&quot; as the reference time, and select</span>
        <span class="c1"># corresponding values for SNRs and the SNR limit.</span>
        <span class="c1"># The weaker calibrators CHECK and PHASE will use an SNR limit of 32</span>
        <span class="c1"># (phasesnr) and scan-based values. The other, brighter, calibrators</span>
        <span class="c1"># typically use an SNR limit of 10 (intphasesnr).</span>
        <span class="k">if</span> <span class="n">intent</span> <span class="ow">in</span> <span class="n">WEAK_CALIBRATOR_INTENTS</span><span class="p">:</span>
            <span class="n">snrs</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">snrs</span>
            <span class="n">snrlimit</span> <span class="o">=</span> <span class="n">inputs</span><span class="o">.</span><span class="n">phasesnr</span>
            <span class="n">ref_times_to_use</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">scantimes</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">snrs</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">snrsint</span>
            <span class="n">snrlimit</span> <span class="o">=</span> <span class="n">inputs</span><span class="o">.</span><span class="n">intphasesnr</span>
            <span class="n">ref_times_to_use</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">inttimes</span>

        <span class="c1"># Initialize and populate outputs.</span>
        <span class="n">goodsnrs</span><span class="p">,</span> <span class="n">ref_times</span><span class="p">,</span> <span class="n">int_times</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">snr</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">snrs</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">snr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">goodsnrs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                <span class="n">ref_times</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                <span class="n">int_times</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">goodsnrs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">snr</span> <span class="o">&gt;=</span> <span class="n">snrlimit</span><span class="p">)</span>
                <span class="n">ref_times</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ref_times_to_use</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">int_times</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">inttimes</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">SNRTestResult</span><span class="p">(</span>
            <span class="n">spw_ids</span><span class="o">=</span><span class="n">result</span><span class="o">.</span><span class="n">spwids</span><span class="p">,</span>
            <span class="n">snr_values</span><span class="o">=</span><span class="n">snrs</span><span class="p">,</span>
            <span class="n">is_good_snr</span><span class="o">=</span><span class="n">goodsnrs</span><span class="p">,</span>
            <span class="n">reference_times</span><span class="o">=</span><span class="n">ref_times</span><span class="p">,</span>
            <span class="n">integration_times</span><span class="o">=</span><span class="n">int_times</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_do_combined_snr_test</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spwlist</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">perspwsnr</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">spwmap</span><span class="p">:</span> <span class="nb">list</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute combined SNRs from the &quot;per-SpW SNR&quot;. Grouping of SpWs is</span>
<span class="sd">        specified by input parameter spwmap.</span>

<span class="sd">        For each grouped SpWs, combined SNR is calculated by:</span>
<span class="sd">            combined SNR = numpy.linalg.norm(list of per SpW SNR in a group)</span>

<span class="sd">        Args:</span>
<span class="sd">            spwlist: List of spw IDs to calculate combined SNR</span>
<span class="sd">            perspwsnr: List of SNRs of each SpW</span>
<span class="sd">            spwmap: List representing a spectral window map that specifies</span>
<span class="sd">                which SpW IDs should be combined.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Dictionary containing for a given reference SpW the corresponding</span>
<span class="sd">            mapped SpWs and combined SNR.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Start combined SpW SNR test&quot;</span><span class="p">)</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;- spwlist to analyze: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">spwlist</span><span class="p">))</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;- per SpW SNR: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">perspwsnr</span><span class="p">))</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;- spwmap = </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">spwmap</span><span class="p">))</span>

        <span class="c1"># Initialize return object.</span>
        <span class="n">combined_snrs</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># Filter reference SpW IDs of each group.</span>
        <span class="n">unique_mappedspw</span> <span class="o">=</span> <span class="p">{</span><span class="n">spwmap</span><span class="p">[</span><span class="n">spwid</span><span class="p">]</span> <span class="k">for</span> <span class="n">spwid</span> <span class="ow">in</span> <span class="n">spwlist</span><span class="p">}</span>
        <span class="k">for</span> <span class="n">mappedspwid</span> <span class="ow">in</span> <span class="n">unique_mappedspw</span><span class="p">:</span>
            <span class="n">snrlist</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">combined_idx</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="c1"># only consider SpW IDs in spwlist for combination</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">spwlist</span><span class="p">)):</span>
                <span class="n">spwid</span> <span class="o">=</span> <span class="n">spwlist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">spwmap</span><span class="p">[</span><span class="n">spwid</span><span class="p">]</span> <span class="o">==</span> <span class="n">mappedspwid</span><span class="p">:</span>
                    <span class="n">snr</span> <span class="o">=</span> <span class="n">perspwsnr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">snr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="n">snrlist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">snr</span><span class="p">)</span>
                    <span class="n">combined_idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">snrlist</span><span class="p">:</span>
                <span class="n">LOG</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;No SpW with valid SNR values; cannot calculate the combined SNR&#39;</span><span class="p">)</span>
                <span class="k">return</span> <span class="p">{}</span>

            <span class="c1"># calculate combined SNR from per spw SNR</span>
            <span class="n">combined_snr</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">snrlist</span><span class="p">)</span>
            <span class="n">combined_spws</span> <span class="o">=</span> <span class="p">[</span><span class="n">spwlist</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">combined_idx</span><span class="p">]</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Reference SpW ID = </span><span class="si">{}</span><span class="s1"> (Combined SpWs = </span><span class="si">{}</span><span class="s1">) : Combined SNR = </span><span class="si">{}</span><span class="s1">&#39;</span>
                     <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mappedspwid</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">combined_spws</span><span class="p">),</span> <span class="n">combined_snr</span><span class="p">))</span>
            <span class="c1"># For current reference SpW, store list of combined SpWs and</span>
            <span class="c1"># the combined SNR.</span>
            <span class="n">combined_snrs</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">mappedspwid</span><span class="p">)]</span> <span class="o">=</span> <span class="p">(</span><span class="n">combined_spws</span><span class="p">,</span> <span class="n">combined_snr</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">combined_snrs</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_do_gaincal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">caltable</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">field</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">intent</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                    <span class="n">gaintype</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">solint</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">combine</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                    <span class="n">minblperant</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">minsnr</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">GaincalResults</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Runs gaincal worker task separately for each SpectralSpec present</span>
<span class="sd">        among the requested SpWs, each appending to the same caltable.</span>

<span class="sd">        The CalApplications in the result are modified to set calwt to False.</span>

<span class="sd">        Args:</span>
<span class="sd">            caltable: name of output caltable</span>
<span class="sd">            field: field selection string</span>
<span class="sd">            intent: intent selection string</span>
<span class="sd">            gaintype: gain type to use</span>
<span class="sd">            solint: solution interval to use</span>
<span class="sd">            combine: selects whether to combine SpWs</span>
<span class="sd">            minblperant: minimum baselines per antenna</span>
<span class="sd">            minsnr: minimum SNR</span>

<span class="sd">        Returns:</span>
<span class="sd">            Results object from gaincal worker task.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">inputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span>
        <span class="n">ms</span> <span class="o">=</span> <span class="n">inputs</span><span class="o">.</span><span class="n">ms</span>

        <span class="c1"># Identify which science spws were selected by inputs parameter.</span>
        <span class="n">request_spws</span> <span class="o">=</span> <span class="n">ms</span><span class="o">.</span><span class="n">get_spectral_windows</span><span class="p">(</span><span class="n">task_arg</span><span class="o">=</span><span class="n">inputs</span><span class="o">.</span><span class="n">spw</span><span class="p">)</span>

        <span class="c1"># Identify which scans covered the requested intent, field, and any of</span>
        <span class="c1"># the requested spws.</span>
        <span class="n">targeted_scans</span> <span class="o">=</span> <span class="n">ms</span><span class="o">.</span><span class="n">get_scans</span><span class="p">(</span><span class="n">scan_intent</span><span class="o">=</span><span class="n">intent</span><span class="p">,</span> <span class="n">spw</span><span class="o">=</span><span class="n">inputs</span><span class="o">.</span><span class="n">spw</span><span class="p">,</span> <span class="n">field</span><span class="o">=</span><span class="n">field</span><span class="p">)</span>

        <span class="c1"># Among the requested spws, identify which have a scan among the</span>
        <span class="c1"># targeted scans.</span>
        <span class="n">scan_spws</span> <span class="o">=</span> <span class="p">{</span><span class="n">spw</span> <span class="k">for</span> <span class="n">scan</span> <span class="ow">in</span> <span class="n">targeted_scans</span> <span class="k">for</span> <span class="n">spw</span> <span class="ow">in</span> <span class="n">scan</span><span class="o">.</span><span class="n">spws</span> <span class="k">if</span> <span class="n">spw</span> <span class="ow">in</span> <span class="n">request_spws</span><span class="p">}</span>

        <span class="c1"># Create a separate phase solution caltable for each SpectralSpec</span>
        <span class="c1"># grouping of SpWs and collect the corresponding CalApplications from</span>
        <span class="c1"># the task results. Each caltable should have a unique filename since</span>
        <span class="c1"># the filename includes the SpW selection.</span>
        <span class="n">original_calapps</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">spectral_spec</span><span class="p">,</span> <span class="n">tuning_spw_ids</span> <span class="ow">in</span> <span class="n">utils</span><span class="o">.</span><span class="n">get_spectralspec_to_spwid_map</span><span class="p">(</span><span class="n">scan_spws</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">tuning_spw_str</span> <span class="o">=</span> <span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">tuning_spw_ids</span><span class="p">)])</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Processing spectral spec </span><span class="si">{}</span><span class="s1">, spws </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">spectral_spec</span><span class="p">,</span> <span class="n">tuning_spw_str</span><span class="p">))</span>

            <span class="n">scans_with_data</span> <span class="o">=</span> <span class="n">ms</span><span class="o">.</span><span class="n">get_scans</span><span class="p">(</span><span class="n">spw</span><span class="o">=</span><span class="n">tuning_spw_str</span><span class="p">,</span> <span class="n">scan_intent</span><span class="o">=</span><span class="n">inputs</span><span class="o">.</span><span class="n">intent</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">scans_with_data</span><span class="p">:</span>
                <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;No data to process for spectral spec </span><span class="si">{}</span><span class="s1">. Continuing...&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">spectral_spec</span><span class="p">))</span>
                <span class="k">continue</span>

            <span class="c1"># added in case not passed - PL2024 was hardcoded</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">solint</span><span class="p">:</span>
                <span class="n">solint</span> <span class="o">=</span> <span class="s1">&#39;inf&#39;</span>

            <span class="c1"># Initialize gaincal inputs.</span>
            <span class="n">task_args</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;output_dir&#39;</span><span class="p">:</span> <span class="n">inputs</span><span class="o">.</span><span class="n">output_dir</span><span class="p">,</span>
                <span class="s1">&#39;vis&#39;</span><span class="p">:</span> <span class="n">inputs</span><span class="o">.</span><span class="n">vis</span><span class="p">,</span>
                <span class="s1">&#39;caltable&#39;</span><span class="p">:</span> <span class="n">caltable</span><span class="p">,</span>
                <span class="s1">&#39;field&#39;</span><span class="p">:</span> <span class="n">field</span><span class="p">,</span>
                <span class="s1">&#39;intent&#39;</span><span class="p">:</span> <span class="n">intent</span><span class="p">,</span>
                <span class="s1">&#39;spw&#39;</span><span class="p">:</span> <span class="n">tuning_spw_str</span><span class="p">,</span>
                <span class="s1">&#39;solint&#39;</span><span class="p">:</span> <span class="n">solint</span><span class="p">,</span>
                <span class="s1">&#39;gaintype&#39;</span><span class="p">:</span> <span class="n">gaintype</span><span class="p">,</span>
                <span class="s1">&#39;calmode&#39;</span><span class="p">:</span> <span class="s1">&#39;p&#39;</span><span class="p">,</span>
                <span class="s1">&#39;minsnr&#39;</span><span class="p">:</span> <span class="n">minsnr</span><span class="p">,</span>
                <span class="s1">&#39;combine&#39;</span><span class="p">:</span> <span class="n">combine</span><span class="p">,</span>
                <span class="s1">&#39;refant&#39;</span><span class="p">:</span> <span class="n">inputs</span><span class="o">.</span><span class="n">refant</span><span class="p">,</span>
                <span class="s1">&#39;minblperant&#39;</span><span class="p">:</span> <span class="n">minblperant</span><span class="p">,</span>
            <span class="p">}</span>
            <span class="n">task_inputs</span> <span class="o">=</span> <span class="n">gtypegaincal</span><span class="o">.</span><span class="n">GTypeGaincalInputs</span><span class="p">(</span><span class="n">inputs</span><span class="o">.</span><span class="n">context</span><span class="p">,</span> <span class="o">**</span><span class="n">task_args</span><span class="p">)</span>

            <span class="c1"># Initialize and execute gaincal task.</span>
            <span class="n">phasecal_task</span> <span class="o">=</span> <span class="n">gtypegaincal</span><span class="o">.</span><span class="n">GTypeGaincal</span><span class="p">(</span><span class="n">task_inputs</span><span class="p">)</span>
            <span class="n">phasecal_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_executor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">phasecal_task</span><span class="p">)</span>

            <span class="c1"># Collect CalApplications.</span>
            <span class="n">original_calapps</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">phasecal_result</span><span class="o">.</span><span class="n">pool</span><span class="p">)</span>

        <span class="c1"># Phase solution caltables should always be registered to be applied</span>
        <span class="c1"># with calwt=False (PIPE-1154). Create an updated version of each</span>
        <span class="c1"># CalApplication with the override to set calwt to False. Replace any</span>
        <span class="c1"># existing CalApplications in latest tuning result with complete list</span>
        <span class="c1"># of all updated CalApplications, and return this as the final result.</span>
        <span class="n">processed_calapps</span> <span class="o">=</span> <span class="p">[</span><span class="n">callibrary</span><span class="o">.</span><span class="n">copy_calapplication</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">calwt</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">original_calapps</span><span class="p">]</span>
        <span class="n">phasecal_result</span><span class="o">.</span><span class="n">pool</span> <span class="o">=</span> <span class="n">processed_calapps</span>
        <span class="n">phasecal_result</span><span class="o">.</span><span class="n">final</span> <span class="o">=</span> <span class="n">processed_calapps</span>

        <span class="k">return</span> <span class="n">phasecal_result</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_do_phaseup</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">GaincalResults</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates the SpW-to-SpW phase-up caltable, and merges the resulting</span>
<span class="sd">        table into the local task context.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Results object from gaincal worker task.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">inputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span>

        <span class="c1"># Create spw-to-spw phaseup caltable.</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Computing spw phase-up table for </span><span class="si">{</span><span class="n">inputs</span><span class="o">.</span><span class="n">ms</span><span class="o">.</span><span class="n">basename</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">tuning_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_do_gaincal</span><span class="p">(</span><span class="n">caltable</span><span class="o">=</span><span class="n">inputs</span><span class="o">.</span><span class="n">caltable</span><span class="p">,</span> <span class="n">field</span><span class="o">=</span><span class="n">inputs</span><span class="o">.</span><span class="n">field</span><span class="p">,</span> <span class="n">intent</span><span class="o">=</span><span class="n">inputs</span><span class="o">.</span><span class="n">intent</span><span class="p">,</span>
                                         <span class="n">gaintype</span><span class="o">=</span><span class="s1">&#39;G&#39;</span><span class="p">,</span> <span class="n">combine</span><span class="o">=</span><span class="n">inputs</span><span class="o">.</span><span class="n">combine</span><span class="p">,</span> <span class="n">minsnr</span><span class="o">=</span><span class="n">inputs</span><span class="o">.</span><span class="n">minsnr</span><span class="p">,</span>
                                         <span class="n">minblperant</span><span class="o">=</span><span class="n">inputs</span><span class="o">.</span><span class="n">minblperant</span><span class="p">)</span>

        <span class="c1"># Accept this spw-to-spw phase offsets result into the local context,</span>
        <span class="c1"># to ensure the caltable is included in pre-apply for subsequent steps</span>
        <span class="c1"># in this task.</span>
        <span class="n">tuning_result</span><span class="o">.</span><span class="n">accept</span><span class="p">(</span><span class="n">inputs</span><span class="o">.</span><span class="n">context</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">tuning_result</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_do_diagnostic_phasecal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spwmaps</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">IntentField</span><span class="p">,</span> <span class="n">SpwMapping</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">GaincalResults</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates diagnostic phase caltables for each phase calibrator field and</span>
<span class="sd">        each check source field, where the SpW-to-SpW phase-up caltable should</span>
<span class="sd">        be included in pre-apply (since it was merged into local context).</span>

<span class="sd">        These tables are used later in this stage to assess the median SNR</span>
<span class="sd">        achieved for each phase calibrator / check source in each SpW after the</span>
<span class="sd">        SpW-to-SpW phase-up is applied (PIPE-665).</span>

<span class="sd">        Use phase gaincal parameters appropriate for the SpW mapping derived</span>
<span class="sd">        earlier for each phase calibrator / check source field. Similar to</span>
<span class="sd">        hifa_timegaincal, set minblperant to 4 and minsnr to 3.</span>

<span class="sd">        Args:</span>
<span class="sd">            spwmaps: dictionary with (Intent, Field) combinations as keys and</span>
<span class="sd">                corresponding spectral window mapping as values.</span>

<span class="sd">        Returns:</span>
<span class="sd">            List of result objects from gaincal worker task(s) that produced</span>
<span class="sd">            the diagnostic phase caltable(s).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">inputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span>

        <span class="c1"># Derive separate phase solutions for each PHASE and each CHECK field.</span>
        <span class="n">gaincal_results</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">intent</span><span class="p">,</span> <span class="n">field</span><span class="p">),</span> <span class="n">spwmapping</span> <span class="ow">in</span> <span class="n">spwmaps</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># PIPE-2499: for the CHECK and PHASE calibrators, force the use of</span>
            <span class="c1"># solint=&#39;inf&#39; in the upcoming diagnostic phase solve.</span>
            <span class="k">if</span> <span class="n">intent</span> <span class="ow">in</span> <span class="n">WEAK_CALIBRATOR_INTENTS</span><span class="p">:</span>
                <span class="n">solint</span> <span class="o">=</span> <span class="s1">&#39;inf&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">solint</span> <span class="o">=</span> <span class="n">spwmapping</span><span class="o">.</span><span class="n">solint</span>

            <span class="c1"># Retrieve combine parameter from SpW mapping.</span>
            <span class="n">combine</span> <span class="o">=</span> <span class="s1">&#39;spw&#39;</span> <span class="k">if</span> <span class="n">spwmapping</span><span class="o">.</span><span class="n">combine</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span>

            <span class="c1"># Create diagnostic phase caltables.</span>
            <span class="c1"># PIPE-665: for the diagnostic phase caltables, always use</span>
            <span class="c1"># minsnr=3, minblperant=4.</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Computing diagnostic phase caltable for </span><span class="si">{</span><span class="n">inputs</span><span class="o">.</span><span class="n">ms</span><span class="o">.</span><span class="n">basename</span><span class="si">}</span><span class="s1">, intent=</span><span class="si">{</span><span class="n">intent</span><span class="si">}</span><span class="s1">,&#39;</span>
                     <span class="sa">f</span><span class="s1">&#39; field=</span><span class="si">{</span><span class="n">field</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">)</span>
            <span class="n">gaincal_results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_do_gaincal</span><span class="p">(</span><span class="n">field</span><span class="o">=</span><span class="n">field</span><span class="p">,</span> <span class="n">intent</span><span class="o">=</span><span class="n">intent</span><span class="p">,</span> <span class="n">gaintype</span><span class="o">=</span><span class="n">spwmapping</span><span class="o">.</span><span class="n">gaintype</span><span class="p">,</span>
                                                    <span class="n">solint</span><span class="o">=</span><span class="n">solint</span><span class="p">,</span> <span class="n">combine</span><span class="o">=</span><span class="n">combine</span><span class="p">,</span> <span class="n">minblperant</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">minsnr</span><span class="o">=</span><span class="mi">3</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">gaincal_results</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_compute_median_snr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gaincal_results</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">GaincalResults</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span> <span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method evaluates the diagnostic phase caltable(s) produced in an</span>
<span class="sd">        earlier step to compute the median achieved SNR for each intent/field</span>
<span class="sd">        and for each SpW.</span>

<span class="sd">        Args:</span>
<span class="sd">            gaincal_results: List of gaincal worker task results representing</span>
<span class="sd">                the diagnostic phase caltable(s).</span>

<span class="sd">        Returns:</span>
<span class="sd">            Dictionary with intent, field name, and SpW as keys, and</span>
<span class="sd">            corresponding median achieved SNR as values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">inputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span>

        <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Computing median achieved phase SNR information for </span><span class="si">{</span><span class="n">inputs</span><span class="o">.</span><span class="n">ms</span><span class="o">.</span><span class="n">basename</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">)</span>
        <span class="n">snr_info</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">result</span> <span class="ow">in</span> <span class="n">gaincal_results</span><span class="p">:</span>
            <span class="n">field</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">inputs</span><span class="p">[</span><span class="s1">&#39;field&#39;</span><span class="p">]</span>
            <span class="n">intent</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">inputs</span><span class="p">[</span><span class="s1">&#39;intent&#39;</span><span class="p">]</span>
            <span class="c1"># Evaluate each CalApp in the result: for a given intent, field,</span>
            <span class="c1"># there can be separate gaintable (one per spectralspec).</span>
            <span class="k">for</span> <span class="n">calapp</span> <span class="ow">in</span> <span class="n">result</span><span class="o">.</span><span class="n">final</span><span class="p">:</span>
                <span class="c1"># Get SpWs and SNR info from caltable.</span>
                <span class="k">with</span> <span class="n">casa_tools</span><span class="o">.</span><span class="n">TableReader</span><span class="p">(</span><span class="n">calapp</span><span class="o">.</span><span class="n">gaintable</span><span class="p">)</span> <span class="k">as</span> <span class="n">table</span><span class="p">:</span>
                    <span class="n">spws</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">getcol</span><span class="p">(</span><span class="s2">&quot;SPECTRAL_WINDOW_ID&quot;</span><span class="p">)</span>
                    <span class="n">snrs</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">getcol</span><span class="p">(</span><span class="s2">&quot;SNR&quot;</span><span class="p">)</span>

                <span class="c1"># Evaluate each unique SpW separately.</span>
                <span class="k">for</span> <span class="n">spw</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">spws</span><span class="p">)):</span>
                    <span class="c1"># Get indices in caltable data corresponding to current SpW.</span>
                    <span class="n">ind_spw</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">spws</span> <span class="o">==</span> <span class="n">spw</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

                    <span class="c1"># Get number of correlations for this SpW.</span>
                    <span class="n">corr_type</span> <span class="o">=</span> <span class="n">commonhelpermethods</span><span class="o">.</span><span class="n">get_corr_products</span><span class="p">(</span><span class="n">inputs</span><span class="o">.</span><span class="n">ms</span><span class="p">,</span> <span class="n">spw</span><span class="p">)</span>
                    <span class="n">ncorrs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">corr_type</span><span class="p">)</span>

                    <span class="c1"># Compute median achieved SNR and store in snr_info. If this</span>
                    <span class="c1"># SpW covers a single polarisation, then compute the median SNR</span>
                    <span class="c1"># using only the one corresponding column in the caltable.</span>
                    <span class="k">if</span> <span class="n">ncorrs</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="c1"># Identify which column in caltable to use for computing</span>
                        <span class="c1"># the median SNR.</span>
                        <span class="n">ind_col</span> <span class="o">=</span> <span class="n">commonhelpermethods</span><span class="o">.</span><span class="n">get_pol_id</span><span class="p">(</span><span class="n">inputs</span><span class="o">.</span><span class="n">ms</span><span class="p">,</span> <span class="n">spw</span><span class="p">,</span> <span class="n">corr_type</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                        <span class="n">snr_info</span><span class="p">[(</span><span class="n">intent</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">spw</span><span class="p">)]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">snrs</span><span class="p">[</span><span class="n">ind_col</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ind_spw</span><span class="p">])</span>
                    <span class="c1"># Otherwise, i.e. SpW is multi-pol, use all columns.</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">snr_info</span><span class="p">[(</span><span class="n">intent</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">spw</span><span class="p">)]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">snrs</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ind_spw</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">snr_info</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_do_decoherence_assessment</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">],</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">List</span><span class="p">]:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Starting phase RMS structure function decoherence assessment.&quot;</span><span class="p">)</span>

            <span class="c1"># Initialize the phase RMS structure function assessment</span>
            <span class="n">inputs</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">)</span>
            <span class="n">phase_rms</span> <span class="o">=</span> <span class="n">PhaseStabilityHeuristics</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">outlier_limit</span><span class="o">=</span><span class="mf">180.0</span><span class="p">,</span> <span class="n">flag_tolerance</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span> <span class="n">max_poor_ant</span><span class="o">=</span><span class="mi">11</span><span class="p">)</span>

            <span class="c1"># Do the analysis</span>
            <span class="n">phaserms_results</span><span class="p">,</span> <span class="n">phaserms_cycletime</span><span class="p">,</span> <span class="n">phaserms_totaltime</span><span class="p">,</span> <span class="n">phaserms_antout</span> <span class="o">=</span> <span class="n">phase_rms</span><span class="o">.</span><span class="n">analysis</span><span class="p">()</span>

        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="n">phaserms_results</span><span class="p">,</span> <span class="n">phaserms_cycletime</span><span class="p">,</span> <span class="n">phaserms_totaltime</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
            <span class="n">phaserms_antout</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;For </span><span class="si">{}</span><span class="s2">, phase RMS structure function analysis failed&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">ms</span><span class="o">.</span><span class="n">basename</span><span class="p">))</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">traceback</span><span class="o">.</span><span class="n">format_exc</span><span class="p">())</span>

        <span class="k">return</span> <span class="n">phaserms_results</span><span class="p">,</span> <span class="n">phaserms_cycletime</span><span class="p">,</span> <span class="n">phaserms_totaltime</span><span class="p">,</span> <span class="n">phaserms_antout</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_get_intent_field</span><span class="p">(</span><span class="n">ms</span><span class="p">:</span> <span class="n">MeasurementSet</span><span class="p">,</span> <span class="n">intents</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">exclude_intents</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]:</span>
        <span class="c1"># If provided, convert &quot;intents to exclude&quot; into set of strings.</span>
        <span class="k">if</span> <span class="n">exclude_intents</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">exclude_intents</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">exclude_intents</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">exclude_intents</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">))</span>

        <span class="n">intent_field</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">intent</span> <span class="ow">in</span> <span class="n">intents</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">ms</span><span class="o">.</span><span class="n">get_fields</span><span class="p">(</span><span class="n">intent</span><span class="o">=</span><span class="n">intent</span><span class="p">):</span>
                <span class="c1"># Check whether found field also covers any of the intents to</span>
                <span class="c1"># skip.</span>
                <span class="n">excluded_intents_found</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="n">intents</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">exclude_intents</span><span class="p">)</span>

                <span class="c1"># PIPE-2499: skip an AMPLITUDE field if it has overlap the</span>
                <span class="c1"># BANDPASS calibrator.</span>
                <span class="k">if</span> <span class="n">intent</span> <span class="o">==</span> <span class="s1">&#39;AMPLITUDE&#39;</span> <span class="ow">and</span> <span class="s1">&#39;BANDPASS&#39;</span> <span class="ow">in</span> <span class="n">field</span><span class="o">.</span><span class="n">intents</span><span class="p">:</span>
                    <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">ms</span><span class="o">.</span><span class="n">basename</span><span class="si">}</span><span class="s1">: will not derive spwmap for field </span><span class="si">{</span><span class="n">field</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1"> (#</span><span class="si">{</span><span class="n">field</span><span class="o">.</span><span class="n">id</span><span class="si">}</span><span class="s1">) and intent&#39;</span>
                             <span class="sa">f</span><span class="s1">&#39; </span><span class="si">{</span><span class="n">intent</span><span class="si">}</span><span class="s1"> because this field also covers the BANDPASS calibrator intent.&#39;</span><span class="p">)</span>
                    <span class="k">continue</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">excluded_intents_found</span><span class="p">:</span>
                    <span class="n">intent_field</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">intent</span><span class="p">,</span> <span class="n">field</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Log a message to explain why no spwmap will be derived</span>
                    <span class="c1"># for this particular combination of field and intent.</span>
                    <span class="n">excluded_intents_str</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">excluded_intents_found</span><span class="p">))</span>
                    <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">ms</span><span class="o">.</span><span class="n">basename</span><span class="si">}</span><span class="s1">: will not derive spwmap for field </span><span class="si">{</span><span class="n">field</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1"> (#</span><span class="si">{</span><span class="n">field</span><span class="o">.</span><span class="n">id</span><span class="si">}</span><span class="s1">) and intent&#39;</span>
                             <span class="sa">f</span><span class="s1">&#39; </span><span class="si">{</span><span class="n">intent</span><span class="si">}</span><span class="s1"> because this field also covers calibrator intent(s) </span><span class="si">{</span><span class="n">excluded_intents_str</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">intent_field</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_compute_solint</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">spwids</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">snrs</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">ref_times</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">int_times</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">intent</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">mappingmode</span><span class="p">:</span> <span class="nb">str</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the optimal solution interval and gaintype.</span>

<span class="sd">        Computes the optimal values to use for solution interval and gaintype</span>
<span class="sd">        in phase-up gaincal solutions. The ideal solution interval is a single</span>
<span class="sd">        integration time interval (solint=&#39;int&#39;), but this method uses the SNR</span>
<span class="sd">        estimates provided to ensure that sufficient SNR is achieved, or whether</span>
<span class="sd">        some amount of time averaging (i.e. solint &gt; &#39;int&#39;) is necessary.</span>

<span class="sd">        spwids, snrs, ref_times, and int_times are all passed from the SNR test</span>
<span class="sd">        function, where SNRs are based on the reference time (ref_times), and</span>
<span class="sd">        int_times is provided as the integration time (for each SpW).</span>

<span class="sd">        The mappingmode indicates what type of spw mapping is used in the</span>
<span class="sd">        phase-up solve:</span>

<span class="sd">          * single: uses no mapping (each spw mapped to itself); in this case,</span>
<span class="sd">            the value of the lowest (worst) SNR will be used.</span>
<span class="sd">          * mapping: uses spw re-mapping; in this case, the highest SNR will be</span>
<span class="sd">            used, as low-SNR SpWs will be re-mapped to this highest SNR SpW.</span>
<span class="sd">          * combine: uses spw combination; in this case, linearalg is used to</span>
<span class="sd">            compute the combined SNR that is then used to govern the solint.</span>

<span class="sd">        Args:</span>
<span class="sd">            spwids: List of the spectral window IDs.</span>
<span class="sd">            snrs: List of the SNR per SpW, calculated for the reference time.</span>
<span class="sd">            ref_times: List of the reference time per SPW, in minutes.</span>
<span class="sd">            int_times: List of the integration time per SPW, in minutes.</span>
<span class="sd">            intent: Intent to compute solint for.</span>
<span class="sd">            mappingmode: Type of spw mapping to be used in phase solve, with</span>
<span class="sd">                options: &#39;single&#39;, &#39;mapping&#39;, &#39;combine&#39;.</span>

<span class="sd">        Returns:</span>
<span class="sd">            3-tuple containing:</span>
<span class="sd">              * Solution interval to use, as string (e.g. &quot;int&quot;, or &quot;10.0s&quot;)</span>
<span class="sd">              * Gaintype to use (&quot;G&quot; or &quot;T&quot;)</span>
<span class="sd">              * SNR threshold used</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">inputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span>
        <span class="n">quanta</span> <span class="o">=</span> <span class="n">casa_tools</span><span class="o">.</span><span class="n">quanta</span>

        <span class="c1"># Set default SNR limit based on intent. This may get overridden further</span>
        <span class="c1"># below, e.g. case of optimal solint for bright calibrators.</span>
        <span class="n">snr_threshold_used</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_snr_limit_for_intent</span><span class="p">(</span><span class="n">intent</span><span class="p">)</span>

        <span class="c1"># Restrict the input SpWs, SNRs, and times to the SpWs-to-use.</span>
        <span class="c1">#</span>
        <span class="c1"># Bright AMPLITUDE or BANDPASS calibrators in Band-to-Band datasets will</span>
        <span class="c1"># have scans in both the (high-freq) diffgain source SpWs and the</span>
        <span class="c1"># (low-freq) diffgain reference SpWs, and subsequent phase solves for</span>
        <span class="c1"># these calibrators will be done in a single call for all those SpWs.</span>
        <span class="c1"># For these calibrators, use only the diffgain source SpWs, expected to</span>
        <span class="c1"># have low SNR, to compute the optimal solution interval.</span>
        <span class="k">if</span> <span class="n">inputs</span><span class="o">.</span><span class="n">ms</span><span class="o">.</span><span class="n">is_band_to_band</span> <span class="ow">and</span> <span class="n">intent</span> <span class="ow">in</span> <span class="p">{</span><span class="s1">&#39;AMPLITUDE&#39;</span><span class="p">,</span> <span class="s1">&#39;BANDPASS&#39;</span><span class="p">}:</span>
            <span class="n">dgsrc_spwids</span> <span class="o">=</span> <span class="p">[</span><span class="n">spw</span><span class="o">.</span><span class="n">id</span> <span class="k">for</span> <span class="n">spw</span> <span class="ow">in</span> <span class="n">inputs</span><span class="o">.</span><span class="n">ms</span><span class="o">.</span><span class="n">get_spectral_windows</span><span class="p">(</span><span class="n">intent</span><span class="o">=</span><span class="s1">&#39;DIFFGAINSRC&#39;</span><span class="p">)]</span>
            <span class="n">to_keep</span> <span class="o">=</span> <span class="p">[</span><span class="n">idx</span> <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">spwid</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">spwids</span><span class="p">)</span> <span class="k">if</span> <span class="n">spwid</span> <span class="ow">in</span> <span class="n">dgsrc_spwids</span><span class="p">]</span>
        <span class="c1"># For all other data, loop over the spectral specs and identify the</span>
        <span class="c1"># SpectralSpec with the lowest-usable-SNR SpW in it; this SpectralSpec</span>
        <span class="c1"># and its SpWs (and corresponding SNR values) will be used in the</span>
        <span class="c1"># subsequent evaluation of best solint / gaintype.</span>
        <span class="c1"># Standard datasets will typically contain a single spectral spec, but</span>
        <span class="c1"># spectral scans or multi-tuning datasets will contain multiple spectral</span>
        <span class="c1"># specs.</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">scispws</span> <span class="o">=</span> <span class="n">inputs</span><span class="o">.</span><span class="n">ms</span><span class="o">.</span><span class="n">get_spectral_windows</span><span class="p">()</span>
            <span class="n">to_keep</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">snr_min</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">)</span>
            <span class="n">spectralspec_to_spw_ids</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">get_spectralspec_to_spwid_map</span><span class="p">(</span><span class="n">scispws</span><span class="p">)</span>

            <span class="c1"># Identify the spws with the lowest SNR that&#39;s still usable. This runs two</span>
            <span class="c1"># passes through the data:</span>
            <span class="c1">#     first pass: only consider SNRs above the threshold</span>
            <span class="c1">#     second pass: consider all SNRs if nothing was found in the first pass</span>
            <span class="k">for</span> <span class="n">above_threshold</span> <span class="ow">in</span> <span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">spwids_in_spec</span> <span class="ow">in</span> <span class="n">spectralspec_to_spw_ids</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                    <span class="c1"># Gets indices of SpWs that are in current spectral spec</span>
                    <span class="n">spw_index</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">spwid</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">spwids</span><span class="p">)</span> <span class="k">if</span> <span class="n">spwid</span> <span class="ow">in</span> <span class="n">spwids_in_spec</span><span class="p">]</span>
                    <span class="c1"># and their corresponding SNR values</span>
                    <span class="n">spectralspec_snrs</span> <span class="o">=</span> <span class="p">[</span><span class="n">snrs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">spw_index</span><span class="p">]</span>
                    <span class="c1"># filter out SNRs below threshold for first pass</span>
                    <span class="k">if</span> <span class="n">above_threshold</span><span class="p">:</span>
                        <span class="n">spectralspec_snrs</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">spectralspec_snrs</span> <span class="k">if</span> <span class="n">s</span> <span class="o">&gt;</span> <span class="n">snr_threshold_used</span><span class="p">]</span>
                    <span class="c1"># find the minimum and the corresponding spw to keep</span>
                    <span class="k">if</span> <span class="n">spectralspec_snrs</span><span class="p">:</span>
                        <span class="n">min_snr</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">spectralspec_snrs</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">min_snr</span> <span class="o">&lt;</span> <span class="n">snr_min</span><span class="p">:</span>
                            <span class="n">to_keep</span><span class="p">,</span> <span class="n">snr_min</span> <span class="o">=</span> <span class="n">spw_index</span><span class="p">,</span> <span class="n">min_snr</span>
                <span class="c1"># if we found an SNR, we&#39;re done - otherwise, loop again with above_threshold=False</span>
                <span class="k">if</span> <span class="n">to_keep</span><span class="p">:</span>
                    <span class="k">break</span>

        <span class="c1"># Filter SNRs and times for SpWs to keep.</span>
        <span class="c1"># PIPE-2499: for reference and integration time, it is assumed this is</span>
        <span class="c1"># the same across all SpWs, so pick the first element as representative,</span>
        <span class="c1"># and convert these times from minutes to seconds.</span>
        <span class="n">snrs</span> <span class="o">=</span> <span class="p">[</span><span class="n">snrs</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">to_keep</span><span class="p">]</span>
        <span class="n">int_time</span> <span class="o">=</span> <span class="n">int_times</span><span class="p">[</span><span class="n">to_keep</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">*</span> <span class="mf">60.</span>
        <span class="n">ref_time</span> <span class="o">=</span> <span class="n">ref_times</span><span class="p">[</span><span class="n">to_keep</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">*</span> <span class="mf">60.</span>

        <span class="c1"># Select what SNR (among SNRs for all considered SpWs) to let govern the</span>
        <span class="c1"># optimal solution interval based on what type of SpW mapping mode will</span>
        <span class="c1"># be used in subsequent phase-up solves.</span>
        <span class="k">match</span> <span class="n">mappingmode</span><span class="p">:</span>
            <span class="k">case</span> <span class="s1">&#39;single&#39;</span><span class="p">:</span>
                <span class="c1"># If no mapping is used (each spw mapped to itself), then use the</span>
                <span class="c1"># lowest (worst) SNR to govern the optimal solint.</span>
                <span class="n">snr_to_use</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">snrs</span><span class="p">)</span>
            <span class="k">case</span> <span class="s1">&#39;mapping&#39;</span><span class="p">:</span>
                <span class="c1"># Use lowest SNR of all &#39;good&#39; SNRs, i.e. those above snr_threshold_used.</span>
                <span class="c1"># As &#39;mapping&#39; is only set when there is least one good SNR, we do not need</span>
                <span class="c1"># to provide a default or handle the ValueError that would be raised by taking</span>
                <span class="c1"># min() of an empty list</span>
                <span class="n">snr_to_use</span> <span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="n">snr</span> <span class="k">for</span> <span class="n">snr</span> <span class="ow">in</span> <span class="n">snrs</span> <span class="k">if</span> <span class="n">snr</span> <span class="o">&gt;</span> <span class="n">snr_threshold_used</span><span class="p">])</span>
            <span class="k">case</span> <span class="s1">&#39;combine&#39;</span><span class="p">:</span>
                <span class="c1"># If using SpW combination, then compute the Euclidean norm of the</span>
                <span class="c1"># SNR values to represent the combined SNR.</span>
                <span class="n">snr_to_use</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">snrs</span><span class="p">)</span>
            <span class="k">case</span><span class="w"> </span><span class="k">_</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid mappingmode: </span><span class="si">{</span><span class="n">mappingmode</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Set SNR for integration time and required SNR based on the intent.</span>
        <span class="k">if</span> <span class="n">intent</span> <span class="ow">in</span> <span class="n">WEAK_CALIBRATOR_INTENTS</span><span class="p">:</span>
            <span class="c1"># For the potentially weaker calibrators, scale the SNR thresholds.</span>
            <span class="n">int_snr</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">int_time</span><span class="o">/</span><span class="n">ref_time</span><span class="p">)</span> <span class="o">*</span> <span class="n">snr_to_use</span>
            <span class="n">req_snr</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">int_time</span><span class="o">/</span><span class="n">ref_time</span><span class="p">)</span> <span class="o">*</span> <span class="n">inputs</span><span class="o">.</span><span class="n">phasesnr</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># No scaling for the other calibrators (BANDPASS, DIFFGAIN, ...).</span>
            <span class="n">int_snr</span> <span class="o">=</span> <span class="n">snr_to_use</span>
            <span class="n">req_snr</span> <span class="o">=</span> <span class="n">inputs</span><span class="o">.</span><span class="n">intphasesnr</span>

        <span class="c1"># Compute the required solint by scaling the integration time by the</span>
        <span class="c1"># ratio of required SNR over integration-time-based SNR.</span>
        <span class="n">req_solint</span> <span class="o">=</span> <span class="n">int_time</span> <span class="o">*</span> <span class="p">(</span><span class="n">req_snr</span><span class="o">/</span><span class="n">int_snr</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
        <span class="c1"># By default, assume that the phase-up will use gaintype=&#39;G&#39;, i.e. solve</span>
        <span class="c1"># for the standard complex polarization-specific gain.</span>
        <span class="n">gaintype</span> <span class="o">=</span> <span class="s2">&quot;G&quot;</span>

        <span class="c1"># If the required solint after rounding would be at/below the</span>
        <span class="c1"># integration time (i.e. &lt; 1.5 integration time), then &#39;int&#39; is already</span>
        <span class="c1"># the optimal (lowest) solint to use, so return early with this (and &#39;G&#39;</span>
        <span class="c1"># as the corresponding default gaintype).</span>
        <span class="k">if</span> <span class="n">req_solint</span> <span class="o">&lt;</span> <span class="mf">1.5</span> <span class="o">*</span> <span class="n">int_time</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;int&#39;</span><span class="p">,</span> <span class="n">gaintype</span><span class="p">,</span> <span class="n">snr_threshold_used</span>

        <span class="c1"># If the required solint (with default gaintype) is above &#39;int&#39;, and the</span>
        <span class="c1"># phase-up will use SpW combination, then prefer to use gaintype &quot;T&quot;,</span>
        <span class="c1"># i.e. solving across polarizations. Since this improves the SNR,</span>
        <span class="c1"># re-check whether with gaintype=&#39;T&#39; the required solint would fall at</span>
        <span class="c1"># or below &#39;int&#39;.</span>
        <span class="k">if</span> <span class="n">mappingmode</span> <span class="o">==</span> <span class="s1">&#39;combine&#39;</span><span class="p">:</span>
            <span class="n">gaintype</span> <span class="o">=</span> <span class="s1">&#39;T&#39;</span>
            <span class="c1"># Scale the integration-time based SNR threshold, assuming that with</span>
            <span class="c1"># gaintype=&#39;T&#39; the signal is combined from at least 2 polarizations;</span>
            <span class="c1"># and re-compute the required solint with this scaled int-time SNR.</span>
            <span class="n">int_snr</span> <span class="o">=</span> <span class="n">int_snr</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">req_solint</span> <span class="o">=</span> <span class="n">int_time</span> <span class="o">*</span> <span class="p">(</span><span class="n">req_snr</span><span class="o">/</span><span class="n">int_snr</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
            <span class="c1"># If the required solint with gaintype=&#39;T&#39; after rounding is</span>
            <span class="c1"># at/below the integration time, then return early with this as the</span>
            <span class="c1"># optimal solint.</span>
            <span class="k">if</span> <span class="n">req_solint</span> <span class="o">&lt;</span> <span class="mf">1.5</span> <span class="o">*</span> <span class="n">int_time</span><span class="p">:</span>
                <span class="k">return</span> <span class="s1">&#39;int&#39;</span><span class="p">,</span> <span class="n">gaintype</span><span class="p">,</span> <span class="n">snr_threshold_used</span>

        <span class="c1"># If the required solint is definitely above the integration time, even</span>
        <span class="c1"># after considering the options of using SpW combination and</span>
        <span class="c1"># gaintype=&#39;T&#39; then proceed to compute the optimal solint above &#39;int&#39;,</span>
        <span class="c1"># using different approaches for the weaker &quot;CHECK&quot; and &quot;PHASE&quot;</span>
        <span class="c1"># calibrators vs. all other (assumed bright) calibrators.</span>
        <span class="k">if</span> <span class="n">intent</span> <span class="ow">in</span> <span class="n">WEAK_CALIBRATOR_INTENTS</span><span class="p">:</span>
            <span class="c1"># For CHECK and PHASE calibrators, the required SNR will have been</span>
            <span class="c1"># based on scan times (passed along as the reference time).</span>
            <span class="n">scan_time</span> <span class="o">=</span> <span class="n">ref_time</span>

            <span class="c1"># If the required solint is more than half the scan time, then cap</span>
            <span class="c1"># the optimal solint to a maximum of half the scan time.</span>
            <span class="k">if</span> <span class="n">req_solint</span> <span class="o">&gt;</span> <span class="n">scan_time</span> <span class="o">/</span> <span class="mf">2.</span><span class="p">:</span>
                <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">inputs</span><span class="o">.</span><span class="n">ms</span><span class="o">.</span><span class="n">basename</span><span class="si">}</span><span class="s2">, intent=</span><span class="si">{</span><span class="n">intent</span><span class="si">}</span><span class="s2">: setting the optimal gaincal solint to half the scan&quot;</span>
                         <span class="sa">f</span><span class="s2">&quot; time.&quot;</span><span class="p">)</span>
                <span class="n">solint</span> <span class="o">=</span> <span class="n">scan_time</span> <span class="o">/</span> <span class="mf">2.</span>
            <span class="c1"># Otherwise, the required solint is larger than the integration time</span>
            <span class="c1"># but less than half the scan time, so proceed to find the best</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Compute how many integration times fit in the required solint</span>
                <span class="c1"># and in the scan time. The results should be &gt;= 2, as the case</span>
                <span class="c1"># of 1 (after rounding) would have resulted in an early return</span>
                <span class="c1"># in a preceding step.</span>
                <span class="n">req_solint_in_int</span> <span class="o">=</span> <span class="n">round_half_up</span><span class="p">(</span><span class="n">req_solint</span> <span class="o">/</span> <span class="n">int_time</span><span class="p">)</span>
                <span class="n">max_solints_in_scan</span> <span class="o">=</span> <span class="n">round_half_up</span><span class="p">(</span><span class="n">scan_time</span> <span class="o">/</span> <span class="n">int_time</span><span class="p">)</span>

                <span class="c1"># Identify candidate solints as multiples of the integration</span>
                <span class="c1"># time, between 2x int and half of the scan time, that also work</span>
                <span class="c1"># as an exact division of the scan time, i.e. resulting in</span>
                <span class="c1"># exact equal solution intervals with no remainder.</span>
                <span class="n">time_factors</span> <span class="o">=</span> <span class="p">[</span><span class="n">t</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">max_solints_in_scan</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span>
                                <span class="k">if</span> <span class="n">max_solints_in_scan</span> <span class="o">%</span> <span class="n">t</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span>
                <span class="n">valid_factors</span> <span class="o">=</span> <span class="p">[</span><span class="n">t</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">time_factors</span> <span class="k">if</span> <span class="n">t</span> <span class="o">&gt;=</span> <span class="n">req_solint_in_int</span><span class="p">]</span>

                <span class="c1"># If any valid integer multiple candidates were found, then use</span>
                <span class="c1"># the lowest factor to set the solution interval.</span>
                <span class="k">if</span> <span class="n">valid_factors</span><span class="p">:</span>
                    <span class="n">solint</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">valid_factors</span><span class="p">)</span> <span class="o">*</span> <span class="n">int_time</span>
                <span class="c1"># Otherwise, revert to PL2024 heuristic and set solint to a</span>
                <span class="c1"># quarter of the scan time, without forcing to nearest integer</span>
                <span class="c1"># multiple of integration time.</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">inputs</span><span class="o">.</span><span class="n">ms</span><span class="o">.</span><span class="n">basename</span><span class="si">}</span><span class="s2">, intent=</span><span class="si">{</span><span class="n">intent</span><span class="si">}</span><span class="s2">: unable to find optimal number of integrations&quot;</span>
                             <span class="sa">f</span><span class="s2">&quot; within a scan of the SNR requirement; setting the gaincal solint to 1/4 scan time.&quot;</span><span class="p">)</span>
                    <span class="n">solint</span> <span class="o">=</span> <span class="n">scan_time</span> <span class="o">/</span> <span class="mf">4.</span>

        <span class="c1"># Optimal solint determination for all other (i.e. bright) calibrators.</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Set solint to nearest integer multiple of the integration time.</span>
            <span class="n">solint</span> <span class="o">=</span> <span class="n">round_half_up</span><span class="p">(</span><span class="n">req_solint</span> <span class="o">/</span> <span class="n">int_time</span><span class="p">)</span> <span class="o">*</span> <span class="n">int_time</span>

            <span class="c1"># If any of the fields for this bright calibrator are used as the</span>
            <span class="c1"># flux calibrator, then use the lowest allowed integration-time</span>
            <span class="c1"># based SNR limit instead, to minimize the solint and associated</span>
            <span class="c1"># decoherence error that would impact flux scaling (PIPE-2499).</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="s2">&quot;AMPLITUDE&quot;</span> <span class="ow">in</span> <span class="n">f</span><span class="o">.</span><span class="n">intents</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">inputs</span><span class="o">.</span><span class="n">ms</span><span class="o">.</span><span class="n">get_fields</span><span class="p">(</span><span class="n">intent</span><span class="o">=</span><span class="n">intent</span><span class="p">)):</span>
                <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">inputs</span><span class="o">.</span><span class="n">ms</span><span class="o">.</span><span class="n">basename</span><span class="si">}</span><span class="s2">: the optimal solution interval found for intent </span><span class="si">{</span><span class="n">intent</span><span class="si">}</span><span class="s2"> is larger than&quot;</span>
                         <span class="sa">f</span><span class="s2">&quot; &#39;int&#39;, but this intent is shared with the AMPLITUDE intent on at least one field, and the&quot;</span>
                         <span class="sa">f</span><span class="s2">&quot; amplitude calibrator requires the shortest viable solint. Re-computing optimal solint based&quot;</span>
                         <span class="sa">f</span><span class="s2">&quot; on reduced SNR limit of </span><span class="si">{</span><span class="n">inputs</span><span class="o">.</span><span class="n">intphasesnrmin</span><span class="si">}</span><span class="s2"> (&#39;intphasesnrmin&#39;).&quot;</span><span class="p">)</span>

                <span class="c1"># Re-compute the required solint based on re-scaling from</span>
                <span class="c1"># normal integration-time based SNR threshold to the minimum</span>
                <span class="c1"># integration-time based SNR threshold. First, propagate the</span>
                <span class="c1"># SNR scaling from the working &#39;req_solint&#39; (i.e. unrounded)</span>
                <span class="n">req_solint</span> <span class="o">=</span> <span class="n">req_solint</span> <span class="o">*</span> <span class="p">(</span><span class="n">inputs</span><span class="o">.</span><span class="n">intphasesnrmin</span> <span class="o">/</span> <span class="n">inputs</span><span class="o">.</span><span class="n">intphasesnr</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
                <span class="c1"># now round it according to a unit of integration time</span>
                <span class="n">solint</span> <span class="o">=</span> <span class="n">round_half_up</span><span class="p">(</span><span class="n">req_solint</span> <span class="o">/</span> <span class="n">int_time</span><span class="p">)</span> <span class="o">*</span> <span class="n">int_time</span>
                <span class="n">snr_threshold_used</span>  <span class="o">=</span> <span class="n">inputs</span><span class="o">.</span><span class="n">intphasesnrmin</span>

                <span class="c1"># If this adjusted solint after rounding would be at/below the</span>
                <span class="c1"># integration time (i.e. &lt; 1.5 integration time), then return</span>
                <span class="c1"># early with &#39;int&#39; as the optimal solint.</span>
                <span class="k">if</span> <span class="n">solint</span> <span class="o">&lt;</span> <span class="mf">1.5</span> <span class="o">*</span> <span class="n">int_time</span><span class="p">:</span>
                    <span class="k">return</span> <span class="s1">&#39;int&#39;</span><span class="p">,</span> <span class="n">gaintype</span><span class="p">,</span> <span class="n">snr_threshold_used</span>

            <span class="c1"># If the optimal solint exceeds the maximum solint threshold, then</span>
            <span class="c1"># set the final solint to this maximum threshold, rounded to nearest</span>
            <span class="c1"># integer multiple of the integration time.</span>
            <span class="k">if</span> <span class="n">solint</span> <span class="o">&gt;=</span> <span class="n">inputs</span><span class="o">.</span><span class="n">phaseupmaxsolint</span><span class="p">:</span>
                <span class="n">LOG</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">inputs</span><span class="o">.</span><span class="n">ms</span><span class="o">.</span><span class="n">basename</span><span class="si">}</span><span class="s2">, intent=</span><span class="si">{</span><span class="n">intent</span><span class="si">}</span><span class="s2">: optimal solint </span><span class="si">{</span><span class="n">solint</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">s exceeds the maximum&quot;</span>
                            <span class="sa">f</span><span class="s2">&quot; allowed limit of </span><span class="si">{</span><span class="n">inputs</span><span class="o">.</span><span class="n">phaseupmaxsolint</span><span class="si">}</span><span class="s2">s, and will be capped to this limit (rounded&quot;</span>
                            <span class="sa">f</span><span class="s2">&quot; to nearest integer multiple of integration time). Phase-up in subsequent Pipeline stages&quot;</span>
                            <span class="sa">f</span><span class="s2">&quot; will have low solution SNR.&quot;</span><span class="p">)</span>
                <span class="n">solint</span> <span class="o">=</span> <span class="n">round_half_up</span><span class="p">(</span><span class="n">inputs</span><span class="o">.</span><span class="n">phaseupmaxsolint</span> <span class="o">/</span> <span class="n">int_time</span><span class="p">)</span> <span class="o">*</span> <span class="n">int_time</span>

        <span class="c1"># Finally, convert the optimal solint to a string, and use &quot;int&quot; if</span>
        <span class="c1"># the optimal solint was below the integration time.</span>
        <span class="k">if</span> <span class="n">solint</span> <span class="o">&lt;=</span> <span class="n">int_time</span><span class="p">:</span>
            <span class="n">solint</span> <span class="o">=</span> <span class="s1">&#39;int&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">solint</span> <span class="o">=</span> <span class="n">quanta</span><span class="o">.</span><span class="n">tos</span><span class="p">(</span><span class="n">quanta</span><span class="o">.</span><span class="n">quantity</span><span class="p">(</span><span class="n">solint</span><span class="p">,</span> <span class="s1">&#39;s&#39;</span><span class="p">),</span> <span class="mi">3</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">solint</span><span class="p">,</span> <span class="n">gaintype</span><span class="p">,</span> <span class="n">snr_threshold_used</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_unregister_spwphaseup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">inputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span>
        <span class="n">ms</span> <span class="o">=</span> <span class="n">inputs</span><span class="o">.</span><span class="n">ms</span>

        <span class="c1"># predicate function that triggers when the spwphaseup caltable is detected</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">spwphaseup_matcher</span><span class="p">(</span><span class="n">_</span><span class="p">:</span> <span class="n">callibrary</span><span class="o">.</span><span class="n">CalToArgs</span><span class="p">,</span> <span class="n">calfrom</span><span class="p">:</span> <span class="n">callibrary</span><span class="o">.</span><span class="n">CalFrom</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;hifa_spwphaseup&#39;</span> <span class="ow">in</span> <span class="n">calfrom</span><span class="o">.</span><span class="n">gaintable</span>

        <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Temporarily unregistering previous spwphaseup tables while task executes&#39;</span><span class="p">)</span>
        <span class="n">inputs</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">callibrary</span><span class="o">.</span><span class="n">unregister_calibrations</span><span class="p">(</span><span class="n">spwphaseup_matcher</span><span class="p">)</span>

        <span class="c1"># Reset the spwmaps registered in the MS. This will be restored if the</span>
        <span class="c1"># result is not accepted.</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Temporarily resetting spwmaps for </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">ms</span><span class="o">.</span><span class="n">basename</span><span class="p">)</span>
        <span class="n">ms</span><span class="o">.</span><span class="n">spwmaps</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_snr_info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">snr_test_result</span><span class="p">:</span> <span class="n">SNRTestResult</span><span class="p">,</span> <span class="n">combined_snrs</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper method that takes phase SNR info from the SNR test, and returns</span>
<span class="sd">        phase SNR info for all SpWs specified in inputs.spw.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            snr_test_result: SnrTestResult</span>
<span class="sd">                SnrTestResult used as reference source for SNRs per spectral</span>
<span class="sd">                window</span>
<span class="sd">            combined_snrs: dict</span>
<span class="sd">                Dictionary of reference SpWs with list of corresponding</span>
<span class="sd">                combined SpW and combined phase SNR.</span>

<span class="sd">        Returns:</span>
<span class="sd">            List of tuples, specifying string representing SpW(s) and</span>
<span class="sd">            corresponding phase SNR.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">spw_snr</span> <span class="o">=</span> <span class="p">{</span><span class="nb">str</span><span class="p">(</span><span class="n">spw_id</span><span class="p">):</span> <span class="n">snr</span>
                   <span class="k">for</span> <span class="n">spw_id</span><span class="p">,</span> <span class="n">snr</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">snr_test_result</span><span class="o">.</span><span class="n">spw_ids</span><span class="p">,</span> <span class="n">snr_test_result</span><span class="o">.</span><span class="n">snr_values</span><span class="p">)}</span>
        <span class="n">snr_info</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Create entry for each SpW specified by inputs.</span>
        <span class="k">for</span> <span class="n">spwid</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">spw</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">):</span>
            <span class="c1"># If this SpW is the reference SpW for a group of combined SpWs</span>
            <span class="c1"># then add an entry to list the combined SNR.</span>
            <span class="k">if</span> <span class="n">spwid</span> <span class="ow">in</span> <span class="n">combined_snrs</span><span class="p">:</span>
                <span class="n">combined_spws</span> <span class="o">=</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">combined_snrs</span><span class="p">[</span><span class="n">spwid</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">combined_snr</span> <span class="o">=</span> <span class="n">combined_snrs</span><span class="p">[</span><span class="n">spwid</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">snr_info</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="sa">f</span><span class="s1">&#39;Combined (</span><span class="si">{</span><span class="n">combined_spws</span><span class="si">}</span><span class="s1">)&#39;</span><span class="p">,</span> <span class="n">combined_snr</span><span class="p">))</span>

            <span class="c1"># Retrieve SNR info for individual SpW if available.</span>
            <span class="n">snr</span> <span class="o">=</span> <span class="n">spw_snr</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">spwid</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="n">snr_info</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="nb">str</span><span class="p">(</span><span class="n">spwid</span><span class="p">),</span> <span class="n">snr</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">snr_info</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_compute_snr_from_gaincal</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">snr_result</span><span class="p">:</span> <span class="n">SNRTestResult</span><span class="p">,</span>
            <span class="n">field</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
            <span class="n">intent</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
            <span class="n">low_snr_threshold</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">catalogue_snr_multiplier</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">gaintable_snr_multiplier</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Estimates the Signal-to-Noise Ratio (SNR) by generating and analyzing a gaincal</span>
<span class="sd">        calibration table. Updates the SNR values in the provided SnrTestResult object</span>
<span class="sd">        based on the analysis results.</span>

<span class="sd">        This function implements the SNR estimation logic described in PIPE-2505:</span>
<span class="sd">        - For SPWs with SNR below threshold: applies a scaling factor (catalogue_snr_multiplier)</span>
<span class="sd">          to avoid calibration failures</span>
<span class="sd">        - For SPWs with SNR above threshold: computes new SNR estimates using gaincal analysis,</span>
<span class="sd">          applying a scaling factor to the measured values.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            snr_result: SnrTestResult</span>
<span class="sd">                Object containing SNR test results, including spw_ids and snr_values that</span>
<span class="sd">                will be updated based on the analysis.</span>
<span class="sd">            field: str</span>
<span class="sd">                Field identifier to use for the gaincal calculation.</span>
<span class="sd">            intent: str</span>
<span class="sd">                Intent identifier to use for the gaincal calculation.</span>
<span class="sd">            low_snr_threshold: float, optional</span>
<span class="sd">                Threshold below which SPWs are considered low SNR and gaincal is not attempted.</span>
<span class="sd">                Default is -1 (corresponds to &#39;X&#39; in PIPE-2505), forcing gaincal</span>
<span class="sd">                for all SPWs.</span>
<span class="sd">            catalogue_snr_multiplier: float, optional</span>
<span class="sd">                Scaling factor applied to SNR values derived from the flux catalogue.</span>
<span class="sd">                Default is 0.75 (corresponds to &#39;Y&#39; in PIPE-2505).</span>
<span class="sd">            gaintable_snr_multiplier: float, optional</span>
<span class="sd">                Scaling factor applied to SNR values measured from the temporary gaintable.</span>
<span class="sd">                Default is 1.0 (corresponds to &#39;Z&#39; in PIPE-2505).</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">                The function updates the snr_result object in place.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">snr_result</span><span class="o">.</span><span class="n">has_no_snrs</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="c1"># these variables can&#39;t be arg defaults as it would make them impossible to change post-import</span>
        <span class="k">if</span> <span class="n">low_snr_threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">low_snr_threshold</span> <span class="o">=</span> <span class="n">LOW_SNR_THRESHOLD</span>
        <span class="k">if</span> <span class="n">catalogue_snr_multiplier</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">catalogue_snr_multiplier</span> <span class="o">=</span> <span class="n">CATALOGUE_SNR_MULTIPLIER</span>
        <span class="k">if</span> <span class="n">gaintable_snr_multiplier</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">gaintable_snr_multiplier</span> <span class="o">=</span> <span class="n">GAINTABLE_SNR_MULTIPLIER</span>

        <span class="c1"># dict to map spw IDs to corrected SNR values</span>
        <span class="n">snr_corrections</span> <span class="o">=</span> <span class="p">{</span><span class="n">spw_id</span><span class="p">:</span> <span class="n">snr</span> <span class="k">for</span> <span class="n">spw_id</span><span class="p">,</span> <span class="n">snr</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">snr_result</span><span class="o">.</span><span class="n">spw_ids</span><span class="p">,</span> <span class="n">snr_result</span><span class="o">.</span><span class="n">snr_values</span><span class="p">)</span>
                           <span class="k">if</span> <span class="n">snr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">}</span>

        <span class="c1"># identify spws above/below the low-SNR threshold (=&#39;X&#39; in PIPE-2505 spec)</span>
        <span class="n">low_snr_spws</span><span class="p">,</span> <span class="n">high_snr_spws</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_classify_spws_by_snr</span><span class="p">(</span><span class="n">snr_corrections</span><span class="p">,</span> <span class="n">low_snr_threshold</span><span class="p">)</span>

        <span class="c1"># running gaincal minsnr=2 would result in failure for low-SNR spws. For these</span>
        <span class="c1"># low-SNR spws, set the estimated SNR to Y * SNR</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_snr_for_low_snr_spws</span><span class="p">(</span><span class="n">snr_corrections</span><span class="p">,</span> <span class="n">low_snr_spws</span><span class="p">,</span> <span class="n">low_snr_threshold</span><span class="p">,</span> <span class="n">catalogue_snr_multiplier</span><span class="p">)</span>

        <span class="c1"># For the remaining high SNR windows, generate a G caltable and set the</span>
        <span class="c1"># estimated SNR to Z * median SNR, as measured from the caltable</span>
        <span class="k">if</span> <span class="n">high_snr_spws</span><span class="p">:</span>
            <span class="n">caltable_filename</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_generate_gain_caltable</span><span class="p">(</span><span class="n">field</span><span class="p">,</span> <span class="n">intent</span><span class="p">,</span> <span class="n">high_snr_spws</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_snr_for_high_snr_spws</span><span class="p">(</span><span class="n">snr_corrections</span><span class="p">,</span> <span class="n">high_snr_spws</span><span class="p">,</span> <span class="n">caltable_filename</span><span class="p">,</span> <span class="n">gaintable_snr_multiplier</span><span class="p">)</span>

        <span class="n">snr_limit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_snr_limit_for_intent</span><span class="p">(</span><span class="n">intent</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_snr_result</span><span class="p">(</span><span class="n">snr_result</span><span class="p">,</span> <span class="n">snr_corrections</span><span class="p">,</span> <span class="n">snr_limit</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_snr_limit_for_intent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">intent</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determines the appropriate signal-to-noise ratio (SNR) limit based on the given intent.</span>

<span class="sd">        The method compares the provided intent with a predefined set of weak calibrator</span>
<span class="sd">        intents to decide which SNR limit should be applied.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            intent (str): the intent to evaluate</span>

<span class="sd">        Returns:</span>
<span class="sd">            float: the applicable SNR limit based on the provided intent.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">phasesnr</span> <span class="k">if</span> <span class="n">intent</span> <span class="ow">in</span> <span class="n">WEAK_CALIBRATOR_INTENTS</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">intphasesnr</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_classify_spws_by_snr</span><span class="p">(</span><span class="n">snr_corrections</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span> <span class="n">threshold</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">set</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">set</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Classifies spectral windows (SPWs) into two sets based on their Signal-to-Noise</span>
<span class="sd">        Ratio (SNR) compared to a provided threshold. This method identifies and</span>
<span class="sd">        categorizes SPWs with low SNR and high SNR, returning them as two separate sets.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            snr_corrections (dict[int, float]): A dictionary mapping SPW IDs to their</span>
<span class="sd">                corresponding SNR values.</span>
<span class="sd">            threshold (float): The SNR threshold for classification. SPWs with SNRs</span>
<span class="sd">                lower than this value are categorized as low SNR, while the rest are</span>
<span class="sd">                categorized as high SNR.</span>

<span class="sd">        Returns:</span>
<span class="sd">            tuple[set[int], set[int]]: A tuple containing two sets:</span>
<span class="sd">                - The first set contains the SPW IDs of SPWs with SNR lower than the</span>
<span class="sd">                  threshold (low SNR).</span>
<span class="sd">                - The second set contains the SPW IDs of SPWs with SNR equal to or</span>
<span class="sd">                  higher than the threshold (high SNR).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">low_snr_spws</span> <span class="o">=</span> <span class="p">{</span><span class="n">spw_id</span> <span class="k">for</span> <span class="n">spw_id</span><span class="p">,</span> <span class="n">snr</span> <span class="ow">in</span> <span class="n">snr_corrections</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">snr</span> <span class="o">&lt;</span> <span class="n">threshold</span><span class="p">}</span>
        <span class="n">high_snr_spws</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">snr_corrections</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">-</span> <span class="n">low_snr_spws</span>
        <span class="k">return</span> <span class="n">low_snr_spws</span><span class="p">,</span> <span class="n">high_snr_spws</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_update_snr_for_low_snr_spws</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">snr_corrections</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
            <span class="n">low_snr_spws</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
            <span class="n">threshold</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
            <span class="n">multiplier</span><span class="p">:</span> <span class="nb">float</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Handles low signal-to-noise ratio (SNR) spectral windows (spws) by applying a</span>
<span class="sd">        multiplier to their SNR values. This method modifies the provided</span>
<span class="sd">        `snr_corrections` dictionary in place.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            snr_corrections (dict[int, float]): A dictionary mapping spw IDs to their</span>
<span class="sd">                SNR values. The SNR values are updated for spws that meet the low-SNR</span>
<span class="sd">                condition.</span>
<span class="sd">            low_snr_spws (set[int]): A set of spw IDs that are identified as having</span>
<span class="sd">                low SNR values (below the threshold).</span>
<span class="sd">            threshold (float): The SNR threshold used for identifying spws as low-SNR</span>
<span class="sd">                spws.</span>
<span class="sd">            multiplier (float): The multiplication factor applied to the SNR values of</span>
<span class="sd">                low-SNR spws.</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">spw_id</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">low_snr_spws</span><span class="p">):</span>
            <span class="n">old_snr</span> <span class="o">=</span> <span class="n">snr_corrections</span><span class="p">[</span><span class="n">spw_id</span><span class="p">]</span>
            <span class="n">snr_corrections</span><span class="p">[</span><span class="n">spw_id</span><span class="p">]</span> <span class="o">*=</span> <span class="n">multiplier</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Estimated SNR for </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">vis</span><span class="si">}</span><span class="s2"> spw </span><span class="si">{</span><span class="n">spw_id</span><span class="si">}</span><span class="s2"> is below threshold &quot;</span>
                     <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">threshold</span><span class="si">}</span><span class="s2">. Skipping gaincal; setting SNR for combine heuristics to &quot;</span>
                     <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">snr_corrections</span><span class="p">[</span><span class="n">spw_id</span><span class="p">]</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="n">multiplier</span><span class="si">}</span><span class="s2"> * </span><span class="si">{</span><span class="n">old_snr</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_generate_gain_caltable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">field</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">intent</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">high_snr_spws</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates a gain caltable for high SNR spectral windows.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            field (str): The field to calibrate.</span>
<span class="sd">            intent (str): The scan intent to process</span>
<span class="sd">            high_snr_spws (set[int]): A set of spectral window indices with high</span>
<span class="sd">                signal-to-noise ratios</span>

<span class="sd">        Returns:</span>
<span class="sd">            filename (str): The name of the generated gain caltable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">solint</span> <span class="o">=</span> <span class="s1">&#39;inf&#39;</span> <span class="k">if</span> <span class="n">intent</span> <span class="ow">in</span> <span class="n">WEAK_CALIBRATOR_INTENTS</span> <span class="k">else</span> <span class="s1">&#39;int&#39;</span>

        <span class="n">inputs</span> <span class="o">=</span> <span class="n">GTypeGaincalInputs</span><span class="p">(</span>
            <span class="n">context</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">context</span><span class="p">,</span>
            <span class="n">vis</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">vis</span><span class="p">,</span>
            <span class="n">field</span><span class="o">=</span><span class="n">field</span><span class="p">,</span>
            <span class="n">intent</span><span class="o">=</span><span class="n">intent</span><span class="p">,</span>
            <span class="c1"># note: we only select the high SNR spws here</span>
            <span class="n">spw</span><span class="o">=</span><span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">high_snr_spws</span><span class="p">))),</span>
            <span class="n">calmode</span><span class="o">=</span><span class="s1">&#39;p&#39;</span><span class="p">,</span>
            <span class="n">solint</span><span class="o">=</span><span class="n">solint</span><span class="p">,</span>
            <span class="n">minsnr</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="n">append</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">task</span> <span class="o">=</span> <span class="n">GTypeGaincal</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>
        <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_executor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">inputs</span><span class="o">.</span><span class="n">caltable</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_update_snr_for_high_snr_spws</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">snr_corrections</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
            <span class="n">high_snr_spws</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
            <span class="n">caltable_filename</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
            <span class="n">multiplier</span><span class="p">:</span> <span class="nb">float</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Processes high Signal-to-Noise Ratio (SNR) spectral windows (spws) and updates</span>
<span class="sd">        the SNR corrections dictionary with computed or default values based on the</span>
<span class="sd">        filtered calibrated table data.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            snr_corrections (dict[int, float]): A dictionary to store SNR corrections</span>
<span class="sd">                for each spectral window where the keys are the spectral window IDs,</span>
<span class="sd">                and the values are the corresponding corrections.</span>
<span class="sd">            high_snr_spws (set[int]): A set containing IDs of the spectral windows</span>
<span class="sd">                determined to have high SNR values.</span>
<span class="sd">            caltable_filename (str): filename of the caltable to analyse</span>
<span class="sd">            multiplier (float): A multiplier factor applied to the median SNR values</span>
<span class="sd">                for applying a scaling adjustment to the estimated SNR.</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">                This function updates the snr_corrections dict in place.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">caltable</span> <span class="o">=</span> <span class="n">CaltableWrapperFactory</span><span class="o">.</span><span class="n">from_caltable</span><span class="p">(</span><span class="n">caltable_filename</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">OSError</span><span class="p">:</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Caltable for </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">vis</span><span class="si">}</span><span class="s1"> is missing, most likely due to zero&#39;</span>
                     <span class="sa">f</span><span class="s1">&#39;solutions. Estimated SNR set to zero for all spws.&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">spw_id</span> <span class="ow">in</span> <span class="n">high_snr_spws</span><span class="p">:</span>
                <span class="n">snr_corrections</span><span class="p">[</span><span class="n">spw_id</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">return</span>

        <span class="k">for</span> <span class="n">spw</span> <span class="ow">in</span> <span class="n">high_snr_spws</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">snr_data</span> <span class="o">=</span> <span class="n">caltable</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">spw</span><span class="o">=</span><span class="n">spw</span><span class="p">)</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;SNR&#39;</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;No SNR data present in temporary gain table for </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">vis</span><span class="si">}</span><span class="s1"> &#39;</span>
                         <span class="sa">f</span><span class="s1">&#39;spw </span><span class="si">{</span><span class="n">spw</span><span class="si">}</span><span class="s1">. Setting estimated SNR to zero.&#39;</span><span class="p">)</span>
                <span class="n">snr_corrections</span><span class="p">[</span><span class="n">spw</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">continue</span>

            <span class="c1"># Get number of correlations for this SpW.</span>
            <span class="n">corr_type</span> <span class="o">=</span> <span class="n">commonhelpermethods</span><span class="o">.</span><span class="n">get_corr_products</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">ms</span><span class="p">,</span> <span class="n">spw</span><span class="p">)</span>
            <span class="n">ncorrs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">corr_type</span><span class="p">)</span>
            <span class="n">is_single_polarisation</span> <span class="o">=</span> <span class="n">ncorrs</span> <span class="o">==</span> <span class="mi">1</span>

            <span class="k">if</span> <span class="n">is_single_polarisation</span><span class="p">:</span>
                <span class="c1"># For single pol, one column will be populated with zeroes or nulls.</span>
                <span class="c1"># Identify which column holds data for the median SNR calculation</span>
                <span class="n">idx_for_pol</span> <span class="o">=</span> <span class="n">commonhelpermethods</span><span class="o">.</span><span class="n">get_pol_id</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">ms</span><span class="p">,</span> <span class="n">spw</span><span class="p">,</span> <span class="n">corr_type</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="c1"># note the use of numpy.median over numpy.ma.median: we WANT to include</span>
                <span class="c1"># the masked/flagged values in the median calculation. To avoid triggering</span>
                <span class="c1"># the UserWarning that results from operating on a masked array, we operate</span>
                <span class="c1"># on data</span>
                <span class="c1"># See https://open-jira.nrao.edu/browse/PIPE-2505?focusedId=237663&amp;page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-237663</span>
                <span class="n">median_snr</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">snr_data</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span> <span class="n">idx_for_pol</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># otherwise, calculate the median over all pols. As obove, including masked values</span>
                <span class="n">median_snr</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">snr_data</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">median_snr</span> <span class="ow">in</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">nan</span><span class="p">):</span>
                <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;No valid data in temporary gain table for </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">vis</span><span class="si">}</span><span class="s1"> &#39;</span>
                         <span class="sa">f</span><span class="s1">&#39;spw </span><span class="si">{</span><span class="n">spw</span><span class="si">}</span><span class="s1">. Setting estimated SNR to zero.&#39;</span><span class="p">)</span>
                <span class="n">snr_corrections</span><span class="p">[</span><span class="n">spw</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">snr_corrections</span><span class="p">[</span><span class="n">spw</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">median_snr</span> <span class="o">*</span> <span class="n">multiplier</span><span class="p">)</span>
                <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Based on a temporary gain table, calculated SNR for </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">vis</span><span class="si">}</span><span class="s1"> &#39;</span>
                         <span class="sa">f</span><span class="s1">&#39;spw </span><span class="si">{</span><span class="n">spw</span><span class="si">}</span><span class="s1"> = </span><span class="si">{</span><span class="n">median_snr</span><span class="si">:</span><span class="s1">.3f</span><span class="si">}</span><span class="s1">. Setting SNR for combine heuristics to &#39;</span>
                         <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">snr_corrections</span><span class="p">[</span><span class="n">spw</span><span class="p">]</span><span class="si">:</span><span class="s1">.3f</span><span class="si">}</span><span class="s1"> = </span><span class="si">{</span><span class="n">multiplier</span><span class="si">}</span><span class="s1"> * </span><span class="si">{</span><span class="n">median_snr</span><span class="si">:</span><span class="s1">.3f</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_update_snr_result</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">snr_result</span><span class="p">:</span> <span class="n">SNRTestResult</span><span class="p">,</span> <span class="n">snr_corrections</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span> <span class="n">snr_limit</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Updates the snr_result object with corrected SNR values based on the given</span>
<span class="sd">        snr_corrections. The function maps each spectral window&#39;s (SPW) ID from</span>
<span class="sd">        snr_result to a corrected SNR value using the snr_corrections dictionary. If</span>
<span class="sd">        no correction is found for a particular SPW ID, the original SNR value is</span>
<span class="sd">        retained.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            snr_result (SNRTestResult): An object of type SnrTestResult. It contains</span>
<span class="sd">                the SPW IDs and their corresponding SNR values to be updated.</span>
<span class="sd">            snr_corrections (dict[int, float]): A dictionary mapping SPW IDs (int) to</span>
<span class="sd">                corrected SNR values (float).</span>
<span class="sd">            snr_limit (float): The SNR threshold used to identify spws with acceptable</span>
<span class="sd">                SNR.</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_snrs</span> <span class="o">=</span> <span class="p">[</span><span class="n">snr_corrections</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">spw</span><span class="p">,</span> <span class="n">snr</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">spw</span><span class="p">,</span> <span class="n">snr</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">snr_result</span><span class="o">.</span><span class="n">spw_ids</span><span class="p">,</span> <span class="n">snr_result</span><span class="o">.</span><span class="n">snr_values</span><span class="p">)]</span>

        <span class="c1"># recompute good_snrs and has_no_snrs as they are used as triggers in the mapping process</span>
        <span class="n">good_snrs</span> <span class="o">=</span> <span class="p">[</span><span class="n">snr</span> <span class="o">&gt;=</span> <span class="n">snr_limit</span> <span class="k">for</span> <span class="n">snr</span> <span class="ow">in</span> <span class="n">new_snrs</span><span class="p">]</span>

        <span class="n">snr_result</span><span class="o">.</span><span class="n">snr_values</span> <span class="o">=</span> <span class="n">new_snrs</span>
        <span class="n">snr_result</span><span class="o">.</span><span class="n">is_good_snr</span> <span class="o">=</span> <span class="n">good_snrs</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_process_combined_snrs</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">snr_result</span><span class="p">:</span> <span class="n">SNRTestResult</span><span class="p">,</span>
            <span class="n">calc_snr_result</span><span class="p">:</span> <span class="n">SNRTestResult</span><span class="p">,</span>
            <span class="n">spwmap</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">float</span><span class="p">]],</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">float</span><span class="p">]]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Process SNR results for combined spws for both empirical and catalogue SNRs</span>
<span class="sd">        using the same spwmap.</span>

<span class="sd">        Args:</span>
<span class="sd">            snr_result: SNRTestResult object containing empirical SNR values</span>
<span class="sd">            calc_snr_result: SNRTestResult object containing catalogue SNR values</span>
<span class="sd">            spwmap: list representing spectral window mapping</span>

<span class="sd">        Returns:</span>
<span class="sd">            tuple: (combined_snrs, calc_combined_snrs) containing the combined SNR results</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">combined_snrs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_do_combined_snr_test</span><span class="p">(</span>
            <span class="n">snr_result</span><span class="o">.</span><span class="n">spw_ids</span><span class="p">,</span>
            <span class="n">snr_result</span><span class="o">.</span><span class="n">snr_values</span><span class="p">,</span>
            <span class="n">spwmap</span>
        <span class="p">)</span>

        <span class="n">calc_combined_snrs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_do_combined_snr_test</span><span class="p">(</span>
            <span class="n">calc_snr_result</span><span class="o">.</span><span class="n">spw_ids</span><span class="p">,</span>
            <span class="n">calc_snr_result</span><span class="o">.</span><span class="n">snr_values</span><span class="p">,</span>
            <span class="n">spwmap</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">combined_snrs</span><span class="p">,</span> <span class="n">calc_combined_snrs</span></div>



<span class="k">class</span><span class="w"> </span><span class="nc">SpwPhaseupResults</span><span class="p">(</span><span class="n">basetask</span><span class="o">.</span><span class="n">Results</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vis</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">phasecal_mapping</span><span class="p">:</span> <span class="n">Dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">phaseup_result</span><span class="p">:</span> <span class="n">GaincalResults</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">snr_info</span><span class="p">:</span> <span class="n">Dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">spwmaps</span><span class="p">:</span> <span class="n">Dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">unregister_existing</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                 <span class="n">phaserms_totaltime</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">phaserms_cycletime</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">phaserms_results</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">phaserms_antout</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialise the phaseup spw mapping results object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">spwmaps</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">spwmaps</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">phaserms_antout</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">phaserms_antout</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">vis</span> <span class="o">=</span> <span class="n">vis</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">phasecal_mapping</span> <span class="o">=</span> <span class="n">phasecal_mapping</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">phaseup_result</span> <span class="o">=</span> <span class="n">phaseup_result</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">snr_info</span> <span class="o">=</span> <span class="n">snr_info</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spwmaps</span> <span class="o">=</span> <span class="n">spwmaps</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unregister_existing</span> <span class="o">=</span> <span class="n">unregister_existing</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">phaserms_totaltime</span> <span class="o">=</span> <span class="n">phaserms_totaltime</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">phaserms_cycletime</span> <span class="o">=</span> <span class="n">phaserms_cycletime</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">phaserms_results</span> <span class="o">=</span> <span class="n">phaserms_results</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">phaserms_antout</span> <span class="o">=</span> <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">phaserms_antout</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">merge_with_context</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39; No results to merge &#39;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">phaseup_result</span><span class="o">.</span><span class="n">final</span><span class="p">:</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39; No results to merge &#39;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="c1"># PIPE-629: if requested, unregister previous spwphaseup caltables from</span>
        <span class="c1"># the context before merging in the newly derived caltable.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">unregister_existing</span><span class="p">:</span>
            <span class="c1"># Identify the MS to process</span>
            <span class="n">vis</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vis</span><span class="p">)</span>

            <span class="c1"># predicate function that triggers when the spwphaseup caltable is</span>
            <span class="c1"># detected for this MS</span>
            <span class="k">def</span><span class="w"> </span><span class="nf">spwphaseup_matcher</span><span class="p">(</span><span class="n">calto</span><span class="p">:</span> <span class="n">callibrary</span><span class="o">.</span><span class="n">CalToArgs</span><span class="p">,</span> <span class="n">calfrom</span><span class="p">:</span> <span class="n">callibrary</span><span class="o">.</span><span class="n">CalFrom</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
                <span class="n">calto_vis</span> <span class="o">=</span> <span class="p">{</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">calto</span><span class="o">.</span><span class="n">vis</span><span class="p">}</span>
                <span class="n">do_delete</span> <span class="o">=</span> <span class="s1">&#39;hifa_spwphaseup&#39;</span> <span class="ow">in</span> <span class="n">calfrom</span><span class="o">.</span><span class="n">gaintable</span> <span class="ow">and</span> <span class="n">vis</span> <span class="ow">in</span> <span class="n">calto_vis</span>
                <span class="k">if</span> <span class="n">do_delete</span><span class="p">:</span>
                    <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Unregistering previous spwphaseup tables for </span><span class="si">{</span><span class="n">vis</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">do_delete</span>

            <span class="n">context</span><span class="o">.</span><span class="n">callibrary</span><span class="o">.</span><span class="n">unregister_calibrations</span><span class="p">(</span><span class="n">spwphaseup_matcher</span><span class="p">)</span>

        <span class="c1"># Merge the spw phaseup offset table</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">phaseup_result</span><span class="o">.</span><span class="n">merge_with_context</span><span class="p">(</span><span class="n">context</span><span class="p">)</span>

        <span class="n">ms</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">observing_run</span><span class="o">.</span><span class="n">get_ms</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">vis</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ms</span><span class="p">:</span>
            <span class="c1"># Merge the spectral window mappings.</span>
            <span class="n">ms</span><span class="o">.</span><span class="n">spwmaps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spwmaps</span>

            <span class="c1"># Merge the phase calibrator mapping.</span>
            <span class="n">ms</span><span class="o">.</span><span class="n">phasecal_mapping</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">phasecal_mapping</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vis</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">phaseup_result</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="s1">&#39;SpwPhaseupResults:</span><span class="se">\n</span><span class="s1">&#39;</span>
                    <span class="s1">&#39;</span><span class="se">\t</span><span class="s1">No spw phaseup table computed&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;SpwPhaseupResults:</span><span class="se">\n</span><span class="s1">vis=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">vis</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">intent</span><span class="p">,</span> <span class="n">field</span><span class="p">),</span> <span class="n">spwmapping</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spwmaps</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">s</span> <span class="o">+=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="se">\t</span><span class="si">{</span><span class="n">intent</span><span class="si">}</span><span class="s1">, </span><span class="si">{</span><span class="n">field</span><span class="si">}</span><span class="s1">:</span><span class="se">\n</span><span class="s1">&#39;</span>
                <span class="n">s</span> <span class="o">+=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="se">\t\t</span><span class="s1">Combine = </span><span class="si">{</span><span class="n">spwmapping</span><span class="o">.</span><span class="n">combine</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span>
                <span class="n">s</span> <span class="o">+=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="se">\t\t</span><span class="s1">Spwmap = </span><span class="si">{</span><span class="n">spwmapping</span><span class="o">.</span><span class="n">spwmap</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span>
                <span class="n">s</span> <span class="o">+=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="se">\t\t</span><span class="s1">Solint = </span><span class="si">{</span><span class="n">spwmapping</span><span class="o">.</span><span class="n">solint</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span>
                <span class="n">s</span> <span class="o">+=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="se">\t\t</span><span class="s1">Gaintype = </span><span class="si">{</span><span class="n">spwmapping</span><span class="o">.</span><span class="n">gaintype</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span>
            <span class="k">return</span> <span class="n">s</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020–2025, Pipeline Dev. Team, build: 2025.1.1.56+247-g51f7e999a3-update-docs-build-and-packaging-setup.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>