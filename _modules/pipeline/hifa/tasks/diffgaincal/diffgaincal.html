

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>pipeline.hifa.tasks.diffgaincal.diffgaincal &mdash; Pipeline 
 (2025.1.1.56) 2025.1.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../../../_static/mystnb.8ecb98da25f57f5357bf6f572d296f466b2cfe2517ffebfabe82451661e28f02.css" />
      <link rel="stylesheet" type="text/css" href="../../../../../_static/graphviz.css?v=4ae1632d" />
      <link rel="stylesheet" type="text/css" href="../../../../../_static/sphinx_astrorefs.css?v=4d4a2fdb" />
      <link rel="stylesheet" type="text/css" href="../../../../../_static/copybutton.css?v=76b2166b" />
      <link rel="stylesheet" type="text/css" href="../../../../../_static/custom_theme.css?v=047bd54c" />

  
    <link rel="shortcut icon" href="../../../../../_static/favicon-16x16.png"/>
      <script src="../../../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../../../_static/documentation_options.js?v=e72a64b0"></script>
      <script src="../../../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="../../../../../_static/clipboard.min.js?v=a7894cd8"></script>
      <script src="../../../../../_static/copybutton.js?v=0729d509"></script>
      <script type="module" src="https://cdn.jsdelivr.net/npm/mermaid@11.12.1/dist/mermaid.esm.min.mjs"></script>
      <script type="module" src="https://cdn.jsdelivr.net/npm/@mermaid-js/layout-elk@0.2.0/dist/mermaid-layout-elk.esm.min.mjs"></script>
      <script type="module">import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@11.12.1/dist/mermaid.esm.min.mjs";import elkLayouts from "https://cdn.jsdelivr.net/npm/@mermaid-js/layout-elk@0.2.0/dist/mermaid-layout-elk.esm.min.mjs";mermaid.registerLayoutLoaders(elkLayouts);mermaid.initialize({startOnLoad:false});</script>
      <script src="https://cdn.jsdelivr.net/npm/d3@7.9.0/dist/d3.min.js"></script>
      <script type="module">import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@11.12.1/dist/mermaid.esm.min.mjs";

const defaultStyle = document.createElement('style');
defaultStyle.textContent = `pre.mermaid {
    /* Same as .mermaid-container > pre */
    display: block;
    width: 100%;
}

pre.mermaid > svg {
    /* Same as .mermaid-container > pre > svg */
    height: 500px;
    width: 100%;
    max-width: 100% !important;
}
`;
document.head.appendChild(defaultStyle);

const fullscreenStyle = document.createElement('style');
fullscreenStyle.textContent = `.mermaid-container {
    display: flex;
    flex-direction: row;
    width: 100%;
}

.mermaid-container > pre {
    display: block;
    width: 100%;
}

.mermaid-container > pre > svg {
    height: 500px;
    width: 100%;
    max-width: 100% !important;
}

.mermaid-fullscreen-btn {
    width: 28px;
    height: 28px;
    background: rgba(255, 255, 255, 0.95);
    border: 1px solid rgba(0, 0, 0, 0.3);
    border-radius: 4px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s;
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
    font-size: 14px;
    line-height: 1;
    padding: 0;
    color: #333;
}

.mermaid-fullscreen-btn:hover {
    opacity: 100% !important;
    background: rgba(255, 255, 255, 1);
    box-shadow: 0 3px 10px rgba(0, 0, 0, 0.3);
    transform: scale(1.1);
}

.mermaid-fullscreen-btn.dark-theme {
    background: rgba(50, 50, 50, 0.95);
    border: 1px solid rgba(255, 255, 255, 0.3);
    color: #e0e0e0;
}

.mermaid-fullscreen-btn.dark-theme:hover {
    background: rgba(60, 60, 60, 1);
    box-shadow: 0 3px 10px rgba(255, 255, 255, 0.2);
}

.mermaid-fullscreen-modal {
    display: none;
    position: fixed !important;
    top: 0 !important;
    left: 0 !important;
    width: 95vw;
    height: 100vh;
    background: rgba(255, 255, 255, 0.98);
    z-index: 9999;
    padding: 20px;
    overflow: auto;
}

.mermaid-fullscreen-modal.dark-theme {
    background: rgba(0, 0, 0, 0.98);
}

.mermaid-fullscreen-modal.active {
    display: flex;
    align-items: center;
    justify-content: center;
}

.mermaid-container-fullscreen {
    position: relative;
    width: 95vw;
    height: 90vh;
    max-width: 95vw;
    max-height: 90vh;
    background: white;
    border-radius: 8px;
    padding: 20px;
    box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
    overflow: auto;
    display: flex;
    align-items: center;
    justify-content: center;
}

.mermaid-container-fullscreen.dark-theme {
    background: #1a1a1a;
    box-shadow: 0 10px 40px rgba(0, 0, 0, 0.8);
}

.mermaid-container-fullscreen pre.mermaid {
    width: 100%;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
}

.mermaid-container-fullscreen .mermaid svg {
    height: 100% !important;
    width: 100% !important;
    cursor: grab;
}

.mermaid-fullscreen-close {
    position: fixed !important;
    top: 20px !important;
    right: 20px !important;
    width: 40px;
    height: 40px;
    background: rgba(255, 255, 255, 0.95);
    border: 1px solid rgba(0, 0, 0, 0.2);
    border-radius: 50%;
    cursor: pointer;
    z-index: 10000;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    transition: all 0.2s;
    font-size: 24px;
    line-height: 1;
    color: #333;
}

.mermaid-fullscreen-close:hover {
    background: white;
    box-shadow: 0 6px 16px rgba(0, 0, 0, 0.4);
    transform: scale(1.1);
}

.mermaid-fullscreen-close.dark-theme {
    background: rgba(50, 50, 50, 0.95);
    border: 1px solid rgba(255, 255, 255, 0.2);
    color: #e0e0e0;
}

.mermaid-fullscreen-close.dark-theme:hover {
    background: rgba(60, 60, 60, 1);
    box-shadow: 0 6px 16px rgba(255, 255, 255, 0.2);
}

.mermaid-fullscreen-modal .mermaid-fullscreen-btn {
    display: none !important;
}`;
document.head.appendChild(fullscreenStyle);

// Detect if page has dark background
const isDarkTheme = () => {
    const bgColor = window.getComputedStyle(document.body).backgroundColor;
    const match = bgColor.match(/rgb\((\d+),\s*(\d+),\s*(\d+)/);
    if (match) {
        const r = parseInt(match[1]);
        const g = parseInt(match[2]);
        const b = parseInt(match[3]);
        const brightness = (r * 299 + g * 587 + b * 114) / 1000;
        return brightness < 128;
    }
    return false;
};

const load = async () => {
    await mermaid.run();

    const all_mermaids = document.querySelectorAll(".mermaid");
    const mermaids_processed = document.querySelectorAll(".mermaid[data-processed='true']");

    if ("True" === "True") {
        const mermaids_to_add_zoom = -1 === -1 ? all_mermaids.length : -1;
        if(mermaids_to_add_zoom > 0) {
            var svgs = d3.selectAll(".mermaid svg");
            if(all_mermaids.length !== mermaids_processed.length) {
                setTimeout(load, 200);
                return;
            } else if(svgs.size() !== mermaids_to_add_zoom) {
                setTimeout(load, 200);
                return;
            } else {
                svgs.each(function() {
                    var svg = d3.select(this);
                    svg.html("<g class='wrapper'>" + svg.html() + "</g>");
                    var inner = svg.select("g");
                    var zoom = d3.zoom().on("zoom", function(event) {
                        inner.attr("transform", event.transform);
                    });
                    svg.call(zoom);
                });
            }
        }
    } else if(all_mermaids.length !== mermaids_processed.length) {
        // Wait for mermaid to process all diagrams
        setTimeout(load, 200);
        return;
    }

    const darkTheme = isDarkTheme();

    // Stop here if not adding fullscreen capability
    if ("True" !== "True") return;

    const modal = document.createElement('div');
    modal.className = 'mermaid-fullscreen-modal' + (darkTheme ? ' dark-theme' : '');
    modal.setAttribute('role', 'dialog');
    modal.setAttribute('aria-modal', 'true');
    modal.setAttribute('aria-label', 'Fullscreen diagram viewer');
    modal.innerHTML = `
        <button class="mermaid-fullscreen-close${darkTheme ? ' dark-theme' : ''}" aria-label="Close fullscreen">✕</button>
        <div class="mermaid-container-fullscreen${darkTheme ? ' dark-theme' : ''}"></div>
    `;
    document.body.appendChild(modal);

    const modalContent = modal.querySelector('.mermaid-container-fullscreen');
    const closeBtn = modal.querySelector('.mermaid-fullscreen-close');

    let previousScrollOffset = [window.scrollX, window.scrollY];

    const closeModal = () => {
        modal.classList.remove('active');
        modalContent.innerHTML = '';
        document.body.style.overflow = ''
        window.scrollTo({left: previousScrollOffset[0], top: previousScrollOffset[1], behavior: 'instant'});
    };

    closeBtn.addEventListener('click', closeModal);
    modal.addEventListener('click', (e) => {
        if (e.target === modal) closeModal();
    });
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && modal.classList.contains('active')) {
            closeModal();
        }
    });

    const allButtons = [];

    document.querySelectorAll('.mermaid').forEach((mermaidDiv) => {
        if (mermaidDiv.parentNode.classList.contains('mermaid-container') ||
            mermaidDiv.closest('.mermaid-fullscreen-modal')) {
            return;
        }

        const container = document.createElement('div');
        container.className = 'mermaid-container';
        mermaidDiv.parentNode.insertBefore(container, mermaidDiv);
        container.appendChild(mermaidDiv);

        const fullscreenBtn = document.createElement('button');
        fullscreenBtn.className = 'mermaid-fullscreen-btn' + (darkTheme ? ' dark-theme' : '');
        fullscreenBtn.setAttribute('aria-label', 'View diagram in fullscreen');
        fullscreenBtn.textContent = '⛶';
        fullscreenBtn.style.opacity = '50%';

        // Calculate dynamic position based on diagram's margin and padding
        const diagramStyle = window.getComputedStyle(mermaidDiv);
        const marginTop = parseFloat(diagramStyle.marginTop) || 0;
        const marginRight = parseFloat(diagramStyle.marginRight) || 0;
        const paddingTop = parseFloat(diagramStyle.paddingTop) || 0;
        const paddingRight = parseFloat(diagramStyle.paddingRight) || 0;
        fullscreenBtn.style.top = `${marginTop + paddingTop + 4}px`;
        fullscreenBtn.style.right = `${marginRight + paddingRight + 4}px`;

        fullscreenBtn.addEventListener('click', () => {
            previousScrollOffset = [window.scroll, window.scrollY];
            const clone = mermaidDiv.cloneNode(true);
            modalContent.innerHTML = '';
            modalContent.appendChild(clone);

            const svg = clone.querySelector('svg');
            if (svg) {
                svg.removeAttribute('width');
                svg.removeAttribute('height');
                svg.style.width = '100%';
                svg.style.height = 'auto';
                svg.style.maxWidth = '100%';
                svg.style.sdisplay = 'block';

                if ("True" === "True") {
                    setTimeout(() => {
                        const g = svg.querySelector('g');
                        if (g) {
                            var svgD3 = d3.select(svg);
                            svgD3.html("<g class='wrapper'>" + svgD3.html() + "</g>");
                            var inner = svgD3.select("g");
                            var zoom = d3.zoom().on("zoom", function(event) {
                                inner.attr("transform", event.transform);
                            });
                            svgD3.call(zoom);
                        }
                    }, 100);
                }
            }

            modal.classList.add('active');
            document.body.style.overflow = 'hidden';
        });

        container.appendChild(fullscreenBtn);
        allButtons.push(fullscreenBtn);
    });

    // Update theme classes when theme changes
    const updateTheme = () => {
        const dark = isDarkTheme();
        allButtons.forEach(btn => {
            if (dark) {
                btn.classList.add('dark-theme');
            } else {
                btn.classList.remove('dark-theme');
            }
        });
        if (dark) {
            modal.classList.add('dark-theme');
            modalContent.classList.add('dark-theme');
            closeBtn.classList.add('dark-theme');
        } else {
            modal.classList.remove('dark-theme');
            modalContent.classList.remove('dark-theme');
            closeBtn.classList.remove('dark-theme');
        }
    };

    // Watch for theme changes
    const observer = new MutationObserver(updateTheme);
    observer.observe(document.documentElement, {
        attributes: true,
        attributeFilter: ['class', 'style', 'data-theme']
    });
    observer.observe(document.body, {
        attributes: true,
        attributeFilter: ['class', 'style']
    });
};

window.addEventListener("load", load);
</script>
    <script src="../../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: gray" >

          
          
          <a href="../../../../../index.html" class="icon icon-home">
            Pipeline 
 (2025.1.1.56)
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Basics</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../develdocmd/ways_to_run_the_pipeline.html">Ways to run the Pipeline</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../develdocmd/recipes.html">Pipeline Recipes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../dependencies.html">Dependencies of <code class="docutils literal notranslate"><span class="pre">Pipeline</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../releases.html">Releases</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../timeline.html">Roadmap &amp; Branching Strategy</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../apisummary.html">Full APIs (autosummary)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../apisummary.html#pipeline-tasks-autosummary">Pipeline Tasks (autosummary)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../apisummary.html#pipeline-domain-context-autosummary">Pipeline domain/context (autosummary)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../apisummary.html#pipeline-domain-infrastructure-modules-automodapi">Pipeline domain/infrastructure modules (automodapi)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../apisummary.html#pipeline-h-tasks-modules-autmodapi"><code class="docutils literal notranslate"><span class="pre">pipeline.h*.tasks</span></code> modules (autmodapi)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../apisummary.html#inheritance-diagrams-for-pipeline-task-inputs-results-classes">Inheritance Diagrams for Pipeline <code class="docutils literal notranslate"><span class="pre">Task</span></code>/<code class="docutils literal notranslate"><span class="pre">Inputs</span></code>/<code class="docutils literal notranslate"><span class="pre">Results</span></code> Classes</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Developer Notes</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../develdocmd/ALMA-Imaging-Workflow.html">ALMA interferometry imaging workflow</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../develdocmd/VLA-Imaging-Workflow.html">VLA interferometry imaging workflow</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../develdocmd/VLASS-SE-CONT-Imaging-Workflow.html">VLASS-SE-CONT imaging workflow</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../develdocmd/VLASS-SE-CUBE-Imaging-Workflow.html">VLASS-SE-CUBE imaging workflow</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../develdocmd/selfcal_workflow.html">VLASS Selfcal &amp; Restore workflows</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../develdocmd/comparing_pipeline_executions.html">Comparing pipeline executions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../develdocmd/building_the_pipeline.html">Building the pipeline</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../modular.html">Run the Pipeline in a Conda environment</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../develdocmd/pipeline_tests.html">Pipeline testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../develdocmd/DataType_Testing.html">DataType Testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../develdocmd/QA_scores.html">Pipeline Quality Assurance (QA) Score Class Design</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../develdocmd/DeveloperDocumentation.html">Pipeline developer documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../develdocmd/python3_conversion_notes.html">Python 3 conversion notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../heuristics/field_parameter.html">Field parameter</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../heuristics/FlaggingTasks.html">Pipeline Flagging Tasks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../notebooks/context.html">Pipeline Context and Domain Objects</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../notebooks/tier0dask.html">“Tier0” Parallelization with Dask/Futures</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: gray" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../../index.html">Pipeline 
 (2025.1.1.56)</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../../../index.html">Module code</a></li>
          <li class="breadcrumb-item"><a href="../../../../pipeline.html">pipeline</a></li>
      <li class="breadcrumb-item active">pipeline.hifa.tasks.diffgaincal.diffgaincal</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for pipeline.hifa.tasks.diffgaincal.diffgaincal</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">pipeline.infrastructure</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">infrastructure</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pipeline.infrastructure.basetask</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">basetask</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pipeline.infrastructure.callibrary</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">callibrary</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pipeline.infrastructure.vdp</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">vdp</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pipeline.domain.measurementset</span><span class="w"> </span><span class="kn">import</span> <span class="n">MeasurementSet</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pipeline.h.tasks.common</span><span class="w"> </span><span class="kn">import</span> <span class="n">commonhelpermethods</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pipeline.hif.tasks.gaincal</span><span class="w"> </span><span class="kn">import</span> <span class="n">common</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pipeline.hif.tasks.gaincal</span><span class="w"> </span><span class="kn">import</span> <span class="n">gtypegaincal</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pipeline.hifa.heuristics.phasespwmap</span><span class="w"> </span><span class="kn">import</span> <span class="n">IntentField</span><span class="p">,</span> <span class="n">SpwMapping</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pipeline.hifa.heuristics.phasespwmap</span><span class="w"> </span><span class="kn">import</span> <span class="n">combine_spwmap</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pipeline.hifa.heuristics.phasespwmap</span><span class="w"> </span><span class="kn">import</span> <span class="n">update_spwmap_for_band_to_band</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pipeline.infrastructure</span><span class="w"> </span><span class="kn">import</span> <span class="n">casa_tools</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pipeline.infrastructure</span><span class="w"> </span><span class="kn">import</span> <span class="n">task_registry</span>

<span class="n">LOG</span> <span class="o">=</span> <span class="n">infrastructure</span><span class="o">.</span><span class="n">get_logger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s1">&#39;DiffGaincal&#39;</span><span class="p">,</span>
    <span class="s1">&#39;DiffGaincalInputs&#39;</span><span class="p">,</span>
    <span class="s1">&#39;DiffGaincalResults&#39;</span><span class="p">,</span>
<span class="p">]</span>


<span class="k">class</span><span class="w"> </span><span class="nc">DiffGaincalResults</span><span class="p">(</span><span class="n">basetask</span><span class="o">.</span><span class="n">Results</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vis</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">final</span><span class="p">:</span> <span class="nb">list</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">pool</span><span class="p">:</span> <span class="nb">list</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">residual_phase_result</span><span class="p">:</span> <span class="n">common</span><span class="o">.</span><span class="n">GaincalResults</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">ref_phase_result</span><span class="p">:</span> <span class="n">common</span><span class="o">.</span><span class="n">GaincalResults</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">spwmaps</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialise the differential gain results object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vis</span> <span class="o">=</span> <span class="n">vis</span>

        <span class="c1"># Lists of CalApplications.</span>
        <span class="k">if</span> <span class="n">final</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">final</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">pool</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pool</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">error</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">final</span> <span class="o">=</span> <span class="n">final</span><span class="p">[:]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pool</span> <span class="o">=</span> <span class="n">pool</span><span class="p">[:]</span>

        <span class="c1"># Spectral window mappings (populated if task decides this needs to be</span>
        <span class="c1"># updated.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spwmaps</span> <span class="o">=</span> <span class="n">spwmaps</span> <span class="k">if</span> <span class="n">spwmaps</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">{}</span>

        <span class="c1"># QA message about missing SpWs.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qa_message</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>

        <span class="c1"># Results from child phase gaincal tasks.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">residual_phase_result</span> <span class="o">=</span> <span class="n">residual_phase_result</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ref_phase_result</span> <span class="o">=</span> <span class="n">ref_phase_result</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">merge_with_context</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
        <span class="c1"># Register all CalApplications from each session.</span>
        <span class="k">for</span> <span class="n">calapp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">final</span><span class="p">:</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Adding calibration to callibrary:</span><span class="se">\n</span><span class="si">{</span><span class="n">calapp</span><span class="o">.</span><span class="n">calto</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span>
                      <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">calapp</span><span class="o">.</span><span class="n">calfrom</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">context</span><span class="o">.</span><span class="n">callibrary</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">calapp</span><span class="o">.</span><span class="n">calto</span><span class="p">,</span> <span class="n">calapp</span><span class="o">.</span><span class="n">calfrom</span><span class="p">)</span>

        <span class="c1"># If this task derived new spectral window mappings, then merge these</span>
        <span class="c1"># into the MS.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">spwmaps</span><span class="p">:</span>
            <span class="n">ms</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">observing_run</span><span class="o">.</span><span class="n">get_ms</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">vis</span><span class="p">)</span>
            <span class="n">ms</span><span class="o">.</span><span class="n">spwmaps</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spwmaps</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;DiffGaincalResults&#39;</span>


<span class="k">class</span><span class="w"> </span><span class="nc">DiffGaincalInputs</span><span class="p">(</span><span class="n">vdp</span><span class="o">.</span><span class="n">StandardInputs</span><span class="p">):</span>

    <span class="n">flagging_frac_limit</span> <span class="o">=</span> <span class="n">vdp</span><span class="o">.</span><span class="n">VisDependentProperty</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="mf">0.7</span><span class="p">)</span>
    <span class="n">hm_spwmapmode</span> <span class="o">=</span> <span class="n">vdp</span><span class="o">.</span><span class="n">VisDependentProperty</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">)</span>

    <span class="nd">@hm_spwmapmode</span><span class="o">.</span><span class="n">convert</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">hm_spwmapmode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="n">allowed</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="s1">&#39;both&#39;</span><span class="p">,</span> <span class="s1">&#39;never&#39;</span><span class="p">,</span> <span class="s1">&#39;offset&#39;</span><span class="p">,</span> <span class="s1">&#39;reference&#39;</span><span class="p">,</span> <span class="s1">&#39;residual&#39;</span><span class="p">}</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">allowed</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">((</span><span class="s1">&#39;</span><span class="si">{!r}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">allowed</span><span class="p">))</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Value not in allowed value set (</span><span class="si">{!s}</span><span class="s1">): </span><span class="si">{!r}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">value</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">value</span>

    <span class="n">missing_scans_frac_limit</span> <span class="o">=</span> <span class="n">vdp</span><span class="o">.</span><span class="n">VisDependentProperty</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="mf">0.7</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">output_dir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">flagging_frac_limit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">hm_spwmapmode</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">missing_scans_frac_limit</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize Inputs.</span>

<span class="sd">        Args:</span>
<span class="sd">            context: Pipeline context object containing state information.</span>

<span class="sd">            output_dir: Output directory.</span>
<span class="sd">                Defaults to None, which corresponds to the current working directory.</span>

<span class="sd">            vis: The list of input MeasurementSets. Defaults to the list of</span>
<span class="sd">                MeasurementSets specified in the pipeline context.</span>

<span class="sd">                Example: ``[&#39;M32A.ms&#39;, &#39;M32B.ms&#39;]``</span>

<span class="sd">            flagging_frac_limit: if the fraction of flagged data in the</span>
<span class="sd">                temporary phase gaintable exceeds this limit then SpW</span>
<span class="sd">                combination is triggered.</span>

<span class="sd">            hm_spwmapmode: The spectral window mapping heuristic mode. The</span>
<span class="sd">                options are:</span>

<span class="sd">                - ``&#39;all&#39;``: SpW combination is forced for the diffgain</span>
<span class="sd">                    low-frequency reference intent solutions, the diffgain</span>
<span class="sd">                    high-frequency source intent solutions (actual band-to-band</span>
<span class="sd">                    offsets), and for the diagnostic residual phase offsets on</span>
<span class="sd">                    the diffgain high-frequency source intent.</span>
<span class="sd">                - ``&#39;auto&#39;``: Assess need for SpW combination based on SpwMapping</span>
<span class="sd">                    from hifa_spwphaseup, and where necessary check the</span>
<span class="sd">                    gaintable for missing SpWs / too many flagged data / too few</span>
<span class="sd">                    scan solutions.</span>
<span class="sd">                - ``&#39;both&#39;``: SpW combination is forced for the diffgain</span>
<span class="sd">                    low-frequency reference intent solutions and for the</span>
<span class="sd">                    diagnostic residual phase offsets on the diffgain</span>
<span class="sd">                    high-frequency source intent.</span>
<span class="sd">                - ``&#39;offset&#39;``: SpW combination is forced for the diffgain</span>
<span class="sd">                    high-frequency source intent solutions (actual band-to-band</span>
<span class="sd">                    offsets).</span>
<span class="sd">                - ``&#39;reference&#39;``: SpW combination is forced for the diffgain</span>
<span class="sd">                    low-frequency reference intent solutions.</span>
<span class="sd">                - ``&#39;residual&#39;``: SpW combination is forced for the diagnostic</span>
<span class="sd">                    residual phase offsets on the diffgain high-frequency source</span>
<span class="sd">                    intent.</span>

<span class="sd">                Example: ``hm_spwmapmode=&#39;auto&#39;``</span>

<span class="sd">            missing_scans_frac_limit: if the fraction of missing scans in the</span>
<span class="sd">                temporary phase gaintable exceeds this limit then SpW</span>
<span class="sd">                combination is triggered.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="c1"># Standard Pipeline inputs.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">context</span> <span class="o">=</span> <span class="n">context</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vis</span> <span class="o">=</span> <span class="n">vis</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_dir</span> <span class="o">=</span> <span class="n">output_dir</span>

        <span class="c1"># Diffgaincal specific inputs.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flagging_frac_limit</span> <span class="o">=</span> <span class="n">flagging_frac_limit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hm_spwmapmode</span><span class="o">=</span> <span class="n">hm_spwmapmode</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">missing_scans_frac_limit</span> <span class="o">=</span> <span class="n">missing_scans_frac_limit</span>


<div class="viewcode-block" id="DiffGaincal">
<a class="viewcode-back" href="../../../../../_automodapi/pipeline.hifa.tasks.DiffGaincal.html#pipeline.hifa.tasks.DiffGaincal">[docs]</a>
<span class="nd">@task_registry</span><span class="o">.</span><span class="n">set_equivalent_casa_task</span><span class="p">(</span><span class="s1">&#39;hifa_diffgaincal&#39;</span><span class="p">)</span>
<span class="nd">@task_registry</span><span class="o">.</span><span class="n">set_casa_commands_comment</span><span class="p">(</span><span class="s1">&#39;Compute the differential gain calibration.&#39;</span><span class="p">)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">DiffGaincal</span><span class="p">(</span><span class="n">basetask</span><span class="o">.</span><span class="n">StandardTaskTemplate</span><span class="p">):</span>
    <span class="n">Inputs</span> <span class="o">=</span> <span class="n">DiffGaincalInputs</span>

<div class="viewcode-block" id="DiffGaincal.prepare">
<a class="viewcode-back" href="../../../../../_automodapi/pipeline.hifa.tasks.DiffGaincal.html#pipeline.hifa.tasks.DiffGaincal.prepare">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">prepare</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DiffGaincalResults</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Execute differential gain calibration heuristics and return Results</span>
<span class="sd">        object that includes final caltables.</span>

<span class="sd">        Returns:</span>
<span class="sd">            DiffGaincalResults instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Initialize results.</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">DiffGaincalResults</span><span class="p">(</span><span class="n">vis</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">vis</span><span class="p">)</span>

        <span class="c1"># Compute phase solutions for the diffgain reference intent.</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Computing phase gain table for the diffgain reference intent.&#39;</span><span class="p">)</span>
        <span class="n">result</span><span class="o">.</span><span class="n">ref_phase_result</span><span class="p">,</span> <span class="n">result</span><span class="o">.</span><span class="n">spwmaps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_do_phasecal_for_diffgain_reference</span><span class="p">()</span>

        <span class="c1"># Compute phase solutions for the diffgain on-source spectral windows.</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Computing phase gain table for the diffgain on-source intent.&#39;</span><span class="p">)</span>
        <span class="n">dg_src_phase_results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_do_phasecal_for_diffgain_onsource</span><span class="p">()</span>
        <span class="c1"># Adopt resulting CalApplication(s) and QA message into final result.</span>
        <span class="k">if</span> <span class="n">dg_src_phase_results</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">pool</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">dg_src_phase_results</span><span class="o">.</span><span class="n">pool</span><span class="p">)</span>
            <span class="n">result</span><span class="o">.</span><span class="n">qa_message</span> <span class="o">=</span> <span class="n">dg_src_phase_results</span><span class="o">.</span><span class="n">qa_message</span>

        <span class="c1"># Compute residual phase offsets for the diffgain on-source intent, for</span>
        <span class="c1"># diagnostic plots in the weblog.</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Computing residual phase offsets for the diffgain on-source intent.&#39;</span><span class="p">)</span>
        <span class="n">result</span><span class="o">.</span><span class="n">residual_phase_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_do_phasecal_for_diffgain_residual_offsets</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="DiffGaincal.analyse">
<a class="viewcode-back" href="../../../../../_automodapi/pipeline.hifa.tasks.DiffGaincal.html#pipeline.hifa.tasks.DiffGaincal.analyse">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">analyse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="p">:</span> <span class="n">DiffGaincalResults</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DiffGaincalResults</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Analyze the DiffGaincalResults: check that all caltables from</span>
<span class="sd">        CalApplications exist on disk.</span>

<span class="sd">        Args:</span>
<span class="sd">            result: DiffGaincalResults instance.</span>

<span class="sd">        Returns:</span>
<span class="sd">            DiffGaincalResults instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check that the caltables were all generated.</span>
        <span class="n">on_disk</span> <span class="o">=</span> <span class="p">[</span><span class="n">ca</span> <span class="k">for</span> <span class="n">ca</span> <span class="ow">in</span> <span class="n">result</span><span class="o">.</span><span class="n">pool</span> <span class="k">if</span> <span class="n">ca</span><span class="o">.</span><span class="n">exists</span><span class="p">()]</span>
        <span class="n">result</span><span class="o">.</span><span class="n">final</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">on_disk</span>

        <span class="n">missing</span> <span class="o">=</span> <span class="p">[</span><span class="n">ca</span> <span class="k">for</span> <span class="n">ca</span> <span class="ow">in</span> <span class="n">result</span><span class="o">.</span><span class="n">pool</span> <span class="k">if</span> <span class="n">ca</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">on_disk</span><span class="p">]</span>
        <span class="n">result</span><span class="o">.</span><span class="n">error</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="n">result</span><span class="o">.</span><span class="n">error</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">missing</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">result</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_assess_if_spw_combination_is_necessary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">intent</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">spw</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">force_for_spwmapmodes</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
                                                <span class="n">scan_groups</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Assess whether spectral window combination is necessary based on</span>
<span class="sd">        `hm_spwmapmode`, the SpwMapping for given intent, and/or whether SpWs</span>
<span class="sd">        would be missing in final gaintable.</span>

<span class="sd">        Args:</span>
<span class="sd">            intent: Intent to assess.</span>
<span class="sd">            spw: List of Spectral Window IDs to assess.</span>
<span class="sd">            force_for_spwmapmodes: List of values for `hm_spwmapmode` for which</span>
<span class="sd">                to force SpW combination.</span>
<span class="sd">            scan_groups: Optional, list of group(s) of scans to assess.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Boolean declaring whether to use SpW combination.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">inputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span>

        <span class="c1"># Force SpW combination if hm_spwmapmode matches any of the specified</span>
        <span class="c1"># &quot;forced&quot; modes, which can include any of the allowed values for the</span>
        <span class="c1"># input parameter hm_spwmapmode *except* for hm_spwmapmode=&#39;auto&#39;</span>
        <span class="c1"># (&#39;auto&#39; is separately evaluated below).</span>
        <span class="k">if</span> <span class="n">inputs</span><span class="o">.</span><span class="n">hm_spwmapmode</span> <span class="ow">in</span> <span class="n">force_for_spwmapmodes</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="c1"># For automatic hm_spwmapmode, check whether SpW combination is</span>
        <span class="c1"># required based on SpwMapping or in case the resulting caltable would</span>
        <span class="c1"># contain any missing/fully flagged SpWs.</span>
        <span class="n">combine_spw</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">inputs</span><span class="o">.</span><span class="n">hm_spwmapmode</span> <span class="o">==</span> <span class="s1">&#39;auto&#39;</span><span class="p">:</span>
            <span class="c1"># Assess the SpwMapping for diffgain calibrator for whether SpW</span>
            <span class="c1"># combination is required.</span>
            <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">inputs</span><span class="o">.</span><span class="n">ms</span><span class="o">.</span><span class="n">get_fields</span><span class="p">(</span><span class="n">intent</span><span class="o">=</span><span class="n">intent</span><span class="p">):</span>
                <span class="n">combine_spw</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_assess_spw_combine_based_on_spwmapping_and_snr</span><span class="p">(</span>
                    <span class="n">intent</span><span class="p">,</span> <span class="n">field</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">spw</span><span class="p">,</span> <span class="n">scan_groups</span><span class="o">=</span><span class="n">scan_groups</span><span class="p">)</span>
                <span class="c1"># Assessment is made in a loop over all diffgain calibrator</span>
                <span class="c1"># fields, and as soon as SpW combination is needed for one, it</span>
                <span class="c1"># is required for all. In practice, it is currently expected</span>
                <span class="c1"># that band-to-band datasets only have a single diffgain</span>
                <span class="c1"># calibrator. Should this change in operations in the future,</span>
                <span class="c1"># then it should be revisited whether to apply a single SpW</span>
                <span class="c1"># combination strategy to all diffgain calibrators and their</span>
                <span class="c1"># corresponding phase calibrator sources.</span>
                <span class="k">if</span> <span class="n">combine_spw</span><span class="p">:</span>
                    <span class="k">break</span>

            <span class="c1"># If no SpW combination is needed based on SpwMapping, then generate</span>
            <span class="c1"># a temporary (diagnostic) phase caltable without SpW combination,</span>
            <span class="c1"># and check whether any SpWs would be missing / fully flagged; if</span>
            <span class="c1"># so, then force SpW combination after all.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">combine_spw</span><span class="p">:</span>
                <span class="c1"># If provided groups of scans, then do combination over scan.</span>
                <span class="n">combine</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span> <span class="k">if</span> <span class="n">scan_groups</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="s1">&#39;scan&#39;</span>
                <span class="n">diag_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_do_phasecal</span><span class="p">(</span><span class="n">intent</span><span class="o">=</span><span class="n">intent</span><span class="p">,</span> <span class="n">spw</span><span class="o">=</span><span class="n">spw</span><span class="p">,</span> <span class="n">combine</span><span class="o">=</span><span class="n">combine</span><span class="p">)</span>
                <span class="n">bad_spws</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_assess_spws_in_gaintable</span><span class="p">(</span><span class="n">diag_result</span><span class="p">,</span> <span class="n">combine_spw</span><span class="p">,</span> <span class="n">spw</span><span class="p">,</span> <span class="n">scan_groups</span><span class="o">=</span><span class="n">scan_groups</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">bad_spws</span><span class="p">:</span>
                    <span class="n">combine_spw</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">return</span> <span class="n">combine_spw</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_assess_spw_combine_based_on_spwmapping_and_snr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">intent</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">field</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">spwids</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
                                                        <span class="n">scan_groups</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Assess whether spectral window combination is necessary based on</span>
<span class="sd">        spectral window mapping and scaling estimated SNR (for solint) to full</span>
<span class="sd">        aggregate exposure time of scans.</span>

<span class="sd">        Args:</span>
<span class="sd">            intent: Intent to assess; should be DIFFGAINREF or DIFFGAINSRC.</span>
<span class="sd">            field: Field to assess.</span>
<span class="sd">            spwids: Spectral window IDs to assess SNR for in case SpwMapping</span>
<span class="sd">                specified to use spectral window combination.</span>
<span class="sd">            scan_groups: Optional: list of scan groups to assess.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Boolean declaring whether to use spectral window combination.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Try to retrieve SpW mapping info from MS for requested intent and</span>
        <span class="c1"># field.</span>
        <span class="n">spwmapping</span><span class="p">:</span> <span class="n">SpwMapping</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">ms</span><span class="o">.</span><span class="n">spwmaps</span><span class="o">.</span><span class="n">get</span><span class="p">((</span><span class="n">intent</span><span class="p">,</span> <span class="n">field</span><span class="p">),</span> <span class="kc">None</span><span class="p">)</span>

        <span class="c1"># If no SpW mapping info is available, then the default is to use no SpW</span>
        <span class="c1"># combination.</span>
        <span class="k">if</span> <span class="n">spwmapping</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># Otherwise, proceed to assess the info in the SpW mapping info to</span>
        <span class="c1"># determine whether to use SpW combination:</span>

        <span class="c1"># Track whether SpWs were re-mapped or combined.</span>
        <span class="n">spws_mapped_or_combined</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># If SpWs are combined, then use input spectral windows for SNR</span>
        <span class="c1"># assessment.</span>
        <span class="k">if</span> <span class="n">spwmapping</span><span class="o">.</span><span class="n">combine</span><span class="p">:</span>
            <span class="n">spws_mapped_or_combined</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">spwids_mapped</span> <span class="o">=</span> <span class="n">spwids</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">ms</span><span class="o">.</span><span class="n">basename</span><span class="si">}</span><span class="s2">: SpwMapping for intent </span><span class="si">{</span><span class="n">intent</span><span class="si">}</span><span class="s2"> is using spectral window combination,&quot;</span>
                     <span class="sa">f</span><span class="s2">&quot; re-assessing estimated SNR based on full exposure times of corresponding scans.&quot;</span><span class="p">)</span>
        <span class="c1"># Otherwise, check if any SpWs are re-mapped, and select those SpWs</span>
        <span class="c1"># for SNR assessment.</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">spwids_mapped</span> <span class="o">=</span> <span class="p">[</span><span class="n">idx</span> <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">spwid</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">spwmapping</span><span class="o">.</span><span class="n">spwmap</span><span class="p">)</span> <span class="k">if</span> <span class="n">idx</span> <span class="o">!=</span> <span class="n">spwid</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">spwids_mapped</span><span class="p">:</span>
                <span class="n">spws_mapped_or_combined</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">ms</span><span class="o">.</span><span class="n">basename</span><span class="si">}</span><span class="s2">: SpwMapping for intent </span><span class="si">{</span><span class="n">intent</span><span class="si">}</span><span class="s2"> is using spectral window mapping,&quot;</span>
                         <span class="sa">f</span><span class="s2">&quot; re-assessing estimated SNR based on full exposure times of corresponding scans.&quot;</span><span class="p">)</span>

        <span class="c1"># If SpWs are to be re-mapped or combined, proceed to assess if SpW</span>
        <span class="c1"># combination would still be needed after scaling estimated SNR from</span>
        <span class="c1"># solint to full exposure time (scan time * nr. scans).</span>
        <span class="k">if</span> <span class="n">spws_mapped_or_combined</span><span class="p">:</span>
            <span class="c1"># Retrieve scan and integration time.</span>
            <span class="n">scantime</span><span class="p">,</span> <span class="n">inttime</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_scan_and_integration_time</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">ms</span><span class="p">,</span> <span class="n">intent</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">spwids</span><span class="p">)</span>

            <span class="c1"># Retrieve solution interval time in seconds from SpW mapping.</span>
            <span class="k">if</span> <span class="n">spwmapping</span><span class="o">.</span><span class="n">solint</span> <span class="o">==</span> <span class="s1">&#39;int&#39;</span><span class="p">:</span>
                <span class="n">solint</span> <span class="o">=</span> <span class="n">inttime</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Assume solint was recorded as string in units of seconds,</span>
                <span class="c1"># convert to float with CASA quanta.</span>
                <span class="n">solint</span> <span class="o">=</span> <span class="n">casa_tools</span><span class="o">.</span><span class="n">quanta</span><span class="o">.</span><span class="n">quantity</span><span class="p">(</span><span class="n">spwmapping</span><span class="o">.</span><span class="n">solint</span><span class="p">)[</span><span class="s1">&#39;value&#39;</span><span class="p">]</span>

            <span class="c1"># Get the number of scans from groups of scans if provided, but</span>
            <span class="c1"># otherwise assume this to be a single scan.</span>
            <span class="c1"># It is assumed that the band-to-band observation uses the same</span>
            <span class="c1"># number of scans in each scan group, so the first scan group is</span>
            <span class="c1"># taken as representative of how long a scan group should be.</span>
            <span class="n">nr_scans</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">scan_groups</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">if</span> <span class="n">scan_groups</span> <span class="k">else</span> <span class="mi">1</span>

            <span class="c1"># Compute SNR scale factor, to scale estimated SNR for current</span>
            <span class="c1"># solint to expected SNR for exposure time.</span>
            <span class="n">snr_scale_factor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">scantime</span> <span class="o">*</span> <span class="n">nr_scans</span> <span class="o">/</span> <span class="n">solint</span><span class="p">)</span>

            <span class="c1"># Loop over SpWs in SNR info and check each re-mapped/combined</span>
            <span class="c1"># SpW whether the scaled estimated SNR would (still) be below</span>
            <span class="c1"># the minimum required SNR threshold.</span>
            <span class="n">spwids_mapped</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">spwids_mapped</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">spwid</span><span class="p">,</span> <span class="n">snr</span> <span class="ow">in</span> <span class="n">spwmapping</span><span class="o">.</span><span class="n">snr_info</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">spwid</span> <span class="ow">in</span> <span class="n">spwids_mapped</span> <span class="ow">and</span> <span class="n">snr</span> <span class="o">*</span> <span class="n">snr_scale_factor</span> <span class="o">&lt;</span> <span class="n">spwmapping</span><span class="o">.</span><span class="n">snr_threshold_used</span><span class="p">:</span>
                    <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">ms</span><span class="o">.</span><span class="n">basename</span><span class="si">}</span><span class="s2">, intent </span><span class="si">{</span><span class="n">intent</span><span class="si">}</span><span class="s2">: estimated SNR is below threshold for good&quot;</span>
                             <span class="sa">f</span><span class="s2">&quot; solutions (</span><span class="si">{</span><span class="n">spwmapping</span><span class="o">.</span><span class="n">snr_threshold_used</span><span class="si">}</span><span class="s2">) for at least one of the re-mapped&quot;</span>
                             <span class="sa">f</span><span class="s2">&quot; / combined SpWs, will use SpW combination.&quot;</span><span class="p">)</span>
                    <span class="k">return</span> <span class="kc">True</span>

        <span class="c1"># If this is reached, then it is expected that no SpW combination is</span>
        <span class="c1"># necessary based on info in SpwMapping.</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_assess_spws_in_gaintable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gaincal_results</span><span class="p">:</span> <span class="n">common</span><span class="o">.</span><span class="n">GaincalResults</span><span class="p">,</span> <span class="n">combine_spw</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">spw</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
                                  <span class="n">scan_groups</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        If no SpW combination was expected to be used, then this method assesses</span>
<span class="sd">        the resulting temporary phase caltable for missing SpWs, fully flagged</span>
<span class="sd">        SpWs, and/or SpWs with large fraction of flagged scans, and returns</span>
<span class="sd">        these as a single QA message. If this message is not empty, then SpW</span>
<span class="sd">        combination is deemed necessary after all.</span>

<span class="sd">        Args:</span>
<span class="sd">            gaincal_results: List of gaincal worker task results representing</span>
<span class="sd">                the temporary phase caltable.</span>
<span class="sd">            combine_spw: boolean declaring whether SpW combination is to be used.</span>
<span class="sd">            spw: SpW IDs to consider.</span>
<span class="sd">            scan_groups: Groups of scans to consider (impacts nr. of scan</span>
<span class="sd">                solutions expected in caltable).</span>

<span class="sd">        Returns:</span>
<span class="sd">            String message described what SpWs in temporary caltable have issues.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If SpW combination was already required, return early; no need to</span>
        <span class="c1"># assess whether flagged/missing data in gaintable would necessitate SpW</span>
        <span class="c1"># combination.</span>
        <span class="k">if</span> <span class="n">combine_spw</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;&#39;</span>

        <span class="n">inputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span>

        <span class="c1"># Retrieve caltable and which intent it was derived for.</span>
        <span class="n">caltable</span> <span class="o">=</span> <span class="n">gaincal_results</span><span class="o">.</span><span class="n">final</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">gaintable</span>
        <span class="n">intent</span> <span class="o">=</span> <span class="n">gaincal_results</span><span class="o">.</span><span class="n">inputs</span><span class="p">[</span><span class="s1">&#39;intent&#39;</span><span class="p">]</span>

        <span class="c1"># Retrieve SpW ID, scan, and flagging columns from the caltable.</span>
        <span class="k">with</span> <span class="n">casa_tools</span><span class="o">.</span><span class="n">TableReader</span><span class="p">(</span><span class="n">caltable</span><span class="p">)</span> <span class="k">as</span> <span class="n">table</span><span class="p">:</span>
            <span class="n">tbl_spwids</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">getcol</span><span class="p">(</span><span class="s2">&quot;SPECTRAL_WINDOW_ID&quot;</span><span class="p">)</span>
            <span class="n">tbl_flags</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">getcol</span><span class="p">(</span><span class="s2">&quot;FLAG&quot;</span><span class="p">)</span>
            <span class="n">tbl_scanids</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">getcol</span><span class="p">(</span><span class="s2">&quot;SCAN_NUMBER&quot;</span><span class="p">)</span>

        <span class="c1"># Proceed with 3 separate tests, keeping track of what SpWs are missing,</span>
        <span class="c1"># or have too few scan solutions, or too much data flagged.</span>
        <span class="n">bad_spws</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># First check if all requested SpWs are present in the gaintable.</span>
        <span class="n">missing_spwids</span> <span class="o">=</span> <span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">spw</span> <span class="k">if</span> <span class="n">s</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">tbl_spwids</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">missing_spwids</span><span class="p">:</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">caltable</span><span class="si">}</span><span class="s2">: missing solutions for SpW(s) </span><span class="si">{</span><span class="n">missing_spwids</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
            <span class="n">bad_spws</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;SpW(s) </span><span class="si">{</span><span class="n">missing_spwids</span><span class="si">}</span><span class="s2"> have no solutions.&quot;</span><span class="p">)</span>

        <span class="c1"># Secondly, check if the number of scan solutions in the caltable is</span>
        <span class="c1"># significantly lower (set by threshold parameters) than the expected</span>
        <span class="c1"># nr. of scan solutions, which can happen if scans are entirely flagged</span>
        <span class="c1"># in prior stages.</span>
        <span class="c1">#</span>
        <span class="c1"># To do so, first determine number of scan solutions expected in</span>
        <span class="c1"># caltable. If no scan groups were provided, then expect 1 solution per</span>
        <span class="c1"># scan; otherwise expect 1 solution per group (combining over scan).</span>
        <span class="k">if</span> <span class="n">scan_groups</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">n_exp_scan_solns</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">ms</span><span class="o">.</span><span class="n">get_scans</span><span class="p">(</span><span class="n">scan_intent</span><span class="o">=</span><span class="n">intent</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">n_exp_scan_solns</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">scan_groups</span><span class="p">)</span>
        <span class="c1"># And then determine for each SpW ID whether the nr. of scan solutions</span>
        <span class="c1"># compared to expected number is acceptable.</span>
        <span class="n">spw_with_too_many_missing_scans</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">uniq_spwid</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">tbl_spwids</span><span class="p">)):</span>
            <span class="c1"># Determine unique scans for current SpW.</span>
            <span class="n">scanids_for_spwid</span> <span class="o">=</span> <span class="p">{</span><span class="n">tbl_scanids</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">spwid</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">tbl_spwids</span><span class="p">)</span> <span class="k">if</span> <span class="n">spwid</span> <span class="o">==</span> <span class="n">uniq_spwid</span><span class="p">}</span>

            <span class="c1"># Compute fraction of missing scan solutions in table.</span>
            <span class="n">missing_scan_ratio</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">scanids_for_spwid</span><span class="p">))</span> <span class="o">/</span> <span class="n">n_exp_scan_solns</span>

            <span class="c1"># If fraction of missing scans exceeds the limit, then mark this SpW</span>
            <span class="c1"># as bad.</span>
            <span class="k">if</span> <span class="n">missing_scan_ratio</span> <span class="o">&gt;</span> <span class="n">inputs</span><span class="o">.</span><span class="n">missing_scans_frac_limit</span><span class="p">:</span>
                <span class="n">spw_with_too_many_missing_scans</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">uniq_spwid</span><span class="p">)</span>

        <span class="c1"># If any SpW has too many missing scans:</span>
        <span class="k">if</span> <span class="n">spw_with_too_many_missing_scans</span><span class="p">:</span>
            <span class="n">bad_spws</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;SpW(s) </span><span class="si">{</span><span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">spw_with_too_many_missing_scans</span><span class="p">)</span><span class="si">}</span><span class="s2"> have too many missing&quot;</span>
                            <span class="sa">f</span><span class="s2">&quot; scans.&quot;</span><span class="p">)</span>

        <span class="c1"># Thirdly, assess for each SpW whether the fraction of flagged data is</span>
        <span class="c1"># above the maximum threshold.</span>
        <span class="n">spw_with_too_much_flagging</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">uniq_spwid</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">tbl_spwids</span><span class="p">)):</span>
            <span class="c1"># Get indices in caltable data corresponding to current SpW.</span>
            <span class="n">idx_spw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">tbl_spwids</span> <span class="o">==</span> <span class="n">uniq_spwid</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># Get number of correlations (polarizations) for this SpW.</span>
            <span class="n">corr_type</span> <span class="o">=</span> <span class="n">commonhelpermethods</span><span class="o">.</span><span class="n">get_corr_products</span><span class="p">(</span><span class="n">inputs</span><span class="o">.</span><span class="n">ms</span><span class="p">,</span> <span class="n">uniq_spwid</span><span class="p">)</span>
            <span class="n">ncorrs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">corr_type</span><span class="p">)</span>

            <span class="c1"># For single-polarization data, the caltable is expected to still</span>
            <span class="c1"># contain at least 2 columns, so identify which polarization index</span>
            <span class="c1"># to use. For multi-pol data, assess all polarizations.</span>
            <span class="k">if</span> <span class="n">ncorrs</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">pol_to_assess</span> <span class="o">=</span> <span class="p">[</span><span class="n">commonhelpermethods</span><span class="o">.</span><span class="n">get_pol_id</span><span class="p">(</span><span class="n">inputs</span><span class="o">.</span><span class="n">ms</span><span class="p">,</span> <span class="n">uniq_spwid</span><span class="p">,</span> <span class="n">corr_type</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">pol_to_assess</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tbl_flags</span><span class="p">)))</span>

            <span class="c1"># Separately assess each polarization, but as soon as 1 pol has too</span>
            <span class="c1"># much flagged data, then consider SpW bad.</span>
            <span class="k">for</span> <span class="n">idx_pol</span> <span class="ow">in</span> <span class="n">pol_to_assess</span><span class="p">:</span>
                <span class="c1"># Compute fraction of flagged rows for current polarization and</span>
                <span class="c1"># SpW. Numpy treats True as 1 and False as 0, so can use mean.</span>
                <span class="n">flag_ratio</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">tbl_flags</span><span class="p">[</span><span class="n">idx_pol</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">idx_spw</span><span class="p">])</span>
                <span class="c1"># If fraction of flagged data in even just one polarization</span>
                <span class="c1"># exceeds the limit, then mark this SpW as bad, and continue</span>
                <span class="c1"># with next SpW.</span>
                <span class="k">if</span> <span class="n">flag_ratio</span> <span class="o">&gt;</span> <span class="n">inputs</span><span class="o">.</span><span class="n">flagging_frac_limit</span><span class="p">:</span>
                    <span class="n">spw_with_too_much_flagging</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">uniq_spwid</span><span class="p">)</span>
                    <span class="k">break</span>

        <span class="c1"># If any SpW has too much flagged data:</span>
        <span class="k">if</span> <span class="n">spw_with_too_much_flagging</span><span class="p">:</span>
            <span class="n">bad_spws</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;SpW(s) </span><span class="si">{</span><span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">spw_with_too_much_flagging</span><span class="p">)</span><span class="si">}</span><span class="s2"> have too high fraction of&quot;</span>
                            <span class="sa">f</span><span class="s2">&quot; flagged data.&quot;</span><span class="p">)</span>

        <span class="c1"># Return as single string.</span>
        <span class="n">bad_spws_message</span> <span class="o">=</span> <span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">bad_spws</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">bad_spws_message</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_do_gaincal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">intent</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">spw</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">combine</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">caltable</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                    <span class="n">scan</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">append</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">common</span><span class="o">.</span><span class="n">GaincalResults</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Local method to call the G-type gaincal worker task, with pre-defined</span>
<span class="sd">        values for parameters that are shared among all gaincal steps in this</span>
<span class="sd">        task.</span>

<span class="sd">        Args:</span>
<span class="sd">            intent: intent selection to use.</span>
<span class="sd">            spw: spectral windows to use.</span>
<span class="sd">            combine: axis to combine solutions over.</span>
<span class="sd">            caltable: name of caltable to use.</span>
<span class="sd">            scan: scan selection to use.</span>
<span class="sd">            append: boolean whether to append to existing caltable.</span>

<span class="sd">        Returns:</span>
<span class="sd">            GaincalResults</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">task_args</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;output_dir&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">output_dir</span><span class="p">,</span>
            <span class="s1">&#39;vis&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">vis</span><span class="p">,</span>
            <span class="s1">&#39;caltable&#39;</span><span class="p">:</span> <span class="n">caltable</span><span class="p">,</span>
            <span class="s1">&#39;intent&#39;</span><span class="p">:</span> <span class="n">intent</span><span class="p">,</span>
            <span class="s1">&#39;spw&#39;</span><span class="p">:</span> <span class="n">spw</span><span class="p">,</span>
            <span class="s1">&#39;scan&#39;</span><span class="p">:</span> <span class="n">scan</span><span class="p">,</span>
            <span class="s1">&#39;combine&#39;</span><span class="p">:</span> <span class="n">combine</span><span class="p">,</span>
            <span class="s1">&#39;solint&#39;</span><span class="p">:</span> <span class="s1">&#39;inf&#39;</span><span class="p">,</span>
            <span class="s1">&#39;calmode&#39;</span><span class="p">:</span> <span class="s1">&#39;p&#39;</span><span class="p">,</span>
            <span class="s1">&#39;minsnr&#39;</span><span class="p">:</span> <span class="mf">3.0</span><span class="p">,</span>
            <span class="s1">&#39;refantmode&#39;</span><span class="p">:</span> <span class="s1">&#39;strict&#39;</span><span class="p">,</span>
            <span class="s1">&#39;append&#39;</span><span class="p">:</span> <span class="n">append</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="n">task_inputs</span> <span class="o">=</span> <span class="n">gtypegaincal</span><span class="o">.</span><span class="n">GTypeGaincalInputs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">context</span><span class="p">,</span> <span class="o">**</span><span class="n">task_args</span><span class="p">)</span>
        <span class="n">task</span> <span class="o">=</span> <span class="n">gtypegaincal</span><span class="o">.</span><span class="n">GTypeGaincal</span><span class="p">(</span><span class="n">task_inputs</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_executor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_do_phasecal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">intent</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">spw</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">combine</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">common</span><span class="o">.</span><span class="n">GaincalResults</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Local method to perform phase gaincal with pre-defined values for</span>
<span class="sd">        parameters shared among all gaincal steps in this task.</span>

<span class="sd">        If combination over scan is required, then this method identifies the</span>
<span class="sd">        scan groups and calls gaincal for each scan group, ensuring solutions</span>
<span class="sd">        are appended to the same final caltable.</span>

<span class="sd">        Args:</span>
<span class="sd">            intent: intent selection to use.</span>
<span class="sd">            spw: spectral windows to use.</span>
<span class="sd">            combine: axis to combine solutions over.</span>

<span class="sd">        Returns:</span>
<span class="sd">            GaincalResults</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># SpW IDs as string for CASA gaincal.</span>
        <span class="n">spwids_str</span> <span class="o">=</span> <span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">spw</span><span class="p">)</span>

        <span class="c1"># If combine is not specified or not combining over scans, then perform</span>
        <span class="c1"># single gaincal for given intent, spw, and combine.</span>
        <span class="k">if</span> <span class="n">combine</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="s1">&#39;scan&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">combine</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_do_gaincal</span><span class="p">(</span><span class="n">intent</span><span class="o">=</span><span class="n">intent</span><span class="p">,</span> <span class="n">spw</span><span class="o">=</span><span class="n">spwids_str</span><span class="p">,</span> <span class="n">combine</span><span class="o">=</span><span class="n">combine</span><span class="p">)</span>
        <span class="c1"># Otherwise, perform separate gaincal for each scan group:</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Determine scan groups for intent.</span>
            <span class="n">scan_groups</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_scan_groups</span><span class="p">(</span><span class="n">intent</span><span class="o">=</span><span class="n">intent</span><span class="p">)</span>

            <span class="c1"># Run gaincal for the first scan group.</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_do_gaincal</span><span class="p">(</span><span class="n">intent</span><span class="o">=</span><span class="n">intent</span><span class="p">,</span> <span class="n">spw</span><span class="o">=</span><span class="n">spwids_str</span><span class="p">,</span> <span class="n">combine</span><span class="o">=</span><span class="n">combine</span><span class="p">,</span> <span class="n">scan</span><span class="o">=</span><span class="n">scan_groups</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

            <span class="c1"># Run gaincal for any additional scan groups, appending to the initial caltable.</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">scan_groups</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">caltable</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">inputs</span><span class="p">[</span><span class="s1">&#39;caltable&#39;</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">scan_group</span> <span class="ow">in</span> <span class="n">scan_groups</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_do_gaincal</span><span class="p">(</span><span class="n">intent</span><span class="o">=</span><span class="n">intent</span><span class="p">,</span> <span class="n">spw</span><span class="o">=</span><span class="n">spwids_str</span><span class="p">,</span> <span class="n">combine</span><span class="o">=</span><span class="n">combine</span><span class="p">,</span> <span class="n">caltable</span><span class="o">=</span><span class="n">caltable</span><span class="p">,</span> <span class="n">scan</span><span class="o">=</span><span class="n">scan_group</span><span class="p">,</span>
                                     <span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_do_phasecal_for_diffgain_reference</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">common</span><span class="o">.</span><span class="n">GaincalResults</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="n">IntentField</span><span class="p">,</span> <span class="n">SpwMapping</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute phase gain solutions for the diffgain reference intent and</span>
<span class="sd">        register the resulting caltable in the local task context to be applied</span>
<span class="sd">        to the diffgain on-source intent.</span>

<span class="sd">        Returns:</span>
<span class="sd">            2-tuple containing:</span>
<span class="sd">            * GaincalResults for diffgain reference.</span>
<span class="sd">            * Updated SpW mapping dictionary; can be empty if no updates were necessary.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">intent</span> <span class="o">=</span> <span class="s1">&#39;DIFFGAINREF&#39;</span>

        <span class="c1"># Select which spectral windows to act on.</span>
        <span class="n">spwids</span> <span class="o">=</span> <span class="p">[</span><span class="n">spw</span><span class="o">.</span><span class="n">id</span> <span class="k">for</span> <span class="n">spw</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">ms</span><span class="o">.</span><span class="n">get_spectral_windows</span><span class="p">(</span><span class="n">intent</span><span class="o">=</span><span class="n">intent</span><span class="p">)]</span>

        <span class="c1"># Assess if SpW combination is necessary.</span>
        <span class="n">combine_spw</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_assess_if_spw_combination_is_necessary</span><span class="p">(</span>
            <span class="n">intent</span><span class="p">,</span> <span class="n">spwids</span><span class="p">,</span> <span class="n">force_for_spwmapmodes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="s1">&#39;both&#39;</span><span class="p">,</span> <span class="s1">&#39;reference&#39;</span><span class="p">])</span>

        <span class="c1"># With choice made of whether SpW combination is necessary, now run</span>
        <span class="c1"># phase calibration for the diffgain reference intent scans.</span>
        <span class="n">combine</span> <span class="o">=</span> <span class="s1">&#39;spw&#39;</span> <span class="k">if</span> <span class="n">combine_spw</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span>
        <span class="n">phasecal_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_do_phasecal</span><span class="p">(</span><span class="n">intent</span><span class="o">=</span><span class="n">intent</span><span class="p">,</span> <span class="n">spw</span><span class="o">=</span><span class="n">spwids</span><span class="p">,</span> <span class="n">combine</span><span class="o">=</span><span class="n">combine</span><span class="p">)</span>

        <span class="c1"># Check phase caltable for missing / fully flagged SpW, turn into QA</span>
        <span class="c1"># message, and attach message to phase GaincalResults.</span>
        <span class="n">phasecal_result</span><span class="o">.</span><span class="n">qa_message</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_assess_spws_in_gaintable</span><span class="p">(</span><span class="n">phasecal_result</span><span class="p">,</span> <span class="n">combine_spw</span><span class="p">,</span> <span class="n">spwids</span><span class="p">)</span>

        <span class="c1"># Update SpW mapping for phase calibrator based on whether SpW</span>
        <span class="c1"># combination is necessary for the diffgain reference.</span>
        <span class="n">updated_spwmaps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_update_spwmap_for_phase</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">ms</span><span class="p">,</span> <span class="n">combine_spw</span><span class="p">)</span>

        <span class="c1"># If a caltable was created, then create a modified CalApplication to</span>
        <span class="c1"># correctly register the caltable.</span>
        <span class="k">if</span> <span class="n">phasecal_result</span><span class="o">.</span><span class="n">pool</span><span class="p">:</span>
            <span class="c1"># Retrieve the diffgain spectral windows, and create SpW mapping to</span>
            <span class="c1"># re-map diffgain on-source SpWs to diffgain reference SpWs.</span>
            <span class="n">dg_refspws</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">ms</span><span class="o">.</span><span class="n">get_spectral_windows</span><span class="p">(</span><span class="n">intent</span><span class="o">=</span><span class="s1">&#39;DIFFGAINREF&#39;</span><span class="p">)</span>
            <span class="n">dg_srcspws</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">ms</span><span class="o">.</span><span class="n">get_spectral_windows</span><span class="p">(</span><span class="n">intent</span><span class="o">=</span><span class="s1">&#39;DIFFGAINSRC&#39;</span><span class="p">)</span>
            <span class="n">dg_spwmap</span> <span class="o">=</span> <span class="n">update_spwmap_for_band_to_band</span><span class="p">([],</span> <span class="n">dg_refspws</span><span class="p">,</span> <span class="n">dg_srcspws</span><span class="p">,</span> <span class="n">combine_spw</span><span class="p">)</span>

            <span class="c1"># Define CalApplication overrides to specify how the diffgain</span>
            <span class="c1"># reference phase solutions should be registered in the callibrary.</span>
            <span class="c1"># Note: solutions derived for the diffgain reference intent are</span>
            <span class="c1"># registered here to be applied to the diffgain on-source intent and</span>
            <span class="c1"># SpWs with a corresponding SpW mapping.</span>
            <span class="n">calapp_overrides</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;calwt&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
                <span class="s1">&#39;intent&#39;</span><span class="p">:</span> <span class="s1">&#39;DIFFGAINSRC&#39;</span><span class="p">,</span>
                <span class="s1">&#39;interp&#39;</span><span class="p">:</span> <span class="s1">&#39;linearPD,linear&#39;</span><span class="p">,</span>
                <span class="s1">&#39;spw&#39;</span><span class="p">:</span> <span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">spw</span><span class="o">.</span><span class="n">id</span><span class="p">)</span> <span class="k">for</span> <span class="n">spw</span> <span class="ow">in</span> <span class="n">dg_srcspws</span><span class="p">),</span>
                <span class="s1">&#39;spwmap&#39;</span><span class="p">:</span> <span class="n">dg_spwmap</span><span class="p">,</span>
            <span class="p">}</span>

            <span class="c1"># There should be only 1 caltable, so replace the CalApp for that</span>
            <span class="c1"># one.</span>
            <span class="n">modified_calapp</span> <span class="o">=</span> <span class="n">callibrary</span><span class="o">.</span><span class="n">copy_calapplication</span><span class="p">(</span><span class="n">phasecal_result</span><span class="o">.</span><span class="n">pool</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">**</span><span class="n">calapp_overrides</span><span class="p">)</span>
            <span class="n">phasecal_result</span><span class="o">.</span><span class="n">pool</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">modified_calapp</span>
            <span class="n">phasecal_result</span><span class="o">.</span><span class="n">final</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">modified_calapp</span>

            <span class="c1"># Register these diffgain reference phase solutions into local</span>
            <span class="c1"># context to ensure that these are used in pre-apply when computing</span>
            <span class="c1"># phase solutions for the diffgain on-source intent.</span>
            <span class="n">phasecal_result</span><span class="o">.</span><span class="n">accept</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">context</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">phasecal_result</span><span class="p">,</span> <span class="n">updated_spwmaps</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_do_phasecal_for_diffgain_onsource</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">common</span><span class="o">.</span><span class="n">GaincalResults</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute phase gain solutions for the diffgain on-source intent. Gain</span>
<span class="sd">        solutions are created separately for groups of scans, using</span>
<span class="sd">        combine=&#39;scan&#39;, and appended to a single caltable. Each scan group is</span>
<span class="sd">        intended to comprise scans taken closely together in time (typically</span>
<span class="sd">        alternated with the diffgain reference scans), and these groups are</span>
<span class="sd">        typically done before and after the science target scans. In practice,</span>
<span class="sd">        scan groups are identified as scans with IDs separated by less than 4.</span>

<span class="sd">        The resulting caltable is immediately registered with the callibrary in</span>
<span class="sd">        the local task context (to ensure pre-apply in the subsequent</span>
<span class="sd">        computation of residual offset). For final acceptance of this caltable</span>
<span class="sd">        in the top-level callibrary, the CalApplication is updated to ensure the</span>
<span class="sd">        resulting caltable will be applied to the science target or check</span>
<span class="sd">        source.</span>

<span class="sd">        Returns:</span>
<span class="sd">            GaincalResults for the diffgain on-source phase solutions caltable,</span>
<span class="sd">            or None if no diffgain scan groups are identified.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">intent</span> <span class="o">=</span> <span class="s1">&#39;DIFFGAINSRC&#39;</span>

        <span class="c1"># Determine scan groups for diffgain on-source intent. Exit early if no</span>
        <span class="c1"># scan groups could be identified.</span>
        <span class="n">scan_groups</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_scan_groups</span><span class="p">(</span><span class="n">intent</span><span class="o">=</span><span class="n">intent</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">scan_groups</span><span class="p">:</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">ms</span><span class="o">.</span><span class="n">basename</span><span class="si">}</span><span class="s2">: no scan groups found for diffgain on-source intent.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># Select which spectral windows to act on.</span>
        <span class="n">spwids</span> <span class="o">=</span> <span class="p">[</span><span class="n">spw</span><span class="o">.</span><span class="n">id</span> <span class="k">for</span> <span class="n">spw</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">ms</span><span class="o">.</span><span class="n">get_spectral_windows</span><span class="p">(</span><span class="n">intent</span><span class="o">=</span><span class="n">intent</span><span class="p">)]</span>

        <span class="c1"># Assess if SpW combination is necessary.</span>
        <span class="n">combine_spw</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_assess_if_spw_combination_is_necessary</span><span class="p">(</span>
            <span class="n">intent</span><span class="p">,</span> <span class="n">spwids</span><span class="p">,</span> <span class="n">force_for_spwmapmodes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="s1">&#39;offset&#39;</span><span class="p">],</span> <span class="n">scan_groups</span><span class="o">=</span><span class="n">scan_groups</span><span class="p">)</span>

        <span class="c1"># With choice made of whether SpW combination is necessary, now run</span>
        <span class="c1"># phase calibration for the diffgain on-source intent scans. Note, for</span>
        <span class="c1"># the diffgain on-source intent, solves are done separately per-scan,</span>
        <span class="c1"># using combination over the scan.</span>
        <span class="n">combine</span> <span class="o">=</span> <span class="s1">&#39;scan,spw&#39;</span> <span class="k">if</span> <span class="n">combine_spw</span> <span class="k">else</span> <span class="s1">&#39;scan&#39;</span>
        <span class="n">phasecal_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_do_phasecal</span><span class="p">(</span><span class="n">intent</span><span class="o">=</span><span class="n">intent</span><span class="p">,</span> <span class="n">spw</span><span class="o">=</span><span class="n">spwids</span><span class="p">,</span> <span class="n">combine</span><span class="o">=</span><span class="n">combine</span><span class="p">)</span>

        <span class="c1"># Check phase caltable for missing / fully flagged SpW, turn into QA</span>
        <span class="c1"># message, and attach message to phase GaincalResults.</span>
        <span class="n">phasecal_result</span><span class="o">.</span><span class="n">qa_message</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_assess_spws_in_gaintable</span><span class="p">(</span><span class="n">phasecal_result</span><span class="p">,</span> <span class="n">combine_spw</span><span class="p">,</span> <span class="n">spwids</span><span class="p">,</span>
                                                                    <span class="n">scan_groups</span><span class="o">=</span><span class="n">scan_groups</span><span class="p">)</span>

        <span class="c1"># If a caltable was created, then create a modified CalApplication to</span>
        <span class="c1"># correctly register the caltable.</span>
        <span class="k">if</span> <span class="n">phasecal_result</span><span class="o">.</span><span class="n">pool</span><span class="p">:</span>
            <span class="c1"># If SpW combination was used for the diffgain on-source, then</span>
            <span class="c1"># compute a corresponding SpW map.</span>
            <span class="k">if</span> <span class="n">combine_spw</span><span class="p">:</span>
                <span class="n">dg_srcspws</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">ms</span><span class="o">.</span><span class="n">get_spectral_windows</span><span class="p">(</span><span class="n">intent</span><span class="o">=</span><span class="n">intent</span><span class="p">)</span>
                <span class="n">dg_spwmap</span> <span class="o">=</span> <span class="n">combine_spwmap</span><span class="p">(</span><span class="n">dg_srcspws</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dg_spwmap</span> <span class="o">=</span> <span class="p">[]</span>
                
            <span class="c1"># Prior to registering this caltable into the local context, set</span>
            <span class="c1"># overrides in the CalApplication:</span>
            <span class="n">calapp_overrides</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;calwt&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
                <span class="s1">&#39;intent&#39;</span><span class="p">:</span> <span class="n">intent</span><span class="p">,</span>
                <span class="s1">&#39;spwmap&#39;</span><span class="p">:</span> <span class="n">dg_spwmap</span><span class="p">,</span>
            <span class="p">}</span>
            <span class="n">modified_calapp</span> <span class="o">=</span> <span class="n">callibrary</span><span class="o">.</span><span class="n">copy_calapplication</span><span class="p">(</span><span class="n">phasecal_result</span><span class="o">.</span><span class="n">pool</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">**</span><span class="n">calapp_overrides</span><span class="p">)</span>
            <span class="n">phasecal_result</span><span class="o">.</span><span class="n">pool</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">modified_calapp</span>
            <span class="n">phasecal_result</span><span class="o">.</span><span class="n">final</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">modified_calapp</span>

            <span class="c1"># Register the diffgain on-source phase solutions into local context</span>
            <span class="c1"># to ensure that these are used in pre-apply when computing the</span>
            <span class="c1"># residual phase offsets (diagnostic) caltable.</span>
            <span class="n">phasecal_result</span><span class="o">.</span><span class="n">accept</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">context</span><span class="p">)</span>

            <span class="c1"># Update the CalApplication again, this time to ensure this diffgain</span>
            <span class="c1"># phase offsets caltable will be applied to the science target</span>
            <span class="c1"># and/or check source.</span>
            <span class="n">calapp_overrides</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;calwt&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
                <span class="s1">&#39;intent&#39;</span><span class="p">:</span> <span class="s1">&#39;TARGET,CHECK&#39;</span><span class="p">,</span>
                <span class="s1">&#39;spwmap&#39;</span><span class="p">:</span> <span class="n">dg_spwmap</span><span class="p">,</span>
            <span class="p">}</span>
            <span class="n">modified_calapp</span> <span class="o">=</span> <span class="n">callibrary</span><span class="o">.</span><span class="n">copy_calapplication</span><span class="p">(</span><span class="n">phasecal_result</span><span class="o">.</span><span class="n">pool</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">**</span><span class="n">calapp_overrides</span><span class="p">)</span>
            <span class="n">phasecal_result</span><span class="o">.</span><span class="n">pool</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">modified_calapp</span>
            <span class="n">phasecal_result</span><span class="o">.</span><span class="n">final</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">modified_calapp</span>

        <span class="k">return</span> <span class="n">phasecal_result</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_do_phasecal_for_diffgain_residual_offsets</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">common</span><span class="o">.</span><span class="n">GaincalResults</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute residual phase offsets caltable for the diffgain on-source intent.</span>

<span class="sd">        Returns:</span>
<span class="sd">            GaincalResults for the diffgain on-source residual phase solutions</span>
<span class="sd">            caltable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">intent</span> <span class="o">=</span> <span class="s1">&#39;DIFFGAINSRC&#39;</span>

        <span class="c1"># Select which spectral windows to act on.</span>
        <span class="n">spwids</span> <span class="o">=</span> <span class="p">[</span><span class="n">spw</span><span class="o">.</span><span class="n">id</span> <span class="k">for</span> <span class="n">spw</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">ms</span><span class="o">.</span><span class="n">get_spectral_windows</span><span class="p">(</span><span class="n">intent</span><span class="o">=</span><span class="n">intent</span><span class="p">)]</span>

        <span class="c1"># Assess if SpW combination is necessary.</span>
        <span class="n">combine_spw</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_assess_if_spw_combination_is_necessary</span><span class="p">(</span>
            <span class="n">intent</span><span class="p">,</span> <span class="n">spwids</span><span class="p">,</span> <span class="n">force_for_spwmapmodes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="s1">&#39;both&#39;</span><span class="p">,</span> <span class="s1">&#39;residual&#39;</span><span class="p">])</span>

        <span class="c1"># With choice made of whether SpW combination is necessary, now run</span>
        <span class="c1"># phase calibration for the diffgain on-source intent scans, with the</span>
        <span class="c1"># phase solutions for diffgain on-source intent in pre-apply, to assess</span>
        <span class="c1"># the residual phase offsets.</span>
        <span class="n">combine</span> <span class="o">=</span> <span class="s1">&#39;spw&#39;</span> <span class="k">if</span> <span class="n">combine_spw</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span>
        <span class="n">phasecal_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_do_phasecal</span><span class="p">(</span><span class="n">intent</span><span class="o">=</span><span class="n">intent</span><span class="p">,</span> <span class="n">spw</span><span class="o">=</span><span class="n">spwids</span><span class="p">,</span> <span class="n">combine</span><span class="o">=</span><span class="n">combine</span><span class="p">)</span>

        <span class="c1"># Check phase caltable for missing / fully flagged SpW, turn into QA</span>
        <span class="c1"># message, and attach message to phase GaincalResults.</span>
        <span class="n">phasecal_result</span><span class="o">.</span><span class="n">qa_message</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_assess_spws_in_gaintable</span><span class="p">(</span><span class="n">phasecal_result</span><span class="p">,</span> <span class="n">combine_spw</span><span class="p">,</span> <span class="n">spwids</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">phasecal_result</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_scan_groups</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">intent</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return list of scan groups associated with given intent, where each</span>
<span class="sd">        group are scans separated by less than 4 in ID.</span>

<span class="sd">        E.g., if the scans for given intent are:</span>
<span class="sd">          &#39;5,7,9,11,79,81,83&#39;</span>
<span class="sd">        Then this will return:</span>
<span class="sd">          [&#39;5,7,9,11&#39;, &#39;79,81,83&#39;]</span>

<span class="sd">        Returns:</span>
<span class="sd">            List of groups of scans.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get IDs of DIFFGAIN scans for given intent.</span>
        <span class="n">dg_scanids</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">scan</span><span class="o">.</span><span class="n">id</span> <span class="k">for</span> <span class="n">scan</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">ms</span><span class="o">.</span><span class="n">get_scans</span><span class="p">(</span><span class="n">scan_intent</span><span class="o">=</span><span class="n">intent</span><span class="p">))</span>

        <span class="c1"># Group scans separated in ID by less than 4.</span>
        <span class="n">scan_groups</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">group</span><span class="p">))</span>
                       <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">dg_scanids</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">dg_scanids</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>

        <span class="k">return</span> <span class="n">scan_groups</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_update_spwmap_for_phase</span><span class="p">(</span><span class="n">ms</span><span class="p">:</span> <span class="n">MeasurementSet</span><span class="p">,</span> <span class="n">combine_spw</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="n">IntentField</span><span class="p">,</span> <span class="n">SpwMapping</span><span class="p">]:</span>
        <span class="c1"># If SpW combination is not necessary, then no need for updated</span>
        <span class="c1"># SpW mapping.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">combine_spw</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{}</span>

        <span class="c1"># Otherwise, check whether there exists a SpwMapping for the PHASE</span>
        <span class="c1"># calibrator; if this was already specifying to use SpW combination,</span>
        <span class="c1"># then no need for an updated SpwMapping.</span>
        <span class="n">phase_spwmappings</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">ms</span><span class="o">.</span><span class="n">spwmaps</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span><span class="o">.</span><span class="n">intent</span> <span class="o">==</span> <span class="s1">&#39;PHASE&#39;</span><span class="p">}</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">phase_spwmappings</span> <span class="ow">or</span> <span class="nb">any</span><span class="p">(</span><span class="n">spwmapping</span><span class="o">.</span><span class="n">combine</span> <span class="k">for</span> <span class="n">spwmapping</span> <span class="ow">in</span> <span class="n">phase_spwmappings</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
            <span class="k">return</span> <span class="p">{}</span>

        <span class="c1"># Otherwise, proceed to create a new SpW map for the PHASE calibrator</span>
        <span class="c1"># that is appropriate for SpW combination.</span>
        <span class="c1">#</span>
        <span class="c1"># First create a SpW map for combining the (low frequency) diffgain</span>
        <span class="c1"># reference SpWs.</span>
        <span class="n">dg_refspws</span> <span class="o">=</span> <span class="n">ms</span><span class="o">.</span><span class="n">get_spectral_windows</span><span class="p">(</span><span class="n">intent</span><span class="o">=</span><span class="s1">&#39;DIFFGAINREF&#39;</span><span class="p">)</span>
        <span class="n">spwmap</span> <span class="o">=</span> <span class="n">combine_spwmap</span><span class="p">(</span><span class="n">dg_refspws</span><span class="p">)</span>
        <span class="c1"># Then, update the SpW map for band-to-band, adding in the (high</span>
        <span class="c1"># frequency) diffgain science SpWs.</span>
        <span class="n">dg_srcspws</span> <span class="o">=</span> <span class="n">ms</span><span class="o">.</span><span class="n">get_spectral_windows</span><span class="p">(</span><span class="n">intent</span><span class="o">=</span><span class="s1">&#39;DIFFGAINSRC&#39;</span><span class="p">)</span>
        <span class="n">spwmap</span> <span class="o">=</span> <span class="n">update_spwmap_for_band_to_band</span><span class="p">(</span><span class="n">spwmap</span><span class="p">,</span> <span class="n">dg_refspws</span><span class="p">,</span> <span class="n">dg_srcspws</span><span class="p">,</span> <span class="n">combine</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Update the SpwMapping for the PHASE calibrators.</span>
        <span class="k">for</span> <span class="n">intfld</span><span class="p">,</span> <span class="n">spwmapping</span> <span class="ow">in</span> <span class="n">phase_spwmappings</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># Retrieve SNR estimates for diffgain reference SpWs, compute their</span>
            <span class="c1"># estimated combined SNR.</span>
            <span class="n">dg_refspwids</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">id</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">dg_refspws</span><span class="p">]</span>
            <span class="n">combined_snr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">([</span><span class="n">snr</span> <span class="k">for</span> <span class="n">spwid</span><span class="p">,</span> <span class="n">snr</span> <span class="ow">in</span> <span class="n">spwmapping</span><span class="o">.</span><span class="n">snr_info</span>
                                           <span class="k">if</span> <span class="n">spwid</span> <span class="ow">in</span> <span class="n">dg_refspwids</span><span class="p">])</span>
            <span class="c1"># Create new SNR info dictionary with the combined SNR entry, and</span>
            <span class="c1"># add the SNR info for individual SpWs from the original SpwMapping.</span>
            <span class="n">snr_info</span> <span class="o">=</span> <span class="p">{</span><span class="sa">f</span><span class="s2">&quot;Combined (</span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dg_refspwids</span><span class="p">)</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">:</span> <span class="n">combined_snr</span><span class="p">}</span>
            <span class="n">snr_info</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">spwmapping</span><span class="o">.</span><span class="n">snr_info</span><span class="p">)</span>

            <span class="c1"># Store as a new SpwMapping with updated values for combine, spwmap,</span>
            <span class="c1"># and the SNR info.</span>
            <span class="n">phase_spwmappings</span><span class="p">[</span><span class="n">intfld</span><span class="p">]</span> <span class="o">=</span> <span class="n">spwmapping</span><span class="o">.</span><span class="n">_replace</span><span class="p">(</span><span class="n">combine</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">spwmap</span><span class="o">=</span><span class="n">spwmap</span><span class="p">,</span> <span class="n">snr_info</span><span class="o">=</span><span class="n">snr_info</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">phase_spwmappings</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_get_scan_and_integration_time</span><span class="p">(</span><span class="n">ms</span><span class="p">:</span> <span class="n">MeasurementSet</span><span class="p">,</span> <span class="n">intent</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">field</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">spwids</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieve the scan (exposure) and integration time, in seconds, used for</span>
<span class="sd">        given intent and field in given measurement set.</span>

<span class="sd">        Args:</span>
<span class="sd">            ms: measurement set to use.</span>
<span class="sd">            intent: intent to retrieve times for.</span>
<span class="sd">            field: field to retrieve times for.</span>
<span class="sd">            spwids: spectral window ids to retrieve times for.</span>

<span class="sd">        Returns:</span>
<span class="sd">            2-Tuple containing:</span>
<span class="sd">            - scan (exposure) time in seconds for given ms, intent, field.</span>
<span class="sd">            - integration time in seconds for given ms, intent, field.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get scans for given intent, field, spwids.</span>
        <span class="n">scans</span> <span class="o">=</span> <span class="n">ms</span><span class="o">.</span><span class="n">get_scans</span><span class="p">(</span><span class="n">scan_intent</span><span class="o">=</span><span class="n">intent</span><span class="p">,</span> <span class="n">field</span><span class="o">=</span><span class="n">field</span><span class="p">,</span> <span class="n">spw</span><span class="o">=</span><span class="n">spwids</span><span class="p">)</span>

        <span class="c1"># Assume that the integration time and scan time are the same for all</span>
        <span class="c1"># scans and all SpWs for given intent, so use the first scan and first</span>
        <span class="c1"># spectral window as the representative ones.</span>
        <span class="n">int_time</span> <span class="o">=</span> <span class="n">scans</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">mean_interval</span><span class="p">(</span><span class="n">spwids</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">total_seconds</span><span class="p">()</span>
        <span class="n">scan_time</span> <span class="o">=</span> <span class="n">scans</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">exposure_time</span><span class="p">(</span><span class="n">spwids</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">total_seconds</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">scan_time</span><span class="p">,</span> <span class="n">int_time</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020–2025, Pipeline Dev. Team, build: 2025.1.1.56+250-g1994e22177-update-docs-build-and-packaging-setup.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>