

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>pipeline.hifa.tasks.fluxscale.qa &mdash; Pipeline unknown documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../../../_static/graphviz.css?v=4ae1632d" />
      <link rel="stylesheet" type="text/css" href="../../../../../_static/custom_theme.css?v=678032d9" />

  
      <script src="../../../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../../../_static/documentation_options.js?v=3f1b9271"></script>
      <script src="../../../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../../index.html" class="icon icon-home">
            Pipeline
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Pipeline Tasks</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../pipeline_tasks/pipeline_tasks.html">Pipeline Heuristics Tasks</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Pipeline Task (sphinx-autosummary)</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../_autosummary/pipeline.h.cli.html">pipeline.h.cli</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../_autosummary/pipeline.hif.cli.html">pipeline.hif.cli</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../_autosummary/pipeline.hifa.cli.html">pipeline.hifa.cli</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../_autosummary/pipeline.hifv.cli.html">pipeline.hifv.cli</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../_autosummary/pipeline.hsd.cli.html">pipeline.hsd.cli</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../_autosummary/pipeline.hsdn.cli.html">pipeline.hsdn.cli</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../_autosummary/pipeline.domain.html">pipeline.domain</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../_autosummary/pipeline.infrastructure.launcher.html">pipeline.infrastructure.launcher</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../_autosummary/pipeline.domain.html">pipeline.domain</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../_autosummary/pipeline.infrastructure.launcher.html">pipeline.infrastructure.launcher</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Pipeline Heuristics</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../heuristics/field_parameter.html">Field parameter</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../heuristics/FlaggingTasks.html">Pipeline Flagging Tasks</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Releases etc.</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../releases.html">Pipeline Releases</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../modular.html">Run the Pipeline in a Conda environment</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../dependencies.html">Dependencies of <cite>Pipeline</cite></a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Pipeline Basics</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../basics.html">pipeline.domain</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../basics.html#module-pipeline.infrastructure.launcher">pipeline.infrastructure.launcher</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Task Classes</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../task_classes.html">pipeline</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../task_classes.html#module-pipeline.hif.tasks">pipeline-l2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../task_classes.html#module-pipeline.hif">pipeline-l3</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../task_classes.html#pipeline-diagram">pipeline-diagram</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Developer Notes</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../develdocmd/ways_to_run_the_pipeline.html">Ways to run the Pipeline</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../develdocmd/comparing_pipeline_executions.html">Comparing pipeline executions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../develdocmd/building_the_pipeline.html">Building the pipeline</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../develdocmd/ALMA-Imaging-Workflow.html">ALMA interferometry imaging workflow</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../develdocmd/VLA-Imaging-Workflow.html">VLA interferometry imaging workflow</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../develdocmd/VLASS-SE-CONT-Imaging-Workflow.html">VLASS-SE-CONT imaging workflow</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../develdocmd/VLASS-SE-CUBE-Imaging-Workflow.html">VLASS-SE-CUBE imaging workflow</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../develdocmd/selfcal_workflow.html">VLASS Selfcal &amp; Restore workflows</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../develdocmd/pipeline_tests.html">Pipeline testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../develdocmd/DataType_Testing.html">DataType Testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../develdocmd/QA_scores.html">Pipeline Quality Assurance (QA) Score Class Design</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../develdocmd/DeveloperDocumentation.html">Pipeline developer documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../develdocmd/python3_conversion_notes.html">Python 3 conversion notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../develdocmd/recipes.html">Pipeline Recipes</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Examples Notes (from Jupyter Notebooks)</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../examples/test1.html">test</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Example Notes (from .rst)</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../examples/test2.html">Example 1</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../../index.html">Pipeline</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../../../index.html">Module code</a></li>
          <li class="breadcrumb-item"><a href="../../../../pipeline.html">pipeline</a></li>
      <li class="breadcrumb-item active">pipeline.hifa.tasks.fluxscale.qa</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for pipeline.hifa.tasks.fluxscale.qa</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">ast</span>
<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">import</span> <span class="nn">operator</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">from</span> <span class="nn">decimal</span> <span class="kn">import</span> <span class="n">Decimal</span>
<span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">sqrt</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Tuple</span>

<span class="kn">import</span> <span class="nn">numpy</span>

<span class="kn">import</span> <span class="nn">pipeline.infrastructure</span> <span class="k">as</span> <span class="nn">infrastructure</span>
<span class="kn">import</span> <span class="nn">pipeline.infrastructure.pipelineqa</span> <span class="k">as</span> <span class="nn">pqa</span>
<span class="kn">import</span> <span class="nn">pipeline.infrastructure.utils</span> <span class="k">as</span> <span class="nn">utils</span>
<span class="kn">import</span> <span class="nn">pipeline.qa.scorecalculator</span> <span class="k">as</span> <span class="nn">qacalc</span>
<span class="kn">from</span> <span class="nn">pipeline.domain</span> <span class="kn">import</span> <span class="n">Field</span><span class="p">,</span> <span class="n">FluxMeasurement</span><span class="p">,</span> <span class="n">MeasurementSet</span><span class="p">,</span> <span class="n">SpectralWindow</span>
<span class="kn">from</span> <span class="nn">pipeline.domain.measures</span> <span class="kn">import</span> <span class="n">FluxDensity</span><span class="p">,</span> <span class="n">FluxDensityUnits</span><span class="p">,</span> <span class="n">Frequency</span><span class="p">,</span> <span class="n">FrequencyUnits</span>
<span class="kn">from</span> <span class="nn">pipeline.h.tasks.common</span> <span class="kn">import</span> <span class="n">commonfluxresults</span>
<span class="kn">from</span> <span class="nn">pipeline.h.tasks.importdata.fluxes</span> <span class="kn">import</span> <span class="n">ORIGIN_ANALYSIS_UTILS</span><span class="p">,</span> <span class="n">ORIGIN_XML</span>
<span class="kn">from</span> <span class="nn">pipeline.hifa.heuristics.snr</span> <span class="kn">import</span> <span class="n">ALMA_BANDS</span><span class="p">,</span> <span class="n">ALMA_SENSITIVITIES</span><span class="p">,</span> <span class="n">ALMA_TSYS</span>
<span class="kn">from</span> <span class="nn">pipeline.hifa.tasks.importdata.dbfluxes</span> <span class="kn">import</span> <span class="n">ORIGIN_DB</span>
<span class="kn">from</span> <span class="nn">pipeline.infrastructure</span> <span class="kn">import</span> <span class="n">casa_tools</span>
<span class="kn">from</span> <span class="nn">pipeline.infrastructure.launcher</span> <span class="kn">import</span> <span class="n">Context</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">gcorfluxscale</span>

<span class="n">LOG</span> <span class="o">=</span> <span class="n">infrastructure</span><span class="o">.</span><span class="n">get_logger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>

<span class="n">COLSHAPE_FORMAT</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\[(?P&lt;num_pols&gt;\d+), (?P&lt;num_rows&gt;\d+)\]&#39;</span><span class="p">)</span>

<span class="c1"># Defines some characteristic values for each ALMA receiver band.</span>
<span class="c1"># sensitivity = mJy (for 16*12m antennas, 1 minute, 8 GHz, 2pol)</span>
<span class="n">BandInfo</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;BandInfo&#39;</span><span class="p">,</span> <span class="s1">&#39;name number nominal_tsys sensitivity&#39;</span><span class="p">)</span>
<span class="n">BAND_INFOS</span> <span class="o">=</span> <span class="p">[</span><span class="n">BandInfo</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">ALMA_BANDS</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">number</span><span class="o">=</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">nominal_tsys</span><span class="o">=</span><span class="n">ALMA_TSYS</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                       <span class="n">sensitivity</span><span class="o">=</span><span class="n">FluxDensity</span><span class="p">(</span><span class="n">ALMA_SENSITIVITIES</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">FluxDensityUnits</span><span class="o">.</span><span class="n">MILLIJANSKY</span><span class="p">))</span>
              <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ALMA_BANDS</span><span class="p">))]</span>

<span class="c1"># External flux providers</span>
<span class="n">EXTERNAL_SOURCES</span> <span class="o">=</span> <span class="p">(</span><span class="n">ORIGIN_ANALYSIS_UTILS</span><span class="p">,</span> <span class="n">ORIGIN_DB</span><span class="p">,</span> <span class="n">ORIGIN_XML</span><span class="p">)</span>

<span class="c1"># Trusted flux providers. Using untrusted providers will result in a warning.</span>
<span class="n">TRUSTED_SOURCES</span> <span class="o">=</span> <span class="p">(</span><span class="n">ORIGIN_ANALYSIS_UTILS</span><span class="p">,</span> <span class="n">ORIGIN_DB</span><span class="p">)</span>


<div class="viewcode-block" id="GcorFluxscaleQAHandler">
<a class="viewcode-back" href="../../../../../_apidoc/pipeline.hifa.tasks.fluxscale.html#pipeline.hifa.tasks.fluxscale.qa.GcorFluxscaleQAHandler">[docs]</a>
<span class="k">class</span> <span class="nc">GcorFluxscaleQAHandler</span><span class="p">(</span><span class="n">pqa</span><span class="o">.</span><span class="n">QAPlugin</span><span class="p">):</span>
    <span class="n">result_cls</span> <span class="o">=</span> <span class="n">commonfluxresults</span><span class="o">.</span><span class="n">FluxCalibrationResults</span>
    <span class="n">child_cls</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">generating_task</span> <span class="o">=</span> <span class="n">gcorfluxscale</span><span class="o">.</span><span class="n">GcorFluxscale</span>

<div class="viewcode-block" id="GcorFluxscaleQAHandler.handle">
<a class="viewcode-back" href="../../../../../_apidoc/pipeline.hifa.tasks.fluxscale.html#pipeline.hifa.tasks.fluxscale.qa.GcorFluxscaleQAHandler.handle">[docs]</a>
    <span class="k">def</span> <span class="nf">handle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">result</span><span class="p">):</span>
        <span class="n">vis</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">inputs</span><span class="p">[</span><span class="s1">&#39;vis&#39;</span><span class="p">]</span>
        <span class="n">ms</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">observing_run</span><span class="o">.</span><span class="n">get_ms</span><span class="p">(</span><span class="n">vis</span><span class="p">)</span>

        <span class="c1"># Check for existence of field / spw combinations for which</span>
        <span class="c1"># the derived fluxes are missing.</span>
        <span class="n">score1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_missing_derived_fluxes</span><span class="p">(</span><span class="n">ms</span><span class="p">,</span> <span class="n">result</span><span class="o">.</span><span class="n">inputs</span><span class="p">[</span><span class="s1">&#39;transfer&#39;</span><span class="p">],</span> <span class="n">result</span><span class="o">.</span><span class="n">inputs</span><span class="p">[</span><span class="s1">&#39;transintent&#39;</span><span class="p">],</span>
                                              <span class="n">result</span><span class="o">.</span><span class="n">measurements</span><span class="p">)</span>
        <span class="n">score2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_low_snr_fluxes</span><span class="p">(</span><span class="n">ms</span><span class="p">,</span> <span class="n">result</span><span class="o">.</span><span class="n">measurements</span><span class="p">)</span>
        <span class="n">scores</span> <span class="o">=</span> <span class="p">[</span><span class="n">score1</span><span class="p">,</span> <span class="n">score2</span><span class="p">]</span>

        <span class="n">scores</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">score_kspw</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">result</span><span class="p">))</span>

        <span class="n">result</span><span class="o">.</span><span class="n">qa</span><span class="o">.</span><span class="n">pool</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">scores</span><span class="p">)</span></div>


    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_missing_derived_fluxes</span><span class="p">(</span><span class="n">ms</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">intent</span><span class="p">,</span> <span class="n">measurements</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check whether there are missing derived fluxes. </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">qacalc</span><span class="o">.</span><span class="n">score_missing_derived_fluxes</span><span class="p">(</span><span class="n">ms</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">intent</span><span class="p">,</span> <span class="n">measurements</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_low_snr_fluxes</span><span class="p">(</span><span class="n">ms</span><span class="p">,</span> <span class="n">measurements</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check whether there are low SNR derived fluxes. </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">qacalc</span><span class="o">.</span><span class="n">score_derived_fluxes_snr</span><span class="p">(</span><span class="n">ms</span><span class="p">,</span> <span class="n">measurements</span><span class="p">)</span></div>



<div class="viewcode-block" id="GcorFluxscaleListQAHandler">
<a class="viewcode-back" href="../../../../../_apidoc/pipeline.hifa.tasks.fluxscale.html#pipeline.hifa.tasks.fluxscale.qa.GcorFluxscaleListQAHandler">[docs]</a>
<span class="k">class</span> <span class="nc">GcorFluxscaleListQAHandler</span><span class="p">(</span><span class="n">pqa</span><span class="o">.</span><span class="n">QAPlugin</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    QA handler for a list containing FluxCalibrationResults.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">result_cls</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Iterable</span>
    <span class="n">child_cls</span> <span class="o">=</span> <span class="n">commonfluxresults</span><span class="o">.</span><span class="n">FluxCalibrationResults</span>
    <span class="n">generating_task</span> <span class="o">=</span> <span class="n">gcorfluxscale</span><span class="o">.</span><span class="n">GcorFluxscale</span>

<div class="viewcode-block" id="GcorFluxscaleListQAHandler.handle">
<a class="viewcode-back" href="../../../../../_apidoc/pipeline.hifa.tasks.fluxscale.html#pipeline.hifa.tasks.fluxscale.qa.GcorFluxscaleListQAHandler.handle">[docs]</a>
    <span class="k">def</span> <span class="nf">handle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">result</span><span class="p">):</span>
        <span class="c1"># collate the QAScores from each child result, pulling them into our</span>
        <span class="c1"># own QAscore list</span>
        <span class="n">collated</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">flatten</span><span class="p">([</span><span class="n">r</span><span class="o">.</span><span class="n">qa</span><span class="o">.</span><span class="n">pool</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">result</span><span class="p">])</span>
        <span class="n">result</span><span class="o">.</span><span class="n">qa</span><span class="o">.</span><span class="n">pool</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">collated</span>

        <span class="n">mses</span> <span class="o">=</span> <span class="p">[</span><span class="n">r</span><span class="o">.</span><span class="n">inputs</span><span class="p">[</span><span class="s1">&#39;vis&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">result</span><span class="p">]</span>
        <span class="n">longmsg</span> <span class="o">=</span> <span class="s1">&#39;No missing derived fluxes in </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">utils</span><span class="o">.</span><span class="n">commafy</span><span class="p">(</span><span class="n">mses</span><span class="p">,</span> <span class="n">quotes</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">conjunction</span><span class="o">=</span><span class="s1">&#39;or&#39;</span><span class="p">)</span>
        <span class="n">result</span><span class="o">.</span><span class="n">qa</span><span class="o">.</span><span class="n">all_unity_longmsg</span> <span class="o">=</span> <span class="n">longmsg</span></div>
</div>



<div class="viewcode-block" id="score_kspw">
<a class="viewcode-back" href="../../../../../_apidoc/pipeline.hifa.tasks.fluxscale.html#pipeline.hifa.tasks.fluxscale.qa.score_kspw">[docs]</a>
<span class="k">def</span> <span class="nf">score_kspw</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">result</span><span class="p">):</span>
    <span class="c1"># Spec from CAS-10792:</span>
    <span class="c1">#</span>
    <span class="c1"># QA score 1: &quot;internal spw-spw consistency&quot;:</span>
    <span class="c1">#</span>
    <span class="c1"># Use a ratio of the (gflux flux for the SPW in question) / (catalog</span>
    <span class="c1"># flux for the SPW in question) / ( the same thing calculated for the</span>
    <span class="c1"># highest SNR wide [&gt;= 1 GHz] SPW). More precisely, defining</span>
    <span class="c1"># r_SPW = (gflux flux for SPW) / (catalog flux for SPW), I suggest</span>
    <span class="c1"># using K_SPW = r_spw / r_max_snr_spw as the metric. If there are no</span>
    <span class="c1"># &gt;= 1 GHz SPWs, use the highest SNR SPW which has a bandwidth greater</span>
    <span class="c1"># than or equal to the median bandwidth of all SPWs. SNR is to be</span>
    <span class="c1"># calculated from au.gaincalSNR() or equivalent, not from the SNR</span>
    <span class="c1"># implied by the weblog, which is less reliable in general.</span>

    <span class="c1"># Retrieve the MS.</span>
    <span class="n">ms</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">observing_run</span><span class="o">.</span><span class="n">get_ms</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">inputs</span><span class="p">[</span><span class="s1">&#39;vis&#39;</span><span class="p">])</span>

    <span class="c1"># Gather SpW IDs for all fields with flux measurements in the result.</span>
    <span class="n">fluxmeas_spwids</span> <span class="o">=</span> <span class="p">{</span><span class="n">fd</span><span class="o">.</span><span class="n">spw_id</span> <span class="k">for</span> <span class="n">measurements</span> <span class="ow">in</span> <span class="n">result</span><span class="o">.</span><span class="n">measurements</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="k">for</span> <span class="n">fd</span> <span class="ow">in</span> <span class="n">measurements</span><span class="p">}</span>

    <span class="c1"># Compute SNR info per SpW for the phase calibrator field; exit early if</span>
    <span class="c1"># no SNR info is available.</span>
    <span class="n">snr_info</span> <span class="o">=</span> <span class="n">_compute_snr_info</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">ms</span><span class="p">,</span> <span class="n">fluxmeas_spwids</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">snr_info</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span>

    <span class="c1"># Check whether the SNR info could be computed for all SpWs for which there</span>
    <span class="c1"># are flux measurements. If not, then log an error and return early.</span>
    <span class="n">snr_info_spwids</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">snr_info</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">fluxmeas_spwids</span><span class="p">}</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">snr_info_spwids</span><span class="o">.</span><span class="n">issuperset</span><span class="p">(</span><span class="n">fluxmeas_spwids</span><span class="p">):</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;Error calculating internal spw-spw consistency: could not identify highest SNR spectral window&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[]</span>

    <span class="c1"># Create QA scores for each field with flux measurements.</span>
    <span class="n">all_scores</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">field_id</span><span class="p">,</span> <span class="n">measurements</span> <span class="ow">in</span> <span class="n">result</span><span class="o">.</span><span class="n">measurements</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="c1"># get domain object for the field.</span>
        <span class="n">fields</span> <span class="o">=</span> <span class="n">ms</span><span class="o">.</span><span class="n">get_fields</span><span class="p">(</span><span class="n">task_arg</span><span class="o">=</span><span class="n">field_id</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">fields</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="n">field</span> <span class="o">=</span> <span class="n">fields</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># these strings will be used repeatedly in log messages</span>
        <span class="n">msg_intents</span> <span class="o">=</span> <span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">field</span><span class="o">.</span><span class="n">intents</span><span class="p">)</span>
        <span class="n">msg_fieldname</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">dequote</span><span class="p">(</span><span class="n">field</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

        <span class="c1"># Among SpWs in flux measurements for this field, identify the SpW with</span>
        <span class="c1"># the highest SNR. If no SpW could be determined, then skip this field</span>
        <span class="c1"># and continue with the next one.</span>
        <span class="n">highest_snr_spw</span> <span class="o">=</span> <span class="n">_get_highest_snr_spw</span><span class="p">(</span><span class="n">snr_info</span><span class="p">,</span> <span class="n">measurements</span><span class="p">,</span> <span class="n">ms</span><span class="p">,</span> <span class="n">msg_fieldname</span><span class="p">,</span> <span class="n">msg_intents</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">highest_snr_spw</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="c1"># Get the flux measurement with highest SNR and corresponding ratio of</span>
        <span class="c1"># derived flux over catalog flux. If no flux ratio could be determined,</span>
        <span class="c1"># then skip this field and continue with the next one.</span>
        <span class="n">highest_snr_measurement</span><span class="p">,</span> <span class="n">r_snr</span> <span class="o">=</span> <span class="n">_get_highest_snr_measurement_and_flux_ratio</span><span class="p">(</span>
            <span class="n">field</span><span class="p">,</span> <span class="n">highest_snr_spw</span><span class="p">,</span> <span class="n">measurements</span><span class="p">,</span> <span class="n">msg_fieldname</span><span class="p">,</span> <span class="n">msg_intents</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">r_snr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="c1"># Identify the other, non-highest-SNR, flux measurements that need to</span>
        <span class="c1"># be scored.</span>
        <span class="n">other_measurements</span> <span class="o">=</span> <span class="p">[</span><span class="n">m</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">measurements</span> <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">highest_snr_measurement</span><span class="p">]</span>

        <span class="c1"># Compute &quot;k_spw&quot; for the &quot;other&quot; measurements for current field. If no</span>
        <span class="c1"># &quot;k_spw&quot; could be computed, then skip this field and continue with the</span>
        <span class="c1"># next one.</span>
        <span class="n">k_spws</span> <span class="o">=</span> <span class="n">_compute_k_spws_for_flux_measurements</span><span class="p">(</span><span class="n">field</span><span class="p">,</span> <span class="n">other_measurements</span><span class="p">,</span> <span class="n">r_snr</span><span class="p">,</span> <span class="n">msg_fieldname</span><span class="p">,</span> <span class="n">msg_intents</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">k_spws</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="c1"># Compute QA score based on &quot;k_spw&quot; for current field, and add to list</span>
        <span class="c1"># of all QA scores.</span>
        <span class="n">field_qa_scores</span> <span class="o">=</span> <span class="p">[</span><span class="n">qacalc</span><span class="o">.</span><span class="n">score_gfluxscale_k_spw</span><span class="p">(</span><span class="n">ms</span><span class="o">.</span><span class="n">basename</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">spw_id</span><span class="p">,</span> <span class="n">k_spw</span><span class="p">,</span> <span class="n">highest_snr_spw</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
                           <span class="k">for</span> <span class="n">spw_id</span><span class="p">,</span> <span class="n">k_spw</span> <span class="ow">in</span> <span class="n">k_spws</span><span class="p">]</span>
        <span class="n">all_scores</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">field_qa_scores</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">all_scores</span></div>



<span class="k">def</span> <span class="nf">_compute_snr_info</span><span class="p">(</span><span class="n">context</span><span class="p">:</span> <span class="n">Context</span><span class="p">,</span> <span class="n">ms</span><span class="p">:</span> <span class="n">MeasurementSet</span><span class="p">,</span> <span class="n">spwids</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute and return the per-antenna, per-SpW SNR for given measurement set</span>
<span class="sd">    and spectral window IDs.</span>

<span class="sd">    Args:</span>
<span class="sd">        context: pipeline Context</span>
<span class="sd">        ms: MeasurementSet domain object</span>
<span class="sd">        spwids: IDs of SpWs to compute SNR for</span>

<span class="sd">    Returns:</span>
<span class="sd">        Dictionary of SNR info keyed by spectral window ID.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Get the path to the Tsys caltable for the current MS. If no matching</span>
    <span class="c1"># Tsys caltable was found, that is ok, gaincalSNR will do without.</span>
    <span class="n">caltable_path</span> <span class="o">=</span> <span class="n">_get_tsys_caltable_path</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">ms</span><span class="o">.</span><span class="n">basename</span><span class="p">)</span>

    <span class="c1"># PIPE-2083: for standard (non-BandToBand) datasets, a single SNR assessment</span>
    <span class="c1"># using the PHASE field should cover all Science SpWs:</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">ms</span><span class="o">.</span><span class="n">is_band_to_band</span><span class="p">:</span>
        <span class="n">spws</span> <span class="o">=</span> <span class="n">ms</span><span class="o">.</span><span class="n">get_spectral_windows</span><span class="p">(</span><span class="n">task_arg</span><span class="o">=</span><span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">spwids</span><span class="p">))</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ms</span><span class="o">.</span><span class="n">basename</span><span class="si">}</span><span class="s2">: computing SNR info for phase calibrator.&quot;</span><span class="p">)</span>
        <span class="n">snr_info</span> <span class="o">=</span> <span class="n">_compute_snr_info_for_intent</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">ms</span><span class="p">,</span> <span class="n">caltable_path</span><span class="p">,</span> <span class="n">spws</span><span class="p">,</span> <span class="n">intent</span><span class="o">=</span><span class="s1">&#39;PHASE&#39;</span><span class="p">)</span>
    <span class="c1"># For a BandToBand dataset, the PHASE field will only cover the diffgain</span>
    <span class="c1"># reference SpWs. To also obtain SNR estimates for the diffgain on-source</span>
    <span class="c1"># SpWs, a separate SNR assessment needs to be run using the CHECK source</span>
    <span class="c1"># field.</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># First split the requested SpW IDs into diffgain reference and</span>
        <span class="c1"># on-source SpWs.</span>
        <span class="n">spw_str</span> <span class="o">=</span> <span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">spwids</span><span class="p">)</span>
        <span class="n">dg_refspws</span> <span class="o">=</span> <span class="n">ms</span><span class="o">.</span><span class="n">get_spectral_windows</span><span class="p">(</span><span class="n">task_arg</span><span class="o">=</span><span class="n">spw_str</span><span class="p">,</span> <span class="n">intent</span><span class="o">=</span><span class="s1">&#39;DIFFGAINREF&#39;</span><span class="p">)</span>
        <span class="n">dg_srcspws</span> <span class="o">=</span> <span class="n">ms</span><span class="o">.</span><span class="n">get_spectral_windows</span><span class="p">(</span><span class="n">task_arg</span><span class="o">=</span><span class="n">spw_str</span><span class="p">,</span> <span class="n">intent</span><span class="o">=</span><span class="s1">&#39;DIFFGAINSRC&#39;</span><span class="p">)</span>

        <span class="c1"># Compute the SNR estimates for the diffgain reference SpWs.</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ms</span><span class="o">.</span><span class="n">basename</span><span class="si">}</span><span class="s2"> is a BandToBand project: computing SNR info for diffgain reference SpWs using the&quot;</span>
                 <span class="sa">f</span><span class="s2">&quot; phase calibrator.&quot;</span><span class="p">)</span>
        <span class="n">snr_info_dg_ref</span> <span class="o">=</span> <span class="n">_compute_snr_info_for_intent</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">ms</span><span class="p">,</span> <span class="n">caltable_path</span><span class="p">,</span> <span class="n">dg_refspws</span><span class="p">,</span> <span class="n">intent</span><span class="o">=</span><span class="s1">&#39;PHASE&#39;</span><span class="p">)</span>

        <span class="c1"># Compute the SNR estimates for the diffgain on-source SpWs.</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ms</span><span class="o">.</span><span class="n">basename</span><span class="si">}</span><span class="s2"> is a BandToBand project: computing SNR info for diffgain on-source SpWs using the&quot;</span>
                 <span class="sa">f</span><span class="s2">&quot; check source.&quot;</span><span class="p">)</span>
        <span class="n">snr_info_dg_src</span> <span class="o">=</span> <span class="n">_compute_snr_info_for_intent</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">ms</span><span class="p">,</span> <span class="n">caltable_path</span><span class="p">,</span> <span class="n">dg_srcspws</span><span class="p">,</span> <span class="n">intent</span><span class="o">=</span><span class="s1">&#39;CHECK&#39;</span><span class="p">)</span>

        <span class="c1"># Merge the resulting dictionaries, keeping only the SpW keys.</span>
        <span class="n">snr_info</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">snr_info_dg_ref</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">spwids</span><span class="p">}</span>
        <span class="n">snr_info</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">snr_info_dg_src</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">spwids</span><span class="p">})</span>

    <span class="k">return</span> <span class="n">snr_info</span>


<span class="k">def</span> <span class="nf">_compute_snr_info_for_intent</span><span class="p">(</span><span class="n">context</span><span class="p">:</span> <span class="n">Context</span><span class="p">,</span> <span class="n">ms</span><span class="p">:</span> <span class="n">MeasurementSet</span><span class="p">,</span> <span class="n">caltable_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                                 <span class="n">spws</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">SpectralWindow</span><span class="p">],</span> <span class="n">intent</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;PHASE&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute and return the per-antenna, per-SpW SNR for given measurement set,</span>
<span class="sd">    intent, and spectral windows.</span>

<span class="sd">    This function first identifies what field to analyse for given intent, then</span>
<span class="sd">    retrieves the fluxes for that field, and finally calls &quot;gaincalSNR&quot; to</span>
<span class="sd">    compute the SNR info.</span>

<span class="sd">    Args:</span>
<span class="sd">        context: pipeline Context</span>
<span class="sd">        ms: MeasurementSet domain object</span>
<span class="sd">        caltable_path: path to the Tsys caltable</span>
<span class="sd">        spws: SpectralWindow objects to compute SNR for</span>
<span class="sd">        intent: observing intent to use for the calibrator</span>

<span class="sd">    Returns:</span>
<span class="sd">        Dictionary of SNR info keyed by spectral window ID.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Identify what field to analyse; exit early if none was found.</span>
    <span class="n">field</span> <span class="o">=</span> <span class="n">_get_field_to_analyse</span><span class="p">(</span><span class="n">ms</span><span class="p">,</span> <span class="n">intent</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">field</span><span class="p">:</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Error calculating internal spw-spw consistency: no field found for </span><span class="si">{</span><span class="n">intent</span><span class="si">}</span><span class="s1"> intent.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">{}</span>

    <span class="c1"># Retrieve fluxes for selected field; exit early if none are found.</span>
    <span class="n">fluxes</span> <span class="o">=</span> <span class="n">_get_fluxes_for_field</span><span class="p">(</span><span class="n">ms</span><span class="p">,</span> <span class="n">field</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">fluxes</span><span class="p">:</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Error calculating internal spw-spw consistency: no flux densities found for </span><span class="si">{</span><span class="n">intent</span><span class="si">}</span><span class="s1"> intent&#39;</span>
                  <span class="sa">f</span><span class="s1">&#39; (field: </span><span class="si">{</span><span class="n">utils</span><span class="o">.</span><span class="n">dequote</span><span class="p">(</span><span class="n">field</span><span class="o">.</span><span class="n">name</span><span class="p">)</span><span class="si">}</span><span class="s1">)&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">{}</span>

    <span class="c1"># Run gaincalSNR to compute SNR info per SpW for current field. Warn if no</span>
    <span class="c1"># SNR info was returned.</span>
    <span class="n">gaincalsnr_output</span> <span class="o">=</span> <span class="n">gaincalSNR</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">ms</span><span class="p">,</span> <span class="n">caltable_path</span><span class="p">,</span> <span class="n">fluxes</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">spws</span><span class="p">,</span> <span class="n">intent</span><span class="o">=</span><span class="n">intent</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">gaincalsnr_output</span><span class="p">:</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Error calculating internal spw-spw consistency: no result from gaincalSNR function&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">gaincalsnr_output</span>


<span class="k">def</span> <span class="nf">_compute_k_spws_for_flux_measurements</span><span class="p">(</span><span class="n">field</span><span class="p">:</span> <span class="n">Field</span><span class="p">,</span> <span class="n">flux_measurements</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">FluxMeasurement</span><span class="p">],</span> <span class="n">r_snr</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
                                          <span class="n">msg_fieldname</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">msg_intents</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">list</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the &quot;k_spw&quot; metric for given list of flux measurements and given</span>
<span class="sd">    flux ratio for highest SNR SpW.</span>

<span class="sd">    If no catalog fluxes are available, return early with None.</span>

<span class="sd">    Args:</span>
<span class="sd">        field: field to retrieve catalog fluxes for</span>
<span class="sd">        flux_measurements: flux measurements to compute k_spw for</span>
<span class="sd">        r_snr: flux ratio for highest SNR SpW</span>
<span class="sd">        msg_fieldname: pre-formatted name of field, for log messages</span>
<span class="sd">        msg_intents: pre-formatted name of intents, for log messages</span>

<span class="sd">    Returns:</span>
<span class="sd">        List of &#39;k_spw&#39; for given flux measurements, or None.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">k_spws</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">flux_measurements</span><span class="p">:</span>
        <span class="c1"># Retrieve catalog fluxes for current flux measurement; exit early if</span>
        <span class="c1"># none could be found.</span>
        <span class="n">catalogue_fluxes</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">field</span><span class="o">.</span><span class="n">flux_densities</span> <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">origin</span> <span class="ow">in</span> <span class="n">EXTERNAL_SOURCES</span> <span class="ow">and</span> <span class="n">f</span><span class="o">.</span><span class="n">spw_id</span> <span class="o">==</span> <span class="n">m</span><span class="o">.</span><span class="n">spw_id</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">catalogue_fluxes</span><span class="p">:</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;No catalogue measurement for </span><span class="si">{}</span><span class="s1"> (</span><span class="si">{}</span><span class="s1">) spw </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">msg_fieldname</span><span class="p">,</span> <span class="n">msg_intents</span><span class="p">,</span> <span class="n">m</span><span class="o">.</span><span class="n">spw_id</span><span class="p">))</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="k">assert</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">catalogue_fluxes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">catalogue_flux</span> <span class="o">=</span> <span class="n">catalogue_fluxes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Compute ratio of derived flux over catalog flux for current</span>
        <span class="c1"># measurement.</span>
        <span class="n">r_spw</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">I</span><span class="o">.</span><span class="n">to_units</span><span class="p">(</span><span class="n">FluxDensityUnits</span><span class="o">.</span><span class="n">JANSKY</span><span class="p">)</span> <span class="o">/</span> <span class="n">catalogue_flux</span><span class="o">.</span><span class="n">I</span><span class="o">.</span><span class="n">to_units</span><span class="p">(</span><span class="n">FluxDensityUnits</span><span class="o">.</span><span class="n">JANSKY</span><span class="p">)</span>

        <span class="c1"># Compute &quot;k_spw&quot; as the ratio of the flux ratio for current measurement</span>
        <span class="c1"># over the ratio for the highest SNR measurement.</span>
        <span class="n">k_spw</span> <span class="o">=</span> <span class="n">r_spw</span> <span class="o">/</span> <span class="n">r_snr</span>
        <span class="n">k_spws</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">m</span><span class="o">.</span><span class="n">spw_id</span><span class="p">,</span> <span class="n">k_spw</span><span class="p">))</span>

    <span class="c1"># Sort &quot;k_spw&quot; by SpW ID.</span>
    <span class="n">k_spws</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">operator</span><span class="o">.</span><span class="n">itemgetter</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">k_spws</span>


<span class="k">def</span> <span class="nf">_get_field_to_analyse</span><span class="p">(</span><span class="n">ms</span><span class="p">:</span> <span class="n">MeasurementSet</span><span class="p">,</span> <span class="n">intent</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Field</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Identify and return which field to analyse for the &quot;k_spw&quot; score.</span>

<span class="sd">    If there is more than one field for given intent calibrator, then pick the</span>
<span class="sd">    first one that does NOT also have observe_target intent. If all have both</span>
<span class="sd">    intents, then continue to use the first one observed.</span>

<span class="sd">    Args:</span>
<span class="sd">        ms: MeasurementSet to find field for</span>
<span class="sd">        intent: intent to find field for</span>

<span class="sd">    Returns:</span>
<span class="sd">        Field to analyse.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">candidate_fields</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">ms</span><span class="o">.</span><span class="n">get_fields</span><span class="p">(</span><span class="n">intent</span><span class="o">=</span><span class="n">intent</span><span class="p">)</span> <span class="k">if</span> <span class="s1">&#39;TARGET&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">f</span><span class="o">.</span><span class="n">intents</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">candidate_fields</span><span class="p">:</span>
        <span class="n">candidate_fields</span> <span class="o">=</span> <span class="n">ms</span><span class="o">.</span><span class="n">get_fields</span><span class="p">(</span><span class="n">intent</span><span class="o">=</span><span class="n">intent</span><span class="p">)</span>
    <span class="n">field</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">candidate_fields</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">f</span><span class="p">:</span> <span class="n">f</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">min</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">field</span>


<span class="k">def</span> <span class="nf">_get_fluxes_for_field</span><span class="p">(</span><span class="n">ms</span><span class="p">:</span> <span class="n">MeasurementSet</span><span class="p">,</span> <span class="n">field</span><span class="p">:</span> <span class="n">Field</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return flux information for given measurement set and field.</span>

<span class="sd">    Select flux measurements that are from external sources, and return for each</span>
<span class="sd">    the SpW ID, SpW mean frequency, and total intensity.</span>

<span class="sd">    Args:</span>
<span class="sd">        ms: MeasurementSet to retrieve fluxes for</span>
<span class="sd">        field: field to retrieve fluxes for</span>

<span class="sd">    Returns:</span>
<span class="sd">        List of 3-tuples, containing:</span>
<span class="sd">            SpW ID for flux measurement</span>
<span class="sd">            Mean frequency of SpW in Hertz</span>
<span class="sd">            Total intensity in Jansky in flux measurement.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">fluxes</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">fm</span> <span class="ow">in</span> <span class="p">[</span><span class="n">fm</span> <span class="k">for</span> <span class="n">fm</span> <span class="ow">in</span> <span class="n">field</span><span class="o">.</span><span class="n">flux_densities</span> <span class="k">if</span> <span class="n">fm</span><span class="o">.</span><span class="n">origin</span> <span class="ow">in</span> <span class="n">EXTERNAL_SOURCES</span><span class="p">]:</span>
        <span class="n">spw</span> <span class="o">=</span> <span class="n">ms</span><span class="o">.</span><span class="n">get_spectral_window</span><span class="p">(</span><span class="n">fm</span><span class="o">.</span><span class="n">spw_id</span><span class="p">)</span>
        <span class="n">fluxes</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">spw</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">spw</span><span class="o">.</span><span class="n">mean_frequency</span><span class="o">.</span><span class="n">to_units</span><span class="p">(</span><span class="n">FrequencyUnits</span><span class="o">.</span><span class="n">HERTZ</span><span class="p">)),</span>
                       <span class="nb">float</span><span class="p">(</span><span class="n">fm</span><span class="o">.</span><span class="n">I</span><span class="o">.</span><span class="n">to_units</span><span class="p">(</span><span class="n">FluxDensityUnits</span><span class="o">.</span><span class="n">JANSKY</span><span class="p">))))</span>
    <span class="k">return</span> <span class="n">fluxes</span>


<span class="k">def</span> <span class="nf">_get_highest_snr_measurement_and_flux_ratio</span><span class="p">(</span><span class="n">field</span><span class="p">:</span> <span class="n">Field</span><span class="p">,</span> <span class="n">highest_snr_spw</span><span class="p">:</span> <span class="n">SpectralWindow</span><span class="p">,</span>
                                                <span class="n">measurements</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">FluxMeasurement</span><span class="p">],</span> <span class="n">msg_fieldname</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                                                <span class="n">msg_intents</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">FluxMeasurement</span><span class="p">,</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Retrieve flux measurement for given &quot;highest SNR&quot; SpW, compute ratio of</span>
<span class="sd">    derived over catalog flux, and return both flux measurement and flux ratio.</span>

<span class="sd">    If no catalog fluxes are available, then the flux ratio is returned as None.</span>

<span class="sd">    Args:</span>
<span class="sd">        field: field to retrieve catalog fluxes for</span>
<span class="sd">        highest_snr_spw: SpW with highest SNR</span>
<span class="sd">        measurements: derived flux measurements for given field</span>
<span class="sd">        msg_fieldname: pre-formatted name of field, for log messages</span>
<span class="sd">        msg_intents: pre-formatted name of intents, for log messages</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tuple containing flux measurement and flux ratio for highest SNR SpW</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Retrieve flux measurement for highest SNR SpW.</span>
    <span class="n">highest_snr_measurement</span> <span class="o">=</span> <span class="p">[</span><span class="n">m</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">measurements</span> <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">spw_id</span> <span class="o">==</span> <span class="n">highest_snr_spw</span><span class="o">.</span><span class="n">id</span><span class="p">]</span>
    <span class="k">assert</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">highest_snr_measurement</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">highest_snr_measurement</span> <span class="o">=</span> <span class="n">highest_snr_measurement</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">highest_snr_i</span> <span class="o">=</span> <span class="n">highest_snr_measurement</span><span class="o">.</span><span class="n">I</span>

    <span class="c1"># Retrieve the catalogue flux for the highest SNR spw.</span>
    <span class="n">catalogue_fluxes</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">field</span><span class="o">.</span><span class="n">flux_densities</span>
                        <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">origin</span> <span class="ow">in</span> <span class="n">EXTERNAL_SOURCES</span>
                        <span class="ow">and</span> <span class="n">f</span><span class="o">.</span><span class="n">spw_id</span> <span class="o">==</span> <span class="n">highest_snr_measurement</span><span class="o">.</span><span class="n">spw_id</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">catalogue_fluxes</span><span class="p">:</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Cannot calculate internal spw-spw consistency for </span><span class="si">{}</span><span class="s1"> (</span><span class="si">{}</span><span class="s1">): no catalogue measurement for &#39;</span>
                    <span class="s1">&#39;highest SNR spw (</span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">msg_fieldname</span><span class="p">,</span> <span class="n">msg_intents</span><span class="p">,</span> <span class="n">highest_snr_measurement</span><span class="o">.</span><span class="n">spw_id</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">highest_snr_measurement</span><span class="p">,</span> <span class="kc">None</span>
    <span class="k">assert</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">catalogue_fluxes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">catalogue_flux</span> <span class="o">=</span> <span class="n">catalogue_fluxes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Compute ratio of derived flux to catalogue flux for highest SNR spw.</span>
    <span class="n">r_snr</span> <span class="o">=</span> <span class="n">highest_snr_i</span><span class="o">.</span><span class="n">to_units</span><span class="p">(</span><span class="n">FluxDensityUnits</span><span class="o">.</span><span class="n">JANSKY</span><span class="p">)</span> <span class="o">/</span> <span class="n">catalogue_flux</span><span class="o">.</span><span class="n">I</span><span class="o">.</span><span class="n">to_units</span><span class="p">(</span><span class="n">FluxDensityUnits</span><span class="o">.</span><span class="n">JANSKY</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">highest_snr_measurement</span><span class="p">,</span> <span class="n">r_snr</span>


<span class="k">def</span> <span class="nf">_get_highest_snr_spw</span><span class="p">(</span><span class="n">snr_info</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">flux_measurements</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">FluxMeasurement</span><span class="p">],</span> <span class="n">ms</span><span class="p">:</span> <span class="n">MeasurementSet</span><span class="p">,</span>
                         <span class="n">msg_fieldname</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">msg_intents</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">SpectralWindow</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the highest SNR SpW for flux measurements based on SNR information.</span>

<span class="sd">    Args:</span>
<span class="sd">        snr_info: dictionary with output from the gaincal SNR assessment</span>
<span class="sd">        flux_measurements: flux measurements to consider</span>
<span class="sd">        ms: measurement set to consider</span>
<span class="sd">        msg_fieldname: pre-formatted name of field, for log messages</span>
<span class="sd">        msg_intents: pre-formatted name of intents, for log messages</span>

<span class="sd">    Returns:</span>
<span class="sd">        Spectral window with highest SNR</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Define 1 GHZ for bandwidth comparisons.</span>
    <span class="n">one_ghz</span> <span class="o">=</span> <span class="n">Frequency</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">FrequencyUnits</span><span class="o">.</span><span class="n">GIGAHERTZ</span><span class="p">)</span>

    <span class="c1"># Determine which SpWs to consider based on what SpWs are present in the</span>
    <span class="c1"># flux measurements and the given intent(s).</span>
    <span class="n">spws</span> <span class="o">=</span> <span class="n">ms</span><span class="o">.</span><span class="n">get_spectral_windows</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">spw_id</span><span class="p">)</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">flux_measurements</span><span class="p">))</span>
    <span class="c1"># PIPE-2083: for BandToBand datasets, override the selection if the intents</span>
    <span class="c1"># cover either PHASE or CHECK, to restrict to just the diffgain reference</span>
    <span class="c1"># SpWs for PHASE intent or diffgain on-source SpWs for CHECK intent.</span>
    <span class="k">if</span> <span class="n">ms</span><span class="o">.</span><span class="n">is_band_to_band</span><span class="p">:</span>
        <span class="k">if</span> <span class="s1">&#39;PHASE&#39;</span> <span class="ow">in</span> <span class="n">msg_intents</span><span class="p">:</span>
            <span class="n">spws</span> <span class="o">=</span> <span class="n">ms</span><span class="o">.</span><span class="n">get_spectral_windows</span><span class="p">(</span><span class="n">task_arg</span><span class="o">=</span><span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">spw_id</span><span class="p">)</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">flux_measurements</span><span class="p">),</span>
                                           <span class="n">intent</span><span class="o">=</span><span class="s1">&#39;DIFFGAINREF&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="s1">&#39;CHECK&#39;</span> <span class="ow">in</span> <span class="n">msg_intents</span><span class="p">:</span>
            <span class="n">spws</span> <span class="o">=</span> <span class="n">ms</span><span class="o">.</span><span class="n">get_spectral_windows</span><span class="p">(</span><span class="n">task_arg</span><span class="o">=</span><span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">spw_id</span><span class="p">)</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">flux_measurements</span><span class="p">),</span>
                                           <span class="n">intent</span><span class="o">=</span><span class="s1">&#39;DIFFGAINSRC&#39;</span><span class="p">)</span>

    <span class="c1"># discard narrow windows &lt; 1GHz</span>
    <span class="n">spw_snr_candidates</span> <span class="o">=</span> <span class="p">[</span><span class="n">spw</span> <span class="k">for</span> <span class="n">spw</span> <span class="ow">in</span> <span class="n">spws</span> <span class="k">if</span> <span class="n">spw</span><span class="o">.</span><span class="n">bandwidth</span> <span class="o">&gt;=</span> <span class="n">one_ghz</span><span class="p">]</span>

    <span class="c1"># fall back to median bandwidth selection if all the windows are narrow</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">spw_snr_candidates</span><span class="p">:</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;No wide (&gt;= 1 GHz) spectral windows identified for </span><span class="si">{}</span><span class="s1"> (</span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">msg_fieldname</span><span class="p">,</span> <span class="n">msg_intents</span><span class="p">))</span>

        <span class="c1"># find median bandwidth of all spws...</span>
        <span class="n">bandwidths</span> <span class="o">=</span> <span class="p">[</span><span class="n">spw</span><span class="o">.</span><span class="n">bandwidth</span><span class="o">.</span><span class="n">to_units</span><span class="p">(</span><span class="n">FrequencyUnits</span><span class="o">.</span><span class="n">HERTZ</span><span class="p">)</span> <span class="k">for</span> <span class="n">spw</span> <span class="ow">in</span> <span class="n">spws</span><span class="p">]</span>
        <span class="n">median_bandwidth</span> <span class="o">=</span> <span class="n">Frequency</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">bandwidths</span><span class="p">),</span> <span class="n">FrequencyUnits</span><span class="o">.</span><span class="n">HERTZ</span><span class="p">)</span>

        <span class="c1"># ... and identify SNR spw candidates accordingly</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Taking highest SNR window from spws with bandwidth &gt;= </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">median_bandwidth</span><span class="p">))</span>
        <span class="n">spw_snr_candidates</span> <span class="o">=</span> <span class="p">[</span><span class="n">spw</span> <span class="k">for</span> <span class="n">spw</span> <span class="ow">in</span> <span class="n">spws</span> <span class="k">if</span> <span class="n">spw</span><span class="o">.</span><span class="n">bandwidth</span> <span class="o">&gt;=</span> <span class="n">median_bandwidth</span><span class="p">]</span>

    <span class="c1"># PIPE-2083: if no SpW SNR candidates could be found, log error and return</span>
    <span class="c1"># early.</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">spw_snr_candidates</span><span class="p">:</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">ms</span><span class="o">.</span><span class="n">basename</span><span class="si">}</span><span class="s1">: Error calculating internal spw-spw consistency for </span><span class="si">{</span><span class="n">msg_fieldname</span><span class="si">}</span><span class="s1">&#39;</span>
                  <span class="sa">f</span><span class="s1">&#39; (</span><span class="si">{</span><span class="n">msg_intents</span><span class="si">}</span><span class="s1">): could not identify candidate spectral windows.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="c1"># Identify the spw with the highest SNR.</span>
    <span class="n">highest_snr_spw</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">spw_snr_candidates</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">spw</span><span class="p">:</span> <span class="n">snr_info</span><span class="p">[</span><span class="n">spw</span><span class="o">.</span><span class="n">id</span><span class="p">][</span><span class="s1">&#39;snr&#39;</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">highest_snr_spw</span>


<span class="k">def</span> <span class="nf">_get_tsys_caltable_path</span><span class="p">(</span><span class="n">context</span><span class="p">:</span> <span class="n">Context</span><span class="p">,</span> <span class="n">vis</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Identify the Tsys caltable for the current vis, and return the path to this</span>
<span class="sd">    table.</span>

<span class="sd">    Args:</span>
<span class="sd">        context: pipeline context</span>
<span class="sd">        vis: MS to look up Tsys caltable for</span>

<span class="sd">    Returns:</span>
<span class="sd">        Path to the Tsys caltable.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Go through all caltables registered in callibrary looking for a Tsys</span>
    <span class="c1"># caltable matching this vis.</span>
    <span class="k">for</span> <span class="n">caltable_path</span> <span class="ow">in</span> <span class="n">context</span><span class="o">.</span><span class="n">callibrary</span><span class="o">.</span><span class="n">active</span><span class="o">.</span><span class="n">get_caltable</span><span class="p">(</span><span class="n">caltypes</span><span class="o">=</span><span class="s1">&#39;tsys&#39;</span><span class="p">):</span>
        <span class="k">with</span> <span class="n">casa_tools</span><span class="o">.</span><span class="n">TableReader</span><span class="p">(</span><span class="n">caltable_path</span><span class="p">)</span> <span class="k">as</span> <span class="n">table</span><span class="p">:</span>
            <span class="n">msname</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">getkeyword</span><span class="p">(</span><span class="s1">&#39;MSName&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">msname</span> <span class="ow">in</span> <span class="n">vis</span><span class="p">:</span>
            <span class="k">break</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">caltable_path</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
    <span class="k">return</span> <span class="n">caltable_path</span>


<div class="viewcode-block" id="gaincalSNR">
<a class="viewcode-back" href="../../../../../_apidoc/pipeline.hifa.tasks.fluxscale.html#pipeline.hifa.tasks.fluxscale.qa.gaincalSNR">[docs]</a>
<span class="k">def</span> <span class="nf">gaincalSNR</span><span class="p">(</span><span class="n">context</span><span class="p">:</span> <span class="n">Context</span><span class="p">,</span> <span class="n">ms</span><span class="p">:</span> <span class="n">MeasurementSet</span><span class="p">,</span> <span class="n">tsysTable</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">flux</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]],</span>
               <span class="n">field</span><span class="p">:</span> <span class="n">Field</span><span class="p">,</span> <span class="n">spws</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">SpectralWindow</span><span class="p">],</span> <span class="n">intent</span><span class="o">=</span><span class="s1">&#39;PHASE&#39;</span><span class="p">,</span> <span class="n">required_snr</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">25</span><span class="p">,</span>
               <span class="n">edge_fraction</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.03125</span><span class="p">,</span> <span class="n">min_snr</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">10</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the per-antenna SNR expected for gaincal(solint=&#39;inf&#39;) on a</span>
<span class="sd">    per-spw basis and recommends whether bandwidth transfer and/or</span>
<span class="sd">    combine=&#39;spw&#39; is needed.</span>

<span class="sd">    This function is based upon the analysisUtils gaincalSNR code by Todd Hunter.</span>

<span class="sd">    :param context: pipeline Context</span>
<span class="sd">    :param ms: MeasurementSet domain object</span>
<span class="sd">    :param tsysTable: path to Tsys caltable</span>
<span class="sd">    :type tsysTable: str</span>
<span class="sd">    :param flux: the list of flux measurements to use</span>
<span class="sd">    :type flux: [FluxDensity, ...]</span>
<span class="sd">    :param field: the field to use</span>
<span class="sd">    :type field: Field</span>
<span class="sd">    :param spws: the spectral windows to make predictions for</span>
<span class="sd">    :type spws: [SpectralWindow, ...]</span>
<span class="sd">    :param intent: observing intent to use for the calibrator</span>
<span class="sd">    :type intent: str</span>
<span class="sd">    :param required_snr: threshold for which to make decisions (default=25)</span>
<span class="sd">    :param edge_fraction: the fraction of bandwidth to ignore on each edge of a</span>
<span class="sd">        TDM window (default=0.03125)</span>
<span class="sd">    :param min_snr: threshold for when even aggregate bandwidth is expected to</span>
<span class="sd">        fail (default=10)</span>
<span class="sd">    :return: a dictionary keyed by spectral window ID</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Set maximum effective bandwidth per baseband.</span>
    <span class="n">max_effective_bandwidth_per_baseband</span> <span class="o">=</span> <span class="n">Frequency</span><span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">edge_fraction</span><span class="p">),</span> <span class="n">FrequencyUnits</span><span class="o">.</span><span class="n">GIGAHERTZ</span><span class="p">)</span>

    <span class="c1"># 1) Get the number of antennas in the dataset. In principle, this should</span>
    <span class="c1">#    be the number of unflagged antennas on the PHASE calibrator. Here we</span>
    <span class="c1">#    have the simpler option to compute the number of completely unflagged</span>
    <span class="c1">#    antennas.</span>
    <span class="n">num_antennas</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ms</span><span class="o">.</span><span class="n">antennas</span><span class="p">)</span>
    <span class="n">seven_metres_majority</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">([</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">ms</span><span class="o">.</span><span class="n">antennas</span> <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">diameter</span> <span class="o">==</span> <span class="mf">7.0</span><span class="p">])</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">num_antennas</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mf">0.5</span>
    <span class="k">if</span> <span class="n">seven_metres_majority</span><span class="p">:</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;This is an ACA 7m dataset.&#39;</span><span class="p">)</span>

    <span class="c1"># 2) Get the calibrator and target object spw(s) to process.</span>
    <span class="n">spw_types</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;TDM&#39;</span><span class="p">,</span> <span class="s1">&#39;FDM&#39;</span><span class="p">)</span>
    <span class="n">all_gaincal_spws</span> <span class="o">=</span> <span class="p">{</span><span class="n">spw</span> <span class="k">for</span> <span class="n">spw</span> <span class="ow">in</span> <span class="n">ms</span><span class="o">.</span><span class="n">spectral_windows</span> <span class="k">if</span> <span class="n">intent</span> <span class="ow">in</span> <span class="n">spw</span><span class="o">.</span><span class="n">intents</span> <span class="ow">and</span> <span class="n">spw</span><span class="o">.</span><span class="n">type</span> <span class="ow">in</span> <span class="n">spw_types</span><span class="p">}</span>
    <span class="n">all_target_spws</span> <span class="o">=</span> <span class="p">{</span><span class="n">spw</span> <span class="k">for</span> <span class="n">spw</span> <span class="ow">in</span> <span class="n">ms</span><span class="o">.</span><span class="n">spectral_windows</span> <span class="k">if</span> <span class="s1">&#39;TARGET&#39;</span> <span class="ow">in</span> <span class="n">spw</span><span class="o">.</span><span class="n">intents</span> <span class="ow">and</span> <span class="n">spw</span><span class="o">.</span><span class="n">type</span> <span class="ow">in</span> <span class="n">spw_types</span><span class="p">}</span>
    <span class="n">all_spws</span> <span class="o">=</span> <span class="n">all_gaincal_spws</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">spws</span><span class="p">)</span>

    <span class="n">num_basebands</span> <span class="o">=</span> <span class="nb">len</span><span class="p">({</span><span class="n">spw</span><span class="o">.</span><span class="n">baseband</span> <span class="k">for</span> <span class="n">spw</span> <span class="ow">in</span> <span class="n">all_spws</span><span class="p">})</span>
    <span class="n">aggregate_bandwidth</span> <span class="o">=</span> <span class="n">compute_aggregate_bandwidth</span><span class="p">(</span><span class="n">all_gaincal_spws</span><span class="p">)</span>
    <span class="n">widest_spw</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">all_target_spws</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">operator</span><span class="o">.</span><span class="n">attrgetter</span><span class="p">(</span><span class="s1">&#39;bandwidth&#39;</span><span class="p">))</span>

    <span class="c1"># 3) Identify scans of the gaincal target for each gaincal spw, then</span>
    <span class="c1">#    compute the median time on-source for these scans.</span>
    <span class="n">scans</span> <span class="o">=</span> <span class="p">{</span><span class="n">spw</span><span class="p">:</span> <span class="p">[</span><span class="n">scan</span> <span class="k">for</span> <span class="n">scan</span> <span class="ow">in</span> <span class="n">ms</span><span class="o">.</span><span class="n">scans</span> <span class="k">if</span> <span class="n">intent</span> <span class="ow">in</span> <span class="n">scan</span><span class="o">.</span><span class="n">intents</span> <span class="ow">and</span> <span class="n">spw</span> <span class="ow">in</span> <span class="n">scan</span><span class="o">.</span><span class="n">spws</span> <span class="ow">and</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">scan</span><span class="o">.</span><span class="n">fields</span><span class="p">]</span>
             <span class="k">for</span> <span class="n">spw</span> <span class="ow">in</span> <span class="n">all_gaincal_spws</span><span class="p">}</span>

    <span class="c1"># compute the median length of a &quot;solint=&#39;inf&#39;, combine=&#39;&#39;&quot; scan. In</span>
    <span class="c1"># principle, this should be the time weighted by percentage of unflagged</span>
    <span class="c1"># data. Also, the method below will include sub-scan latency.</span>
    <span class="n">time_on_source</span> <span class="o">=</span> <span class="p">{</span><span class="n">spw</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">median</span><span class="p">([</span><span class="n">scan</span><span class="o">.</span><span class="n">exposure_time</span><span class="p">(</span><span class="n">spw</span><span class="o">.</span><span class="n">id</span><span class="p">)</span> <span class="k">for</span> <span class="n">scan</span> <span class="ow">in</span> <span class="n">scans</span><span class="p">[</span><span class="n">spw</span><span class="p">]])</span>
                      <span class="k">for</span> <span class="n">spw</span> <span class="ow">in</span> <span class="n">all_gaincal_spws</span><span class="p">}</span>

    <span class="n">spw_to_flux_density</span> <span class="o">=</span> <span class="p">{</span><span class="n">spw_id</span><span class="p">:</span> <span class="n">FluxDensity</span><span class="p">(</span><span class="n">flux_jy</span><span class="p">,</span> <span class="n">FluxDensityUnits</span><span class="o">.</span><span class="n">JANSKY</span><span class="p">)</span> <span class="k">for</span> <span class="n">spw_id</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">flux_jy</span> <span class="ow">in</span> <span class="n">flux</span><span class="p">}</span>

    <span class="n">gaincal_spw_ids</span> <span class="o">=</span> <span class="p">{</span><span class="n">spw</span><span class="o">.</span><span class="n">id</span> <span class="k">for</span> <span class="n">spw</span> <span class="ow">in</span> <span class="n">all_gaincal_spws</span><span class="p">}</span>
    <span class="n">phase_spw_to_tsys_spw</span> <span class="o">=</span> <span class="p">{</span><span class="n">ms</span><span class="o">.</span><span class="n">spectral_windows</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span> <span class="n">ms</span><span class="o">.</span><span class="n">spectral_windows</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>
                             <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">utils</span><span class="o">.</span><span class="n">get_calfroms</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">ms</span><span class="o">.</span><span class="n">basename</span><span class="p">,</span> <span class="s1">&#39;tsys&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">spwmap</span><span class="p">)</span>
                             <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">gaincal_spw_ids</span><span class="p">}</span>
    <span class="c1"># map CALIBRATE_PHASE spw to Tsys scans for the corresponding Tsys spw</span>
    <span class="n">phase_spw_to_tsys_scans</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">phase_spw</span><span class="p">:</span> <span class="p">[</span><span class="n">scan</span> <span class="k">for</span> <span class="n">scan</span> <span class="ow">in</span> <span class="n">ms</span><span class="o">.</span><span class="n">scans</span> <span class="k">if</span> <span class="s1">&#39;ATMOSPHERE&#39;</span> <span class="ow">in</span> <span class="n">scan</span><span class="o">.</span><span class="n">intents</span> <span class="ow">and</span> <span class="n">tsys_spw</span> <span class="ow">in</span> <span class="n">scan</span><span class="o">.</span><span class="n">spws</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">phase_spw</span><span class="p">,</span> <span class="n">tsys_spw</span> <span class="ow">in</span> <span class="n">phase_spw_to_tsys_spw</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="n">wrapper</span> <span class="o">=</span> <span class="n">CaltableWrapperFactory</span><span class="o">.</span><span class="n">from_caltable</span><span class="p">(</span><span class="n">tsysTable</span><span class="p">)</span>

    <span class="c1"># keys: CALIBRATE_PHASE spws, values: corresponding Tsys values</span>
    <span class="n">get_snr_info</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># Flag value to get SNR info or not</span>
    <span class="n">median_tsys</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">phase_spw</span><span class="p">,</span> <span class="n">tsys_scans</span> <span class="ow">in</span> <span class="n">phase_spw_to_tsys_scans</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="c1"># If there are multiple scans for an spw, then simply use the Tsys of the first scan</span>
        <span class="n">first_tsys_scan</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">tsys_scans</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">operator</span><span class="o">.</span><span class="n">attrgetter</span><span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">))</span>
        <span class="n">tsys_spw</span> <span class="o">=</span> <span class="n">phase_spw_to_tsys_spw</span><span class="p">[</span><span class="n">phase_spw</span><span class="p">]</span>
        <span class="n">scan_data</span> <span class="o">=</span> <span class="n">wrapper</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">spw</span><span class="o">=</span><span class="n">tsys_spw</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">scan</span><span class="o">=</span><span class="n">first_tsys_scan</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">scan_data</span><span class="p">[</span><span class="s1">&#39;FPARAM&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">mask</span><span class="p">):</span>  <span class="c1"># Assign NaN if everything is masked</span>
            <span class="n">median_tsys</span><span class="p">[</span><span class="n">phase_spw</span><span class="o">.</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">get_snr_info</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">median_tsys</span><span class="p">[</span><span class="n">phase_spw</span><span class="o">.</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">scan_data</span><span class="p">[</span><span class="s1">&#39;FPARAM&#39;</span><span class="p">])</span>

    <span class="c1"># PIPE-1208: If any scan is fully masked, attempt to retrieve the info on</span>
    <span class="c1"># estimated SNRs that was derived during hifa_spwphaseup.</span>
    <span class="n">snr_info</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">get_snr_info</span><span class="p">:</span>
        <span class="c1"># Check if a SpW mapping was registered for current field and intent.</span>
        <span class="n">spwmap</span> <span class="o">=</span> <span class="n">ms</span><span class="o">.</span><span class="n">spwmaps</span><span class="o">.</span><span class="n">get</span><span class="p">((</span><span class="n">intent</span><span class="p">,</span> <span class="n">field</span><span class="o">.</span><span class="n">name</span><span class="p">),</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">spwmap</span><span class="p">:</span>
            <span class="c1"># If a direct match exists, then use the corresponding SNR info.</span>
            <span class="n">snr_info</span> <span class="o">=</span> <span class="n">spwmap</span><span class="o">.</span><span class="n">snr_info</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Otherwise, retrieve SNR info from the first SpW mapping that</span>
            <span class="c1"># matches the current intent.</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">spwmap_intent</span><span class="p">,</span> <span class="n">_</span><span class="p">),</span> <span class="n">spwmap</span> <span class="ow">in</span> <span class="n">ms</span><span class="o">.</span><span class="n">spwmaps</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">spwmap_intent</span> <span class="o">==</span> <span class="n">intent</span><span class="p">:</span>
                    <span class="n">snr_info</span> <span class="o">=</span> <span class="n">spwmap</span><span class="o">.</span><span class="n">snr_info</span>
                    <span class="k">break</span>
        <span class="c1"># Report if the retrieval of SNR info from hifa_spwphaseup failed.</span>
        <span class="k">if</span> <span class="n">snr_info</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ms</span><span class="o">.</span><span class="n">basename</span><span class="si">}</span><span class="s2">: Estimated SNR from hifa_spwphaseup could not be retrieved.&quot;</span><span class="p">)</span>

    <span class="c1"># 6) compute the expected channel-averaged SNR</span>
    <span class="c1"># TODO Ask Todd if this is an error or a confusingly-named variable</span>
    <span class="n">num_baselines</span> <span class="o">=</span> <span class="n">num_antennas</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c1"># for an antenna-based solution</span>

    <span class="n">diffgain_mode</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">mydict</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="n">eight_ghz</span> <span class="o">=</span> <span class="n">Frequency</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="n">FrequencyUnits</span><span class="o">.</span><span class="n">GIGAHERTZ</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">spw</span> <span class="ow">in</span> <span class="n">all_target_spws</span><span class="p">:</span>
        <span class="n">obsspw</span> <span class="o">=</span> <span class="n">spw</span>
        <span class="k">if</span> <span class="n">spw</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">all_gaincal_spws</span><span class="p">:</span>
            <span class="c1"># If this spw was not observed on the phase calibrator, then use the widest</span>
            <span class="c1"># spw from the same baseband that *was* observed on the phase calibrator</span>
            <span class="c1"># Ignore band-2-band possibility for now</span>
            <span class="n">alt_spw</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="n">w</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">all_gaincal_spws</span> <span class="k">if</span> <span class="n">spw</span><span class="o">.</span><span class="n">baseband</span> <span class="o">==</span> <span class="n">w</span><span class="o">.</span><span class="n">baseband</span><span class="p">],</span>
                          <span class="n">key</span><span class="o">=</span><span class="n">operator</span><span class="o">.</span><span class="n">attrgetter</span><span class="p">(</span><span class="s1">&#39;bandwidth&#39;</span><span class="p">))</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;This is a BandToBand or BandwidthSwitching project: spw </span><span class="si">{</span><span class="n">spw</span><span class="o">.</span><span class="n">id</span><span class="si">}</span><span class="s2"> matched to spw&quot;</span>
                      <span class="sa">f</span><span class="s2">&quot; </span><span class="si">{</span><span class="n">alt_spw</span><span class="o">.</span><span class="n">id</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
            <span class="n">spw</span> <span class="o">=</span> <span class="n">alt_spw</span>

        <span class="n">mydict</span><span class="p">[</span><span class="n">spw</span><span class="o">.</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">diffgain_mode</span><span class="p">[</span><span class="n">obsspw</span><span class="p">]</span> <span class="o">=</span> <span class="n">spw</span>
        <span class="n">band_info</span> <span class="o">=</span> <span class="p">[</span><span class="n">b</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">BAND_INFOS</span> <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">spw</span><span class="o">.</span><span class="n">band</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="n">relative_tsys</span> <span class="o">=</span> <span class="n">median_tsys</span><span class="p">[</span><span class="n">spw</span><span class="o">.</span><span class="n">id</span><span class="p">]</span> <span class="o">/</span> <span class="n">band_info</span><span class="o">.</span><span class="n">nominal_tsys</span>
        <span class="n">time_factor</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">time_on_source</span><span class="p">[</span><span class="n">spw</span><span class="p">]</span><span class="o">.</span><span class="n">total_seconds</span><span class="p">()</span> <span class="o">/</span> <span class="mf">60.0</span><span class="p">)</span>
        <span class="n">array_size_factor</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="mi">16</span> <span class="o">*</span> <span class="mi">15</span> <span class="o">/</span> <span class="mf">2.</span><span class="p">)</span> <span class="o">/</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">num_baselines</span><span class="p">)</span>

        <span class="n">area_factor</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="k">if</span> <span class="n">seven_metres_majority</span><span class="p">:</span>
            <span class="c1"># scale by antenna collecting area</span>
            <span class="n">area_factor</span> <span class="o">=</span> <span class="p">(</span><span class="mf">12.</span><span class="o">/</span><span class="mf">7.</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>

        <span class="c1"># scale by chan bandwidth</span>
        <span class="n">bandwidth_factor</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">eight_ghz</span> <span class="o">/</span> <span class="nb">min</span><span class="p">([</span><span class="n">spw</span><span class="o">.</span><span class="n">bandwidth</span><span class="p">,</span> <span class="n">max_effective_bandwidth_per_baseband</span><span class="p">]))</span>
        <span class="c1"># scale to single polarization solutions</span>
        <span class="n">polarization_factor</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">factor</span> <span class="o">=</span> <span class="n">relative_tsys</span> <span class="o">*</span> <span class="n">time_factor</span> <span class="o">*</span> <span class="n">array_size_factor</span> <span class="o">*</span> <span class="n">area_factor</span> <span class="o">*</span> <span class="n">bandwidth_factor</span> <span class="o">*</span> <span class="n">polarization_factor</span>
        <span class="n">sensitivity</span> <span class="o">=</span> <span class="n">band_info</span><span class="o">.</span><span class="n">sensitivity</span> <span class="o">*</span> <span class="n">Decimal</span><span class="p">(</span><span class="n">factor</span><span class="p">)</span>

        <span class="n">aggregate_bandwidth_factor</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">eight_ghz</span> <span class="o">/</span> <span class="n">aggregate_bandwidth</span><span class="p">)</span>
        <span class="n">factor</span> <span class="o">=</span> <span class="n">relative_tsys</span> <span class="o">*</span> <span class="n">time_factor</span> <span class="o">*</span> <span class="n">array_size_factor</span> <span class="o">*</span> <span class="n">area_factor</span> <span class="o">*</span> <span class="n">aggregate_bandwidth_factor</span> <span class="o">*</span> <span class="n">polarization_factor</span>
        <span class="n">aggregate_bandwidth_sensitivity</span> <span class="o">=</span> <span class="n">band_info</span><span class="o">.</span><span class="n">sensitivity</span> <span class="o">*</span> <span class="n">Decimal</span><span class="p">(</span><span class="n">factor</span><span class="p">)</span>

        <span class="n">snr_per_spw</span> <span class="o">=</span> <span class="n">spw_to_flux_density</span><span class="p">[</span><span class="n">spw</span><span class="o">.</span><span class="n">id</span><span class="p">]</span> <span class="o">/</span> <span class="n">sensitivity</span>
        <span class="c1"># PIPE-1208: Use the estimated SNR from hifa_spwphaseup if the data is fully masked</span>
        <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">median_tsys</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">spw</span><span class="o">.</span><span class="n">id</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">snr_info</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">str</span><span class="p">(</span><span class="n">spw</span><span class="o">.</span><span class="n">id</span><span class="p">)</span> <span class="ow">in</span> <span class="n">snr_info</span><span class="p">:</span>
                <span class="n">snr_value</span> <span class="o">=</span> <span class="n">snr_info</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">spw</span><span class="o">.</span><span class="n">id</span><span class="p">)]</span>
                <span class="n">mydict</span><span class="p">[</span><span class="n">spw</span><span class="o">.</span><span class="n">id</span><span class="p">][</span><span class="s1">&#39;snr&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="n">snr_value</span><span class="p">)</span>
                <span class="n">mydict</span><span class="p">[</span><span class="n">spw</span><span class="o">.</span><span class="n">id</span><span class="p">][</span><span class="s1">&#39;snr_aggregate&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span>
                    <span class="n">snr_value</span> <span class="o">*</span> <span class="n">sqrt</span><span class="p">(</span>
                        <span class="nb">min</span><span class="p">([</span><span class="n">aggregate_bandwidth</span><span class="p">,</span> <span class="n">max_effective_bandwidth_per_baseband</span> <span class="o">*</span> <span class="n">num_basebands</span><span class="p">])</span> <span class="o">/</span>
                        <span class="nb">min</span><span class="p">([</span><span class="n">spw</span><span class="o">.</span><span class="n">bandwidth</span><span class="p">,</span> <span class="n">max_effective_bandwidth_per_baseband</span><span class="p">]))</span>
                <span class="p">)</span>
                <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ms</span><span class="o">.</span><span class="n">basename</span><span class="si">}</span><span class="s2">: for SpW </span><span class="si">{</span><span class="n">spw</span><span class="o">.</span><span class="n">id</span><span class="si">}</span><span class="s2"> SNR extracted from hifa_spwphaseup (</span><span class="si">{</span><span class="n">snr_value</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">).&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">snr_value</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="n">mydict</span><span class="p">[</span><span class="n">spw</span><span class="o">.</span><span class="n">id</span><span class="p">][</span><span class="s1">&#39;snr&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;0.0&#39;</span><span class="p">)</span>
                <span class="n">mydict</span><span class="p">[</span><span class="n">spw</span><span class="o">.</span><span class="n">id</span><span class="p">][</span><span class="s1">&#39;snr_aggregate&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;0.0&#39;</span><span class="p">)</span>
                <span class="n">LOG</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ms</span><span class="o">.</span><span class="n">basename</span><span class="si">}</span><span class="s2">: for SpW </span><span class="si">{</span><span class="n">spw</span><span class="o">.</span><span class="n">id</span><span class="si">}</span><span class="s2"> SNR could not be extracted from hifa_spwphaseup, SNR set to&quot;</span>
                          <span class="sa">f</span><span class="s2">&quot; 0.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">snr_value</span> <span class="o">=</span> <span class="n">snr_per_spw</span>
            <span class="n">mydict</span><span class="p">[</span><span class="n">spw</span><span class="o">.</span><span class="n">id</span><span class="p">][</span><span class="s1">&#39;snr&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">snr_per_spw</span>
            <span class="n">mydict</span><span class="p">[</span><span class="n">spw</span><span class="o">.</span><span class="n">id</span><span class="p">][</span><span class="s1">&#39;snr_aggregate&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">spw_to_flux_density</span><span class="p">[</span><span class="n">spw</span><span class="o">.</span><span class="n">id</span><span class="p">]</span> <span class="o">/</span> <span class="n">aggregate_bandwidth_sensitivity</span>
        <span class="n">mydict</span><span class="p">[</span><span class="n">spw</span><span class="o">.</span><span class="n">id</span><span class="p">][</span><span class="s1">&#39;meanFreq&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">spw</span><span class="o">.</span><span class="n">mean_frequency</span>
        <span class="n">mydict</span><span class="p">[</span><span class="n">spw</span><span class="o">.</span><span class="n">id</span><span class="p">][</span><span class="s1">&#39;medianTsys&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">median_tsys</span><span class="p">[</span><span class="n">spw</span><span class="o">.</span><span class="n">id</span><span class="p">]</span>
        <span class="n">mydict</span><span class="p">[</span><span class="n">spw</span><span class="o">.</span><span class="n">id</span><span class="p">][</span><span class="s1">&#39;Tsys_spw&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">phase_spw_to_tsys_spw</span><span class="p">[</span><span class="n">spw</span><span class="p">]</span><span class="o">.</span><span class="n">id</span>
        <span class="n">mydict</span><span class="p">[</span><span class="n">spw</span><span class="o">.</span><span class="n">id</span><span class="p">][</span><span class="s1">&#39;bandwidth&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">spw</span><span class="o">.</span><span class="n">bandwidth</span>
        <span class="n">mydict</span><span class="p">[</span><span class="n">spw</span><span class="o">.</span><span class="n">id</span><span class="p">][</span><span class="s1">&#39;bandwidth_effective&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="n">spw</span><span class="o">.</span><span class="n">bandwidth</span><span class="p">,</span> <span class="n">max_effective_bandwidth_per_baseband</span><span class="p">])</span>
        <span class="n">mydict</span><span class="p">[</span><span class="n">spw</span><span class="o">.</span><span class="n">id</span><span class="p">][</span><span class="s1">&#39;calibrator_flux_density&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">spw_to_flux_density</span><span class="p">[</span><span class="n">spw</span><span class="o">.</span><span class="n">id</span><span class="p">]</span>
        <span class="n">mydict</span><span class="p">[</span><span class="n">spw</span><span class="o">.</span><span class="n">id</span><span class="p">][</span><span class="s1">&#39;solint_inf_seconds&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">time_on_source</span><span class="p">[</span><span class="n">spw</span><span class="p">]</span><span class="o">.</span><span class="n">total_seconds</span><span class="p">()</span>
        <span class="n">mydict</span><span class="p">[</span><span class="s1">&#39;aggregate_bandwidth&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="n">aggregate_bandwidth</span><span class="p">,</span> <span class="n">max_effective_bandwidth_per_baseband</span> <span class="o">*</span> <span class="n">num_basebands</span><span class="p">])</span>
        <span class="n">mydict</span><span class="p">[</span><span class="s1">&#39;calibrator&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="n">name</span>

        <span class="k">if</span> <span class="n">spw</span> <span class="o">==</span> <span class="n">obsspw</span><span class="p">:</span>
            <span class="c1"># Then it is not a DIFFGAIN mode (B2B or BWSW) dataset, so compute</span>
            <span class="c1"># snr in widest spw.</span>
            <span class="n">widest_spw_bandwidth_factor</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">eight_ghz</span> <span class="o">/</span> <span class="n">widest_spw</span><span class="o">.</span><span class="n">bandwidth</span><span class="p">)</span>
            <span class="n">factor</span> <span class="o">=</span> <span class="n">relative_tsys</span> <span class="o">*</span> <span class="n">time_factor</span> <span class="o">*</span> <span class="n">array_size_factor</span> <span class="o">*</span> <span class="n">area_factor</span> <span class="o">*</span> <span class="n">widest_spw_bandwidth_factor</span> <span class="o">*</span> <span class="n">polarization_factor</span>
            <span class="n">widest_spw_bandwidth_sensitivity</span> <span class="o">=</span> <span class="n">band_info</span><span class="o">.</span><span class="n">sensitivity</span> <span class="o">*</span> <span class="n">Decimal</span><span class="p">(</span><span class="n">factor</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">median_tsys</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">spw</span><span class="o">.</span><span class="n">id</span><span class="p">)):</span>
                <span class="n">mydict</span><span class="p">[</span><span class="n">spw</span><span class="o">.</span><span class="n">id</span><span class="p">][</span><span class="s1">&#39;snr_widest_spw&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span>
                    <span class="n">snr_value</span> <span class="o">*</span> <span class="n">sqrt</span><span class="p">(</span>
                        <span class="nb">min</span><span class="p">([</span><span class="n">widest_spw</span><span class="o">.</span><span class="n">bandwidth</span><span class="p">,</span> <span class="n">max_effective_bandwidth_per_baseband</span><span class="p">])</span> <span class="o">/</span>
                        <span class="nb">min</span><span class="p">([</span><span class="n">spw</span><span class="o">.</span><span class="n">bandwidth</span><span class="p">,</span> <span class="n">max_effective_bandwidth_per_baseband</span><span class="p">])</span>
                    <span class="p">)</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mydict</span><span class="p">[</span><span class="n">spw</span><span class="o">.</span><span class="n">id</span><span class="p">][</span><span class="s1">&#39;snr_widest_spw&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">spw_to_flux_density</span><span class="p">[</span><span class="n">spw</span><span class="o">.</span><span class="n">id</span><span class="p">]</span> <span class="o">/</span> <span class="n">widest_spw_bandwidth_sensitivity</span>
            <span class="n">mydict</span><span class="p">[</span><span class="n">spw</span><span class="o">.</span><span class="n">id</span><span class="p">][</span><span class="s1">&#39;widest_spw_bandwidth&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">widest_spw</span><span class="o">.</span><span class="n">bandwidth</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mydict</span><span class="p">[</span><span class="n">spw</span><span class="o">.</span><span class="n">id</span><span class="p">][</span><span class="s1">&#39;snr_widest_spw&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">for</span> <span class="n">spw</span> <span class="ow">in</span> <span class="n">all_target_spws</span><span class="p">:</span>
        <span class="n">calspw</span> <span class="o">=</span> <span class="n">diffgain_mode</span><span class="p">[</span><span class="n">spw</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">mydict</span><span class="p">[</span><span class="n">calspw</span><span class="o">.</span><span class="n">id</span><span class="p">][</span><span class="s1">&#39;snr&#39;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">required_snr</span><span class="p">:</span>
            <span class="c1"># PIPE-2083 clarified the status, which I believe is anyway never used</span>
            <span class="k">if</span> <span class="n">spw</span> <span class="o">!=</span> <span class="n">calspw</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">ms</span><span class="o">.</span><span class="n">get_diffgain_mode</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;B2B&#39;</span><span class="p">:</span>
                    <span class="n">mydict</span><span class="p">[</span><span class="n">calspw</span><span class="o">.</span><span class="n">id</span><span class="p">][</span><span class="s1">&#39;status&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;b2b_diffgain_mode&#39;</span>
                <span class="k">elif</span> <span class="n">ms</span><span class="o">.</span><span class="n">get_diffgain_mode</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;BWSW&#39;</span><span class="p">:</span>
                    <span class="n">mydict</span><span class="p">[</span><span class="n">calspw</span><span class="o">.</span><span class="n">id</span><span class="p">][</span><span class="s1">&#39;status&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;bwsw_diffgain_mode&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mydict</span><span class="p">[</span><span class="n">calspw</span><span class="o">.</span><span class="n">id</span><span class="p">][</span><span class="s1">&#39;status&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;normal&#39;</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;science spw </span><span class="si">{}</span><span class="s1"> (</span><span class="si">{}</span><span class="s1">) calibrated by spw </span><span class="si">{}</span><span class="s1"> has sufficient S/N: </span><span class="si">{:.1f}</span><span class="s1">&#39;</span>
                   <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">spw</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">spw</span><span class="o">.</span><span class="n">bandwidth</span><span class="p">,</span> <span class="n">calspw</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">mydict</span><span class="p">[</span><span class="n">calspw</span><span class="o">.</span><span class="n">id</span><span class="p">][</span><span class="s1">&#39;snr&#39;</span><span class="p">]))</span>
        <span class="k">elif</span> <span class="n">mydict</span><span class="p">[</span><span class="n">calspw</span><span class="o">.</span><span class="n">id</span><span class="p">][</span><span class="s1">&#39;snr_widest_spw&#39;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">required_snr</span><span class="p">:</span>
            <span class="n">mydict</span><span class="p">[</span><span class="n">calspw</span><span class="o">.</span><span class="n">id</span><span class="p">][</span><span class="s1">&#39;status&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;spwmap&#39;</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;science spw </span><span class="si">{}</span><span class="s1"> </span><span class="si">{}</span><span class="s1"> calibrated by widest spw (</span><span class="si">{}</span><span class="s1">: bandwidth=</span><span class="si">{}</span><span class="s1">) has sufficient S/N: </span><span class="si">{:.1f}</span><span class="s1">&#39;</span>
                   <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">spw</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">spw</span><span class="o">.</span><span class="n">bandwidth</span><span class="p">,</span> <span class="n">widest_spw</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">widest_spw</span><span class="o">.</span><span class="n">bandwidth</span><span class="p">,</span>
                             <span class="n">mydict</span><span class="p">[</span><span class="n">calspw</span><span class="o">.</span><span class="n">id</span><span class="p">][</span><span class="s1">&#39;snr_widest_spw&#39;</span><span class="p">]))</span>
        <span class="k">elif</span> <span class="n">mydict</span><span class="p">[</span><span class="n">calspw</span><span class="o">.</span><span class="n">id</span><span class="p">][</span><span class="s1">&#39;snr_aggregate&#39;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">min_snr</span><span class="p">:</span>
            <span class="n">mydict</span><span class="p">[</span><span class="n">calspw</span><span class="o">.</span><span class="n">id</span><span class="p">][</span><span class="s1">&#39;status&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;combine_spw&#39;</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;science spw </span><span class="si">{}</span><span class="s1"> (</span><span class="si">{}</span><span class="s1">) calibrated by aggregate bandwidth (</span><span class="si">{}</span><span class="s1">) has sufficient S/N: </span><span class="si">{:.1f}</span><span class="s1">&#39;</span>
                   <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">spw</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">spw</span><span class="o">.</span><span class="n">bandwidth</span><span class="p">,</span> <span class="n">aggregate_bandwidth</span><span class="p">,</span> <span class="n">mydict</span><span class="p">[</span><span class="n">calspw</span><span class="o">.</span><span class="n">id</span><span class="p">][</span><span class="s1">&#39;snr_aggregate&#39;</span><span class="p">]))</span>
        <span class="k">elif</span> <span class="n">mydict</span><span class="p">[</span><span class="n">calspw</span><span class="o">.</span><span class="n">id</span><span class="p">][</span><span class="s1">&#39;medianTsys&#39;</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;science spw </span><span class="si">{}</span><span class="s1"> (</span><span class="si">{}</span><span class="s1">) has a negative median Tsys: there must be a problem in the data&#39;</span>
                   <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">spw</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">spw</span><span class="o">.</span><span class="n">bandwidth</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;science spw </span><span class="si">{}</span><span class="s1"> (</span><span class="si">{}</span><span class="s1">): Even aggregate bandwidth is insufficient (SNR&lt;</span><span class="si">{:.0f}</span><span class="s1">). QA2 Fail!&#39;</span>
                   <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">spw</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">spw</span><span class="o">.</span><span class="n">bandwidth</span><span class="p">,</span> <span class="n">min_snr</span><span class="p">))</span>
            <span class="n">mydict</span><span class="p">[</span><span class="n">calspw</span><span class="o">.</span><span class="n">id</span><span class="p">][</span><span class="s1">&#39;status&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;starved&#39;</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">mydict</span></div>



<div class="viewcode-block" id="compute_aggregate_bandwidth">
<a class="viewcode-back" href="../../../../../_apidoc/pipeline.hifa.tasks.fluxscale.html#pipeline.hifa.tasks.fluxscale.qa.compute_aggregate_bandwidth">[docs]</a>
<span class="k">def</span> <span class="nf">compute_aggregate_bandwidth</span><span class="p">(</span><span class="n">spws</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the aggregate bandwidth for a list of spws of a measurement set.</span>
<span class="sd">    Accounts correctly for overlap.  Called by gaincalSNR().</span>
<span class="sd">    spw: an integer list, or comma-delimited string list of spw IDs</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">min_spw</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">spws</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">operator</span><span class="o">.</span><span class="n">attrgetter</span><span class="p">(</span><span class="s1">&#39;min_frequency&#39;</span><span class="p">))</span>

    <span class="n">aggregate</span> <span class="o">=</span> <span class="p">[</span><span class="n">frequency_min_max_after_aliasing</span><span class="p">(</span><span class="n">min_spw</span><span class="p">)]</span>

    <span class="n">spws_by_frequency</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">spws</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">operator</span><span class="o">.</span><span class="n">attrgetter</span><span class="p">(</span><span class="s1">&#39;min_frequency&#39;</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">spw</span> <span class="ow">in</span> <span class="n">spws_by_frequency</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
        <span class="n">spw_fmin</span><span class="p">,</span> <span class="n">spw_fmax</span> <span class="o">=</span> <span class="n">frequency_min_max_after_aliasing</span><span class="p">(</span><span class="n">spw</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">spw_fmin</span> <span class="o">&lt;</span> <span class="n">aggregate</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">spw_fmax</span><span class="p">:</span>
            <span class="c1"># spw begins before current max window ends, so extend the current</span>
            <span class="c1"># max window</span>
            <span class="n">aggregate</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">aggregate</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">spw_fmax</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">spw_fmin</span> <span class="o">&gt;</span> <span class="n">aggregate</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">spw_fmax</span><span class="p">:</span>
            <span class="c1"># interval is disjoint with existing, so add a new interval</span>
            <span class="n">aggregate</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">spw_fmin</span><span class="p">,</span> <span class="n">spw_fmax</span><span class="p">))</span>

    <span class="n">bw</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">f_range</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="n">f_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">f_range</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">aggregate</span><span class="p">,</span> <span class="n">Frequency</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">bw</span></div>



<div class="viewcode-block" id="frequency_min_max_after_aliasing">
<a class="viewcode-back" href="../../../../../_apidoc/pipeline.hifa.tasks.fluxscale.html#pipeline.hifa.tasks.fluxscale.qa.frequency_min_max_after_aliasing">[docs]</a>
<span class="k">def</span> <span class="nf">frequency_min_max_after_aliasing</span><span class="p">(</span><span class="n">spw</span><span class="p">):</span>
    <span class="n">two_ghz</span> <span class="o">=</span> <span class="n">Frequency</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">FrequencyUnits</span><span class="o">.</span><span class="n">GIGAHERTZ</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">spw</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;TDM&#39;</span> <span class="ow">and</span> <span class="n">spw</span><span class="o">.</span><span class="n">bandwidth</span> <span class="o">==</span> <span class="n">two_ghz</span><span class="p">:</span>
        <span class="c1"># 125Mhz of bandwidth is flagged (=8 channels are flagged, 4 at the</span>
        <span class="c1"># top of the band and 4 at the bottom, due to the anti-aliasing</span>
        <span class="c1"># filters reducing the sensitivity beyond that point.</span>
        <span class="n">low_channel</span> <span class="o">=</span> <span class="n">spw</span><span class="o">.</span><span class="n">channels</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
        <span class="n">high_channel</span> <span class="o">=</span> <span class="n">spw</span><span class="o">.</span><span class="n">channels</span><span class="p">[</span><span class="o">-</span><span class="mi">5</span><span class="p">]</span>
        <span class="c1"># LSB channels could be in descending frequency order</span>
        <span class="k">if</span> <span class="n">low_channel</span><span class="o">.</span><span class="n">low</span> <span class="o">&gt;</span> <span class="n">high_channel</span><span class="o">.</span><span class="n">low</span><span class="p">:</span>
            <span class="n">low_channel</span><span class="p">,</span> <span class="n">high_channel</span> <span class="o">=</span> <span class="n">high_channel</span><span class="p">,</span> <span class="n">low_channel</span>
        <span class="k">return</span> <span class="n">low_channel</span><span class="o">.</span><span class="n">low</span><span class="p">,</span> <span class="n">high_channel</span><span class="o">.</span><span class="n">high</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">spw</span><span class="o">.</span><span class="n">min_frequency</span><span class="p">,</span> <span class="n">spw</span><span class="o">.</span><span class="n">max_frequency</span></div>



<div class="viewcode-block" id="CaltableWrapperFactory">
<a class="viewcode-back" href="../../../../../_apidoc/pipeline.hifa.tasks.fluxscale.html#pipeline.hifa.tasks.fluxscale.qa.CaltableWrapperFactory">[docs]</a>
<span class="k">class</span> <span class="nc">CaltableWrapperFactory</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<div class="viewcode-block" id="CaltableWrapperFactory.from_caltable">
<a class="viewcode-back" href="../../../../../_apidoc/pipeline.hifa.tasks.fluxscale.html#pipeline.hifa.tasks.fluxscale.qa.CaltableWrapperFactory.from_caltable">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_caltable</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;CaltableWrapperFactory.from_caltable(</span><span class="si">%r</span><span class="s1">)&#39;</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">CaltableWrapperFactory</span><span class="o">.</span><span class="n">create_param_wrapper</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span></div>


<div class="viewcode-block" id="CaltableWrapperFactory.create_param_wrapper">
<a class="viewcode-back" href="../../../../../_apidoc/pipeline.hifa.tasks.fluxscale.html#pipeline.hifa.tasks.fluxscale.qa.CaltableWrapperFactory.create_param_wrapper">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">create_param_wrapper</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
        <span class="k">with</span> <span class="n">casa_tools</span><span class="o">.</span><span class="n">TableReader</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="k">as</span> <span class="n">tb</span><span class="p">:</span>
            <span class="n">colnames</span> <span class="o">=</span> <span class="n">tb</span><span class="o">.</span><span class="n">colnames</span><span class="p">()</span>
            <span class="n">scalar_cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">colnames</span> <span class="k">if</span> <span class="n">tb</span><span class="o">.</span><span class="n">isscalarcol</span><span class="p">(</span><span class="n">c</span><span class="p">)]</span>
            <span class="n">var_cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">colnames</span> <span class="k">if</span> <span class="n">tb</span><span class="o">.</span><span class="n">isvarcol</span><span class="p">(</span><span class="n">c</span><span class="p">)]</span>

            <span class="n">dtypes</span> <span class="o">=</span> <span class="p">{</span><span class="n">c</span><span class="p">:</span> <span class="n">get_dtype</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">colnames</span><span class="p">}</span>
            <span class="n">readable_var_cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">dtypes</span> <span class="k">if</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">var_cols</span> <span class="ow">and</span> <span class="n">dtypes</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>
            <span class="n">col_dtypes</span> <span class="o">=</span> <span class="p">[</span><span class="n">dtypes</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">dtypes</span> <span class="k">if</span> <span class="n">dtypes</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>

            <span class="n">data</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">tb</span><span class="o">.</span><span class="n">nrows</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">col_dtypes</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">scalar_cols</span><span class="p">:</span>
                <span class="n">data</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">tb</span><span class="o">.</span><span class="n">getcol</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">readable_var_cols</span><span class="p">:</span>
                <span class="n">records</span> <span class="o">=</span> <span class="n">tb</span><span class="o">.</span><span class="n">getvarcol</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
                <span class="c1"># results in a list of numpy arrays, one for each row in the</span>
                <span class="c1"># caltable. The shape of each numpy array is number of</span>
                <span class="c1"># correlations, number of channels, number of values for that</span>
                <span class="c1"># correlation/channel combination - which is always 1. Squeeze out</span>
                <span class="c1"># the unnecessary dimension and swap the channel and correlation</span>
                <span class="c1"># axes.</span>
                <span class="n">row_data</span> <span class="o">=</span> <span class="p">[</span><span class="n">records</span><span class="p">[</span><span class="s1">&#39;r</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">records</span><span class="p">))]</span>

                <span class="c1"># Different spectral windows can have different numbers of</span>
                <span class="c1"># channels, e.g., TDM vs FDM. NumPy doesn&#39;t support jagged</span>
                <span class="c1"># arrays, so the code below ensures the data are uniformly</span>
                <span class="c1"># sized. Spectral windows with fewer channels are coerced to</span>
                <span class="c1"># the same size as the most detailed windows by adding masked</span>
                <span class="c1"># values to the &#39;end&#39; of the data for that row.</span>

                <span class="c1"># Defines required envelope of dimensions, with the number of</span>
                <span class="c1"># rows (unused), number of polarisations, maximum number of</span>
                <span class="c1"># channels</span>
                <span class="n">_</span><span class="p">,</span> <span class="n">x_dim</span><span class="p">,</span> <span class="n">y_dim</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
                <span class="n">column_dtype</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span>

                <span class="n">coerced_rows</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">row_data</span><span class="p">:</span>
                    <span class="n">data_channels</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_array</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">row</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">column_dtype</span><span class="p">)</span>
                    <span class="n">row_x_dim</span><span class="p">,</span> <span class="n">row_y_dim</span> <span class="o">=</span> <span class="n">row</span><span class="o">.</span><span class="n">shape</span>
                    <span class="n">fake_channels</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_all</span><span class="p">((</span><span class="n">x_dim</span><span class="p">,</span> <span class="n">y_dim</span><span class="o">-</span><span class="n">row_y_dim</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">column_dtype</span><span class="p">)</span>
                    <span class="n">coerced_rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">data_channels</span><span class="p">,</span> <span class="n">fake_channels</span><span class="p">)))</span>
                <span class="n">data</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_array</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">coerced_rows</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">column_dtype</span><span class="p">)</span>

            <span class="n">table_keywords</span> <span class="o">=</span> <span class="n">tb</span><span class="o">.</span><span class="n">getkeywords</span><span class="p">()</span>
            <span class="n">column_keywords</span> <span class="o">=</span> <span class="p">{</span><span class="n">c</span><span class="p">:</span> <span class="n">tb</span><span class="o">.</span><span class="n">getcolkeywords</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">colnames</span><span class="p">}</span>

        <span class="c1"># convert to NumPy MaskedArray if FLAG column is present</span>
        <span class="k">if</span> <span class="s1">&#39;FLAG&#39;</span> <span class="ow">in</span> <span class="n">readable_var_cols</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;FLAG&#39;</span><span class="p">]</span>
            <span class="n">var_cols_to_mask</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">readable_var_cols</span> <span class="k">if</span> <span class="n">c</span> <span class="o">!=</span> <span class="s1">&#39;FLAG&#39;</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">var_cols_to_mask</span><span class="p">:</span>
                <span class="n">data</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="n">c</span><span class="p">],</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">CaltableWrapper</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">table_keywords</span><span class="p">,</span> <span class="n">column_keywords</span><span class="p">)</span></div>
</div>



<span class="c1"># maps CASA data types to their numpy equivalent. This dict is used by the</span>
<span class="c1"># get_dtype function below.</span>
<span class="n">CASA_DATA_TYPES</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;int&#39;</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span>
    <span class="s1">&#39;boolean&#39;</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
    <span class="s1">&#39;float&#39;</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
    <span class="s1">&#39;double&#39;</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
    <span class="s1">&#39;complex&#39;</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">complex128</span>
<span class="p">}</span>


<div class="viewcode-block" id="get_dtype">
<a class="viewcode-back" href="../../../../../_apidoc/pipeline.hifa.tasks.fluxscale.html#pipeline.hifa.tasks.fluxscale.qa.get_dtype">[docs]</a>
<span class="k">def</span> <span class="nf">get_dtype</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">col</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the numpy data type for a CASA caltable column.</span>

<span class="sd">    :param tb: CASA table tool with caltable open.</span>
<span class="sd">    :param col: name of column to process</span>
<span class="sd">    :return: 3-tuple of column name, NumPy dtype, column shape</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">col_dtype</span> <span class="o">=</span> <span class="n">tb</span><span class="o">.</span><span class="n">coldatatype</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">tb</span><span class="o">.</span><span class="n">isscalarcol</span><span class="p">(</span><span class="n">col</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">col</span><span class="p">,</span> <span class="n">CASA_DATA_TYPES</span><span class="p">[</span><span class="n">col_dtype</span><span class="p">]</span>

    <span class="k">elif</span> <span class="n">tb</span><span class="o">.</span><span class="n">isvarcol</span><span class="p">(</span><span class="n">col</span><span class="p">):</span>
        <span class="c1"># PIPE-1323: pre-check if the first row of this column is an empty cell, a scenario in which</span>
        <span class="c1"># the RuntimeError exception and a CASA &#39;SEVERE&#39; message will be triggered.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">tb</span><span class="o">.</span><span class="n">iscelldefined</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">shapes_string</span> <span class="o">=</span> <span class="n">tb</span><span class="o">.</span><span class="n">getcolshapestring</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">RuntimeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># spectral windows can have different shapes, e.g., TDM vs FDM,</span>
            <span class="c1"># therefore the shape needs to be a list of shapes.</span>
            <span class="n">shapes</span> <span class="o">=</span> <span class="p">[</span><span class="n">ast</span><span class="o">.</span><span class="n">literal_eval</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">shapes_string</span><span class="p">]</span>

            <span class="n">x_dimensions</span> <span class="o">=</span> <span class="p">{</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">shape</span> <span class="ow">in</span> <span class="n">shapes</span><span class="p">}</span>
            <span class="k">assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x_dimensions</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>

            <span class="c1"># find the maximum dimensions of a row</span>
            <span class="n">max_row_shape</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">shapes</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">col</span><span class="p">,</span> <span class="n">CASA_DATA_TYPES</span><span class="p">[</span><span class="n">col_dtype</span><span class="p">],</span> <span class="n">max_row_shape</span></div>



<div class="viewcode-block" id="CaltableWrapper">
<a class="viewcode-back" href="../../../../../_apidoc/pipeline.hifa.tasks.fluxscale.html#pipeline.hifa.tasks.fluxscale.qa.CaltableWrapper">[docs]</a>
<span class="k">class</span> <span class="nc">CaltableWrapper</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">table_keywords</span><span class="p">,</span> <span class="n">column_keywords</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filename</span> <span class="o">=</span> <span class="n">filename</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">table_keywords</span> <span class="o">=</span> <span class="n">table_keywords</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">column_keywords</span> <span class="o">=</span> <span class="n">column_keywords</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">allowed</span><span class="p">,</span> <span class="n">column</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="nb">iter</span><span class="p">(</span><span class="n">allowed</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="n">allowed</span> <span class="o">=</span> <span class="p">[</span><span class="n">allowed</span><span class="p">]</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">allowed</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">a</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">column</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> column </span><span class="si">{}</span><span class="s1"> value not found: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">,</span> <span class="n">column</span><span class="p">,</span> <span class="n">a</span><span class="p">))</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">mask</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">column</span><span class="p">]</span> <span class="o">==</span> <span class="n">a</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">mask</span>

<div class="viewcode-block" id="CaltableWrapper.filter">
<a class="viewcode-back" href="../../../../../_apidoc/pipeline.hifa.tasks.fluxscale.html#pipeline.hifa.tasks.fluxscale.qa.CaltableWrapper.filter">[docs]</a>
    <span class="k">def</span> <span class="nf">filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spw</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">antenna</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">scan</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">field</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">mask_args</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># create a mask that lets all data through for columns that are not</span>
        <span class="c1"># specified as arguments, or just the specified values through for</span>
        <span class="c1"># columns that are specified as arguments</span>
        <span class="k">def</span> <span class="nf">passthrough</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">column_name</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">column_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                    <span class="n">mask_args</span><span class="p">[</span><span class="n">column_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">column_name</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mask_args</span><span class="p">[</span><span class="n">column_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span>

        <span class="k">for</span> <span class="n">arg</span><span class="p">,</span> <span class="n">column_name</span> <span class="ow">in</span> <span class="p">[(</span><span class="n">spw</span><span class="p">,</span> <span class="s1">&#39;SPECTRAL_WINDOW_ID&#39;</span><span class="p">),</span> <span class="p">(</span><span class="n">antenna</span><span class="p">,</span> <span class="s1">&#39;ANTENNA1&#39;</span><span class="p">),</span> <span class="p">(</span><span class="n">field</span><span class="p">,</span> <span class="s1">&#39;FIELD_ID&#39;</span><span class="p">),</span>
                                 <span class="p">(</span><span class="n">scan</span><span class="p">,</span> <span class="s1">&#39;SCAN_NUMBER&#39;</span><span class="p">)]:</span>
            <span class="n">passthrough</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">column_name</span><span class="p">)</span>

        <span class="c1"># combine masks to create final data selection mask</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">mask_args</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">mask</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_mask</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># find data for the selection mask</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>

        <span class="c1"># create new object for the filtered data</span>
        <span class="k">return</span> <span class="n">CaltableWrapper</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">table_keywords</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">column_keywords</span><span class="p">)</span></div>
</div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020–2024, Pipeline Dev. Team.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>