

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>casatools.ms &mdash; Pipeline unknown documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css?v=4ae1632d" />
      <link rel="stylesheet" type="text/css" href="../../_static/custom_theme.css?v=678032d9" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=3f1b9271"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            Pipeline
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Releases etc.</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../releases.html">Past Releases</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dependencies.html">Dependencies of <code class="docutils literal notranslate"><span class="pre">Pipeline</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modular.html">Run the Pipeline in a Conda environment</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../apisummary.html">Pipeline Tasks (from autosummary)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../apisummary.html#full-list">Full List</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">TaskRef (create_docs.py)</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../_taskdocs/taskdocs.html">List of Heuristics Tasks (Pipeline 2023)</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Pipeline Heuristics</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../heuristics/field_parameter.html">Field parameter</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../heuristics/FlaggingTasks.html">Pipeline Flagging Tasks</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Developer Notes</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../develdocmd/ways_to_run_the_pipeline.html">Ways to run the Pipeline</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../develdocmd/comparing_pipeline_executions.html">Comparing pipeline executions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../develdocmd/building_the_pipeline.html">Building the pipeline</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../develdocmd/ALMA-Imaging-Workflow.html">ALMA interferometry imaging workflow</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../develdocmd/VLA-Imaging-Workflow.html">VLA interferometry imaging workflow</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../develdocmd/VLASS-SE-CONT-Imaging-Workflow.html">VLASS-SE-CONT imaging workflow</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../develdocmd/VLASS-SE-CUBE-Imaging-Workflow.html">VLASS-SE-CUBE imaging workflow</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../develdocmd/selfcal_workflow.html">VLASS Selfcal &amp; Restore workflows</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../develdocmd/pipeline_tests.html">Pipeline testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../develdocmd/DataType_Testing.html">DataType Testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../develdocmd/QA_scores.html">Pipeline Quality Assurance (QA) Score Class Design</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../develdocmd/DeveloperDocumentation.html">Pipeline developer documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../develdocmd/python3_conversion_notes.html">Python 3 conversion notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../develdocmd/recipes.html">Pipeline Recipes</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Pipeline Domain/Context (automodapi)</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../basics.html"><code class="docutils literal notranslate"><span class="pre">pipeline.domain</span></code> module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../basics.html#module-pipeline.infrastructure.launcher"><code class="docutils literal notranslate"><span class="pre">pipeline.infrastructure.launcher</span></code> module</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Pipeline Domain/Context (autosummary)</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../_autosummary/pipeline.domain.html">pipeline.domain</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../_autosummary/pipeline.infrastructure.launcher.html">pipeline.infrastructure.launcher</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Pipeline Task/Inputs/Results Classes</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../classes.html">Classes in <code class="docutils literal notranslate"><span class="pre">pipeline.h*.tasks</span></code> modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../classes.html#inheritance-diagrams">Inheritance Diagrams</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Examples Notes (from Jupyter Notebooks)</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../examples/test1.html">test</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Example Notes (from .rst)</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../examples/test2.html">Example 1</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Pipeline</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">casatools.ms</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for casatools.ms</h1><div class="highlight"><pre>
<span></span><span class="c1">##################### generated by xml-casa (v2) from ms.xml ########################</span>
<span class="c1">##################### 419aab85376c97dfba31215cad1c384f ##############################</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">absolute_import</span> 
<span class="kn">from</span> <span class="nn">.__casac__.ms</span> <span class="kn">import</span> <span class="n">ms</span> <span class="k">as</span> <span class="n">_ms</span>

<span class="kn">from</span> <span class="nn">.errors</span> <span class="kn">import</span> <span class="n">create_error_string</span>
<span class="kn">from</span> <span class="nn">.typecheck</span> <span class="kn">import</span> <span class="n">CasaValidator</span> <span class="k">as</span> <span class="n">_validator</span>
<span class="n">_pc</span> <span class="o">=</span> <span class="n">_validator</span><span class="p">(</span> <span class="p">)</span>
<span class="kn">from</span> <span class="nn">.coercetype</span> <span class="kn">import</span> <span class="n">coerce</span> <span class="k">as</span> <span class="n">_coerce</span>
<span class="kn">from</span> <span class="nn">.table</span> <span class="kn">import</span> <span class="n">table</span> <span class="k">as</span> <span class="n">_wrap_table</span>
<span class="kn">from</span> <span class="nn">.msmetadata</span> <span class="kn">import</span> <span class="n">msmetadata</span> <span class="k">as</span> <span class="n">_wrap_msmetadata</span>

<span class="k">class</span> <span class="nc">ms</span><span class="p">:</span>
    <span class="n">_info_group_</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;ms&quot;&quot;&quot;</span>
    <span class="n">_info_desc_</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;Operations on measurement sets&quot;&quot;&quot;</span>
    <span class="c1">### self</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This is the most commonly used constructor. It creates an ms tool</span>
<span class="sd">        which is attached to the specified measurement set table.</span>
<span class="sd">        </span>
<span class="sd">        By default the table is opened read only to prevent you from</span>
<span class="sd">        accidently making changes to the measurement set. Set nomodify to</span>
<span class="sd">        False you you do intend to make changes.</span>
<span class="sd">        </span>
<span class="sd">        Setting the lock argument to True will permanently lock the table</span>
<span class="sd">        preventing other processes from writing to the measurement set.</span>
<span class="sd">        Unless you expect this to happen, and want to prevent it, you</span>
<span class="sd">        should leave the lock argument at the default value which implies</span>
<span class="sd">        auto-locking.</span>
<span class="sd">        </span>
<span class="sd">        The host argument specifies which machine the precompiled ms</span>
<span class="sd">        process should be started on. The default value starts it on the</span>
<span class="sd">        same machine as the one that casapy is running on.</span>
<span class="sd">        </span>
<span class="sd">        In order to run the ms tool on a remote machine you need to</span>
<span class="sd">        satisfy all the following conditions.</span>
<span class="sd">        begin{itemize}</span>
<span class="sd">        item It must be possible to start casa on the remote machine</span>
<span class="sd">        item You must be able to log onto the remote machine without</span>
<span class="sd">        having to type a password</span>
<span class="sd">        item The CASAPATH environment variable must be defined on the</span>
<span class="sd">        remote machine. You may want to set this up in the relevant</span>
<span class="sd">        ``dot&#39;&#39; file eg., adding a line like</span>
<span class="sd">        texttt{source~/usr/local/aips++/aipsinit.csh} in your</span>
<span class="sd">        .cshrc file (for csh).</span>
<span class="sd">        end{itemize}</span>
<span class="sd">        One quick way to check if all three conditions are met is to type,</span>
<span class="sd">        on your local machine (rsh host &#39;echo $CASAPATH&#39;) where host is</span>
<span class="sd">        replaced by the name of the remote machine. If the value of the</span>
<span class="sd">        CASAPATH variable that is printed does not contain something like</span>
<span class="sd">        {aips-root~architecture~site~host} and that all the values are</span>
<span class="sd">        correct for the remote machine you can be certain that starting the</span>
<span class="sd">        ms tool, or any casa server, on the remote host will not work.</span>
<span class="sd">        </span>
<span class="sd">        Each ms tool can only run one function at a time. To solve this</span>
<span class="sd">        you start two servers. The forcenewserver argument allows you to</span>
<span class="sd">        do this by overriding the default behaviour of having each ms tool</span>
<span class="sd">        share the same server.</span>
<span class="sd">        </span>
<span class="sd">        This function returns an ms tool or fail if something went wrong,</span>
<span class="sd">        like an error in the measurement set name.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;swig_object&#39;</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span> <span class="o">=</span> <span class="n">_ms</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">open</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">thems</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">nomodify</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">lock</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Use this function when you have detached (using the close function)</span>
<span class="sd">        the ms tool from a measurement set table and wish to reattach to another</span>
<span class="sd">        measurement set table.</span>
<span class="sd">        </span>
<span class="sd">        If check=true, additional referential integrity checks on the MS</span>
<span class="sd">        are run. If any of these fail, an exception is thrown and the MS</span>
<span class="sd">        is not open (since it is not a valid MS).</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">thems</span><span class="p">,</span> <span class="n">nomodify</span><span class="p">,</span> <span class="n">lock</span><span class="p">,</span> <span class="n">check</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function re-attaches the ms tool to the original MS,</span>
<span class="sd">        effectively discarding any prior operations, in particular any</span>
<span class="sd">        data selection operations using msselect function.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function detaches the ms tool from the associated</span>
<span class="sd">        measurement set table after flushing all the cached changes.</span>
<span class="sd">        After calling this function the ms tool is not associated with</span>
<span class="sd">        any measurement set and using any function other than open or fromfits</span>
<span class="sd">        will result in an error message being sent to the logger.</span>
<span class="sd">        </span>
<span class="sd">        This function can be useful to avoid synchronization problems</span>
<span class="sd">        which can occur when different processes have the same ms open.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">done</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;You should call close() when you are finished using the ms tool</span>
<span class="sd">        to close the measurement set table and free any associated file</span>
<span class="sd">        locks. The measurement set is not deleted.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">done</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function returns the name of the measurement set table that</span>
<span class="sd">        is being manipulated. If the ms tool is not attached to any</span>
<span class="sd">        measurement set, this function will return the string ``none&#39;&#39;.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">name</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">iswritable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function returns True if the underlying MeasurementSet</span>
<span class="sd">        was opened for writing/update.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">iswritable</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">nrow</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">selected</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function returns the number of rows in the measurement set.</span>
<span class="sd">        If the optional argument selected is set to True, it returns the</span>
<span class="sd">        number of currently selected rows, otherwise it returns the</span>
<span class="sd">        number of rows in the original measurement set.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">nrow</span><span class="p">(</span><span class="n">selected</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">getdata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">items</span><span class="o">=</span><span class="p">[</span>  <span class="p">],</span> <span class="n">ifraxis</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ifraxisgap</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">increment</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">average</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function reads the specified items from the currently</span>
<span class="sd">        selected measurement set and returns them in fields of a record.</span>
<span class="sd">        The main difference between this and direct access of the table,</span>
<span class="sd">        using the table tool, is that this function reads data from the</span>
<span class="sd">        selected measurement set, provides access to derived</span>
<span class="sd">        quantities like amplitude and flag_sum, and can reorder the</span>
<span class="sd">        data.</span>
<span class="sd">        </span>
<span class="sd">        As with the ms.range function, the items to read are specified</span>
<span class="sd">        using a vector of strings. Allowable items include: &#39;amplitude&#39;,</span>
<span class="sd">        &#39;corrected_amplitude&#39;, &#39;model_amplitude&#39;, &#39;ratio_amplitude&#39;,</span>
<span class="sd">        &#39;residual_amplitude&#39;, &#39;obs_residual_amplitude&#39;, &#39;antenna1&#39;,</span>
<span class="sd">        &#39;antenna2&#39;, &#39;axis_info&#39;, &#39;data&#39;, &#39;corrected_data&#39;, &#39;float_data&#39;,</span>
<span class="sd">        &#39;model_data&#39;, &#39;ratio_data&#39;, &#39;residual_data&#39;,</span>
<span class="sd">        &#39;obs_residual_data&#39;, &#39;feed1&#39;, &#39;feed2&#39;, &#39;field_id&#39;, &#39;flag&#39;,</span>
<span class="sd">        &#39;flag_row&#39;, &#39;flag_sum&#39;, &#39;ha&#39; (added to &#39;axis_info&#39;),</span>
<span class="sd">        &#39;ifr_number&#39;, &#39;imaginary&#39;, &#39;corrected_imaginary&#39;,</span>
<span class="sd">        &#39;model_imaginary&#39;, &#39;ratio_imaginary&#39;, &#39;residual_imaginary&#39;,</span>
<span class="sd">        &#39;obs_residual_imaginary&#39;, &#39;last&#39; (added to &#39;axis_info&#39;),</span>
<span class="sd">        &#39;phase&#39;, &#39;corrected_phase&#39;, &#39;model_phase&#39;, &#39;ratio_phase&#39;,</span>
<span class="sd">        &#39;residual_phase&#39;, &#39;obs_residual_phase&#39;, &#39;real&#39;,</span>
<span class="sd">        &#39;corrected_real&#39;, &#39;ratio_real&#39;, &#39;residual_real&#39;,</span>
<span class="sd">        &#39;obs_residual_real&#39;, &#39;scan_number&#39;, &#39;sigma&#39;, &#39;data_desc_id&#39;,</span>
<span class="sd">        &#39;time&#39;, &#39;ut&#39; (added to &#39;axis_info&#39;), &#39;uvw&#39;, &#39;u&#39;, &#39;v&#39;, &#39;w&#39;,</span>
<span class="sd">        &#39;uvdist&#39;, and &#39;weight&#39;. Unrecognized items will result in a</span>
<span class="sd">        warning being sent to the logger.  Corrected, model, and float</span>
<span class="sd">        visibilities will result in a warning if these columns do not</span>
<span class="sd">        exist.  Duplicate items are silently ignored.</span>
<span class="sd">        </span>
<span class="sd">        Note that &#39;ha&#39;, &#39;last&#39;, and &#39;ut&#39; must be requested along with</span>
<span class="sd">        &#39;axis_info&#39; and ifraxis=True.  This data will be found in a</span>
<span class="sd">        subrecord of the returned record&#39;s &#39;axis_info&#39; with the key in</span>
<span class="sd">        uppercase.  For example, for &#39;ut&#39;, the data is found in:</span>
<span class="sd">        rec[&#39;axis_info&#39;][&#39;time_axis&#39;][&#39;UT&#39;].  See more information</span>
<span class="sd">        about &#39;axis_info&#39; below.</span>
<span class="sd">        </span>
<span class="sd">        The record that is returned contains fields that correspond to</span>
<span class="sd">        each of the specified items. Most fields will contain an array.</span>
<span class="sd">        The array may be one, two or three dimensional depending on</span>
<span class="sd">        whether the corresponding row in the measurement set is a</span>
<span class="sd">        scalar, one-, or two-dimensional. Unless the ifraxis argument</span>
<span class="sd">        is set to True, the length of the last axis on these arrays</span>
<span class="sd">        will correspond to the number of rows in the selected</span>
<span class="sd">        measurement set.</span>
<span class="sd">        </span>
<span class="sd">        If the ifraxis argument is set to True, the row axis is split</span>
<span class="sd">        into an interferometer axis and a time axis. For example, a</span>
<span class="sd">        measurement set with 90 rows, in an array with 6 telescopes (so</span>
<span class="sd">        that there are 15 interferometers), may have a data array of</span>
<span class="sd">        shape [4,32,90] if ifraxis is False, or [4,32,15,6] if ifraxis</span>
<span class="sd">        is True (assuming there are 4 correlations and 32 channels). If</span>
<span class="sd">        there are missing rows, as will happen if not all</span>
<span class="sd">        interferometers were used for all time-slots, then a default</span>
<span class="sd">        value will be inserted.</span>
<span class="sd">        </span>
<span class="sd">        This splitting of the row axis may not happen for items where</span>
<span class="sd">        there is only a single value per row. For some items the</span>
<span class="sd">        returned vector will contain only as many values as there are</span>
<span class="sd">        interferometers and it is implicit that the same value should</span>
<span class="sd">        be used for all time slots. The antenna1, antenna2, feed1,</span>
<span class="sd">        feed2 and ifr_number items fall in this category. For other</span>
<span class="sd">        items, the returned vector will have as many values as there</span>
<span class="sd">        are time slots and it is implicit that the same value should be</span>
<span class="sd">        used for all interferometers. The field_id, scan_number,</span>
<span class="sd">        data_desc_id, and time items fall into this category.</span>
<span class="sd">        </span>
<span class="sd">        The &#39;axis_info&#39; item provides data labelling information. It</span>
<span class="sd">        returns a record with the following fields: corr_axis,</span>
<span class="sd">        freq_axis, ifr_axis, and time_axis. The latter two fields are</span>
<span class="sd">        not present if ifraxis is set to False.</span>
<span class="sd">        </span>
<span class="sd">        1. The corr_axis field contains a string vector with elements like</span>
<span class="sd">        &#39;RR&#39; or &#39;XY&#39; that indicates which polarizations were correlated</span>
<span class="sd">        together to produce the data. The length of this vector will</span>
<span class="sd">        always be the same as the length of the first axis of the data</span>
<span class="sd">        array.</span>
<span class="sd">        </span>
<span class="sd">        2. The freq_axis field contains a record with two fields, chan_freq</span>
<span class="sd">        and resolution. Each of these fields contains vectors which</span>
<span class="sd">        indicate the centre frequency and spectral resolution (FWHM)</span>
<span class="sd">        of each channel. The length of these vectors will be the same</span>
<span class="sd">        as the length of the second axis in the data.</span>
<span class="sd">        </span>
<span class="sd">        3. The ifr_axis field contains fields: ifr_number, ifr_name,</span>
<span class="sd">        ifr_shortname and baseline. The ifr_number is the same as</span>
<span class="sd">        returned by the &#39;ifr_number&#39; item, 1000*antenna1+antenna2.</span>
<span class="sd">        The ifr_name and ifr_shortname are string vectors containing</span>
<span class="sd">        descriptions of the interferometer; ifr_name contains the names</span>
<span class="sd">        of the antenna pair separated by a hyphen, and ifr_shortname</span>
<span class="sd">        contains the ids of the antenna pair separated by a hyphen.</span>
<span class="sd">        The baseline is the Euclidian distance in meters between the two</span>
<span class="sd">        antennas. All of these vectors have a length equal to the number</span>
<span class="sd">        of interferometers in the selected measurement set, i.e., to the</span>
<span class="sd">        length of the third axis in the data when ifraxis is True.</span>
<span class="sd">        </span>
<span class="sd">        4. The time_axis field contains the MJD seconds field and</span>
<span class="sd">        optionally the HA, UT, and LAST fields. To include the optional</span>
<span class="sd">        fields, you need to add &#39;ha&#39;, &#39;last&#39; or &#39;ut&#39; strings to the list</span>
<span class="sd">        of requested items. All of the fields in the time_axis record</span>
<span class="sd">        contain vectors that indicate the time at the midpoint of the</span>
<span class="sd">        observation and are in seconds. The MJD seconds field is since</span>
<span class="sd">        0 hours on the day having a modified julian day number of zero</span>
<span class="sd">        and the rest are since midnight prior to the start of the</span>
<span class="sd">        observation.</span>
<span class="sd">        </span>
<span class="sd">        An optional gap size can be specified to visually separate</span>
<span class="sd">        groups of interferometers with the same antenna1 index (handy</span>
<span class="sd">        for identifying antennas in an interferometer vs time display).</span>
<span class="sd">        The default is no gap.</span>
<span class="sd">        </span>
<span class="sd">        An optional increment can be specified to return data from every</span>
<span class="sd">        row matching the increment only.</span>
<span class="sd">        </span>
<span class="sd">        When the average flag is set, the data will be averaged over the</span>
<span class="sd">        time axis if the ifraxis is True or the row axis i.e., different</span>
<span class="sd">        interferometers and times may be averaged together. In the</span>
<span class="sd">        latter case, some of the coordinate information, like</span>
<span class="sd">        antenna_id, will no longer make sense. When all data to be</span>
<span class="sd">        averaged is unflagged, the result is the averaged value and the</span>
<span class="sd">        corresponding flag is False. When all data is flagged, the</span>
<span class="sd">        result is set to zero and the corresponding flag is True.  When</span>
<span class="sd">        data to be averaged is mixed (unflagged and flagged), only the</span>
<span class="sd">        unflagged values are averaged and the flag is set to False.</span>
<span class="sd">        </span>
<span class="sd">        You need to call selectinit before calling this function.</span>
<span class="sd">        If you haven&#39;t then selectinit will be called for you with</span>
<span class="sd">        default arguments.</span>
<span class="sd">        </span>
<span class="sd">        Items prefixed with corrected, model, residual or obs_residual</span>
<span class="sd">        are not available unless your measurement set has been processed</span>
<span class="sd">        either with the imager or calibrator tools.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">getdata</span><span class="p">(</span><span class="n">items</span><span class="p">,</span> <span class="n">ifraxis</span><span class="p">,</span> <span class="n">ifraxisgap</span><span class="p">,</span> <span class="n">increment</span><span class="p">,</span> <span class="n">average</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">putdata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">items</span><span class="o">=</span><span class="p">{</span> <span class="p">}):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function allows you to write values from casapy variables</span>
<span class="sd">        back into the measurement set table. The main difference between</span>
<span class="sd">        this and directly accessing the table using the table tool is</span>
<span class="sd">        that this function writes data to the selected measurement set.</span>
<span class="sd">        </span>
<span class="sd">        Unlike the getdata function, you can only put items that</span>
<span class="sd">        correspond to actual table columns. You cannot change the data</span>
<span class="sd">        shape either so that the number of correlations, channels and</span>
<span class="sd">        rows (or interferometers/time slots) must match the values in</span>
<span class="sd">        the selected measurement set. If the values were obtained using</span>
<span class="sd">        the getdata function with ifraxis argument set to True, then</span>
<span class="sd">        any default values added to fill in missing</span>
<span class="sd">        interferometer/timeslots pairs will be ignored when writing</span>
<span class="sd">        the modified values back using this function.</span>
<span class="sd">        </span>
<span class="sd">        Allowable items include:  &#39;data&#39;, &#39;corrected_data&#39;,</span>
<span class="sd">        &#39;model_data&#39;, &#39;flag&#39;, &#39;flag_row&#39;, &#39;sigma&#39;, and &#39;weight&#39;.</span>
<span class="sd">        &#39;float_data&#39; is currently not implemented for putdata.</span>
<span class="sd">        </span>
<span class="sd">        The measurement set has to be opened for read/write access</span>
<span class="sd">        (nomodify=False) to be able to use this function.</span>
<span class="sd">        </span>
<span class="sd">        You need to call selectinit before calling this function.</span>
<span class="sd">        If you haven&#39;t then selectinit will be called for you with</span>
<span class="sd">        default arguments.</span>
<span class="sd">        </span>
<span class="sd">        Items prefixed with corrected, model, residual or obs_residual</span>
<span class="sd">        are not available unless your measurement set has been processed</span>
<span class="sd">        either with the imager or calibrator tools.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">putdata</span><span class="p">(</span><span class="n">items</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">fromfits</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msfile</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">fitsfile</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">nomodify</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">lock</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">obstype</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">host</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">forcenewserver</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">antnamescheme</span><span class="o">=</span><span class="s1">&#39;old&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function will convert a uvfits file to a measurement set table</span>
<span class="sd">        and then open the measurement set table. The newly created</span>
<span class="sd">        measurement set table will continue to exist after the tool has</span>
<span class="sd">        been closed.</span>
<span class="sd">        </span>
<span class="sd">        Setting the lock argument to True will permanently lock the table</span>
<span class="sd">        preventing other processes from writing to the measurement set.</span>
<span class="sd">        Unless you expect this to happen, and want to prevent it, you</span>
<span class="sd">        should leave the lock argument at the default value which implies</span>
<span class="sd">        auto-locking.</span>
<span class="sd">        </span>
<span class="sd">        Note that the variety of fits files that fromfits is able to</span>
<span class="sd">        interpret correctly is limited mostly to files similar to those</span>
<span class="sd">        produced by classic AIPS. In particular, it understands only binary</span>
<span class="sd">        table extensions for the antenna (AN), frequency (FQ) and source</span>
<span class="sd">        (SU) information and ignores other extensions.</span>
<span class="sd">        </span>
<span class="sd">        This function returns True if it successfully attaches the ms tool</span>
<span class="sd">        to a newly created Measurement Set or False if something went</span>
<span class="sd">        wrong, like an error in a file name.</span>
<span class="sd">        </span>
<span class="sd">        NOTE ON WEIGHTS</span>
<span class="sd">        </span>
<span class="sd">        ms.fromfits() will generate a WEIGHT_SPECTRUM column in which it</span>
<span class="sd">        will fill the absolute value of the weight associated with each</span>
<span class="sd">        visibility in the uvfits file.  Negative weights will have the</span>
<span class="sd">        associated FLAGs set to True. It will compute the associated WEIGHT</span>
<span class="sd">        value for that MS row to be the sum of the absolute values of the</span>
<span class="sd">        associated WEIGHT_SPECTRUM values.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">fromfits</span><span class="p">(</span><span class="n">msfile</span><span class="p">,</span> <span class="n">fitsfile</span><span class="p">,</span> <span class="n">nomodify</span><span class="p">,</span> <span class="n">lock</span><span class="p">,</span> <span class="n">obstype</span><span class="p">,</span> <span class="n">host</span><span class="p">,</span> <span class="n">forcenewserver</span><span class="p">,</span> <span class="n">antnamescheme</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">fromfitsidi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msfile</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">fitsfile</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">nomodify</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">lock</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">obstype</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">0</span><span class="p">)):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function will convert a uvfits file to a measurement set table</span>
<span class="sd">        and then open the measurement set table. The newly created</span>
<span class="sd">        measurement set table will continue to exist after the tool has</span>
<span class="sd">        been closed.</span>
<span class="sd">        </span>
<span class="sd">        Setting the lock argument to True will permanently lock the table</span>
<span class="sd">        preventing other processes from writing to the measurement set.</span>
<span class="sd">        Unless you expect this to happen, and want to prevent it, you</span>
<span class="sd">        should leave the lock argument at the default value which implies</span>
<span class="sd">        auto-locking.</span>
<span class="sd">        </span>
<span class="sd">        Note that the variety of fits files that fromfits is able to</span>
<span class="sd">        interpret correctly is limited mostly to files similar to those</span>
<span class="sd">        produced by classic AIPS. In particular, it understands only binary</span>
<span class="sd">        table extensions for the antenna (AN), frequency (FQ) and source</span>
<span class="sd">        (SU) information and ignores other extensions.</span>
<span class="sd">        </span>
<span class="sd">        This function returns True if it successfully attachs the ms tool</span>
<span class="sd">        to a newly created Measurement Set or False if something went</span>
<span class="sd">        wrong, like an error in a file name.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">fromfitsidi</span><span class="p">(</span><span class="n">msfile</span><span class="p">,</span> <span class="n">fitsfile</span><span class="p">,</span> <span class="n">nomodify</span><span class="p">,</span> <span class="n">lock</span><span class="p">,</span> <span class="n">obstype</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">tofits</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fitsfile</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="s1">&#39;corrected&#39;</span><span class="p">,</span> <span class="n">field</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">spw</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">baseline</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">time</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">scan</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">uvrange</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">taql</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">writesyscal</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">multisource</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">combinespw</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">writestation</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">padwithflags</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function writes a uvfits file that contains the data in the</span>
<span class="sd">        measurement set associated with this tool. The fits file is always</span>
<span class="sd">        written in floating point format and the data are always stored in</span>
<span class="sd">        the primary array of the fits file.</span>
<span class="sd">        </span>
<span class="sd">        IMPORTANT NOTE: In general, some of the data averaging features of</span>
<span class="sd">        this method have never worked properly. In general, users should</span>
<span class="sd">        run mstransform to select and average data prior to running</span>
<span class="sd">        tofits(). The associated input parameters are slowly being</span>
<span class="sd">        deprecated and removed.</span>
<span class="sd">        </span>
<span class="sd">        If the measurement set has been imaged or calibrated in CASA, it</span>
<span class="sd">        may contain additional data columns. You need to select ONE of</span>
<span class="sd">        these columns to be written to the fits file. The possible</span>
<span class="sd">        options are:</span>
<span class="sd">        </span>
<span class="sd">        1. observed     This is the raw data as collected by the telescope. All</span>
<span class="sd">        interferometric measurement sets must contain this column.</span>
<span class="sd">        A synonym for &#39;observed&#39; is &#39;data&#39;.</span>
<span class="sd">        2. corrected    This is the calibrated data. A synonym for &#39;corrected&#39; is</span>
<span class="sd">        &#39;corrected_data&#39;.</span>
<span class="sd">        3. model        This is the visibilites that would be measured using</span>
<span class="sd">        the current model of the sky. A synonym for &#39;model&#39; is</span>
<span class="sd">        &#39;model_data&#39;.</span>
<span class="sd">        </span>
<span class="sd">        The parsing of these strings is case insensitive. If any other</span>
<span class="sd">        option is specified then the observed data will be written.</span>
<span class="sd">        </span>
<span class="sd">        By default a single-source uvfits file is written, but if the</span>
<span class="sd">        measurement set contains more than one field or if you set the</span>
<span class="sd">        multisource argument to True a multi-source uvfits file will be</span>
<span class="sd">        written. Because of limitations in the uvfits format you have to</span>
<span class="sd">        ensure that the data shape is fixed for all the data you intend to</span>
<span class="sd">        write to one fits file. See the general description of this tool</span>
<span class="sd">        for how you can select data to meet this condition.</span>
<span class="sd">        </span>
<span class="sd">        The combinespw argument is used to control whether data from</span>
<span class="sd">        different spectral windows will be written as different entries in</span>
<span class="sd">        the fits FQ (frequency) table or combined as different IF&#39;s</span>
<span class="sd">        within one entry in the FQ table. You should normally only set</span>
<span class="sd">        this to True if you know that the data from different spectral</span>
<span class="sd">        windows were observed simultaneously, and the data in the</span>
<span class="sd">        measurement set can be equally divided between all the spectral</span>
<span class="sd">        windows (i.e. each window should have the same width).  Use of</span>
<span class="sd">        this switch is recommended for data to be processed in classic</span>
<span class="sd">        AIPS and difmap (if possible, e.g., standard dual IF observations).</span>
<span class="sd">        </span>
<span class="sd">        The padwithflags argument is only relevant if combinespw is True.</span>
<span class="sd">        If true, it will fill in data that is &#39;missing&#39; with flags to fit</span>
<span class="sd">        the IF structure.  This is appropriate if the MS had a few</span>
<span class="sd">        frequency-dependent flags applied, and was then time-averaged by</span>
<span class="sd">        split.  If the spectral windows were observed at different times,</span>
<span class="sd">        padwithflags=True will add a large number of flags, making the</span>
<span class="sd">        output file significantly longer.  It does not yet support spectral</span>
<span class="sd">        windows with different widths.</span>
<span class="sd">        </span>
<span class="sd">        The fits GC (gain curve) and TY (system temperature) tables can</span>
<span class="sd">        be optionally written by setting the writesyscal argument to True.</span>
<span class="sd">        This is a rather WSRT-specific operation at the moment and may not</span>
<span class="sd">        work correctly for measurement sets from other telescopes.</span>
<span class="sd">        </span>
<span class="sd">        One may overwrite the specified output file if it exists by</span>
<span class="sd">        specifying overwrite=True.</span>
<span class="sd">        </span>
<span class="sd">        NOTE ON WEIGHTS</span>
<span class="sd">        </span>
<span class="sd">        If the MS has no WEIGHT_SPECTRUM column, or if it does, but that</span>
<span class="sd">        column does not contain any data, ms.tofits() will compute the</span>
<span class="sd">        associated weight it writes to the uvfits file by taking the</span>
<span class="sd">        associated WEIGHT column value in the MS and dividing it by the</span>
<span class="sd">        number of channels associated with the spectral window of that</span>
<span class="sd">        visibility.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">tofits</span><span class="p">(</span><span class="n">fitsfile</span><span class="p">,</span> <span class="n">column</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">spw</span><span class="p">,</span> <span class="n">baseline</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">scan</span><span class="p">,</span> <span class="n">uvrange</span><span class="p">,</span> <span class="n">taql</span><span class="p">,</span> <span class="n">writesyscal</span><span class="p">,</span> <span class="n">multisource</span><span class="p">,</span> <span class="n">combinespw</span><span class="p">,</span> <span class="n">writestation</span><span class="p">,</span> <span class="n">padwithflags</span><span class="p">,</span> <span class="n">overwrite</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">listfits</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fitsfile</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;List HDU and typical data rows in a uvfits file</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">listfits</span><span class="p">(</span><span class="n">fitsfile</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">asdmref</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">abspath</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;If the MS is imported from an ASDM  with option lazy=True, the DATA</span>
<span class="sd">        or FLOAT_DATA column of the MS is virtual and directly reads the</span>
<span class="sd">        visibilities from the ASDM. A reference to the original ASDM is</span>
<span class="sd">        stored with the MS. If the ASDM needs to be moved to a different</span>
<span class="sd">        path, the reference to it in the MS needs to be updated. This can</span>
<span class="sd">        be achieved with ms.asdmref().</span>
<span class="sd">        </span>
<span class="sd">        When called with an empty string (default), the method just reports</span>
<span class="sd">        the currently set ASDM path.</span>
<span class="sd">        </span>
<span class="sd">        Return value is a string containing the new path if the path was</span>
<span class="sd">        successfully set or (in the case abspath was empty) the MS indeed</span>
<span class="sd">        contains a ASDM reference, i.e. was lazily imported.</span>
<span class="sd">        </span>
<span class="sd">        If the ASDM does not contain an ASDM reference, the method returns</span>
<span class="sd">        an empty string. If abspath is not empty and there was an error</span>
<span class="sd">        setting the new reference, the method throws an exception.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">asdmref</span><span class="p">(</span><span class="n">abspath</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">concatenate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msfile</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">freqtol</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">dirtol</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">weightscale</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="mf">1.</span><span class="p">),</span> <span class="n">handling</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">destmsfile</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">respectname</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function concatenates two measurement sets together.</span>
<span class="sd">        </span>
<span class="sd">        The data is copied from the measurement set specified in the</span>
<span class="sd">        msfile arguement to the end of the measurement set attached to the</span>
<span class="sd">        ms tool. If a lot of data needs to be copied this function may</span>
<span class="sd">        take some time. You need to open the measurement set for writing</span>
<span class="sd">        in order to use this function.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">msfile</span><span class="p">,</span> <span class="n">freqtol</span><span class="p">,</span> <span class="n">dirtol</span><span class="p">,</span> <span class="n">weightscale</span><span class="p">,</span> <span class="n">handling</span><span class="p">,</span> <span class="n">destmsfile</span><span class="p">,</span> <span class="n">respectname</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">testconcatenate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msfile</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">freqtol</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">dirtol</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">respectname</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function acts like ms.concatenate() with handling==3 (do not</span>
<span class="sd">        concatenate the MAIN and POINTING tables). This is useful for</span>
<span class="sd">        generating, e.g., SPECTRAL_WINDOW and FIELD tables which contain</span>
<span class="sd">        all used SPW and FIELD ids for a set of MSs without having to</span>
<span class="sd">        actually carry out a time-consuming concatenation on disk. The MAIN</span>
<span class="sd">        table in the resulting output MS is that of the original MS, i.e.</span>
<span class="sd">        it is not touched.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">testconcatenate</span><span class="p">(</span><span class="n">msfile</span><span class="p">,</span> <span class="n">freqtol</span><span class="p">,</span> <span class="n">dirtol</span><span class="p">,</span> <span class="n">respectname</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">virtconcatenate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msfile</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">auxfilename</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">freqtol</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">dirtol</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">weightscale</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="mf">1.</span><span class="p">),</span> <span class="n">respectname</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function virtually concatenates two measurement sets together</span>
<span class="sd">        such that they can later be turned into a multi-MS with</span>
<span class="sd">        createmultims().</span>
<span class="sd">        </span>
<span class="sd">        You need to open the measurement set for writing in order to use</span>
<span class="sd">        this function.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">virtconcatenate</span><span class="p">(</span><span class="n">msfile</span><span class="p">,</span> <span class="n">auxfilename</span><span class="p">,</span> <span class="n">freqtol</span><span class="p">,</span> <span class="n">dirtol</span><span class="p">,</span> <span class="n">weightscale</span><span class="p">,</span> <span class="n">respectname</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">createmultims</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outputTableName</span><span class="p">,</span> <span class="n">tables</span><span class="p">,</span> <span class="n">subtables</span><span class="p">,</span> <span class="n">nomodify</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">lock</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">copysubtables</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">omitsubtables</span><span class="o">=</span><span class="p">[</span>  <span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">createmultims</span><span class="p">(</span><span class="n">outputTableName</span><span class="p">,</span> <span class="n">tables</span><span class="p">,</span> <span class="n">subtables</span><span class="p">,</span> <span class="n">nomodify</span><span class="p">,</span> <span class="n">lock</span><span class="p">,</span> <span class="n">copysubtables</span><span class="p">,</span> <span class="n">omitsubtables</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ismultims</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">ismultims</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">split</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outputms</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">field</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">spw</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">step</span><span class="o">=</span><span class="p">[</span> <span class="nb">int</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">],</span> <span class="n">baseline</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">timebin</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">time</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">scan</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">uvrange</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">taql</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">whichcol</span><span class="o">=</span><span class="s1">&#39;DATA&#39;</span><span class="p">,</span> <span class="n">tileshape</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">subarray</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">combine</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">correlation</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">intent</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">obs</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function splits out part of the MS into a new MS. Time and</span>
<span class="sd">        channel averaging can be performed in the process (but not in</span>
<span class="sd">        the same call).</span>
<span class="sd">        </span>
<span class="sd">        When splitting multiple spectral windows, the parameters nchan,</span>
<span class="sd">        start, and step can be vectors, so that each spectral window has</span>
<span class="sd">        its own selection on averaging and number of output channels. But</span>
<span class="sd">        the option of using only one value for each of these parameters</span>
<span class="sd">        means that it will be replicated for all the spectral windows</span>
<span class="sd">        selected.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">outputms</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">spw</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span> <span class="n">baseline</span><span class="p">,</span> <span class="n">timebin</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">scan</span><span class="p">,</span> <span class="n">uvrange</span><span class="p">,</span> <span class="n">taql</span><span class="p">,</span> <span class="n">whichcol</span><span class="p">,</span> <span class="n">tileshape</span><span class="p">,</span> <span class="n">subarray</span><span class="p">,</span> <span class="n">combine</span><span class="p">,</span> <span class="n">correlation</span><span class="p">,</span> <span class="n">intent</span><span class="p">,</span> <span class="n">obs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">partition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outputms</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">field</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">spw</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">baseline</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">timebin</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">time</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">scan</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">uvrange</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">taql</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">whichcol</span><span class="o">=</span><span class="s1">&#39;DATA&#39;</span><span class="p">,</span> <span class="n">tileshape</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">subarray</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">combine</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">intent</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">obs</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function splits out part of the MS into a new MS. Time</span>
<span class="sd">        averaging can be performed in the process.  Unlike split, the</span>
<span class="sd">        subtables and IDs (ANTENNA1, DATA_DESCRIPTION_ID, etc.) are never</span>
<span class="sd">        changed to account for the selection.</span>
<span class="sd">        </span>
<span class="sd">        As a side effect of that property, partition cannot select by</span>
<span class="sd">        channel or correlation, or average channels.  It CAN select by</span>
<span class="sd">        spectral window(s).</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="n">outputms</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">spw</span><span class="p">,</span> <span class="n">baseline</span><span class="p">,</span> <span class="n">timebin</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">scan</span><span class="p">,</span> <span class="n">uvrange</span><span class="p">,</span> <span class="n">taql</span><span class="p">,</span> <span class="n">whichcol</span><span class="p">,</span> <span class="n">tileshape</span><span class="p">,</span> <span class="n">subarray</span><span class="p">,</span> <span class="n">combine</span><span class="p">,</span> <span class="n">intent</span><span class="p">,</span> <span class="n">obs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">summary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">listfile</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">listunfl</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">cachesize</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="mi">50</span><span class="p">),</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">wantreturn</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This method will print a summary of the measurement set to the</span>
<span class="sd">        system logger. The verbose argument provides some control on how</span>
<span class="sd">        much information is displayed.</span>
<span class="sd">        </span>
<span class="sd">        For especially large datasets, the cachesize parameter can be</span>
<span class="sd">        increased for possibly better performance.</span>
<span class="sd">        </span>
<span class="sd">        This method can also return, in the header argument, a record</span>
<span class="sd">        containing the following fields:</span>
<span class="sd">        1. nrow     Number of rows in the measurement set</span>
<span class="sd">        2. name     Name of the measurement set</span>
<span class="sd">        </span>
<span class="sd">        DESCRIPTION OF ALGORITHM TO CALCULATE THE NUMBER OF UNFLAGGED ROWS</span>
<span class="sd">        </span>
<span class="sd">        The number of unflagged rows will only be computed if listunflis</span>
<span class="sd">        True. The number of unflagged rows (the nUnflRows columns in the</span>
<span class="sd">        scans and fields portions of the listing) is calculated by summing</span>
<span class="sd">        the fractional unflagged bandwidth for each row (and hence why the</span>
<span class="sd">        number of unflagged rows, in general, is not an integer). Thus a</span>
<span class="sd">        row which has half of its total bandwidth flagged contributes 0.5</span>
<span class="sd">        rows to the unflagged row count. A row with 20 of 32 channels of</span>
<span class="sd">        homogeneous width contributes 20/32 = 0.625 rows to the unflagged</span>
<span class="sd">        row count. A row with a value of False in the FLAG_ROW column is</span>
<span class="sd">        not counted in the number of unflagged rows.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">summary</span><span class="p">(</span><span class="n">verbose</span><span class="p">,</span> <span class="n">listfile</span><span class="p">,</span> <span class="n">listunfl</span><span class="p">,</span> <span class="n">cachesize</span><span class="p">,</span> <span class="n">overwrite</span><span class="p">,</span> <span class="n">wantreturn</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">getscansummary</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function will return a summary of the main table as a</span>
<span class="sd">        structure</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">getscansummary</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">getspectralwindowinfo</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This method will get a summary of the spectral window actually</span>
<span class="sd">        used in this ms. To be precise those reference by the data</span>
<span class="sd">        description table.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">getspectralwindowinfo</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">getreferencedtables</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">getreferencedtables</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">getfielddirmeas</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dircolname</span><span class="o">=</span><span class="s1">&#39;PHASE_DIR&#39;</span><span class="p">,</span> <span class="n">fieldid</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">time</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;measure&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function returns the direction measures from the given</span>
<span class="sd">        direction column of the MS FIELD table as a either a measure</span>
<span class="sd">        dictionary or sexigesimal string representation.</span>
<span class="sd">        If there is an ephemeris attached, this will give you the time dependent</span>
<span class="sd">        direction for the given direction column including the offset which each</span>
<span class="sd">        field may have to the ephemeris it is referencing. You can use the value</span>
<span class="sd">        &quot;EPHEMERIS_DIR&quot; for parameter &quot;dircolname&quot; to access the unaltered ephemeris</span>
<span class="sd">        direction without any potential mosaic offsets.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">getfielddirmeas</span><span class="p">(</span><span class="n">dircolname</span><span class="p">,</span> <span class="n">fieldid</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="nb">format</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">listhistory</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function lists the contents of the measurement set history</span>
<span class="sd">        table.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">listhistory</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">writehistory</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">parms</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="s1">&#39;MSHistoryHandler::addMessage()&#39;</span><span class="p">,</span> <span class="n">msname</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">app</span><span class="o">=</span><span class="s1">&#39;ms&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function adds a row to the history table of the specified</span>
<span class="sd">        measurement set containing any message that the user wishes to</span>
<span class="sd">        record.  By default the history entry is written to the history</span>
<span class="sd">        table of the measurement set that is currently open, the message</span>
<span class="sd">        origin is recorded as &#39;MSHistoryHandler::addMessage()&#39;, the</span>
<span class="sd">        originating application is &#39;ms&#39; and the input parameters field is</span>
<span class="sd">        empty.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">writehistory</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">parms</span><span class="p">,</span> <span class="n">origin</span><span class="p">,</span> <span class="n">msname</span><span class="p">,</span> <span class="n">app</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">writehistory_batch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">messages</span><span class="o">=</span><span class="p">[</span>  <span class="p">],</span> <span class="n">parms</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="s1">&#39;MSHistoryHandler::addMessage()&#39;</span><span class="p">,</span> <span class="n">msname</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">app</span><span class="o">=</span><span class="s1">&#39;ms&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function works as writehistory but adds a list of messages to</span>
<span class="sd">        the history table, instead of a single message. Each message is written</span>
<span class="sd">        into in a new row. It is recommended for efficiency, as adding rows one</span>
<span class="sd">        at a time can be rather slow, causing for example a delay of the order</span>
<span class="sd">        of 10-30 seconds when writing the history at the end of a normal flagdata</span>
<span class="sd">        command (with 70+ parameter rows).</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">writehistory_batch</span><span class="p">(</span><span class="n">messages</span><span class="p">,</span> <span class="n">parms</span><span class="p">,</span> <span class="n">origin</span><span class="p">,</span> <span class="n">msname</span><span class="p">,</span> <span class="n">app</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">statistics</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">complex_value</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">useflags</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">useweights</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">spw</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">field</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">baseline</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">uvrange</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">correlation</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">scan</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">intent</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">array</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">obs</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">reportingaxes</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">timeaverage</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">timebin</span><span class="o">=</span><span class="s1">&#39;0s&#39;</span><span class="p">,</span> <span class="n">timespan</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">maxuvwdistance</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="mf">0.0</span><span class="p">),</span> <span class="n">doquantiles</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function computes descriptive statistics on the measurement</span>
<span class="sd">        set. It returns the statistical values as a python dictionary.  The</span>
<span class="sd">        given column name must be a numerical column. If it is a complex</span>
<span class="sd">        valued column, the parameter complex_value defines which derived</span>
<span class="sd">        real value is used for the statistics computation.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">statistics</span><span class="p">(</span><span class="n">column</span><span class="p">,</span> <span class="n">complex_value</span><span class="p">,</span> <span class="n">useflags</span><span class="p">,</span> <span class="n">useweights</span><span class="p">,</span> <span class="n">spw</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">baseline</span><span class="p">,</span> <span class="n">uvrange</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">correlation</span><span class="p">,</span> <span class="n">scan</span><span class="p">,</span> <span class="n">intent</span><span class="p">,</span> <span class="n">array</span><span class="p">,</span> <span class="n">obs</span><span class="p">,</span> <span class="n">reportingaxes</span><span class="p">,</span> <span class="n">timeaverage</span><span class="p">,</span> <span class="n">timebin</span><span class="p">,</span> <span class="n">timespan</span><span class="p">,</span> <span class="n">maxuvwdistance</span><span class="p">,</span> <span class="n">doquantiles</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">statisticsold</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">complex_value</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">useflags</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">spw</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">field</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">baseline</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">uvrange</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">correlation</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">scan</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">array</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">obs</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;DEPRECATED: Please use the ms::statistics() function in place of</span>
<span class="sd">        ms::statisticsold().</span>
<span class="sd">        </span>
<span class="sd">        This function computes descriptive statistics on the measurement</span>
<span class="sd">        set. It returns the statistical values as a python dictionary.  The</span>
<span class="sd">        given column name must be a numerical column. If it is a complex</span>
<span class="sd">        valued column, the parameter complex_value defines which derived</span>
<span class="sd">        real value is used for the statistics computation.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">statisticsold</span><span class="p">(</span><span class="n">column</span><span class="p">,</span> <span class="n">complex_value</span><span class="p">,</span> <span class="n">useflags</span><span class="p">,</span> <span class="n">spw</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">baseline</span><span class="p">,</span> <span class="n">uvrange</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">correlation</span><span class="p">,</span> <span class="n">scan</span><span class="p">,</span> <span class="n">array</span><span class="p">,</span> <span class="n">obs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">range</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">items</span><span class="o">=</span><span class="p">[</span>  <span class="p">],</span> <span class="n">useflags</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">blocksize</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">10</span><span class="p">)):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function returns the range of values in the currently</span>
<span class="sd">        selected measurement set for the items specified.</span>
<span class="sd">        </span>
<span class="sd">        Possible items include &#39;amplitude&#39;, &#39;corrected_amplitude&#39;,</span>
<span class="sd">        &#39;model_amplitude&#39;, &#39;antenna1&#39;, &#39;antenna2&#39;, &#39;antennas&#39;,</span>
<span class="sd">        &#39;array_id&#39;, &#39;chan_freq&#39;, &#39;corr_names&#39;, &#39;corr_types&#39;, &#39;feed1&#39;,</span>
<span class="sd">        &#39;feed2&#39;, &#39;field_id&#39;, &#39;fields&#39;, &#39;float_data&#39;, &#39;ifr_number&#39;</span>
<span class="sd">        (1000*antenna1 + antenna2), &#39;imaginary&#39;, &#39;corrected_imaginary&#39;,</span>
<span class="sd">        &#39;model_imaginary&#39;, &#39;num_corr&#39;, &#39;num_chan&#39;, &#39;phase&#39;,</span>
<span class="sd">        &#39;corrected_phase&#39;, &#39;model_phase&#39;, &#39;phase_dir&#39;, &#39;real&#39;,</span>
<span class="sd">        &#39;corrected_real&#39;, &#39;model_real&#39;, &#39;ref_frequency&#39;, &#39;rows&#39;,</span>
<span class="sd">        &#39;scan_number&#39;, &#39;sigma&#39;, &#39;data_desc_id&#39;, &#39;time&#39;, &#39;times&#39;, &#39;u&#39;,</span>
<span class="sd">        &#39;v&#39;, &#39;w&#39;, &#39;uvdist&#39;, and &#39;weight&#39;.  Note that corrected, model,</span>
<span class="sd">        and float versions are available only if these columns are</span>
<span class="sd">        present in the data.</span>
<span class="sd">        </span>
<span class="sd">        You specify items in which you are interested using a string</span>
<span class="sd">        vector where each element is a case insensitive item name.  This</span>
<span class="sd">        function will then return a record that has fields corresponding</span>
<span class="sd">        to each of the specified items. Each field will contain the</span>
<span class="sd">        range of the specified item. For many items the range will be</span>
<span class="sd">        the minimum and maximum values but for some it will be a list of</span>
<span class="sd">        unique values. Unrecognized items are ignored.</span>
<span class="sd">        </span>
<span class="sd">        By default the FLAG column is used to exclude flagged data</span>
<span class="sd">        before any ranges are determined, but you can set useflags=False</span>
<span class="sd">        to include flagged data in the range.  However, if you average</span>
<span class="sd">        in frequency, flagging will still be applied.</span>
<span class="sd">        </span>
<span class="sd">        You can influence the memory use and the reading speed using</span>
<span class="sd">        the blocksize argument - it specifies how big a block of data</span>
<span class="sd">        to read at once (in MB). For large datasets on machines with</span>
<span class="sd">        lots of memory you may speed things up by setting this higher</span>
<span class="sd">        than the default (10 MB).</span>
<span class="sd">        </span>
<span class="sd">        For some items, you need to call selectinit to select a portion</span>
<span class="sd">        of the data with a unique shape prior to calling this function.</span>
<span class="sd">        </span>
<span class="sd">        Items prefixed with corrected, model, residual or obs_residual</span>
<span class="sd">        are not available unless your measurement set has been processed</span>
<span class="sd">        either with the imager or calibrator tools.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="n">items</span><span class="p">,</span> <span class="n">useflags</span><span class="p">,</span> <span class="n">blocksize</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">lister</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">datacolumn</span><span class="o">=</span><span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="n">field</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">spw</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">antenna</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">timerange</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">correlation</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">scan</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">feed</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">array</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">observation</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">uvrange</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">average</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">showflags</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">msselect</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">pagerows</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">50</span><span class="p">),</span> <span class="n">listfile</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This tool lists measurement set visibility data under a number of</span>
<span class="sd">        input selection conditions.  The measurement set data columns that</span>
<span class="sd">        can be listed are: the raw data, corrected data, model data, and</span>
<span class="sd">        residual (corrected - model) data.</span>
<span class="sd">        </span>
<span class="sd">        The output table format is dynamic.  Field, Spectral Window, and</span>
<span class="sd">        Channel columns are not displayed if the column contents are</span>
<span class="sd">        uniform. For example, if ``spw = `1&#39; &#39;&#39; is specified, the spw</span>
<span class="sd">        column will not be displayed.  When a column is not displayed, a</span>
<span class="sd">        message is sent to the logger and terminal indicating that the</span>
<span class="sd">        column values are uniform and listing the uniform value.</span>
<span class="sd">        </span>
<span class="sd">        Table column descriptions:</span>
<span class="sd">        </span>
<span class="sd">        Date/Time               Average date and time of data sample interval</span>
<span class="sd">        Intrf                   Interferometer baseline (antenna names)</span>
<span class="sd">        UVDist                  uv-distance (units of wavelength)</span>
<span class="sd">        Fld                     Field ID</span>
<span class="sd">        SpW                     Spectral Window ID</span>
<span class="sd">        Chn                     Channel number</span>
<span class="sd">        Correlated polarization Correlated polarizations (eg: RR, LL, XY)</span>
<span class="sd">        </span>
<span class="sd">        Sub-columns:</span>
<span class="sd">        </span>
<span class="sd">        Amp                     Visibility amplitude</span>
<span class="sd">        Phs                     Visibility phase</span>
<span class="sd">        Wt                      Weight of visibility measurement</span>
<span class="sd">        F                       Flag: `F&#39; = flagged datum; ` &#39; = unflagged</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">lister</span><span class="p">(</span><span class="n">options</span><span class="p">,</span> <span class="n">datacolumn</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">spw</span><span class="p">,</span> <span class="n">antenna</span><span class="p">,</span> <span class="n">timerange</span><span class="p">,</span> <span class="n">correlation</span><span class="p">,</span> <span class="n">scan</span><span class="p">,</span> <span class="n">feed</span><span class="p">,</span> <span class="n">array</span><span class="p">,</span> <span class="n">observation</span><span class="p">,</span> <span class="n">uvrange</span><span class="p">,</span> <span class="n">average</span><span class="p">,</span> <span class="n">showflags</span><span class="p">,</span> <span class="n">msselect</span><span class="p">,</span> <span class="n">pagerows</span><span class="p">,</span> <span class="n">listfile</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">metadata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cachesize</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="mi">50</span><span class="p">)):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the MS metadata associated with this MS.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_wrap_msmetadata</span><span class="p">(</span><span class="n">swig_object</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">metadata</span><span class="p">(</span><span class="n">cachesize</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">msselect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">items</span><span class="o">=</span><span class="p">{</span> <span class="p">},</span> <span class="n">onlyparse</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A return value of True implies that the combination of all</span>
<span class="sd">        selection expressions resulted in a non-Null combined TaQL</span>
<span class="sd">        expression. False implies that the combined TaQL could not be</span>
<span class="sd">        formed (i.e. it is Null, and the &quot;selected MS&quot; will be the same as</span>
<span class="sd">        the input MS).</span>
<span class="sd">        </span>
<span class="sd">        The details of selection expressions are desribed in the</span>
<span class="sd">        MSSelection Memo.</span>
<span class="sd">        </span>
<span class="sd">        Note that this function can be called multiple times but the</span>
<span class="sd">        result is cumulative.  Each selection will work on the data</span>
<span class="sd">        already selected from all previous calls of this function.  Use</span>
<span class="sd">        the function reset() to reset all selections to NULL (original</span>
<span class="sd">        dataset).</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">msselect</span><span class="p">(</span><span class="n">items</span><span class="p">,</span> <span class="n">onlyparse</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">msselectedindices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The return indices are the result of parsing the MSSelection</span>
<span class="sd">        expressions provided in the msselect function.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">msselectedindices</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">msseltoindex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vis</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">spw</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">field</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">baseline</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">time</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">scan</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">uvrange</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">observation</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">polarization</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">taql</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Utility function that will return the ids of the selection used.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">msseltoindex</span><span class="p">(</span><span class="n">vis</span><span class="p">,</span> <span class="n">spw</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">baseline</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">scan</span><span class="p">,</span> <span class="n">uvrange</span><span class="p">,</span> <span class="n">observation</span><span class="p">,</span> <span class="n">polarization</span><span class="p">,</span> <span class="n">taql</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">selectinit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">datadescid</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">reset</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A measurement set can contain data with a variety of different</span>
<span class="sd">        shapes (as described in the overall description to this tool).  To</span>
<span class="sd">        allow functions to return data in fixed shape arrays you need to</span>
<span class="sd">        select, using this function, rows that contain the same data shape.</span>
<span class="sd">        You do not need to use this function if all the data in your</span>
<span class="sd">        measurement set has only one shape.</span>
<span class="sd">        </span>
<span class="sd">        The DATA_DESC_ID column in the measurement set contains a value</span>
<span class="sd">        that maps to a particular row in the POLARIZATION and</span>
<span class="sd">        SPECTRAL_WINDOW subtables. Hence all rows with the same value in</span>
<span class="sd">        the DATA_DESC_ID column must have the same data shape. To select</span>
<span class="sd">        all the data where the DATA_DESC_ID value is N you call this</span>
<span class="sd">        function with the datadescid argument set to N.</span>
<span class="sd">        </span>
<span class="sd">        It is possible to have a measurement set with differing values in</span>
<span class="sd">        the DATA_DESC_ID column but where all the data is a fixed shape.</span>
<span class="sd">        For example this will occur if the reference frequency changes but</span>
<span class="sd">        the number of spectral channels is fixed. In cases like this all</span>
<span class="sd">        the data can be selected and this function does not need to be</span>
<span class="sd">        used.</span>
<span class="sd">        </span>
<span class="sd">        To return to the completely unselected measurement set, set the</span>
<span class="sd">        reset argument to True. This will allow you to access the full</span>
<span class="sd">        range of rows in the measurement set, rather than just the</span>
<span class="sd">        selected measurement set.</span>
<span class="sd">        </span>
<span class="sd">        The datadescid must always be a non-negative integer.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">selectinit</span><span class="p">(</span><span class="n">datadescid</span><span class="p">,</span> <span class="n">reset</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">select</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">items</span><span class="o">=</span><span class="p">{</span> <span class="p">}):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function will select a subset of the current measurement set</span>
<span class="sd">        based on the range of values for each field in the input record.</span>
<span class="sd">        The range function will return a record that can be altered and</span>
<span class="sd">        used as the argument for this function.  A successful selection</span>
<span class="sd">        returns True. Unrecognized fields are ignored.</span>
<span class="sd">        </span>
<span class="sd">        Allowable items for select include: &#39;antenna1&#39;, &#39;antenna2&#39;,</span>
<span class="sd">        &#39;array_id&#39;, &#39;feed1&#39;, &#39;feed2&#39;, &#39;field_id&#39;, &#39;ifr_number&#39;, &#39;rows&#39;,</span>
<span class="sd">        &#39;scan_number&#39;, &#39;data_desc_id&#39;, &#39;time&#39;, &#39;times&#39;, &#39;u&#39;, &#39;v&#39;, &#39;w&#39;,</span>
<span class="sd">        and &#39;uvdist&#39;.</span>
<span class="sd">        </span>
<span class="sd">        You need to call selectinit before</span>
<span class="sd">        calling this function. If you haven&#39;t then selectinit will be</span>
<span class="sd">        called for you with default arguments.</span>
<span class="sd">        </span>
<span class="sd">        Repeated use of this function, with different arguments, will</span>
<span class="sd">        further refine the selection, resulting in a successively smaller</span>
<span class="sd">        selected measurement set. If the selected measurement set does not</span>
<span class="sd">        contain any rows then this function will return False and send a</span>
<span class="sd">        warning message in the logger. Otherwise this function will return</span>
<span class="sd">        True. To undo all the selections you need to use the selectinit</span>
<span class="sd">        function (with reset=True).</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">items</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">selecttaql</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msselect</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function will select a subset of the current measurement set</span>
<span class="sd">        based on the standard TaQL selection string given.</span>
<span class="sd">        </span>
<span class="sd">        Repeated use of this function, with different arguments, will</span>
<span class="sd">        further refine the selection, resulting in a successively smaller</span>
<span class="sd">        selected measurement set. If the selected measurement set does not</span>
<span class="sd">        contain any rows then this function will return False and send a</span>
<span class="sd">        warning message in the logger. Otherwise this function will return</span>
<span class="sd">        True. To undo all the selections you need to use the selectinit</span>
<span class="sd">        function (with reset=True).  Note that index values used in the</span>
<span class="sd">        TaQL string are zero-based as are all tool indices.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">selecttaql</span><span class="p">(</span><span class="n">msselect</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">selectchannel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nchan</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">start</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">width</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">inc</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">1</span><span class="p">)):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function allows you to select a subset of the frequency</span>
<span class="sd">        channels in the current measurement set.  This function can also</span>
<span class="sd">        average, over frequency channels, prior to providing the values to</span>
<span class="sd">        the user.</span>
<span class="sd">        </span>
<span class="sd">        Selection on channels is not allowed using either the select or</span>
<span class="sd">        command functions, as they can only select entire rows in a</span>
<span class="sd">        measurement set. Channel selection involves accessing only some of</span>
<span class="sd">        the values in a row. Like all the selection functions, this</span>
<span class="sd">        function does not change the current measurement but updates the</span>
<span class="sd">        measurement set selection parameters so that functions like</span>
<span class="sd">        getdata will return the desired subset of the data.  Repeated use</span>
<span class="sd">        of this function will overwrite any previous channel selection.</span>
<span class="sd">        </span>
<span class="sd">        There are four parameters, the number of output channels, the</span>
<span class="sd">        first input channel to use, the number of input channels to</span>
<span class="sd">        average into one output channel, and the increment in the input</span>
<span class="sd">        spectrum for the next output channel. All four parameters need to</span>
<span class="sd">        be specified.</span>
<span class="sd">        </span>
<span class="sd">        When all data to be averaged is unflagged, the result is the</span>
<span class="sd">        averaged value and the corresponding flag is False.  When all data</span>
<span class="sd">        is flagged, the result is set to zero and the corresponding flag is</span>
<span class="sd">        True.  When data to be averaged is mixed (unflagged and flagged),</span>
<span class="sd">        only the unflagged values are averaged and the flag is set to</span>
<span class="sd">        False.</span>
<span class="sd">        </span>
<span class="sd">        This function return True if the selection was successful, and</span>
<span class="sd">        False if not. In the latter case an error message will also be sent</span>
<span class="sd">        to the logger.</span>
<span class="sd">        </span>
<span class="sd">        You need to call selectinit before calling this function.</span>
<span class="sd">        If you haven&#39;t then selectinit will be called for you with default</span>
<span class="sd">        arguments.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">selectchannel</span><span class="p">(</span><span class="n">nchan</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">inc</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">selectpolarization</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wantedpol</span><span class="o">=</span><span class="p">[</span>  <span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function allows you to select a subset of the polarizations</span>
<span class="sd">        in the current measurement set.  This function can also setup</span>
<span class="sd">        conversion to different polarization representations.</span>
<span class="sd">        </span>
<span class="sd">        You specify the polarizations using a string vector. Allowable</span>
<span class="sd">        strings are include I, Q, U, V, RR, RL, LR, LL, XX, YY, XY,</span>
<span class="sd">        YX. These string must be specified in upper case. If the</span>
<span class="sd">        polarizations match those present in the measurement set they will</span>
<span class="sd">        be selected directly, otherwise all polarizations are read and</span>
<span class="sd">        then a conversion step is done. If the conversion cannot be done</span>
<span class="sd">        then an error will be produced when you try to access the data.</span>
<span class="sd">        </span>
<span class="sd">        This function return True if the selection was successful, and</span>
<span class="sd">        False if not.</span>
<span class="sd">        </span>
<span class="sd">        You need to call selectinit before calling this function.</span>
<span class="sd">        If you haven&#39;t then selectinit will be called for you with default</span>
<span class="sd">        arguments.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">selectpolarization</span><span class="p">(</span><span class="n">wantedpol</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">statwt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">combine</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">timebin</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">slidetimebin</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">chanbin</span><span class="o">=</span><span class="s1">&#39;spw&#39;</span><span class="p">,</span> <span class="n">minsamp</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">statalg</span><span class="o">=</span><span class="s1">&#39;classic&#39;</span><span class="p">,</span> <span class="n">fence</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">center</span><span class="o">=</span><span class="s1">&#39;mean&#39;</span><span class="p">,</span> <span class="n">lside</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">zscore</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">maxiter</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">fitspw</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">excludechans</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">wtrange</span><span class="o">=</span><span class="p">[</span>  <span class="p">],</span> <span class="n">preview</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">datacolumn</span><span class="o">=</span><span class="s1">&#39;corrected&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;IF NOT RUN IN PREVIEW MODE, THIS APPLICATION WILL MODIFY THE</span>
<span class="sd">        WEIGHT, WEIGHT SPECTRUM, FLAG, AND FLAG_ROW COLUMNS OF THE INPUT</span>
<span class="sd">        MS. IF YOU WANT A PRISTINE COPY OF THE INPUT MS TO BE PRESERVED,</span>
<span class="sd">        YOU SHOULD MAKE A COPY OF IT BEFORE RUNNING THIS APPLICATION.</span>
<span class="sd">        </span>
<span class="sd">        This application computes weights for the WEIGHT and</span>
<span class="sd">        WEIGHT_SPECTRUM (if present) columns based on the variance of</span>
<span class="sd">        values in the CORRECTED_DATA or DATA column. If the MS does not</span>
<span class="sd">        have the specified data column, the application will fail. The</span>
<span class="sd">        following algorithm is used:</span>
<span class="sd">        </span>
<span class="sd">        1. For unflagged data in each sample, create two sets of values,</span>
<span class="sd">        one set is composed solely of the real part of the data values,</span>
<span class="sd">        the other set is composed solely of the imaginary part of the</span>
<span class="sd">        data values.</span>
<span class="sd">        2. Compute the weighted (by exposure time) variance of each of</span>
<span class="sd">        these sets, v_r and v_i. The weighted variance per unit</span>
<span class="sd">        inverse eposure time, v, is computed using</span>
<span class="sd">        </span>
<span class="sd">        v = sum(e_i * (V_i - &lt;V&gt;)^2)/N,</span>
<span class="sd">        </span>
<span class="sd">        where e_i is the exposure time for real/imaginary part of</span>
<span class="sd">        visibility V_i and</span>
<span class="sd">        </span>
<span class="sd">        &lt;V&gt; = sum(e_i * V_i)/sum(e_i)</span>
<span class="sd">        </span>
<span class="sd">        is the weighted mean of all the visibilities in the set, and N</span>
<span class="sd">        is the number of (unflagged) visibilities.</span>
<span class="sd">        3. Compute v_eq = (v_r + v_i)/2.</span>
<span class="sd">        4. Compute the normalized variance, v_norm = v_eq * &lt;e&gt;, where</span>
<span class="sd">        </span>
<span class="sd">        &lt;e&gt; = sum(e_i)/N</span>
<span class="sd">        </span>
<span class="sd">        is the mean of the exposure times. The associated weight of</span>
<span class="sd">        visibility V_i is e_i/v_eq. The weight will have unit of (data</span>
<span class="sd">        unit)^(-2), e.g., Jy^(-2). The visibility weights are what this</span>
<span class="sd">        application computes and writes.</span>
<span class="sd">        </span>
<span class="sd">        Data are aggregated on a per-baseline, per-data description ID</span>
<span class="sd">        basis. Data are aggregated in bins determined by the specified</span>
<span class="sd">        values of the timebin and chanbin parameters. By default, data for</span>
<span class="sd">        separate correlations are aggregated separately. This behavior can</span>
<span class="sd">        be overridden by specifying combine=&quot;corr&quot; (see below).</span>
<span class="sd">        </span>
<span class="sd">        RULES REGARDING CREATING/INITIALIZING WEIGHT_SPECTRUM COLUMN</span>
<span class="sd">        </span>
<span class="sd">        1. If run in preview mode (preview=True), no data are modified and</span>
<span class="sd">        no columns are added.</span>
<span class="sd">        2. Else if datacolumn equals &#39;residual&#39; or &#39;residual_data&#39; and</span>
<span class="sd">        a CORRECTED_DATA column exists, the WEIGHT and WEIGHT_SPECTRUM</span>
<span class="sd">        columns are not modified.</span>
<span class="sd">        3. Else if the MS already has a WEIGHT_SPECTRUM and this column has</span>
<span class="sd">        been initialized (has values), it will be populated with</span>
<span class="sd">        the new weights.  The WEIGHT column will be populated with the</span>
<span class="sd">        corresponding median values of the associated WEIGHT_SPECTRUM</span>
<span class="sd">        array.</span>
<span class="sd">        4. Else if the frequency range specified for the sample is not the</span>
<span class="sd">        default (&quot;spw&quot;), the WEIGHT_SPECTRUM column will be created (if</span>
<span class="sd">        it doesn&#39;t already exist) and the new weights will be written to</span>
<span class="sd">        it.  The WEIGHT column should be populated with the</span>
<span class="sd">        corresponding median values of the WEIGHT_SPECTRUM array.</span>
<span class="sd">        5. Otherwise the single value for each spectral window will be</span>
<span class="sd">        written to the WEIGHT column; the WEIGHT_SPECTRUM column will</span>
<span class="sd">        not be added if it doesn&#39;t already exist, and if it does, it</span>
<span class="sd">        will remain uninitialized (no values will be written to it).</span>
<span class="sd">        </span>
<span class="sd">        In cases where columns are added and initialized, the</span>
<span class="sd">        WEIGHT_SPECTRUM values will be set equal to the corresponding</span>
<span class="sd">        WEIGHT values, and the SIGMA_SPECTRUM values will be set to the</span>
<span class="sd">        corresponding SIGMA values.</span>
<span class="sd">        </span>
<span class="sd">        CAUTION: For some cases when only a subset of data is selected</span>
<span class="sd">        and the WEIGHT_SPECTRUM and/or SIGMA_SPECTRUM columns are created,</span>
<span class="sd">        there is a known code issue in which these columns are not properly</span>
<span class="sd">        created and initialized for the specified subset of data, although</span>
<span class="sd">        they are properly initialized for the entire dataset. In such cases,</span>
<span class="sd">        an exception will be thrown. Because the columns are created for the</span>
<span class="sd">        entire dataset, the user simply needs to rerun the statwt task using</span>
<span class="sd">        the same parameters and the task should complete as expected. Should</span>
<span class="sd">        this condition occur when the user is using the ms.statwt() tool</span>
<span class="sd">        method, the user should close the ms tool, and then reopen it using</span>
<span class="sd">        the same data set and configure the same selection, and rerun</span>
<span class="sd">        ms.statwt(). The tool method should then complete as expected.</span>
<span class="sd">        </span>
<span class="sd">        RULES FOR MODIFYING WEIGHT, WEIGHT_SPECTRUM, SIGMA, and SIGMA_SPECTRUM</span>
<span class="sd">        </span>
<span class="sd">        1. If datacolum=&#39;corrected&#39; or &#39;residual&#39; then values are written</span>
<span class="sd">        to the WEIGHT and WEIGHT_SPECTRUM (if applicable) columns only.</span>
<span class="sd">        2. If datacolumn=&#39;data&#39; or &#39;residual_data&#39; and the &#39;CORRECTED_DATA&#39;</span>
<span class="sd">        column does not exist, then values are written to the WEIGHT and</span>
<span class="sd">        WEIGHT_SPECTRUM (if applicable) columns and values in the SIGMA</span>
<span class="sd">        and SIGMA_SPECTRUM are set to 1/sqrt(newly computed weight). If</span>
<span class="sd">        a weight value is 0, the corresponding sigma value is -1.</span>
<span class="sd">        3. If datacolumn=&#39;data&#39; or &#39;residual_data&#39; and the &#39;CORRECTED_DATA&#39;</span>
<span class="sd">        column does exist, then the WEIGHT and WEIGHT_SPECTRUM columns</span>
<span class="sd">        are not updated and values in the SIGMA and</span>
<span class="sd">        SIGMA_SPECTRUM are set to 1/sqrt(of the newly computed weight).</span>
<span class="sd">        If a weight value is 0, the corresponding sigma value is -1.</span>
<span class="sd">        In this case, you should either split out the DATA column and</span>
<span class="sd">        run statwt, or run with datacolumn=&#39;corrected&#39; or &#39;residual&#39;</span>
<span class="sd">        to update WEIGHT/WEIGHT_SPECTRUM. Otherwise the data are</span>
<span class="sd">        internally not consistent.</span>
<span class="sd">        </span>
<span class="sd">        TIME BINNING</span>
<span class="sd">        </span>
<span class="sd">        One of two algorithms can be used for time binning. If</span>
<span class="sd">        slidetimebin=True, then a sliding time bin of the specified width</span>
<span class="sd">        is used. If slidetimebin=False, then block time processing is used.</span>
<span class="sd">        The sliding time bin algorithm will generally be both more memory</span>
<span class="sd">        intensive and take longer than the block processing algorithm. Each</span>
<span class="sd">        algorithm is discussed in detail below.</span>
<span class="sd">        </span>
<span class="sd">        If the value of timebin is an integer, this value represents the</span>
<span class="sd">        number of contiguous, unique time stamps (from the MS TIME column)</span>
<span class="sd">        that should be used for averaging.</span>
<span class="sd">        </span>
<span class="sd">        Block Time Processing</span>
<span class="sd">        </span>
<span class="sd">        The data are processed in contiguous time blocks in this case. This</span>
<span class="sd">        means that all WEIGHT_SPECTRUM values will be set to the same value</span>
<span class="sd">        for all data within the same time bin/channel bin/correlation bin</span>
<span class="sd">        (see the section on channel binning and description of combine=&quot;corr&quot;</span>
<span class="sd">        for more details on channel binning and correlation binning).</span>
<span class="sd">        </span>
<span class="sd">        If timebin is specified as a time quantity (eg, &#39;110s&#39;), then the</span>
<span class="sd">        time bins are not necessarily contiguous and are not necessarily the</span>
<span class="sd">        same width. The start of a bin is always coincident with a value</span>
<span class="sd">        from the TIME column, So for example, if values from the TIME column</span>
<span class="sd">        are [20s, 60s, 100s, 140s, 180s, 230s], and timebin = 110s, the</span>
<span class="sd">        first bin would start at 20s and run to 130s, so that data from</span>
<span class="sd">        timestamps 20s, 60s, and 100s will be included in the first bin. The</span>
<span class="sd">        second bin would start at 140s, so that data for timestamps 140s,</span>
<span class="sd">        180s, and 230s would be included in the second bin.</span>
<span class="sd">        </span>
<span class="sd">        In the case where timebin is an integer, this denotes the number of</span>
<span class="sd">        contigous timestamps that should be binned together. Note that, in</span>
<span class="sd">        this case, for rows &quot;left over&quot; in the upper edge of the bin, their</span>
<span class="sd">        values are computed using timebin that would include rows with times</span>
<span class="sd">        earlier than them. For example, in an MS with 8 rows in one block</span>
<span class="sd">        to be processed and timebin=3, timestamps 1, 2, and 3 would be used</span>
<span class="sd">        to compute the weights of the first three three rows, and rows 4, 5,</span>
<span class="sd">        and 6 would be used to compute weights for the next three rows as</span>
<span class="sd">        expected. Rows 7 and 8 are &quot;left over&quot; rows, but three rows (as per</span>
<span class="sd">        the integer timebin specification) are still used to compute them.</span>
<span class="sd">        Row 7 and 8 weights are computed by combining data in rows 6, 7, and 8.</span>
<span class="sd">        </span>
<span class="sd">        Sliding Time Window Processing</span>
<span class="sd">        </span>
<span class="sd">        In the sliding time window case, in the case where timebin is a time</span>
<span class="sd">        quantity, the time window is always centered on the timestamp of the</span>
<span class="sd">        row in question and extends +/-timebin/2 around that timestamp, subject</span>
<span class="sd">        the the time block boundaries.</span>
<span class="sd">        </span>
<span class="sd">        In the case where timebin is an integer, there are two cases to</span>
<span class="sd">        consider:</span>
<span class="sd">        </span>
<span class="sd">        timebin is odd: In this case the target row&#39;s data and the data from</span>
<span class="sd">        the +/-(n-1)/2 rows around the target row are also used.</span>
<span class="sd">        </span>
<span class="sd">        timebin is even: In this case, the target row&#39;s data and the data from</span>
<span class="sd">        the n/2 rows after the target row and the n/2 - 1 rows before the target</span>
<span class="sd">        row are used.</span>
<span class="sd">        </span>
<span class="sd">        When timebin is an int, for &quot;edge&quot; rows, the timebin extends from the</span>
<span class="sd">        edge of the block to the corresponding timebin value of rows away from</span>
<span class="sd">        the edge, so that the timebin is not symmetrical around the target rows,</span>
<span class="sd">        but includes the number of rows specified by the timebin value.</span>
<span class="sd">        </span>
<span class="sd">        OVERRIDING DEFAULT BLOCK BOUNDARIES</span>
<span class="sd">        </span>
<span class="sd">        Rows with the same baselines and data description IDs which are included</span>
<span class="sd">        in that window are used for determining the weight of that row. The</span>
<span class="sd">        boundaries of the time block to which the window is restricted are</span>
<span class="sd">        determined by changes in FIELD_ID, ARRAY_ID, and SCAN_NUMBER. One can</span>
<span class="sd">        override this behavior for FIELD_ID and/or SCAN_NUMBER by specifying the</span>
<span class="sd">        combine parameter (see below). Unlike the time block processing algorithm,</span>
<span class="sd">        this sliding time window algorithm requires that details of all rows for</span>
<span class="sd">        the time window in question are kept in memory, and thus the sliding</span>
<span class="sd">        window algorithm in general and the block processing row when timebin is</span>
<span class="sd">        an int, requires more memory than the block processing method when</span>
<span class="sd">        timebin is a quantity. Also, unlike the block processing method which</span>
<span class="sd">        computes a single value for all weights within a single bin, the sliding</span>
<span class="sd">        window method requires that each row (along with each channel and</span>
<span class="sd">        correlation bin) be processed individually, so in general the sliding</span>
<span class="sd">        window method will take longer than the block processing method.</span>
<span class="sd">        </span>
<span class="sd">        CHANNEL BINNING</span>
<span class="sd">        </span>
<span class="sd">        The width of channel bins is specified via the chanbin parameter.</span>
<span class="sd">        Channel binning occurs within individual spectral windows; bins</span>
<span class="sd">        never span multiple spectral windows. Each channel will be included</span>
<span class="sd">        in exactly one bin.</span>
<span class="sd">        </span>
<span class="sd">        The default value &quot;spw&quot; indicates that all channels in each</span>
<span class="sd">        spectral window are to be included in a single bin.</span>
<span class="sd">        </span>
<span class="sd">        Any other string value is interpreted as a quantity, and so should</span>
<span class="sd">        have frequency units, eg &quot;1MHz&quot;. In this case, the channel</span>
<span class="sd">        frequencies from the CHAN_FREQ column of the SPECTRAL_WINDOW</span>
<span class="sd">        subtable of the MS are used to determine the bins. The first bin</span>
<span class="sd">        starts at the channel frequency of the 0th channel in the spectral</span>
<span class="sd">        window. Channels with frequencies that differ by less than the</span>
<span class="sd">        value specified by the chanbin parameter are included in this bin.</span>
<span class="sd">        The next bin starts at the frequency of the first channel outside</span>
<span class="sd">        the first bin, and the process is repeated until all channels have</span>
<span class="sd">        been binned.</span>
<span class="sd">        </span>
<span class="sd">        If specified as an integer, the value is interpreted as the number</span>
<span class="sd">        of channels to include in each bin. The final bin in the spectral</span>
<span class="sd">        window may not necessarily contain this number of channels. For</span>
<span class="sd">        example, if a spectral window has 15 channels, and chanbin is</span>
<span class="sd">        specified to be 6, then channels 0-5 will comprise the first bin,</span>
<span class="sd">        channels 6-11 the second, and channels 12-14 the third, so that</span>
<span class="sd">        only three channels will comprise the final bin.</span>
<span class="sd">        </span>
<span class="sd">        MINIMUM REQUIRED NUMBER OF VISIBILITIES</span>
<span class="sd">        </span>
<span class="sd">        The minsamp parameter allows the user to specify the minimum number</span>
<span class="sd">        of unflagged visibilities that must be present in a sample for that</span>
<span class="sd">        sample&#39;s weight to be computed. If a sample has less than this</span>
<span class="sd">        number of unflagged points, the associated weights of all the</span>
<span class="sd">        points in the sample are set to zero, and all the points in the</span>
<span class="sd">        sample are flagged.</span>
<span class="sd">        </span>
<span class="sd">        AGGREGATING DATA ACROSS BOUNDARIES</span>
<span class="sd">        </span>
<span class="sd">        By default, data are not aggregated across changes in values in the</span>
<span class="sd">        columns ARRAY_ID, SCAN_NUMBER, STATE_ID, FIELD_ID, and</span>
<span class="sd">        DATA_DESC_ID. One can override this behavior for SCAN_NUMBER,</span>
<span class="sd">        STATE_ID, and FIELD_ID by specifying the combine parameter. For</span>
<span class="sd">        example, specifying combine=&quot;scan&quot; will ignore scan boundaries when</span>
<span class="sd">        aggregating data. Specifying combine=&quot;field, scan&quot; will ignore both</span>
<span class="sd">        scan and field boundaries when aggregating data.</span>
<span class="sd">        </span>
<span class="sd">        Also by default, data for separate correlations are aggregated</span>
<span class="sd">        separately. Data for all correlations within each spectral window</span>
<span class="sd">        can be aggregated together by specifying &quot;corr&quot; in the combine</span>
<span class="sd">        parameter.</span>
<span class="sd">        </span>
<span class="sd">        Any combination and permutation of &quot;scan&quot;, &quot;field&quot;, &quot;state&quot;, and</span>
<span class="sd">        &quot;corr&quot; are supported by the combine parameter. Other values will be</span>
<span class="sd">        silently ignored.</span>
<span class="sd">        </span>
<span class="sd">        STATISTICS ALGORITHMS</span>
<span class="sd">        </span>
<span class="sd">        The supported statistics algorithms are described in detail in the</span>
<span class="sd">        imstat and ia.statistics() help. For the current application, these</span>
<span class="sd">        algorithms are used to compute vr and vi (see above), such that the</span>
<span class="sd">        set of the real parts of the visibilities and the set of the</span>
<span class="sd">        imaginary parts of the visibilities are treated as independent data</span>
<span class="sd">        sets.</span>
<span class="sd">        </span>
<span class="sd">        RANGE OF ACCEPTABLE WEIGHTS</span>
<span class="sd">        </span>
<span class="sd">        The wtrange parameter allows one to specify the acceptable range</span>
<span class="sd">        (inclusive, except for zero) for weights. Data with weights</span>
<span class="sd">        computed to be outside this range will be flagged. If not specified</span>
<span class="sd">        (empty array), all weights are considered to be acceptable. If</span>
<span class="sd">        specified, the array must contain exactly two nonnegative numeric</span>
<span class="sd">        values. Note that data with weights of zero are always flagged.</span>
<span class="sd">        </span>
<span class="sd">        INCLUDING CHANNELS</span>
<span class="sd">        </span>
<span class="sd">        Channels can be included in the computation of the weights by</span>
<span class="sd">        specifying the fitspw parameter. This parameter accepts a</span>
<span class="sd">        valid MS channel selection string. Data associated with the</span>
<span class="sd">        selected channels will be used in computing the weights; all other</span>
<span class="sd">        channels will be excluded from the computation of weights. By</span>
<span class="sd">        default (empty string), all channels are included.</span>
<span class="sd">        </span>
<span class="sd">        PREVIEW MODE</span>
<span class="sd">        </span>
<span class="sd">        By setting preview=True, the application is run in &quot;preview&quot; mode.</span>
<span class="sd">        In this mode, no data in the input MS are changed, although the</span>
<span class="sd">        amount of data that the application would have flagged is reported.</span>
<span class="sd">        </span>
<span class="sd">        DATA COLUMN</span>
<span class="sd">        </span>
<span class="sd">        The datacolumn parameter can be specified to indicate which data</span>
<span class="sd">        column should be used for computing the weights. The values</span>
<span class="sd">        &quot;corrected&quot; for the CORRECTED_DATA column and &quot;data&quot; for the DATA</span>
<span class="sd">        column are supported (minimum match, case insensitive). One may</span>
<span class="sd">        specify &#39;residual&#39; in which case the values used are the result of</span>
<span class="sd">        the CORRECTED_DATA column - model, or &#39;residual_data&#39; in which</span>
<span class="sd">        case the values used are the DATA column - model, where model</span>
<span class="sd">        is the CORRECTED_DATA column if it exists, or if it doesn&#39;t,</span>
<span class="sd">        the virtual source model if one exists, or if that doesn&#39;t, then</span>
<span class="sd">        no model is used and the &#39;residual&#39; and &#39;residual_data&#39; cases</span>
<span class="sd">        are equivalent to the &#39;corrected&#39; and &#39;data&#39; cases, respectively.</span>
<span class="sd">        The last two options are to allow for operation on timescales or</span>
<span class="sd">        frequency ranges which are larger than that over which the sky</span>
<span class="sd">        signal is expected to be constant. This situation arises in eg,</span>
<span class="sd">        OTF mapping, and also perhaps with sources with significant</span>
<span class="sd">        spectral structure. In cases where a necessary column doesn&#39;t</span>
<span class="sd">        exist, an exception will be thrown and no data will be changed.</span>
<span class="sd">        NOTE: It is the user&#39;s responsibility to ensure that a model has</span>
<span class="sd">        been set for all selected fields before using datacolumn=&#39;residual&#39;</span>
<span class="sd">        or &#39;residual_data&#39;.</span>
<span class="sd">        </span>
<span class="sd">        RETURN VALUE</span>
<span class="sd">        </span>
<span class="sd">        In all cases, the mean and variance of the set of all weights computed</span>
<span class="sd">        by the application is reported and returned in a dictionary with keys</span>
<span class="sd">        &#39;mean&#39; and &#39;variance&#39;. Weights for which there are corresponding flags</span>
<span class="sd">        (=True) prior to running the application are excluded from the</span>
<span class="sd">        computation of these statistics. If the WEIGHT_SPECTRUM values are</span>
<span class="sd">        available, they are used to compute the statistics, otherwise,</span>
<span class="sd">        the WEIGHT values are used. The returned statistics are always computed</span>
<span class="sd">        using the classic algorithm; the value of statalg has no impact on how</span>
<span class="sd">        they are computed.</span>
<span class="sd">        </span>
<span class="sd">        OTHER CONSIDERATIONS</span>
<span class="sd">        </span>
<span class="sd">        Flagged values are not used in computing the weights, although the</span>
<span class="sd">        associated weights of these values are updated.</span>
<span class="sd">        </span>
<span class="sd">        If the variance for a set of data is 0, all associated flags for</span>
<span class="sd">        that data are set to True, and the corresponding weights are set to</span>
<span class="sd">        0.</span>
<span class="sd">        </span>
<span class="sd">        Because data are modified in the input MS, the nomodify parameter</span>
<span class="sd">        must be set to False when opening the associated MS tool.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">statwt</span><span class="p">(</span><span class="n">combine</span><span class="p">,</span> <span class="n">timebin</span><span class="p">,</span> <span class="n">slidetimebin</span><span class="p">,</span> <span class="n">chanbin</span><span class="p">,</span> <span class="n">minsamp</span><span class="p">,</span> <span class="n">statalg</span><span class="p">,</span> <span class="n">fence</span><span class="p">,</span> <span class="n">center</span><span class="p">,</span> <span class="n">lside</span><span class="p">,</span> <span class="n">zscore</span><span class="p">,</span> <span class="n">maxiter</span><span class="p">,</span> <span class="n">fitspw</span><span class="p">,</span> <span class="n">excludechans</span><span class="p">,</span> <span class="n">wtrange</span><span class="p">,</span> <span class="n">preview</span><span class="p">,</span> <span class="n">datacolumn</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">oldstatwt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dorms</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">byantenna</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">sepacs</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fitspw</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">fitcorr</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">combine</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">timebin</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">minsamp</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">field</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">spw</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">antenna</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">timerange</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">scan</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">intent</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">array</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">correlation</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">obs</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">datacolumn</span><span class="o">=</span><span class="s1">&#39;corrected_data&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;NOT IMPLEMENTED YET.</span>
<span class="sd">        </span>
<span class="sd">        This function estimates the noise from the scatter of the</span>
<span class="sd">        visibilities, sets SIGMA to it, and WEIGHT to SIGMA**-2.</span>
<span class="sd">        </span>
<span class="sd">        Ideally the visibilities used to estimate the scatter, as selected</span>
<span class="sd">        by fitspw and fitcorr, should be pure noise.  If you know for</span>
<span class="sd">        certain that they are, then setting dorms to True will give the</span>
<span class="sd">        best result.  Otherwise, use False (standard sample standard</span>
<span class="sd">        deviation).  More robust scatter estimates like the interquartile</span>
<span class="sd">        range or median absolute deviation from the median are not offered</span>
<span class="sd">        because they require sorting by value, which is not possible for</span>
<span class="sd">        complex numbers.</span>
<span class="sd">        </span>
<span class="sd">        To beat down the noise of the noise estimate, the sample size per</span>
<span class="sd">        estimate can be made larger than a single spw and baseline.  (Using</span>
<span class="sd">        combine=&#39;spw&#39; is to interpolate between spws with line-free</span>
<span class="sd">        channels is recommended when an spw has no line-free channels.)</span>
<span class="sd">        timebin smooths the noise estimate over time.  windowtype sets the</span>
<span class="sd">        type of time smoothing.</span>
<span class="sd">        </span>
<span class="sd">        WEIGHT and SIGMA will not be changed for samples that have fewer</span>
<span class="sd">        than minsamp visibilities.  Selected visibilities for which no</span>
<span class="sd">        noise estimate is made will be flagged.  Note that minsamp is</span>
<span class="sd">        effectively at least 2 if dorms is False, and 1 if it is True.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">oldstatwt</span><span class="p">(</span><span class="n">dorms</span><span class="p">,</span> <span class="n">byantenna</span><span class="p">,</span> <span class="n">sepacs</span><span class="p">,</span> <span class="n">fitspw</span><span class="p">,</span> <span class="n">fitcorr</span><span class="p">,</span> <span class="n">combine</span><span class="p">,</span> <span class="n">timebin</span><span class="p">,</span> <span class="n">minsamp</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">spw</span><span class="p">,</span> <span class="n">antenna</span><span class="p">,</span> <span class="n">timerange</span><span class="p">,</span> <span class="n">scan</span><span class="p">,</span> <span class="n">intent</span><span class="p">,</span> <span class="n">array</span><span class="p">,</span> <span class="n">correlation</span><span class="p">,</span> <span class="n">obs</span><span class="p">,</span> <span class="n">datacolumn</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">regridspw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outframe</span><span class="o">=</span><span class="s1">&#39;LSRK&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;chan&#39;</span><span class="p">,</span> <span class="n">restfreq</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="o">-</span><span class="mf">3E30</span><span class="p">),</span> <span class="n">interpolation</span><span class="o">=</span><span class="s1">&#39;LINEAR&#39;</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="o">-</span><span class="mf">3E30</span><span class="p">),</span> <span class="n">center</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="o">-</span><span class="mf">3E30</span><span class="p">),</span> <span class="n">bandwidth</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="o">-</span><span class="mf">1.</span><span class="p">),</span> <span class="n">chanwidth</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="o">-</span><span class="mf">1.</span><span class="p">),</span> <span class="n">hanning</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function permits you to transform the spectral data of your</span>
<span class="sd">        measurement set to a given reference frame. The present reference</span>
<span class="sd">        frame information in the MS is examined and the transformation</span>
<span class="sd">        performed accordingly. Since all such transformations are linear in</span>
<span class="sd">        frequency, a pure change of reference frame only affects the</span>
<span class="sd">        channel boundary definitions.</span>
<span class="sd">        </span>
<span class="sd">        In addition, the function permits you to permanently regrid the</span>
<span class="sd">        data, i.e. reduce the channel number and/or move the boundaries</span>
<span class="sd">        using several interpolation methods (selected using parameter</span>
<span class="sd">        &quot;interpolation&quot;). The new channels are equidistant in frequency (if</span>
<span class="sd">        parameter &quot;mode&quot; is chosen to be vrad or freq, or equidistant in</span>
<span class="sd">        wavelength if  parameter &quot;mode&quot; is chosen to be vopt or wave). If</span>
<span class="sd">        &quot;mode&quot; is chosen to be &quot;chan&quot;, the regridding is performed by</span>
<span class="sd">        combining the existing channels, i.e. not moving but just</span>
<span class="sd">        eliminating channel boundaries where necessary.</span>
<span class="sd">        </span>
<span class="sd">        The regridding is applied to the channel definition and all data of</span>
<span class="sd">        the MS, i.e. all columns which contain arrays whose dimensions</span>
<span class="sd">        depend on the number of channels. The input parameters are verified</span>
<span class="sd">        before any modification is made to the MS.</span>
<span class="sd">        </span>
<span class="sd">        The target reference frame can be set by providing the name of a</span>
<span class="sd">        standard reference frame (LSRK, LSRD, BARY, GALACTO, LGROUP, CMB,</span>
<span class="sd">        TOPO, GEO, or SOURCE, default = no change of frame) in parameter</span>
<span class="sd">        &quot;outframe&quot;. For each field in the MS, the channel frequencies are</span>
<span class="sd">        transformed from their present reference frame to the one given by</span>
<span class="sd">        parameter &quot;outframe&quot;.</span>
<span class="sd">        </span>
<span class="sd">        If the regridding parameters are set, they are interpreted in the</span>
<span class="sd">        &quot;outframe&quot; reference frame. The regridding is applied to the data</span>
<span class="sd">        after the reference frame transformation.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">regridspw</span><span class="p">(</span><span class="n">outframe</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">restfreq</span><span class="p">,</span> <span class="n">interpolation</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">center</span><span class="p">,</span> <span class="n">bandwidth</span><span class="p">,</span> <span class="n">chanwidth</span><span class="p">,</span> <span class="n">hanning</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">cvel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;channel&#39;</span><span class="p">,</span> <span class="n">nchan</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">start</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">width</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">interp</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="n">phasec</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">restfreq</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">outframe</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">veltype</span><span class="o">=</span><span class="s1">&#39;radio&#39;</span><span class="p">,</span> <span class="n">hanning</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function permits you to transform the spectral data of your</span>
<span class="sd">        measurement set to a given reference frame and/or regrid it. It</span>
<span class="sd">        will combine all spectral windows of the MS into one.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">cvel</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="n">nchan</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">interp</span><span class="p">,</span> <span class="n">phasec</span><span class="p">,</span> <span class="n">restfreq</span><span class="p">,</span> <span class="n">outframe</span><span class="p">,</span> <span class="n">veltype</span><span class="p">,</span> <span class="n">hanning</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">hanningsmooth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">datacolumn</span><span class="o">=</span><span class="s1">&#39;corrected&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function Hanning smooths the frequency channels with a</span>
<span class="sd">        weighted running average of:</span>
<span class="sd">        smoothedData[i] = 0.25*correctedData[i-1] + 0.50*correctedData[i]</span>
<span class="sd">        + 0.25*correctedData[i-1]</span>
<span class="sd">        The first and last channels are flagged. Inclusion of a flagged</span>
<span class="sd">        value in an average causes that averaged data value to be flagged.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">hanningsmooth</span><span class="p">(</span><span class="n">datacolumn</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">cvelfreqs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spwids</span><span class="o">=</span><span class="p">[</span> <span class="nb">int</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">],</span> <span class="n">fieldids</span><span class="o">=</span><span class="p">[</span> <span class="nb">int</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">],</span> <span class="n">obstime</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;channel&#39;</span><span class="p">,</span> <span class="n">nchan</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">start</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">width</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">phasec</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">restfreq</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">outframe</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">veltype</span><span class="o">=</span><span class="s1">&#39;radio&#39;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Take the spectral grid of a given spectral window, tranform and</span>
<span class="sd">        regrid it as prescribed by the given grid parameters (same as in</span>
<span class="sd">        cvel and clean) and return the transformed values as a list. The MS</span>
<span class="sd">        is not modified. Useful for tests of gridding parameters before</span>
<span class="sd">        using them in cvel or clean.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">cvelfreqs</span><span class="p">(</span><span class="n">spwids</span><span class="p">,</span> <span class="n">fieldids</span><span class="p">,</span> <span class="n">obstime</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">nchan</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">phasec</span><span class="p">,</span> <span class="n">restfreq</span><span class="p">,</span> <span class="n">outframe</span><span class="p">,</span> <span class="n">veltype</span><span class="p">,</span> <span class="n">verbose</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">contsub</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outputms</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">fitspw</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">fitorder</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">combine</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">spw</span><span class="o">=</span><span class="s1">&#39;*&#39;</span><span class="p">,</span> <span class="n">unionspw</span><span class="o">=</span><span class="s1">&#39;*&#39;</span><span class="p">,</span> <span class="n">field</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">scan</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">intent</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">correlation</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">obs</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">whichcol</span><span class="o">=</span><span class="s1">&#39;CORRECTED_DATA&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;DEPRECATED: This function is deprecated and will be removed in an</span>
<span class="sd">        upcoming release.</span>
<span class="sd">        </span>
<span class="sd">        NOT FULLY IMPLEMENTED YET.  uvcontsub uses the cb tool for now.</span>
<span class="sd">        (The only reason to implement it in ms is to save time and disk</span>
<span class="sd">        space.)</span>
<span class="sd">        </span>
<span class="sd">        This function estimates the continuum emission of the MS and writes</span>
<span class="sd">        a MS with that estimate subtracted, using the ms tool.  The</span>
<span class="sd">        estimate is made, separately for the real and imaginary parts of</span>
<span class="sd">        each baseline, by fitting a low order polynomial to the unflagged</span>
<span class="sd">        visibilities selected by fitspw (depending on combine).</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">contsub</span><span class="p">(</span><span class="n">outputms</span><span class="p">,</span> <span class="n">fitspw</span><span class="p">,</span> <span class="n">fitorder</span><span class="p">,</span> <span class="n">combine</span><span class="p">,</span> <span class="n">spw</span><span class="p">,</span> <span class="n">unionspw</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">scan</span><span class="p">,</span> <span class="n">intent</span><span class="p">,</span> <span class="n">correlation</span><span class="p">,</span> <span class="n">obs</span><span class="p">,</span> <span class="n">whichcol</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">continuumsub</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">field</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">fitspw</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">spw</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">solint</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">fitorder</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;subtract&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;DEPRECATED: This function is deprecated and will be removed in an</span>
<span class="sd">        upcoming release.</span>
<span class="sd">        </span>
<span class="sd">        This function provides a means of continuum determination and</span>
<span class="sd">        subtraction by fitting a polynomial of desired order to a subset of</span>
<span class="sd">        channels in each time-averaged uv spectrum.  The fit is used to</span>
<span class="sd">        model the continuum in all channels (not just those used in the</span>
<span class="sd">        fit), for subtraction, if desired.</span>
<span class="sd">        </span>
<span class="sd">        Use the fitspw parameter to limit the spectral windows processed and</span>
<span class="sd">        the range of channels used to estimate the continuum  in each (avoid</span>
<span class="sd">        channels containing spectral lines).</span>
<span class="sd">        </span>
<span class="sd">        The default solution interval &#39;int&#39; will result in per-integration</span>
<span class="sd">        continuum fits for each baseline.</span>
<span class="sd">        </span>
<span class="sd">        The mode parameter indicates how the continuum model (the result of</span>
<span class="sd">        the fit) should be used:</span>
<span class="sd">        - &#39;subtract&#39; will store the continuum model in the MODEL_DATA column</span>
<span class="sd">        and subtract it from the CORRECTED_DATA column</span>
<span class="sd">        - &#39;replace&#39; will replace the CORRECTED_DATA column with the</span>
<span class="sd">        continuum model (useful if you want to image the continuum model</span>
<span class="sd">        result)</span>
<span class="sd">        - &#39;model&#39; will only store the continuum model in the MODEL_DATA</span>
<span class="sd">        column (the CORRECTED_DATA is unaffected).</span>
<span class="sd">        </span>
<span class="sd">        It is important to start the ms tool with nomodify=False so that</span>
<span class="sd">        changes to the dataset will be allowed (see example below).  For</span>
<span class="sd">        now, the only way to recover the un-subtracted CORRECTED_DATA</span>
<span class="sd">        column is to use calibrater.correct() again.</span>
<span class="sd">        </span>
<span class="sd">        Note that the MODEL_DATA and CORRECTED_DATA columns must be present</span>
<span class="sd">        for continuumsub to work correctly.  The function will warn the</span>
<span class="sd">        user if they are not present, and abort.  To add these scratch</span>
<span class="sd">        columns, close the ms tool, then start a calibrater or an imager</span>
<span class="sd">        tool, which will add the scratch columns.  Then restart the ms</span>
<span class="sd">        tool, and try continuumsub again.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">continuumsub</span><span class="p">(</span><span class="n">field</span><span class="p">,</span> <span class="n">fitspw</span><span class="p">,</span> <span class="n">spw</span><span class="p">,</span> <span class="n">solint</span><span class="p">,</span> <span class="n">fitorder</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">uvsub</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function subtracts model visibility data from corrected</span>
<span class="sd">        visibility data leaving the residuals in the corrected data column.</span>
<span class="sd">        If the parameter reverse is set True, this process is reversed.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">uvsub</span><span class="p">(</span><span class="n">reverse</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">addephemeris</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">id</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">ephemerisname</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">comment</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">field</span><span class="o">=</span><span class="p">[</span> <span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">addephemeris</span><span class="p">(</span><span class="nb">id</span><span class="p">,</span> <span class="n">ephemerisname</span><span class="p">,</span> <span class="n">comment</span><span class="p">,</span> <span class="n">field</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">timesort</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newmsname</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function sorts the main table of the measurement set by the</span>
<span class="sd">        contents of the column TIME in ascending order and writes a copy of</span>
<span class="sd">        the MS with the sorted main table into newmsfile.</span>
<span class="sd">        </span>
<span class="sd">        If no newmsname is given, a sorted copy of the MS is written into a</span>
<span class="sd">        new MS under the name x.sorted (where x is the name of the original</span>
<span class="sd">        MS). The original MS is then closed and deleted. The new MS is</span>
<span class="sd">        renamed to the name of the original MS and then reopened.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">timesort</span><span class="p">(</span><span class="n">newmsname</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">sort</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newmsname</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span>  <span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function sorts the main table of the measurement set by the</span>
<span class="sd">        contents of the input set of columns in ascending order and writes</span>
<span class="sd">        a copy of the MS with the sorted main table into newmsfile.</span>
<span class="sd">        </span>
<span class="sd">        If no newmsname is given, a sorted copy of the MS is written into a</span>
<span class="sd">        new MS under the name x.sorted (where x is the name of the original</span>
<span class="sd">        MS). The original MS is then closed and deleted. The new MS is</span>
<span class="sd">        renamed to the name of the original MS and then reopened.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">newmsname</span><span class="p">,</span> <span class="n">columns</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">iterinit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span>  <span class="p">],</span> <span class="n">interval</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="mf">0.0</span><span class="p">),</span> <span class="n">maxrows</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">adddefaultsortcolumns</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Specify the columns to iterate over and the time interval to use</span>
<span class="sd">        for the TIME column iteration.  The columns are specified by their</span>
<span class="sd">        MS column name and must contain scalar values.</span>
<span class="sd">        </span>
<span class="sd">        Note that the following default sort columns are always added to</span>
<span class="sd">        the specified columns: array_id, field_id, data_desc_id and time.</span>
<span class="sd">        This is so that the iterator can keep track of the coordinates</span>
<span class="sd">        associated with the data (field direction, frequency, etc.). If you</span>
<span class="sd">        want to sort on these columns last instead of first, you need to</span>
<span class="sd">        include them in the columns specified. If you don&#39;t want to sort on</span>
<span class="sd">        these columns at all, you can set adddefaultsortcolumns to False.</span>
<span class="sd">        </span>
<span class="sd">        You may want to use iteration for a large dataset. After calling</span>
<span class="sd">        iterinit, you must call iterorigin before attempting to retrieve</span>
<span class="sd">        data with getdata.</span>
<span class="sd">        </span>
<span class="sd">        You need to call selectinit before calling this.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">iterinit</span><span class="p">(</span><span class="n">columns</span><span class="p">,</span> <span class="n">interval</span><span class="p">,</span> <span class="n">maxrows</span><span class="p">,</span> <span class="n">adddefaultsortcolumns</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">iterorigin</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set or reset the iterator to the start of the currently specified</span>
<span class="sd">        iteration.  You need to call this after iterinit, before attempting</span>
<span class="sd">        to retrieve data with getdata. You may also use iterorigin to set</span>
<span class="sd">        the iterator back to the start before you reach the end of the</span>
<span class="sd">        data.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">iterorigin</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">iternext</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This sets the currently selected table (as accessed with getdata)</span>
<span class="sd">        to the next iteration. If there is no more data, the function</span>
<span class="sd">        returns False and the selection is reset to that before the</span>
<span class="sd">        iteration started.  You need to call iterinit and iterorigin</span>
<span class="sd">        before calling this.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">iternext</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">iterend</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This sets the currently selected table (as accessed with</span>
<span class="sd">        getdata) to the table that was selected before iteration</span>
<span class="sd">        started.  Use this to end the iteration prematurely. There is no</span>
<span class="sd">        need to call this if you continue iterating until iternext</span>
<span class="sd">        returns False.</span>
<span class="sd">        </span>
<span class="sd">        See the example below.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">iterend</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">ngetdata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">items</span><span class="o">=</span><span class="p">[</span>  <span class="p">],</span> <span class="n">ifraxis</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ifraxisgap</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">increment</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">average</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;DEPRECATED: Please use the ms::getdata() function in place</span>
<span class="sd">        of ms::ngetdata().</span>
<span class="sd">        </span>
<span class="sd">        This method extracts the data as specified in the items</span>
<span class="sd">        parameter.  The data is returned as a record with each item</span>
<span class="sd">        as a separate key in the record (all in lower case).</span>
<span class="sd">        </span>
<span class="sd">        Unless the iterator was initialized with a niterinit(), this</span>
<span class="sd">        method initializes the iterator as niterinit([&quot;..&quot;],0.0,0,False).</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">ngetdata</span><span class="p">(</span><span class="n">items</span><span class="p">,</span> <span class="n">ifraxis</span><span class="p">,</span> <span class="n">ifraxisgap</span><span class="p">,</span> <span class="n">increment</span><span class="p">,</span> <span class="n">average</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">niterinit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span>  <span class="p">],</span> <span class="n">interval</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="mf">0.0</span><span class="p">),</span> <span class="n">maxrows</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">adddefaultsortcolumns</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;DEPRECATED: Please use the ms::iterinit() function in place</span>
<span class="sd">        of ms::niterinit().</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">niterinit</span><span class="p">(</span><span class="n">columns</span><span class="p">,</span> <span class="n">interval</span><span class="p">,</span> <span class="n">maxrows</span><span class="p">,</span> <span class="n">adddefaultsortcolumns</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">niterorigin</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;DEPRECATED: Please use the ms::iterorigin() function in place</span>
<span class="sd">        of ms::niterorigin().</span>
<span class="sd">        </span>
<span class="sd">        Set or reset the iterator to the start of the currently</span>
<span class="sd">        specified iteration. You need to call this before attempting to</span>
<span class="sd">        iteratively retrieve data with ngetdata. You can set the</span>
<span class="sd">        iteration back to the start before you reach the end of the</span>
<span class="sd">        data.  You need to call iterinit before calling this.  See the</span>
<span class="sd">        example below.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">niterorigin</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">niternext</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;DEPRECATED: Please use the ms::iternext() function in place</span>
<span class="sd">        of ms::niternext().</span>
<span class="sd">        </span>
<span class="sd">        This sets the currently selected table (as accessed with</span>
<span class="sd">        ngetdata) to the next iteration. If there is no more data, the</span>
<span class="sd">        function returns False.  You need to call iterinit and</span>
<span class="sd">        iterorigin before calling this.  See the example below.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">niternext</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">niterend</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;DEPRECATED: Please use the ms::iterend() function in place</span>
<span class="sd">        of ms::niterend().</span>
<span class="sd">        </span>
<span class="sd">        The serves redundant purpose and is here only for backward</span>
<span class="sd">        compatibility.</span>
<span class="sd">        </span>
<span class="sd">        This method returns True if there are no more iterations left.</span>
<span class="sd">        I.e., the iterations have ended.  This same information is also</span>
<span class="sd">        returned by niternext().</span>
<span class="sd">        </span>
<span class="sd">        With the use of the VisibilityIterator in the niterinit(),</span>
<span class="sd">        niterorigin(), niternext() methods, the iterator is set to the</span>
<span class="sd">        original state by calling niterinit() at any time.</span>
<span class="sd">        </span>
<span class="sd">        See the example below.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">niterend</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">nrowold</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">selected</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;DEPRECATED: Please use the ms::nrow() function in place of</span>
<span class="sd">        ms::nrowold().</span>
<span class="sd">        </span>
<span class="sd">        This function returns the number of rows in the measurement</span>
<span class="sd">        set. If the optional argument selected is set to True, it returns</span>
<span class="sd">        the number of currently selected rows, otherwise it returns the</span>
<span class="sd">        the number of rows in the original measurement.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">nrowold</span><span class="p">(</span><span class="n">selected</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">rangeold</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">items</span><span class="o">=</span><span class="p">[</span>  <span class="p">],</span> <span class="n">useflags</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">blocksize</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">10</span><span class="p">)):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;DEPRECATED: Please use the ms::range() function in place of</span>
<span class="sd">        ms::rangeold().</span>
<span class="sd">        </span>
<span class="sd">        This function will return the range of values in the currently</span>
<span class="sd">        selected measurement set for the items specified.  Possible items</span>
<span class="sd">        include most scalar columns, interferometer number</span>
<span class="sd">        (1000*antenna1+antenna2), uvdist(ance), u, v, w, amplitude, phase,</span>
<span class="sd">        real and imaginary components of the data (and corrected and model</span>
<span class="sd">        versions of these - if these columns are present). See the table</span>
<span class="sd">        at the top of the document to find the exact list.</span>
<span class="sd">        </span>
<span class="sd">        You specify items in which you are interested using a string</span>
<span class="sd">        vector where each element is a case insensitive item name.  This</span>
<span class="sd">        function will then return a record that has fields corresponding</span>
<span class="sd">        to each of the specified items. Each field will contain the range</span>
<span class="sd">        of the specified item. For many items the range will be the</span>
<span class="sd">        minimum and maximum values but for some it will be a list of</span>
<span class="sd">        unique values. Unrecognized items are ignored.</span>
<span class="sd">        </span>
<span class="sd">        By default the FLAG column is used to exclude flagged data before</span>
<span class="sd">        any ranges are determined, but you can set useflags=False to</span>
<span class="sd">        include flagged data in the range.  However, if you average in</span>
<span class="sd">        frequency, flagging will still be applied.</span>
<span class="sd">        </span>
<span class="sd">        You can influence the memory use and the reading speed using</span>
<span class="sd">        the blocksize argument - it specifies how big a block of data</span>
<span class="sd">        to read at once (in MB). For large datasets on machines with lots</span>
<span class="sd">        of memory you may speed things up by setting this higher than the</span>
<span class="sd">        default (10 MB).</span>
<span class="sd">        </span>
<span class="sd">        For some items, you need to call selectinitold to select a portion</span>
<span class="sd">        of the data with a unique shape prior to calling this function.</span>
<span class="sd">        </span>
<span class="sd">        Items prefixed with corrected, model, residual or obs_residual</span>
<span class="sd">        are not available unless your measurement set has been processed</span>
<span class="sd">        either with the imager or calibrator tools.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">rangeold</span><span class="p">(</span><span class="n">items</span><span class="p">,</span> <span class="n">useflags</span><span class="p">,</span> <span class="n">blocksize</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">selectinitold</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">datadescid</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">reset</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;DEPRECATED: Please use the ms::selectinit() function in place of</span>
<span class="sd">        ms::selectinitold().</span>
<span class="sd">        </span>
<span class="sd">        A measurement set can contain data with a variety of different</span>
<span class="sd">        shapes (as described in the overall description to this tool).  To</span>
<span class="sd">        allow functions to return data in fixed shape arrays you need to</span>
<span class="sd">        select, using this function, rows that contain the same data</span>
<span class="sd">        shape. You do not need to use this function if all the data in</span>
<span class="sd">        your measurement set has only one shape.</span>
<span class="sd">        </span>
<span class="sd">        The DATA_DESC_ID column in the measurement set contains a</span>
<span class="sd">        value that maps to a particular row in the POLARIZATION and</span>
<span class="sd">        SPECTRAL_WINDOW subtables. Hence all rows with the same</span>
<span class="sd">        value in the DATA_DESC_ID column must have the same data</span>
<span class="sd">        shape. To select all the data where the DATA_DESC_ID value</span>
<span class="sd">        is $N$ you call this function with the datadescid argument set to</span>
<span class="sd">        $N$.</span>
<span class="sd">        </span>
<span class="sd">        It is possible to have a measurement set with differing values in</span>
<span class="sd">        the DATA_DESC_ID column but where all the data is a fixed</span>
<span class="sd">        shape. For example this will occur if the reference frequency</span>
<span class="sd">        changes but the number of spectral channels is fixed. In cases</span>
<span class="sd">        like this all the data can be selected, using this function with</span>
<span class="sd">        an argument of zero.  If the data shape does change and you call</span>
<span class="sd">        this function with an datadescid set to zero  the return value will be False. In all other cases it</span>
<span class="sd">        will be True.</span>
<span class="sd">        </span>
<span class="sd">        To return to the completely unselected measurement set, set the</span>
<span class="sd">        reset argument to True. This will allow you to access the full</span>
<span class="sd">        range of rows in the measurement set, rather than just the</span>
<span class="sd">        selected measurement set.</span>
<span class="sd">        </span>
<span class="sd">        The datadescid must always be a non-negative integer.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">selectinitold</span><span class="p">(</span><span class="n">datadescid</span><span class="p">,</span> <span class="n">reset</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">selectold</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">items</span><span class="o">=</span><span class="p">{</span> <span class="p">}):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;DEPRECATED: Please use the ms::select() function in place of</span>
<span class="sd">        ms::selectold().</span>
<span class="sd">        </span>
<span class="sd">        This function will select a subset of the current measurement set</span>
<span class="sd">        based on the range of values for each field in the input record.</span>
<span class="sd">        The rangeold function will return a record that can be altered and</span>
<span class="sd">        used as the argument for this function.  A successful selection</span>
<span class="sd">        returns True. Unrecognized fields are ignored.</span>
<span class="sd">        </span>
<span class="sd">        Allowable items for selectold include:  antenna1, antenna2,</span>
<span class="sd">        array_id, feed1, feed2, field_id, ifr_number, rows, scan_number,</span>
<span class="sd">        data_desc_id, time, times, u, v, w, and uvdist.</span>
<span class="sd">        </span>
<span class="sd">        You need to call selectinitold before</span>
<span class="sd">        calling this function. If you haven&#39;t then selectinitold will be</span>
<span class="sd">        called for you with default arguments.</span>
<span class="sd">        </span>
<span class="sd">        Repeated use of this function, with different arguments, will</span>
<span class="sd">        further refine the selection, resulting in a successively smaller</span>
<span class="sd">        selected measurement set. If the selected measurement set does not</span>
<span class="sd">        contain any rows then this function will return False and send a</span>
<span class="sd">        warning message in the logger. Otherwise this function will return</span>
<span class="sd">        True. To undo all the selections you need to use the selectinitold</span>
<span class="sd">        function (with reset=True).</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">selectold</span><span class="p">(</span><span class="n">items</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">selecttaqlold</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msselect</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;DEPRECATED: Please use the ms::selecttaql() function in place of</span>
<span class="sd">        ms::selecttaqlold().</span>
<span class="sd">        </span>
<span class="sd">        This function will select a subset of the current measurement set</span>
<span class="sd">        based on the standard TaQL selection string given.</span>
<span class="sd">        </span>
<span class="sd">        Repeated use of this function, with different arguments, will</span>
<span class="sd">        further refine the selection, resulting in a successively smaller</span>
<span class="sd">        selected measurement set. If the selected measurement set does not</span>
<span class="sd">        contain any rows then this function will return False and send a</span>
<span class="sd">        warning message in the logger. Otherwise this function will return</span>
<span class="sd">        True. To undo all the selections you need to use the selectinitold</span>
<span class="sd">        function (with reset=True). Note that index values used in the TaQL</span>
<span class="sd">        string are zero-based as are all tool indices.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">selecttaqlold</span><span class="p">(</span><span class="n">msselect</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">selectchannelold</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nchan</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">start</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">width</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">inc</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">1</span><span class="p">)):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;DEPRECATED: Please use the ms::selectchannel() function in place of</span>
<span class="sd">        ms::selectchannelold().</span>
<span class="sd">        </span>
<span class="sd">        This function allows you to select a subset of the frequency</span>
<span class="sd">        channels in the current measurement set.  This function can also</span>
<span class="sd">        average, over frequency channels, prior to providing the values to</span>
<span class="sd">        the user.</span>
<span class="sd">        </span>
<span class="sd">        Selection on channels is not allowed using either the select or</span>
<span class="sd">        command functions as they can only select entire rows in a</span>
<span class="sd">        measurement set. Channel selection involves accessing only some of</span>
<span class="sd">        the values in a row. Like all the selection functions this</span>
<span class="sd">        function does not change the current measurement but updates the</span>
<span class="sd">        measurement set selection parameters so that functions like</span>
<span class="sd">        getdataold will return the desired subset of the data.  Repeated</span>
<span class="sd">        use of this function will overwrite any previous channel selection.</span>
<span class="sd">        </span>
<span class="sd">        There are four parameters, the number of output channels, the</span>
<span class="sd">        first input channel to use, the number of input channels to</span>
<span class="sd">        average into one output channel, and the increment in the input</span>
<span class="sd">        spectrum for the next output channel. All four parameters need to</span>
<span class="sd">        be specified.</span>
<span class="sd">        </span>
<span class="sd">        When all data to be averaged is unflagged, the result is the</span>
<span class="sd">        averaged value and the corresponding flag is False.  When all data</span>
<span class="sd">        is flagged, the result is set to zero and the corresponding flag is</span>
<span class="sd">        True.  When data to be averaged is mixed (unflagged and flagged),</span>
<span class="sd">        only the unflagged values are averaged and the flag is set to</span>
<span class="sd">        False.</span>
<span class="sd">        </span>
<span class="sd">        This function return True if the selection was successful, and</span>
<span class="sd">        False if not. In the latter case an error message will also be sent</span>
<span class="sd">        to the logger.</span>
<span class="sd">        </span>
<span class="sd">        You need to call selectinitold before</span>
<span class="sd">        calling this function. If you haven&#39;t then selectinitold will be</span>
<span class="sd">        called for you with default arguments.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">selectchannelold</span><span class="p">(</span><span class="n">nchan</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">inc</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">selectpolarizationold</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wantedpol</span><span class="o">=</span><span class="p">[</span>  <span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;DEPRECATED: Please use the ms::selectpolarization() function in</span>
<span class="sd">        place of ms::selectpolarizationold().</span>
<span class="sd">        </span>
<span class="sd">        This function allows you to select a subset of the polarizations</span>
<span class="sd">        in the current measurement set.  This function can also setup</span>
<span class="sd">        conversion to different polarization representations.</span>
<span class="sd">        </span>
<span class="sd">        You specify the polarizations using a string vector. Allowable</span>
<span class="sd">        strings are include I, Q, U, V, RR, RL, LR, LL, XX, YY, XY,</span>
<span class="sd">        YX. These string must be specified in upper case. If the</span>
<span class="sd">        polarizations match those present in the measurement set they will</span>
<span class="sd">        be selected directly, otherwise all polarizations are read and</span>
<span class="sd">        then a conversion step is done. If the conversion cannot be done</span>
<span class="sd">        then an error will be produced when you try to access the data.</span>
<span class="sd">        </span>
<span class="sd">        This function return True if the selection was successful, and</span>
<span class="sd">        False if not.</span>
<span class="sd">        </span>
<span class="sd">        You need to call selectinitold before</span>
<span class="sd">        calling this function. If you haven&#39;t then selectinitold will be</span>
<span class="sd">        called for you with default arguments.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">selectpolarizationold</span><span class="p">(</span><span class="n">wantedpol</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">getdataold</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">items</span><span class="o">=</span><span class="p">[</span>  <span class="p">],</span> <span class="n">ifraxis</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ifraxisgap</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">increment</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">average</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;DEPRECATED: Please use the ms::getdata() function in place</span>
<span class="sd">        of ms::getdataold().</span>
<span class="sd">        </span>
<span class="sd">        This function will read the specified items from the currently</span>
<span class="sd">        selected measurement set and returns them in fields of a record.</span>
<span class="sd">        The main difference between this and direct access of the table,</span>
<span class="sd">        using the table tool, is that this function reads data from the</span>
<span class="sd">        selected measurement set, it provides access to derived</span>
<span class="sd">        quantities like amplitude and flag_sum and it can reorder the</span>
<span class="sd">        data.</span>
<span class="sd">        </span>
<span class="sd">        The items to read are specified, as with the rangeold function,</span>
<span class="sd">        using a vector of strings. Allowable items include:  amplitude,</span>
<span class="sd">        corrected_amplitude, model_amplitude, ratio_amplitude,</span>
<span class="sd">        residual_amplitude, obs_residual_amplitude, antenna1, antenna2,</span>
<span class="sd">        axis_info, data, corrected_data, model_data, ratio_data,</span>
<span class="sd">        residual_data, obs_residual_data, feed1, feed2, field_id, flag,</span>
<span class="sd">        flag_row, flag_sum, ha (added to axis_info), ifr_number, imaginary,</span>
<span class="sd">        corrected_imaginary, model_imaginary, ratio_imaginary,</span>
<span class="sd">        residual_imaginary, obs_residual_imaginary, last (added to</span>
<span class="sd">        axis_info), phase, corrected_phase, model_phase, ratio_phase,</span>
<span class="sd">        residual_phase, obs_residual_phase, real, corrected_real,</span>
<span class="sd">        ratio_real, residual_real, obs_residual_real, scan_number, sigma,</span>
<span class="sd">        data_desc_id, time, ut (added to axis_info), uvw, u, v, w, uvdist,</span>
<span class="sd">        and weight. Unrecognized items will result in a warning being sent</span>
<span class="sd">        to the logger.  Duplicate items are silently ignored.</span>
<span class="sd">        </span>
<span class="sd">        The record that is returned contains fields that correspond to</span>
<span class="sd">        each of the specified items. Most fields will contain an array. The</span>
<span class="sd">        array may be one, two or three dimensional depending on whether the</span>
<span class="sd">        corresponding row in the measurement set is a scalar, one or two</span>
<span class="sd">        dimensional. Unless the ifraxis argument is set to True the length</span>
<span class="sd">        of the last axis on these arrays will correspond to the number of</span>
<span class="sd">        rows in the selected measurement set.</span>
<span class="sd">        </span>
<span class="sd">        If the ifraxis argument is set to True, the row axis is split into</span>
<span class="sd">        an interferometer axis and a time axis. For example a measurement</span>
<span class="sd">        set with 90 rows, in an array with 6 telescopes (so that there are</span>
<span class="sd">        15 interferometers), may have a data array of shape [4,32,90]</span>
<span class="sd">        if ifraxis is False or [4,32,15,6], if ifraxis is True (assuming</span>
<span class="sd">        there are 4 correlations and 32 channels). If there are missing</span>
<span class="sd">        rows as will happen if not all interferometers where used for all</span>
<span class="sd">        time-slots then a default value will be inserted.</span>
<span class="sd">        </span>
<span class="sd">        This splitting of the row axis may not happen for items where</span>
<span class="sd">        there is only a single value per row. For some items the returned</span>
<span class="sd">        vector will contain only as many values as there are</span>
<span class="sd">        interferometers and it is implicit that the same value should be</span>
<span class="sd">        used for all time slots. The antenna1, antenna2, feed1, feed2, and</span>
<span class="sd">        ifr_number items fall in this category. For other items the</span>
<span class="sd">        returned vector will have as many values as there are time slots</span>
<span class="sd">        and it is implicit that the same value should be used for all</span>
<span class="sd">        interefometers. The field_id, scan_number, data_desc_id, and</span>
<span class="sd">        time items fall into this category.</span>
<span class="sd">        </span>
<span class="sd">        The axis_info item provides data labelling information. It</span>
<span class="sd">        returns a record with the following fields: corr_axis, freq_axis,</span>
<span class="sd">        ifr_axis and time_axis. The latter two fields are not present if</span>
<span class="sd">        ifr_axis is set to False. The corr_axis field contains a string</span>
<span class="sd">        vector with elements like &#39;RR&#39; or &#39;XY&#39; that indicates which</span>
<span class="sd">        polarizations where correlated together to produce the data. The</span>
<span class="sd">        length of this vector will always be the same as the length of the</span>
<span class="sd">        first axis of the data array. The freq_axis field contains a record</span>
<span class="sd">        with two fields, chan_freq and resolution. Each of these fields</span>
<span class="sd">        contains vectors which indicate the centre frequency and spectral</span>
<span class="sd">        resolution (FWHM) of each channel. The length of these vectors will</span>
<span class="sd">        be the same as the length of the second axis in the data. The</span>
<span class="sd">        ifr_axis field contains fields: ifr_number, ifr_name,</span>
<span class="sd">        ifr_shortname, and baseline. The ifr_number is the same as returned</span>
<span class="sd">        by the ifr_item, the ifr_name and ifr_shortname are string vecors</span>
<span class="sd">        containing descriptions of the interferometer and the baseline is</span>
<span class="sd">        the Euclidian distance, in meters between the two antennas. All of</span>
<span class="sd">        these vectors have a length equal to the number of interferometers</span>
<span class="sd">        in the selected measurement set ie., to the length of the third</span>
<span class="sd">        axis in the data when ifraxis is True. The time_axis field contains</span>
<span class="sd">        the MJD seconds field and optionally the HA, UT, and LAST fields.</span>
<span class="sd">        To include the optional fields you need to add the ha, last or ut</span>
<span class="sd">        strings to the list of requested items. All the fields in the</span>
<span class="sd">        time_axis record contain vectors that indicate the time at the</span>
<span class="sd">        midpoint of the observation and are in seconds. The MJD seconds</span>
<span class="sd">        field is since 0 hours on the day having a modified julian day</span>
<span class="sd">        number of zero and the rest are since midnight prior to the start</span>
<span class="sd">        of the observation.</span>
<span class="sd">        </span>
<span class="sd">        An optional gap size can be specified to visually separate groups</span>
<span class="sd">        of interferometers with the same antenna1 index (handy for</span>
<span class="sd">        identifying antennas in an interferometer vs time display). The</span>
<span class="sd">        default is no gap.</span>
<span class="sd">        </span>
<span class="sd">        An optional increment can be specified to return data from every</span>
<span class="sd">        row matching the increment only.</span>
<span class="sd">        </span>
<span class="sd">        When the average flag is set, the data will be averaged over the</span>
<span class="sd">        time axis if the ifraxis is True or the row axis i.e., different</span>
<span class="sd">        interferometers and times may be averaged together. In the latter</span>
<span class="sd">        case, some of the coordinate information, like antenna_id, will</span>
<span class="sd">        no longer make sense.  When all data to be averaged is unflagged,</span>
<span class="sd">        the result is the averaged value and the corresponding flag is</span>
<span class="sd">        False. When all data is flagged, the result is set to zero and the</span>
<span class="sd">        corresponding flag is True.  When data to be averaged is mixed</span>
<span class="sd">        (unflagged and flagged), only the unflagged values are averaged and</span>
<span class="sd">        the flag is set to False.</span>
<span class="sd">        </span>
<span class="sd">        You need to call selectinitold before</span>
<span class="sd">        calling this function. If you haven&#39;t then selectinitold will be</span>
<span class="sd">        called for you with default arguments.</span>
<span class="sd">        </span>
<span class="sd">        Items prefixed with corrected, model, residual or obs_residual are</span>
<span class="sd">        not available unless your measurement set has been processed either</span>
<span class="sd">        with the imager or calibrator tools.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">getdataold</span><span class="p">(</span><span class="n">items</span><span class="p">,</span> <span class="n">ifraxis</span><span class="p">,</span> <span class="n">ifraxisgap</span><span class="p">,</span> <span class="n">increment</span><span class="p">,</span> <span class="n">average</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">putdataold</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">items</span><span class="o">=</span><span class="p">{</span> <span class="p">}):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;DEPRECATED: Please use the ms::putdata() function in place</span>
<span class="sd">        of ms::putdataold().</span>
<span class="sd">        </span>
<span class="sd">        This function allows you to write values from casapy variables back</span>
<span class="sd">        into the measurement set table. The main difference between this</span>
<span class="sd">        and directly accessing the table using the table tool is that this</span>
<span class="sd">        function writes data to the selected measurement set.</span>
<span class="sd">        </span>
<span class="sd">        Unlike the getdataold function you can only put items that</span>
<span class="sd">        correspond to actual table columns. You cannot change the data</span>
<span class="sd">        shape either so that the number of correlations, channels and rows</span>
<span class="sd">        (or intereferometers/time slots) must match the values in the</span>
<span class="sd">        selected measurement set. If the values were obtained using the</span>
<span class="sd">        getdataold function with ifraxis argument set to True, then any</span>
<span class="sd">        default values added to fill in missing intereferometer/timeslots</span>
<span class="sd">        pairs will be ignored when writing the modified values back using</span>
<span class="sd">        this function.</span>
<span class="sd">        </span>
<span class="sd">        Allowable items include:  data, corrected_data, model_data, flag,</span>
<span class="sd">        flag_row, sigma, and weight.</span>
<span class="sd">        </span>
<span class="sd">        The measurement set has to be opened for read/write access to be</span>
<span class="sd">        able to use this function.</span>
<span class="sd">        </span>
<span class="sd">        You need to call selectinitold before</span>
<span class="sd">        calling this function. If you haven&#39;t then selectinitold will be</span>
<span class="sd">        called for you with default arguments.</span>
<span class="sd">        </span>
<span class="sd">        Items prefixed with corrected, model, residual or obs_residual are</span>
<span class="sd">        not available unless your measurement set has been processed either</span>
<span class="sd">        with the imager or calibrator tools.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">putdataold</span><span class="p">(</span><span class="n">items</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">iterinitold</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span>  <span class="p">],</span> <span class="n">interval</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="mf">0.0</span><span class="p">),</span> <span class="n">maxrows</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">adddefaultsortcolumns</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;DEPRECATED: Please use the ms::iterinit() function in place</span>
<span class="sd">        of ms::iterinitold().</span>
<span class="sd">        </span>
<span class="sd">        Specify the columns to iterate over and the time interval to use</span>
<span class="sd">        for the TIME column iteration.  The columns are specified by their</span>
<span class="sd">        MS column name and must contain scalar values.</span>
<span class="sd">        </span>
<span class="sd">        Note that the following columns are always added to the specified</span>
<span class="sd">        columns: array_id, field_id, data_desc_id and time. This is so that</span>
<span class="sd">        the iterator can keep track of the coordinates associated with the</span>
<span class="sd">        data (field direction, frequency, etc.). If you want to sort on</span>
<span class="sd">        these columns last instead of first, you need to include them in</span>
<span class="sd">        the columns specified. If you don&#39;t want to sort on these columns</span>
<span class="sd">        at all, you can set adddefaultsortcolumns to False.</span>
<span class="sd">        </span>
<span class="sd">        You may want to use iteration for a large dataset. After calling</span>
<span class="sd">        iterinitold, you must call iteroriginold before attempting to</span>
<span class="sd">        retrieve data with getdataold.</span>
<span class="sd">        </span>
<span class="sd">        You need to call selectinitold before calling this.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">iterinitold</span><span class="p">(</span><span class="n">columns</span><span class="p">,</span> <span class="n">interval</span><span class="p">,</span> <span class="n">maxrows</span><span class="p">,</span> <span class="n">adddefaultsortcolumns</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">iteroriginold</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;DEPRECATED: Please use the ms::iterorigin() function in place</span>
<span class="sd">        of ms::iteroriginold().</span>
<span class="sd">        </span>
<span class="sd">        Set or reset the iterator to the start of the currently specified</span>
<span class="sd">        iteration. You need to call this after iterinitold, before</span>
<span class="sd">        attempting to retrieve data with getdataold. You may also use</span>
<span class="sd">        iteroriginold to set the iteration back to the start before you</span>
<span class="sd">        reach the end of the data.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">iteroriginold</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">iternextold</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;DEPRECATED: Please use the ms::iternext() function in place</span>
<span class="sd">        of ms::iternextold().</span>
<span class="sd">        </span>
<span class="sd">        This sets the currently selected table (as accessed with</span>
<span class="sd">        getdataold) to the next iteration. If there is no more data, the</span>
<span class="sd">        function returns False and the selection is reset to that before</span>
<span class="sd">        the iteration started.  You need to call iterinitold and</span>
<span class="sd">        iteroriginold before calling this.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">iternextold</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">iterendold</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;DEPRECATED: Please use the ms::iterend() function in place</span>
<span class="sd">        of ms::iterendold().</span>
<span class="sd">        </span>
<span class="sd">        This sets the currently selected table (as accessed with</span>
<span class="sd">        getdataold) to the table that was selected</span>
<span class="sd">        before iteration started.  Use this to end the iteration</span>
<span class="sd">        prematurely.  There is no need to call this if you continue</span>
<span class="sd">        iterating until iternextold returns False.</span>
<span class="sd">        </span>
<span class="sd">        See the example below.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">iterendold</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">continuumsubold</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">field</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">fitspw</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">spw</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">solint</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">fitorder</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;subtract&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;DEPRECATED: This function is deprecated and will be removed in an</span>
<span class="sd">        upcoming release.</span>
<span class="sd">        </span>
<span class="sd">        This function provides a means of continuum determination and</span>
<span class="sd">        subtraction by fitting a polynomial of desired order to a subset</span>
<span class="sd">        of channels in each time-averaged uv spectrum.  The fit is used</span>
<span class="sd">        to model the continuum in all channels (not just those used in</span>
<span class="sd">        the fit), for subtraction, if desired.  Use the fitspw parameter</span>
<span class="sd">        to limit the spectral windows processed and the range of channels</span>
<span class="sd">        used to estimate the continuum  in each (avoid channels</span>
<span class="sd">        containing spectral lines).  The default solution interval &#39;int&#39;</span>
<span class="sd">        will result in per-integration continuum fits for each baseline.</span>
<span class="sd">        The mode parameter indicates how the continuum model (the result</span>
<span class="sd">        of the fit) should be used: &#39;subtract&#39; will store the continuum</span>
<span class="sd">        model in the MODEL_DATA column and subtract it from the</span>
<span class="sd">        CORRECTED_DATA column; &#39;replace&#39; will replace the CORRECTED_DATA</span>
<span class="sd">        column with the continuum model (useful if you want to image the</span>
<span class="sd">        continuum model result); and &#39;model&#39; will only store the</span>
<span class="sd">        continuum model in the MODEL_DATA column (the CORRECTED_DATA is</span>
<span class="sd">        unaffected).</span>
<span class="sd">        </span>
<span class="sd">        It is important to open the dataset with nomodify=False so that</span>
<span class="sd">        changes will be allowed (see example below).</span>
<span class="sd">        </span>
<span class="sd">        For now, the only way to recover the un-subtracted CORRECTED_DATA</span>
<span class="sd">        column is to use calibrater.correct() again.</span>
<span class="sd">        </span>
<span class="sd">        Note that the MODEL_DATA and CORRECTED_DATA columns must be</span>
<span class="sd">        present for continuumsubold to work correctly.  The function will</span>
<span class="sd">        warn the user if they are not present, and abort.  To add these</span>
<span class="sd">        scratch columns, close the ms tool, then start a calibrater or an</span>
<span class="sd">        imager tool, which will add the scratch columns.  Then restart</span>
<span class="sd">        the ms tool, and try continuumsubold again.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">continuumsubold</span><span class="p">(</span><span class="n">field</span><span class="p">,</span> <span class="n">fitspw</span><span class="p">,</span> <span class="n">spw</span><span class="p">,</span> <span class="n">solint</span><span class="p">,</span> <span class="n">fitorder</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020–2024, Pipeline Dev. Team.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>