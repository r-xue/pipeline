

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>casatools.calibrater &mdash; Pipeline unknown documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css?v=4ae1632d" />
      <link rel="stylesheet" type="text/css" href="../../_static/custom_theme.css?v=678032d9" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=3f1b9271"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            Pipeline
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Releases etc.</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../releases.html">Past Releases</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dependencies.html">Dependencies of <code class="docutils literal notranslate"><span class="pre">Pipeline</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modular.html">Run the Pipeline in a Conda environment</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../apisummary.html">Pipeline Tasks (from autosummary)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../apisummary.html#full-list">Full List</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">TaskRef (create_docs.py)</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../_taskdocs/taskdocs.html">List of Heuristics Tasks (Pipeline 2023)</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Pipeline Heuristics</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../heuristics/field_parameter.html">Field parameter</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../heuristics/FlaggingTasks.html">Pipeline Flagging Tasks</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Developer Notes</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../develdocmd/ways_to_run_the_pipeline.html">Ways to run the Pipeline</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../develdocmd/comparing_pipeline_executions.html">Comparing pipeline executions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../develdocmd/building_the_pipeline.html">Building the pipeline</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../develdocmd/ALMA-Imaging-Workflow.html">ALMA interferometry imaging workflow</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../develdocmd/VLA-Imaging-Workflow.html">VLA interferometry imaging workflow</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../develdocmd/VLASS-SE-CONT-Imaging-Workflow.html">VLASS-SE-CONT imaging workflow</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../develdocmd/VLASS-SE-CUBE-Imaging-Workflow.html">VLASS-SE-CUBE imaging workflow</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../develdocmd/selfcal_workflow.html">VLASS Selfcal &amp; Restore workflows</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../develdocmd/pipeline_tests.html">Pipeline testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../develdocmd/DataType_Testing.html">DataType Testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../develdocmd/QA_scores.html">Pipeline Quality Assurance (QA) Score Class Design</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../develdocmd/DeveloperDocumentation.html">Pipeline developer documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../develdocmd/python3_conversion_notes.html">Python 3 conversion notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../develdocmd/recipes.html">Pipeline Recipes</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Pipeline Domain/Context (automodapi)</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../basics.html"><code class="docutils literal notranslate"><span class="pre">pipeline.domain</span></code> module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../basics.html#module-pipeline.infrastructure.launcher"><code class="docutils literal notranslate"><span class="pre">pipeline.infrastructure.launcher</span></code> module</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Pipeline Domain/Context (autosummary)</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../_autosummary/pipeline.domain.html">pipeline.domain</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../_autosummary/pipeline.infrastructure.launcher.html">pipeline.infrastructure.launcher</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Pipeline Task/Inputs/Results Classes</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../classes.html">Classes in <code class="docutils literal notranslate"><span class="pre">pipeline.h*.tasks</span></code> modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../classes.html#inheritance-diagrams">Inheritance Diagrams</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Examples Notes (from Jupyter Notebooks)</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../examples/test1.html">test</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Example Notes (from .rst)</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../examples/test2.html">Example 1</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Pipeline</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">casatools.calibrater</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for casatools.calibrater</h1><div class="highlight"><pre>
<span></span><span class="c1">##################### generated by xml-casa (v2) from calibrater.xml ################</span>
<span class="c1">##################### ee9c1ac0f041f6fd47b9ac2de7b642f1 ##############################</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">absolute_import</span> 
<span class="kn">from</span> <span class="nn">.__casac__.calibrater</span> <span class="kn">import</span> <span class="n">calibrater</span> <span class="k">as</span> <span class="n">_calibrater</span>

<span class="kn">from</span> <span class="nn">.errors</span> <span class="kn">import</span> <span class="n">create_error_string</span>
<span class="kn">from</span> <span class="nn">.typecheck</span> <span class="kn">import</span> <span class="n">CasaValidator</span> <span class="k">as</span> <span class="n">_validator</span>
<span class="n">_pc</span> <span class="o">=</span> <span class="n">_validator</span><span class="p">(</span> <span class="p">)</span>
<span class="kn">from</span> <span class="nn">.coercetype</span> <span class="kn">import</span> <span class="n">coerce</span> <span class="k">as</span> <span class="n">_coerce</span>


<span class="k">class</span> <span class="nc">calibrater</span><span class="p">:</span>
    <span class="n">_info_group_</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;calibrater&quot;&quot;&quot;</span>
    <span class="n">_info_desc_</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;Synthesis calibration (self- and cross-)&quot;&quot;&quot;</span>
    <span class="c1">### self</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a {tt calibrater} tool.  The casapy environment provides</span>
<span class="sd">        a standard calibrater tool for general use (cb), but additional calibrater</span>
<span class="sd">        tools may be created if needed.  Calibrater tools created in this way</span>
<span class="sd">        are independent of the standard calibrater tool.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;swig_object&#39;</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span> <span class="o">=</span> <span class="n">_calibrater</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">open</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">compress</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">addcorr</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">addmodel</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Attaches a MeasurementSet to the {tt calibrater} tool for further processing with</span>
<span class="sd">        other methods.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">compress</span><span class="p">,</span> <span class="n">addcorr</span><span class="p">,</span> <span class="n">addmodel</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">selectvis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">spw</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">scan</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">field</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">intent</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">observation</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">baseline</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">uvrange</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">chanmode</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">,</span> <span class="n">nchan</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">start</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">step</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">mstart</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="mf">0.0</span><span class="p">),</span> <span class="s1">&#39;unit&#39;</span><span class="p">:</span> <span class="s1">&#39;km/s&#39;</span><span class="p">},</span> <span class="n">mstep</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="mf">0.0</span><span class="p">),</span> <span class="s1">&#39;unit&#39;</span><span class="p">:</span> <span class="s1">&#39;km/s&#39;</span><span class="p">},</span> <span class="n">msselect</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function provids for selection of the visibility data from the MS</span>
<span class="sd">        which will be treated by subsequent execution of the {stfaf solve} and</span>
<span class="sd">        {stfaf correct} functions.  Note that data selection is not cumulative, i.e.,</span>
<span class="sd">        any selection made in a previous call to {stfaf selectvis} will be overridden</span>
<span class="sd">        by the the current call.</span>
<span class="sd">        </span>
<span class="sd">        Most of the {stfaf selectvis} parameters use the standardized MS Selection</span>
<span class="sd">        syntax.</span>
<span class="sd">        </span>
<span class="sd">        The parameters are described below.  The selected data will satisfy the</span>
<span class="sd">        logical AND of all non-trivially specified parameters.  Note that the</span>
<span class="sd">        old-fashioned strided channel selection parameters are deprecated (and</span>
<span class="sd">        will soon be removed); use spw instead.  Running {stfaf selectvis} with</span>
<span class="sd">        no specified parameters restores selection of the entire MS.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        begin{description}</span>
<span class="sd">        item[time] is used to specify time ranges in a stardard format</span>
<span class="sd">        </span>
<span class="sd">        item[spw] is used to specify spectral window and channel selection.  Currently,</span>
<span class="sd">        only a single channel range can be specified per spw.</span>
<span class="sd">        </span>
<span class="sd">        item[scan] is used to specify scan numbers and ranges</span>
<span class="sd">        </span>
<span class="sd">        item[observation] is used to specify observation ID(s).</span>
<span class="sd">        </span>
<span class="sd">        item[field] is used to specify field names or indices</span>
<span class="sd">        </span>
<span class="sd">        item[baseline] is used to specify antenna and baseline combinations</span>
<span class="sd">        </span>
<span class="sd">        item[uvrange] is used to specify baseline length ranges</span>
<span class="sd">        </span>
<span class="sd">        item[chanmode] is deprecated (use spw)</span>
<span class="sd">        item[nchan] is deprecated (use spw)</span>
<span class="sd">        item[start] is deprecated (use spw)</span>
<span class="sd">        item[step] is deprecated (use spw)</span>
<span class="sd">        item[mstart] is deprecated (use spw)</span>
<span class="sd">        item[mstep] is deprecated (use spw)</span>
<span class="sd">        </span>
<span class="sd">        item[msselect] is used to specify a subselection of data according to</span>
<span class="sd">        Measurement Set columns in conditional combinations not possible</span>
<span class="sd">        with the standard parameters above.  This parameter should be specified</span>
<span class="sd">        as a valid htmladdnormallink{TaQL}{../../notes/199/199.html} expression.</span>
<span class="sd">        If both msselect and the standard selection parameter are used together,</span>
<span class="sd">        they are combined with a logical AND, i.e., the data must jointly satisfy</span>
<span class="sd">        all {stfaf selectvis} parameters.</span>
<span class="sd">        </span>
<span class="sd">        end{description}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">selectvis</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">spw</span><span class="p">,</span> <span class="n">scan</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">intent</span><span class="p">,</span> <span class="n">observation</span><span class="p">,</span> <span class="n">baseline</span><span class="p">,</span> <span class="n">uvrange</span><span class="p">,</span> <span class="n">chanmode</span><span class="p">,</span> <span class="n">nchan</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span> <span class="n">mstart</span><span class="p">,</span> <span class="n">mstep</span><span class="p">,</span> <span class="n">msselect</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">setmodel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">modelimage</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Name of the model image to be used as a sky model for model visibility</span>
<span class="sd">        computations.  For now, this is used only by EP-Jones solver.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">setmodel</span><span class="p">(</span><span class="n">modelimage</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">setptmodel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stokes</span><span class="o">=</span><span class="p">[</span> <span class="nb">float</span><span class="p">(</span><span class="mf">0.0</span><span class="p">),</span><span class="nb">float</span><span class="p">(</span><span class="mf">0.0</span><span class="p">),</span><span class="nb">float</span><span class="p">(</span><span class="mf">0.0</span><span class="p">),</span><span class="nb">float</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span> <span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set a global point source model Stokes parameters to use in solving operations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">setptmodel</span><span class="p">(</span><span class="n">stokes</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">setapply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="mf">0.0</span><span class="p">),</span> <span class="n">table</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">field</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">interp</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="n">select</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">calwt</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">spwmap</span><span class="o">=</span><span class="p">[</span> <span class="nb">int</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">],</span> <span class="n">opacity</span><span class="o">=</span><span class="p">[</span> <span class="nb">float</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span> <span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function is used to specify the calibration components which should be</span>
<span class="sd">        applied during subsequent execution of the {stfaf solve} and</span>
<span class="sd">        {stfaf correct} functions.  This function should be executed as many</span>
<span class="sd">        times as necessary to specify all desired calibration components.</span>
<span class="sd">        </span>
<span class="sd">        Each calibration component represents a separate calibration matrix</span>
<span class="sd">        correction included in the measurement equation. The different types</span>
<span class="sd">        correspond to different instrumental and atmospheric effects.</span>
<span class="sd">        Calibration components are available as calibration tables generated</span>
<span class="sd">        by previous {stfaf solve} executions (types &#39;B&#39;,&#39;BPOLY&#39;,&#39;G&#39;,&#39;GSPLINE&#39;,</span>
<span class="sd">        &#39;D&#39;,&#39;DF&#39;,&#39;T&#39;,&#39;M&#39;,&#39;MF&#39;,&#39;X&#39;), or are calculated analytically on</span>
<span class="sd">        the fly (types &#39;P&#39;, &#39;TOPAC&#39;, &#39;GAINCURVE&#39;).  Upon execution</span>
<span class="sd">        of {stfaf solve} or {stfaf correct}, the group of specified</span>
<span class="sd">        calibration components will be applied in the order prescribed</span>
<span class="sd">        by the Measurement Equation formalism.</span>
<span class="sd">        </span>
<span class="sd">        The parameters are as follows:</span>
<span class="sd">        </span>
<span class="sd">        begin{description}</span>
<span class="sd">        </span>
<span class="sd">        item[type] The calibration type being specified.  This is only required</span>
<span class="sd">        for analytic types (&#39;P&#39;,&#39;TOPAC&#39;,&#39;GAINCURVE&#39;).  When specifying an existing</span>
<span class="sd">        pre-solved calibration table, it is not necessary to explicitly specify the</span>
<span class="sd">        {stfaf type}; this will be discerned from the table.  (Specifying the</span>
<span class="sd">        {stfaf type} as well as the {stfaf table} will force a check that the</span>
<span class="sd">        table contains solutions of the specified type.</span>
<span class="sd">        </span>
<span class="sd">        For {stfaf type=&#39;GAINCURVE&#39;}, an elevation-dependent correction</span>
<span class="sd">        will be applied using parameters read from the data repository.</span>
<span class="sd">        Currently, this is only supported for the VLA.</span>
<span class="sd">        </span>
<span class="sd">        item[t] This parameter will be used in a future release to control</span>
<span class="sd">        the range of applicability of the specified calibration.  Currently,</span>
<span class="sd">        it is ignored.</span>
<span class="sd">        </span>
<span class="sd">        item[table] For pre-solved calibration, the file name of the table</span>
<span class="sd">        to apply.</span>
<span class="sd">        </span>
<span class="sd">        item[field] The fields to select from the specified table, using</span>
<span class="sd">        MS Selection syntax (as in selectvis).</span>
<span class="sd">        </span>
<span class="sd">        item[interp] The desired type of time-dependent interpolation.  Use</span>
<span class="sd">        {stfaf interp=&#39;nearest&#39;} to calibrate each datum with the calibration</span>
<span class="sd">        value nearest in time.  Use {stfaf interp=&#39;linear&#39;} to calibrate each</span>
<span class="sd">        datum with calibration phases and amplitudes linearly interpolated</span>
<span class="sd">        from neighboring (in time) values.  In the case of phase, this mode</span>
<span class="sd">        will assume that phase jumps greater than 180 degrees between neighboring</span>
<span class="sd">        points indicate a cycle slip, and the interpolated value will follow</span>
<span class="sd">        this change in cycle accordingly (i.e., the implied rate will always</span>
<span class="sd">        be less than 180 degrees per sample).  Use {stfaf interp=&#39;aipslin&#39;}</span>
<span class="sd">        to emulate the basic interpolation mode used in classic AIPS, i.e.,</span>
<span class="sd">        linearly interpolated amplitudes, with phases derived from linear</span>
<span class="sd">        interpolation of the complex calibration values.  While this method</span>
<span class="sd">        avoids having to track cycle slips (which is unstable for solutions</span>
<span class="sd">        with very low SNR), it will yield a phase interpolation which becomes</span>
<span class="sd">        increasingly non-linear as the spanned phase difference increases.  The</span>
<span class="sd">        non-linearity mimics the behavior of {stfaf interp=&#39;nearest&#39;} as</span>
<span class="sd">        the spanned phase difference approaches 180 degrees (the phase of the</span>
<span class="sd">        interpolated complex calibration value initially changes very slowly,</span>
<span class="sd">        then rapidly jumps to the second value at the midpoint of the interval).</span>
<span class="sd">        If the uncalibrated phase is changing this rapidly, a &#39;nearest&#39; interpolation</span>
<span class="sd">        is not desirable.  Usually, {stfaf interp=&#39;linear&#39;} is the best choice.</span>
<span class="sd">        The {stfaf interp} parameter is applicable to any calibration type,</span>
<span class="sd">        as long as there are sufficient solutions available to perform the</span>
<span class="sd">        interpolation.  Note that calibration solutions which have been</span>
<span class="sd">        determined for only one timestamp will default to &#39;nearest&#39;.  More</span>
<span class="sd">        interpolation options (e.g., &#39;cubic&#39;) will be added in the future.</span>
<span class="sd">        </span>
<span class="sd">        item[select] Used to specify general selection of a subset of</span>
<span class="sd">        calibration measurements from the table to be applied to the</span>
<span class="sd">        visibility data.  Arbitrary cross-calibration is possible by combining</span>
<span class="sd">        this function with the {stfaf setdata} function.  The string</span>
<span class="sd">        specified must be a valid htmladdnormallink{TaQL}{../../notes/199/199.html}</span>
<span class="sd">        expression.</span>
<span class="sd">        </span>
<span class="sd">        item[spwmap] This parameter is used to indicate how solutions</span>
<span class="sd">        derived from different spectral windows should be applied to other</span>
<span class="sd">        spectral windows.  Nominally, data in each spectral window will be</span>
<span class="sd">        corrected by solutions derived from the same spectral window.  This is</span>
<span class="sd">        the default behavior of {stfaf spwmap}, i.e., if {stfaf spwmap} is</span>
<span class="sd">        not specified, calibrater will insist that data be corrected by</span>
<span class="sd">        solutions from the same spw.  Otherwise, {stfaf spwmap} takes a</span>
<span class="sd">        vector of integers indicating which spectral window {em solutions} to</span>
<span class="sd">        apply to which spectral window {em data}, such that {tt spwmap[j]=i}</span>
<span class="sd">        causes solutions derived from the i-th spectral window to be used to</span>
<span class="sd">        correct the j-th spectral window.  For example, if (say) bandpass</span>
<span class="sd">        solutions are available for spws 0 &amp; 2, and it is desired that these</span>
<span class="sd">        be applied to spws 1 &amp; 3 (as well as 0 &amp; 2), respectively, use</span>
<span class="sd">        {stfaf spwmap=[0,0,2,2]}.  Even if some spws do not require an</span>
<span class="sd">        explicit {stfaf spwmap} setting, yet one or more does, it is safest</span>
<span class="sd">        to specify it explicitly for all, e.g., {stfaf spwmap=[0,1,3,3]}</span>
<span class="sd">        indicates that spw 2 will be corrected with solutions from spw 3, and</span>
<span class="sd">        the others will behave nominally.  Note that if no solutions exist</span>
<span class="sd">        for any of the spws specified in {stfaf spwmap}, an error message</span>
<span class="sd">        will result.</span>
<span class="sd">        </span>
<span class="sd">        item[calwt] If set True, the data weights will be calibrated</span>
<span class="sd">        along with the data.  This is usually desirable.</span>
<span class="sd">        </span>
<span class="sd">        item[opacity] For {stfaf type=&#39;TOPAC&#39;}, an elevation-dependent</span>
<span class="sd">        opacity correction will be applied according to the zenith opacity value</span>
<span class="sd">        supplied in the {stfaf opacity} parameter.  Currently, only one zenith</span>
<span class="sd">        opacity value can be supplied, and it is used for all antennas.</span>
<span class="sd">        </span>
<span class="sd">        end{description}</span>
<span class="sd">        </span>
<span class="sd">        Use the {stfaf state} function to review the list of calibration</span>
<span class="sd">        components that have been set for application.</span>
<span class="sd">        </span>
<span class="sd">        Pending improvements:</span>
<span class="sd">        </span>
<span class="sd">        begin{itemize}</span>
<span class="sd">        item Enable variety of interpolation modes and timescales</span>
<span class="sd">        item Allow for antenna- and time-dependent opacities</span>
<span class="sd">        end{itemize}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">setapply</span><span class="p">(</span><span class="nb">type</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">table</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">interp</span><span class="p">,</span> <span class="n">select</span><span class="p">,</span> <span class="n">calwt</span><span class="p">,</span> <span class="n">spwmap</span><span class="p">,</span> <span class="n">opacity</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">setcallib</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callib</span><span class="o">=</span><span class="p">{</span> <span class="p">}):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;TBD</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">setcallib</span><span class="p">(</span><span class="n">callib</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">validatecallib</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callib</span><span class="o">=</span><span class="p">{</span> <span class="p">}):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;TBD</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">validatecallib</span><span class="p">(</span><span class="n">callib</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">setsolve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s1">&#39;MF&#39;</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">table</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">preavg</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="p">),</span> <span class="n">phaseonly</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">apmode</span><span class="o">=</span><span class="s1">&#39;AP&#39;</span><span class="p">,</span> <span class="n">refant</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">refantmode</span><span class="o">=</span><span class="s1">&#39;flex&#39;</span><span class="p">,</span> <span class="n">minblperant</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="n">solnorm</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">normtype</span><span class="o">=</span><span class="s1">&#39;mean&#39;</span><span class="p">,</span> <span class="n">minsnr</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="mf">0.0</span><span class="p">),</span> <span class="n">combine</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">fillgaps</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">cfcache</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">painc</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="mf">360.0</span><span class="p">),</span> <span class="n">fitorder</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">fraction</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="mf">0.1</span><span class="p">),</span> <span class="n">numedge</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">radius</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">smooth</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">zerorates</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">globalsolve</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">niter</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">100</span><span class="p">),</span> <span class="n">corrcomb</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">,</span> <span class="n">delaywindow</span><span class="o">=</span><span class="p">[</span>  <span class="p">],</span> <span class="n">ratewindow</span><span class="o">=</span><span class="p">[</span>  <span class="p">],</span> <span class="n">paramactive</span><span class="o">=</span><span class="p">[</span>  <span class="p">],</span> <span class="n">concatspws</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">solmode</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">rmsthresh</span><span class="o">=</span><span class="p">[</span>  <span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function specifies the calibration component that will be solved for</span>
<span class="sd">        by the {stff solve} function.  Currently, only one type can</span>
<span class="sd">        be solved for at one time.</span>
<span class="sd">        </span>
<span class="sd">        Each calibration component represents a separate calibration matrix</span>
<span class="sd">        correction included in the measurement equation. The different types</span>
<span class="sd">        correspond to different instrumental and atmospheric effects.</span>
<span class="sd">        Currently, the solvable calibration components are types &#39;G&#39;,&#39;T&#39;,&#39;B&#39;, &#39;D&#39;</span>
<span class="sd">        and &#39;DF&#39;, which are antenna-based, and, &#39;M&#39; and &#39;MF&#39;, which are</span>
<span class="sd">        baseline-based.  Arrange to pre-apply any existing calibration components (of</span>
<span class="sd">        types other than the solved-for one) using the {stfaf setapply}</span>
<span class="sd">        function.</span>
<span class="sd">        </span>
<span class="sd">        The parameters are:</span>
<span class="sd">        </span>
<span class="sd">        begin{description}</span>
<span class="sd">        item[type] Specify the calibration type you want to solve for, from</span>
<span class="sd">        &#39;G&#39;,&#39;T&#39;,&#39;B&#39;,&#39;D&#39;,&#39;DF&#39;,&#39;M&#39;,&#39;MF&#39;.</span>
<span class="sd">        </span>
<span class="sd">        item[t] Specify the solution interval.  This can be specified as an</span>
<span class="sd">        integer (units of seconds assumed) or as a string containing a value</span>
<span class="sd">        and units (e.g., &#39;30s&#39;, &#39;45min&#39;, &#39;2h&#39;) or &#39;inf&#39; (infinite) or &#39;int&#39;</span>
<span class="sd">        (per data integration).  A solution interval of 0 (with or without</span>
<span class="sd">        units) is the same as &#39;int&#39; (per integration), and negative solution</span>
<span class="sd">        intervals are treated as &#39;inf&#39; (infinite).</span>
<span class="sd">        </span>
<span class="sd">        item[table] Specify the output calibration table name in which to</span>
<span class="sd">        store the calibration solve result.  Existing tables will be</span>
<span class="sd">        deleted and replaced.</span>
<span class="sd">        </span>
<span class="sd">        item[append] Append the solutions to an existing table.</span>
<span class="sd">        </span>
<span class="sd">        item[preavg] Specify the amount of pre-average (in time) within</span>
<span class="sd">        the solution interval.  By default, data are averaged up to</span>
<span class="sd">        the solution interval (or up to 5 minutes for &#39;D&#39; solving).</span>
<span class="sd">        </span>
<span class="sd">        item[phaseonly] This parameter is deprecated, use apmode.</span>
<span class="sd">        </span>
<span class="sd">        item[apmode] Control generation of amplitude-only (&#39;a&#39;),</span>
<span class="sd">        phase-only (&#39;p&#39;), or amplitude-and-phase (&#39;ap&#39;, the default) solutions.</span>
<span class="sd">        </span>
<span class="sd">        item[refant] Specify an antenna (using data selection syntax)</span>
<span class="sd">        for referencing the solutions.</span>
<span class="sd">        </span>
<span class="sd">        item[solnorm] Normalize the solutions by their mean post-solve. For</span>
<span class="sd">        &#39;B&#39;, and &#39;MF&#39;, this is a complex normalization per solution spectrum.</span>
<span class="sd">        For other types, this is a global (per-spw) normalization of the</span>
<span class="sd">        amplitudes only.</span>
<span class="sd">        </span>
<span class="sd">        item[minsnr] Specify the SNR below which solution are rejected.</span>
<span class="sd">        </span>
<span class="sd">        item[combine] Specify which data axes (spw, field, scan, or some</span>
<span class="sd">        combination) on which the data should be combined to generate</span>
<span class="sd">        a single solution.  E.g., combine=&#39;spw&#39; will force combination</span>
<span class="sd">        of many spws to form a single solution (per solution interval).</span>
<span class="sd">        Similarly, combine=&#39;scan&#39; with a long solution interval</span>
<span class="sd">        will force the combination of scans to yield individual solutions</span>
<span class="sd">        (per field and spw).  Ordinarily, solutions are always broken</span>
<span class="sd">        at scans boundaries.  Separate multiple combine options with</span>
<span class="sd">        commas.</span>
<span class="sd">        </span>
<span class="sd">        item[fillgaps] For &#39;B&#39; solutions, specify the largest solution</span>
<span class="sd">        channel gap (which arise due to flagged data) that will be filled</span>
<span class="sd">        post-solve via interpolation.  Such solution gaps remain flagged</span>
<span class="sd">        by default.</span>
<span class="sd">        </span>
<span class="sd">        end{description}</span>
<span class="sd">        </span>
<span class="sd">        Pending improvements:</span>
<span class="sd">        </span>
<span class="sd">        begin{itemize}</span>
<span class="sd">        item{Change t to solint?}</span>
<span class="sd">        item{Permit flexible specification of preavg (as for t)}</span>
<span class="sd">        end{itemize}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">setsolve</span><span class="p">(</span><span class="nb">type</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">table</span><span class="p">,</span> <span class="n">append</span><span class="p">,</span> <span class="n">preavg</span><span class="p">,</span> <span class="n">phaseonly</span><span class="p">,</span> <span class="n">apmode</span><span class="p">,</span> <span class="n">refant</span><span class="p">,</span> <span class="n">refantmode</span><span class="p">,</span> <span class="n">minblperant</span><span class="p">,</span> <span class="n">solnorm</span><span class="p">,</span> <span class="n">normtype</span><span class="p">,</span> <span class="n">minsnr</span><span class="p">,</span> <span class="n">combine</span><span class="p">,</span> <span class="n">fillgaps</span><span class="p">,</span> <span class="n">cfcache</span><span class="p">,</span> <span class="n">painc</span><span class="p">,</span> <span class="n">fitorder</span><span class="p">,</span> <span class="n">fraction</span><span class="p">,</span> <span class="n">numedge</span><span class="p">,</span> <span class="n">radius</span><span class="p">,</span> <span class="n">smooth</span><span class="p">,</span> <span class="n">zerorates</span><span class="p">,</span> <span class="n">globalsolve</span><span class="p">,</span> <span class="n">niter</span><span class="p">,</span> <span class="n">corrcomb</span><span class="p">,</span> <span class="n">delaywindow</span><span class="p">,</span> <span class="n">ratewindow</span><span class="p">,</span> <span class="n">paramactive</span><span class="p">,</span> <span class="n">concatspws</span><span class="p">,</span> <span class="n">solmode</span><span class="p">,</span> <span class="n">rmsthresh</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">setsolvegainspline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">table</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;PHAS&#39;</span><span class="p">,</span> <span class="n">splinetime</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="mi">10800</span><span class="p">),</span> <span class="n">preavg</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="mf">0.0</span><span class="p">),</span> <span class="n">npointaver</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span> <span class="n">phasewrap</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="mi">250</span><span class="p">),</span> <span class="n">refant</span><span class="o">=</span><span class="p">[</span> <span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function is a specialization of the {stfaf setsolve} method which</span>
<span class="sd">        should be used when cubic spline G solutions are desired, e.g., when</span>
<span class="sd">        SNR on calibrators is very low.  Currently, this solving mode treats</span>
<span class="sd">        dual polarization data on a per-polarization basis.  The option to</span>
<span class="sd">        obtain a joint solution (a la &#39;T&#39;) will be provided in the future.</span>
<span class="sd">        </span>
<span class="sd">        The visibility data are averaged in frequency (for multi-channel data)</span>
<span class="sd">        prior to the solution.</span>
<span class="sd">        </span>
<span class="sd">        This method uses many of the basic parameters as the generic</span>
<span class="sd">        {stfaf setsolve}.  Parameters unique to the spline solver are:</span>
<span class="sd">        </span>
<span class="sd">        begin{description}</span>
<span class="sd">        </span>
<span class="sd">        item[mode] For phase solutions only, use {stfaf mode=&#39;PHAS&#39;}.  For</span>
<span class="sd">        amplitude solutions only, use {stfaf mode=&#39;AMP&#39;}.  If both are</span>
<span class="sd">        desired, use {stfaf mode=&#39;PHASAMP&#39;}, and both will be solved for</span>
<span class="sd">        using the same spline timescale (this mode also assumes that all</span>
<span class="sd">        calibrators have the correct relative flux densities).  If solving for</span>
<span class="sd">        phase and amplitude separately (usually in this order), it is usually</span>
<span class="sd">        desirable to apply the first one when solving for the second</span>
<span class="sd">        one. Spline solution so obtained will be stored in separate</span>
<span class="sd">        calibration tables.  In the near future, the {stfaf mode} parameter</span>
<span class="sd">        will be consolidated with the generic {stfaf apmode} parameter.</span>
<span class="sd">        </span>
<span class="sd">        item[splinetime] The spline timescale (time between knots) is</span>
<span class="sd">        specified here. The default is 10800 seconds (3 hours).  In future</span>
<span class="sd">        this parameter will be consolidated with the generic {stfaf t}</span>
<span class="sd">        parameter.  The {stfaf preavg} parameter should be set to a value at</span>
<span class="sd">        least 4X shorter than the spline time (an error will occur if there is</span>
<span class="sd">        insufficient sampling within the {stfaf splinetime} timescale), and</span>
<span class="sd">        consistent with the expected coherence.  Consistent with these constraints,</span>
<span class="sd">        use the largest possible value for {stfaf preavg} to optimize the SNR of</span>
<span class="sd">        the pre-solve phase-tracking algorithm.</span>
<span class="sd">        </span>
<span class="sd">        item[npointaver and phasewrap] These parameters tune the</span>
<span class="sd">        phase-unwrapping algorithm when {stfaf mode $=$ &#39;PHAS&#39;}.  Cycle slips</span>
<span class="sd">        are detected (and removed before the spline solve) when the median</span>
<span class="sd">        phase a sequence of length {stfaf npointaver} (in integrations)</span>
<span class="sd">        differs by more than {stfaf phasewrap} degrees from the previous</span>
<span class="sd">        sequence.</span>
<span class="sd">        </span>
<span class="sd">        end{description}</span>
<span class="sd">        </span>
<span class="sd">        Pending improvements:</span>
<span class="sd">        </span>
<span class="sd">        begin{itemize}</span>
<span class="sd">        item Consolidate more parameters with the generic {stfaf setsolve}</span>
<span class="sd">        item Introduce the generic combine options</span>
<span class="sd">        item Improve phase-tracking algorithm</span>
<span class="sd">        end{itemize}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">setsolvegainspline</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">append</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">splinetime</span><span class="p">,</span> <span class="n">preavg</span><span class="p">,</span> <span class="n">npointaver</span><span class="p">,</span> <span class="n">phasewrap</span><span class="p">,</span> <span class="n">refant</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">setsolvebandpoly</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">table</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">combine</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">degamp</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">degphase</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">visnorm</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">solnorm</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">maskcenter</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">maskedge</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="mf">5.0</span><span class="p">),</span> <span class="n">refant</span><span class="o">=</span><span class="p">[</span> <span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function is a specialization of the {stfaf setsolve} method</span>
<span class="sd">        which should be used to arrange for bandpass solving when polynomial</span>
<span class="sd">        solutions for B are desired, e.g., when per-channel SNR on calibrators</span>
<span class="sd">        is too low to obtain a useful sampled bandpass.</span>
<span class="sd">        </span>
<span class="sd">        Prior to the solution, the visibility data are averaged in time,</span>
<span class="sd">        and the solution is performed for both phase and amplitude.</span>
<span class="sd">        </span>
<span class="sd">        This method uses most of the same parameters as the generic</span>
<span class="sd">        {stfaf setsolve}, with a few unique additions:</span>
<span class="sd">        </span>
<span class="sd">        begin{description}</span>
<span class="sd">        </span>
<span class="sd">        item[degamp and degphase] The parameters permit specification</span>
<span class="sd">        of the polynomial order to use in amp and phase.  Specifying</span>
<span class="sd">        0 (zero) yields constant solutions.</span>
<span class="sd">        </span>
<span class="sd">        item[visnorm] This parameter is used to normalize the assembled</span>
<span class="sd">        spectral data, in a per baseline manner.  If set True, this will have</span>
<span class="sd">        the effect of removing any non-frequency-dependent closure errors</span>
<span class="sd">        (e.g., as caused by source structure, or introduced by the instrument)</span>
<span class="sd">        from the data, and should be used with caution.  The resulting</span>
<span class="sd">        solutions will be effectively normalized as well.  When {stfaf</span>
<span class="sd">        visnorm=F} is used, closure errors in the data (as supplied to the</span>
<span class="sd">        solver) may be visible in the form of offsets between the data and</span>
<span class="sd">        solutions.  For bandpass calibration, this is usually ok, as the {em</span>
<span class="sd">        shape} of the bandpass is the most important aspect of the solution.</span>
<span class="sd">        In future this parameter will be generalized and made available</span>
<span class="sd">        for other solve types. (NB: Use of {stfaf solnorm=True} still</span>
<span class="sd">        provides for post-solve normalization of the solutions.)</span>
<span class="sd">        </span>
<span class="sd">        item[maskcenter and maskedge] These parameters control how many</span>
<span class="sd">        channels are ignored on-the-fly, at the center and edges of each input</span>
<span class="sd">        spectral window, respectively.  To avoid edge channels, it is almost</span>
<span class="sd">        always better to flag these channels directly, or select against them</span>
<span class="sd">        in {stfaf setdata}.  Aggressive use of maskedge (large values), will</span>
<span class="sd">        yield polynomial solutions which will tend to diverge at the edges</span>
<span class="sd">        (especially when the polynomial degree is also high), because maskedge</span>
<span class="sd">        does not change the frequency domain of the solutions.  Such solutions</span>
<span class="sd">        should be used with caution in subsequent operations.  (It is best to</span>
<span class="sd">        avoid use of maskedge.)</span>
<span class="sd">        end{description}</span>
<span class="sd">        </span>
<span class="sd">        The BPOLY solution is performed for both phase and amplitude, and the</span>
<span class="sd">        result will be stored in the same table.  The frequency domain of the</span>
<span class="sd">        solutions is limited to only the range of frequencies selected in</span>
<span class="sd">        {stfaf selectvis}.  When correcting data with these solutions (for</span>
<span class="sd">        other solves or with {stfaf correct}), only data within this domain</span>
<span class="sd">        will be corrected.  Data outside (e.g., edge channels avoided in</span>
<span class="sd">        {stfaf setdata} for the solve), will not be corrected.  Therefore,</span>
<span class="sd">        the same (or narrower) channel selection is recommended for all</span>
<span class="sd">        operations using solutions produced by this function and {stfaf</span>
<span class="sd">        solve()}.</span>
<span class="sd">        </span>
<span class="sd">        Note that the {stfaf combine} parmaeter can be used meaningfully with</span>
<span class="sd">        the BPOLY solver.  When combine=&#39;spw&#39;, the data from multiple spws</span>
<span class="sd">        will be combined on a common frequency axis, and a single polynomial</span>
<span class="sd">        will be determined spanning them all.  This is different than for</span>
<span class="sd">        ordinary sampled &#39;B&#39; solutions, for which combine=&#39;spw&#39; causes the</span>
<span class="sd">        bandpass to be combined on a common channel axis, effectively yielding</span>
<span class="sd">        a mean bandpass for the set of spws.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">setsolvebandpoly</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">append</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">combine</span><span class="p">,</span> <span class="n">degamp</span><span class="p">,</span> <span class="n">degphase</span><span class="p">,</span> <span class="n">visnorm</span><span class="p">,</span> <span class="n">solnorm</span><span class="p">,</span> <span class="n">maskcenter</span><span class="p">,</span> <span class="n">maskedge</span><span class="p">,</span> <span class="n">refant</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">returndict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a dictionary containing information about the current calibrater tool state.</span>
<span class="sd">        This dictionary contains the following keys: &#39;antennas&#39;, &#39;apply tables&#39;, &#39;field&#39;, &#39;intents&#39;, &#39;observation&#39;, &#39;scan&#39;, &#39;solve table&#39;, &#39;spw&#39;.</span>
<span class="sd">        </span>
<span class="sd">        Each of these keys will show which values for each of these parameters are selected. By default all of the MS is selected when opened by the calibrater tool.</span>
<span class="sd">        </span>
<span class="sd">        The values of each of these keys is an array of either strings or integers.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">returndict</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">state</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Request the apply/solve state of the calibrater tool.  A listing of</span>
<span class="sd">        all calibration components that have been set for application or</span>
<span class="sd">        solving is written to the logger.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">state</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">apply</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">solve</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Resets the apply and/or solve components previously set by setapply and</span>
<span class="sd">        setsolve.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">reset</span><span class="p">(</span><span class="n">apply</span><span class="p">,</span> <span class="n">solve</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">initcalset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">calset</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">0</span><span class="p">)):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function re-initializes the calibration scratch columns:</span>
<span class="sd">        MODEL_DATA to unity (in total intensity, and unpolarized), and</span>
<span class="sd">        CORRECTED_DATA to (observed) DATA.</span>
<span class="sd">        Optionally if calset is set to 1 any model saved in the MS header to for calibration</span>
<span class="sd">        purposes is deleted</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">initcalset</span><span class="p">(</span><span class="n">calset</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">delmod</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">otf</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">field</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">spw</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">scr</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This method can be used to delete the model visibility</span>
<span class="sd">        data representations in the MS.  The &#39;otf&#39; representation is</span>
<span class="sd">        the new (as of v3.4) &#39;scratch-less&#39; model data, stored as</span>
<span class="sd">        keywords in the MS header containing model data formation</span>
<span class="sd">        instructions.  It is generated by the im tool (setjy, ft, and clean</span>
<span class="sd">        methods; usescratch=F in im.open), and if present, overrides the</span>
<span class="sd">        old-fashioned MODEL_DATA column (if present).  If a user</span>
<span class="sd">        wishes to use the MODEL_DATA column _after_ having operated</span>
<span class="sd">        with the &#39;otf&#39; representation, this method can be used</span>
<span class="sd">        to delete the &#39;otf&#39; represenatation to make the MODEL_DATA</span>
<span class="sd">        column visible.  (Create the MODEL_DATA column by using</span>
<span class="sd">        usescratch=T in the im tool, or by running the cb.open</span>
<span class="sd">        with addmodel=T.)</span>
<span class="sd">        </span>
<span class="sd">        If otf=T, the user may selectively remove only a selection of fields model from the MS by specifying the field parameter. Similarly if the field parameter is specified, selected spws model for those fields may be deleted by specifying the spw.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        For convenience, this method also provides a means for</span>
<span class="sd">        deleting the MODEL_DATA column by setting scr=T.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">delmod</span><span class="p">(</span><span class="n">otf</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">spw</span><span class="p">,</span> <span class="n">scr</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Execution of this function initiates a solve for the calibration component</span>
<span class="sd">        specified in a previous {stfaf setsolve} execution.  Existing calibration</span>
<span class="sd">        components (as specified in one or more {stfaf setapply} executions) will</span>
<span class="sd">        be appropriately applied to the observed and model data according to their</span>
<span class="sd">        position in the Measurement Equation, and their commutation properties.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">correct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">applymode</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function applies the calibration components specified via one or</span>
<span class="sd">        more invocations of the {stff setapply} function to the observed</span>
<span class="sd">        visibility data and writes the result to the CORRECTED_DATA column</span>
<span class="sd">        of the Measurement Set.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">correct</span><span class="p">(</span><span class="n">applymode</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">corrupt</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function applies the calibration components specified via one or</span>
<span class="sd">        more invocations of the {stff setapply} function to the model</span>
<span class="sd">        visibility data and (over-)writes the result to the MODEL_DATA column of the</span>
<span class="sd">        Measurement Set.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">corrupt</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">initweights</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wtmode</span><span class="o">=</span><span class="s1">&#39;nyq&#39;</span><span class="p">,</span> <span class="n">dowtsp</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">tsystable</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">gainfield</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">interp</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">spwmap</span><span class="o">=</span><span class="p">[</span>  <span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function initializes the MS weight info in various ways.</span>
<span class="sd">        </span>
<span class="sd">        If wtmode=&#39;ones&#39;, SIGMA and WEIGHT will be initialized with 1.0,</span>
<span class="sd">        globally.</span>
<span class="sd">        </span>
<span class="sd">        If wtmode=&#39;nyq&#39; (the default), SIGMA and WEIGHT will be initialized</span>
<span class="sd">        according to bandwidth and integration time.  This is the</span>
<span class="sd">        theoretically correct mode for raw normalized visibilities.</span>
<span class="sd">        </span>
<span class="sd">        If wtmode=&#39;sigma&#39;, WEIGHT will be initialized according to the</span>
<span class="sd">        existing SIGMA column.</span>
<span class="sd">        </span>
<span class="sd">        If mode=&#39;weight&#39;, WEIGHT_SPECTRUM will be initialized according to the</span>
<span class="sd">        existing WEIGHT column; dowtspec=T must be specified in this case.</span>
<span class="sd">        </span>
<span class="sd">        For the above wtmodes, if dowtspec=T (or if the WEIGHT_SPECTRUM column</span>
<span class="sd">        already exists), the WEIGHT_SPECTRUM column will be initialized</span>
<span class="sd">        (uniformly in channel), in a manner consistent with the WEIGHT column.</span>
<span class="sd">        If the WEIGHT_SPECTRUM column does not exist, dowtsp=T will force its</span>
<span class="sd">        creation.</span>
<span class="sd">        </span>
<span class="sd">        The follow modes should be used with extreme care: If</span>
<span class="sd">        wtmode=&#39;delwtsp&#39;, the WEIGHT_SPECTRUM column will be deleted (if it</span>
<span class="sd">        exists).  If wtmode=&#39;delsigsp&#39;, the SIGMA_SPECTRUM column will be</span>
<span class="sd">        deleted (if it exists).  Note that creation of SIGMA_SPECTRUM is not</span>
<span class="sd">        supported via this method.</span>
<span class="sd">        </span>
<span class="sd">        Note that this method does not support any prior selection.</span>
<span class="sd">        Intialization of the weight information must currently be done</span>
<span class="sd">        globally or not at all.  This is to maintain consistency.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">initweights</span><span class="p">(</span><span class="n">wtmode</span><span class="p">,</span> <span class="n">dowtsp</span><span class="p">,</span> <span class="n">tsystable</span><span class="p">,</span> <span class="n">gainfield</span><span class="p">,</span> <span class="n">interp</span><span class="p">,</span> <span class="n">spwmap</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">fluxscale</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tablein</span><span class="p">,</span> <span class="n">reference</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">tableout</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">transfer</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">listfile</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">refspwmap</span><span class="o">=</span><span class="p">[</span> <span class="nb">int</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">],</span> <span class="n">gainthreshold</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="p">),</span> <span class="n">antenna</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">timerange</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">scan</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">incremental</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fitorder</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">display</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function is used to bootstrap the amplitude scale the</span>
<span class="sd">        calibration solutions according to specified reference calibrator(s)</span>
<span class="sd">        of known flux density.  This is necessary when the flux densities</span>
<span class="sd">        of some of your calibrators were unknown (and thus were assumed</span>
<span class="sd">        to be 1 Jy) during G solving.</span>
<span class="sd">        </span>
<span class="sd">        The bootstrapping is achieved by comparing the median gain norm of the</span>
<span class="sd">        calibration solutions derived for the calibrators specified in {stfaf</span>
<span class="sd">        reference} (one or more sources with known flux densities at the time</span>
<span class="sd">        of G solving) with that of the calibrators specified in {stfaf</span>
<span class="sd">        transfer}, and enforcing the assumption that the antenna gains are</span>
<span class="sd">        constant, on average.  The gain solutions for the transfer sources are</span>
<span class="sd">        then re-scaled accordingly.   The {stfaf reference} and {stfaf transfer}</span>
<span class="sd">        parameters may be specified using the general field selection syntax</span>
<span class="sd">        (as in {stfaf field} in {stfaf selectvis}).</span>
<span class="sd">        </span>
<span class="sd">        If no {tt transfer} fields are specified, then the solutions for</span>
<span class="sd">        all non-reference fields in {tt tablein} will be re-scaled.</span>
<span class="sd">        </span>
<span class="sd">        If no {tt tableout} is specified the input table will be overwritten</span>
<span class="sd">        with the scaled solutions.  Note that the resulting table will only</span>
<span class="sd">        contain solutions for those fields implicit in the {tt reference} and</span>
<span class="sd">        {tt transfer} specifications.     Use {tt append=T} to append the scaled</span>
<span class="sd">        solutions to an existing table.</span>
<span class="sd">        </span>
<span class="sd">        Use the {stfaf refspwmap} parameter to indicate how data for</span>
<span class="sd">        different spectral windows should be matched in calculating the flux</span>
<span class="sd">        density scale factor for {stfaf transfer} fields. The default</span>
<span class="sd">        behavior for {tt refspwmap} is to insist on precisely matching</span>
<span class="sd">        spectral windows for {tt reference} and {tt transfer} fields.  When</span>
<span class="sd">        specified, the {stfaf refspwmap} parameter takes a vector of integers</span>
<span class="sd">        indicating which spectral window solutions to use as the reference for</span>
<span class="sd">        others, such that {tt refspwmap[j]=i} causes solutions (from reference</span>
<span class="sd">        fields) observed in the i-th spectral window to be used to reference</span>
<span class="sd">        solutions (from transfer fields) observed in the j-th spectral window.</span>
<span class="sd">        For example, for the case of a total of 4 spectral windows: if the</span>
<span class="sd">        {tt reference} fields were observed only in spw=2 &amp; 4, and the {tt</span>
<span class="sd">        transfer} fields were observed variously in all 4 spws, specify {tt</span>
<span class="sd">        refspwmap=[2,2,4,4]}.  This will ensure that {tt transfer} fields</span>
<span class="sd">        observed in spws 1,2,3,4 will be referenced to {tt reference} field</span>
<span class="sd">        data from spws 2,2,4,4, respectively.  Note that if the {tt transfer}</span>
<span class="sd">        fields were observed only in spws 1 &amp; 3, the same specification would</span>
<span class="sd">        work, but {tt refspwmap=[2,2,4]} would suffice.  In this case,</span>
<span class="sd">        nothing need be specified for the 4th spw (there are no transfer</span>
<span class="sd">        fields there), and specifying 2 for the 2nd spw is actually</span>
<span class="sd">        inconsequential (though required so that the specification of 4 for spw 3</span>
<span class="sd">        is properly interpretted).</span>
<span class="sd">        </span>
<span class="sd">        The  gain values used in the flux scaling determination skewed by</span>
<span class="sd">        outliers. The parameters, {tt gainthreshold} and {tt antenna} can be used</span>
<span class="sd">        to limit the input gain solutions to be included in the flux scale determination.</span>
<span class="sd">        Use the {tt gainthreshold} is a threshold in % from the median values of the</span>
<span class="sd">        gain solutions to be used. Use the {tt antenna} to select or de-selesect (using the</span>
<span class="sd">        MSSelection syntax) antenna(s). Futher refinements on the selection based on</span>
<span class="sd">        timerange and scan are possible.</span>
<span class="sd">        </span>
<span class="sd">        The derived flux densities for the transfer fields will be reported in</span>
<span class="sd">        the logger, and returned to the Python dictionary specified in {tt</span>
<span class="sd">        fluxd}.  This will be an 2D array of shape [number-of-spectral-windows</span>
<span class="sd">        X number-of-fields]. When mulitple spectral windows are involved the spectral</span>
<span class="sd">        index will also be reported by fitting the determined flux densities across</span>
<span class="sd">        the freuquencies. The order of a polynomcial to be fitted can be specified with</span>
<span class="sd">        {tt fitorder}.</span>
<span class="sd">        </span>
<span class="sd">        Note that elevation-dependent gain effects may render the basic</span>
<span class="sd">        assumption used here invalid, and so should be corrected for prior to</span>
<span class="sd">        solving for G, using types &#39;TOPAC&#39; or &#39;GAINCURVE&#39; in {tt setapply}.</span>
<span class="sd">        </span>
<span class="sd">        Note that the visibility data itself is not used directly by this</span>
<span class="sd">        function.</span>
<span class="sd">        </span>
<span class="sd">        Pending improvements:</span>
<span class="sd">        </span>
<span class="sd">        begin{itemize}</span>
<span class="sd">        item Allow antenna and uv-distance selection to improve results for</span>
<span class="sd">        resolved calibrators</span>
<span class="sd">        item Set the visibility model according to the flux density results</span>
<span class="sd">        item An option to use the data to derive the relative flux densities</span>
<span class="sd">        end{itemize}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">fluxscale</span><span class="p">(</span><span class="n">tablein</span><span class="p">,</span> <span class="n">reference</span><span class="p">,</span> <span class="n">tableout</span><span class="p">,</span> <span class="n">transfer</span><span class="p">,</span> <span class="n">listfile</span><span class="p">,</span> <span class="n">append</span><span class="p">,</span> <span class="n">refspwmap</span><span class="p">,</span> <span class="n">gainthreshold</span><span class="p">,</span> <span class="n">antenna</span><span class="p">,</span> <span class="n">timerange</span><span class="p">,</span> <span class="n">scan</span><span class="p">,</span> <span class="n">incremental</span><span class="p">,</span> <span class="n">fitorder</span><span class="p">,</span> <span class="n">display</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">accumulate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tablein</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">incrtable</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">tableout</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">field</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">calfield</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">interp</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="p">),</span> <span class="n">spwmap</span><span class="o">=</span><span class="p">[</span> <span class="nb">int</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function enables cumulative calibration using {tt calibrater}.</span>
<span class="sd">        It is the analog of the task ``CLCAL&#39;&#39; in classic AIPS.</span>
<span class="sd">        </span>
<span class="sd">        The {tt accumulate} function is useful when:</span>
<span class="sd">        </span>
<span class="sd">        begin{itemize}</span>
<span class="sd">        item a calibration solution of a particular type already exists,</span>
<span class="sd">        item an incremental calibration solution {em of the same type} is desired</span>
<span class="sd">        (an incremental solution in this context means derived independently</span>
<span class="sd">        from, or determined with respect to, the first)</span>
<span class="sd">        item the first calibration cannot be implicitly recovered in the course</span>
<span class="sd">        of obtaining the incremental solution</span>
<span class="sd">        end{itemize}</span>
<span class="sd">        </span>
<span class="sd">        For example, a phase-only ``G&#39;&#39; self-calibration on a target source</span>
<span class="sd">        may be desired to tweak the full amplitude and phase ``G&#39;&#39; calibration</span>
<span class="sd">        already obtained from a calibrator.  The initial calibration (from the</span>
<span class="sd">        calibrator) contains amplitude information, and so must be carried</span>
<span class="sd">        forward, yet the phase-only solution itself cannot (by definition)</span>
<span class="sd">        recover this information, as a full amplitude and phase</span>
<span class="sd">        self-calibration would.  In this case, the initial solution must be</span>
<span class="sd">        applied while solving for the phase-only solution, then the two</span>
<span class="sd">        solutions combined to form a {em cumulative} calibration embodying</span>
<span class="sd">        the net effect of both. In terms of the Measaurement Equation, the net</span>
<span class="sd">        calibration is the {em product} of the initial and incremental</span>
<span class="sd">        solutions.</span>
<span class="sd">        </span>
<span class="sd">        The analog of {tt accumulate} in classic AIPS is the use of CLCAL to</span>
<span class="sd">        combine a series of (incremental) SN calibration tables to form</span>
<span class="sd">        successive (cumulative) CL calibration tables.</span>
<span class="sd">        </span>
<span class="sd">        Cumulative calibration tables also provide a means of generating</span>
<span class="sd">        carefully interpolated calibration, on variable user-defined</span>
<span class="sd">        timescales, that can be examined prior to application to the data with</span>
<span class="sd">        {tt setapply} and {tt correct}.  The solutions for different fields</span>
<span class="sd">        and/or spectral windows can be interpolated in different ways, with</span>
<span class="sd">        all solutions stored in the same table.</span>
<span class="sd">        </span>
<span class="sd">        The only difference between incremental and cumulative calibration</span>
<span class="sd">        tables is that incremental tables are generated directly from the data</span>
<span class="sd">        via {tt solve} or (in the near future) from other ancilliary data</span>
<span class="sd">        (e.g. weather information), and cumulative tables are generated from</span>
<span class="sd">        other cumulative and incremental tables via {tt accumulate}.  In all</span>
<span class="sd">        other respects (internal format, application to data via {tt</span>
<span class="sd">        setapply} and {tt correct}, plotting with {tt plotcal}, etc.), they</span>
<span class="sd">        are the same, and therefore interchangable.  Thus, {tt accumulate} and</span>
<span class="sd">        cumulative calibration tables need only be used when circumstances</span>
<span class="sd">        require it.</span>
<span class="sd">        </span>
<span class="sd">        The {tt accumulate} function represents a generalization on the</span>
<span class="sd">        classic AIPS CLCAL model of cumulative calibration in that its</span>
<span class="sd">        application is not limited to accumulation of ``G&#39;&#39; solutions (SN/CL</span>
<span class="sd">        tables classic AIPS are the analog of ``G&#39;&#39; (and, implicitly, ``T&#39;&#39;)</span>
<span class="sd">        in {tt aips++}).  In principle, any basic calibration type can be</span>
<span class="sd">        accumulated (onto itself), as long as the result of the accumulation</span>
<span class="sd">        (matrix product) is of the same type.  This is true of all the basic</span>
<span class="sd">        types, except ``D&#39;&#39;.  Accumulation is currently supported for ``B&#39;&#39;,</span>
<span class="sd">        ``G&#39;&#39;, and ``T&#39;&#39;, and, in future, ``F&#39;&#39; (ionospheric Faraday</span>
<span class="sd">        rotation), ``J&#39;&#39; (generic full-polarization calibration),</span>
<span class="sd">        fringe-fitting, and perhaps others.  Accumulation of certain</span>
<span class="sd">        specialized types (e.g., ``GSPLINE&#39;&#39;, ``TOPAC&#39;&#39;, etc.) onto the basic</span>
<span class="sd">        types will be supported in the near future.  The treatment of various</span>
<span class="sd">        calibration from ancilliary data (e.g., system temperatures, weather</span>
<span class="sd">        data, WVR, etc.), as they become available, will also make use of {tt</span>
<span class="sd">        accumulate} to achieve the net calibration.</span>
<span class="sd">        </span>
<span class="sd">        Note that accumulation only makes sense if treatment of a uniquely</span>
<span class="sd">        incremental solution is required (as described above), or if a careful</span>
<span class="sd">        interpolation or sampling of a solution is desired.  In all other</span>
<span class="sd">        cases, re-solving for the type in question will suffice to form</span>
<span class="sd">        the net calibration of that type.  For example, the product of</span>
<span class="sd">        an existing ``G&#39;&#39; solution and an amplitude and phase ``G&#39;&#39; self-cal</span>
<span class="sd">        (solved with the existing solution applied), is equivalent to full</span>
<span class="sd">        amplitude and phase ``G&#39;&#39; selfcal (with no prior solution applied),</span>
<span class="sd">        as long as the timescale of this solution is at least as short as</span>
<span class="sd">        that of the existing solution.</span>
<span class="sd">        </span>
<span class="sd">        Use of {tt accumulate} is straightforward:</span>
<span class="sd">        </span>
<span class="sd">        The {tt tablein} parameter is used to specify the existing cumulative</span>
<span class="sd">        calibration table to which an incremental table is to be applied.</span>
<span class="sd">        Initially, no such table exists, and {tt accumulate} will generate</span>
<span class="sd">        one from scratch (on-the-fly), using the timescale (in seconds)</span>
<span class="sd">        specified by the parameter {tt t}.  These nominal solutions will</span>
<span class="sd">        be unit-amplitude, zero-phase (i.e., unit matrix) calibration,</span>
<span class="sd">        ready to be adjusted by accumulation.  When {tt t} is negative (the</span>
<span class="sd">        default), the table name specified in {tt tablein} must exist and</span>
<span class="sd">        will be used.</span>
<span class="sd">        </span>
<span class="sd">        The {tt incrtable} parameter is used to specify the incremental table</span>
<span class="sd">        that should be applied to {tt tablein}.  The calibration type of</span>
<span class="sd">        {tt incrtable} sets the type assumed in the operation, so {tt</span>
<span class="sd">        tablein} must be of the same type.  If it is not, {tt accumulate}</span>
<span class="sd">        will exit with an error message.  (Certain combinations of types</span>
<span class="sd">        and subtypes will be supported by accumulate in the future.)</span>
<span class="sd">        </span>
<span class="sd">        The {tt tableout} parameter is used to specify the name of the output</span>
<span class="sd">        table to write.  If un-specified (or ``&#39;&#39;), then {tt tablein} will be</span>
<span class="sd">        overwritten.  Use this feature with care, since an error here will</span>
<span class="sd">        require building up the cumulative table from the most recent distinct</span>
<span class="sd">        version (if any).</span>
<span class="sd">        </span>
<span class="sd">        The {tt field} parameter specifies those field names (standard</span>
<span class="sd">        selection syntax) in {tt tablein} to which the incremental solution</span>
<span class="sd">        should be applied.  The solutions for other fields will be passed to</span>
<span class="sd">        {tt tableout} unaltered.  If the cumulative table was created from</span>
<span class="sd">        scratch in this run of {tt accumulate}, then these solutions will be</span>
<span class="sd">        unit-amplitude, zero-phase, as described above.</span>
<span class="sd">        </span>
<span class="sd">        The {tt calfield} parameter is used to specify the fields (standard</span>
<span class="sd">        selection syntax) to select from {tt incrtable} to use when applying</span>
<span class="sd">        to {tt tablein}.  Together, use of {tt field} and {tt calfield}</span>
<span class="sd">        permit completely flexible combinations of calibration accumulation</span>
<span class="sd">        with respect to fields.  Multiple runs of {tt accumulate} can be used</span>
<span class="sd">        to generate a single table with many combinations.  In future, a</span>
<span class="sd">        ``self&#39;&#39; mode will be enabled that will simplify the accumulation of</span>
<span class="sd">        field-specific solutions.</span>
<span class="sd">        </span>
<span class="sd">        The {tt interp} parameter is used to specify the interpolation type</span>
<span class="sd">        to use on the incremental solutions, as in {tt setapply}.  The</span>
<span class="sd">        currently available interpolation types are ``nearest&#39;&#39;, ``linear&#39;&#39;,</span>
<span class="sd">        and ``aipslin&#39;&#39;.  See the {tt setapply} URM documentation for more</span>
<span class="sd">        details.</span>
<span class="sd">        </span>
<span class="sd">        The {tt spwmap} parameter enables accumulating solutions from</span>
<span class="sd">        differing spectral windows.  See {tt setapply} for details</span>
<span class="sd">        on how spwmap works.</span>
<span class="sd">        </span>
<span class="sd">        Pending improvements:</span>
<span class="sd">        </span>
<span class="sd">        begin{itemize}</span>
<span class="sd">        item Implement a ``self&#39;&#39; mode (independent of interpolation type),</span>
<span class="sd">        to simplify or eliminate use of the {tt field} and {tt calfield}</span>
<span class="sd">        parameters in some contexts (e.g., self-cal)</span>
<span class="sd">        item More interpolation modes, e.g., ``cubic&#39;&#39;, and interpolation</span>
<span class="sd">        timescale (timerange to permit interpolation)</span>
<span class="sd">        item Handle propogation (or not) of bad/flagged solutions</span>
<span class="sd">        item Support of specialized types (e.g., TOPAC) onto the basic</span>
<span class="sd">        types</span>
<span class="sd">        item Smoothing (probably a separate function)</span>
<span class="sd">        end{itemize}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">accumulate</span><span class="p">(</span><span class="n">tablein</span><span class="p">,</span> <span class="n">incrtable</span><span class="p">,</span> <span class="n">tableout</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">calfield</span><span class="p">,</span> <span class="n">interp</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">spwmap</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">activityrec</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This funtion enables returning generic information about recent activity.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Pending improvements:</span>
<span class="sd">        </span>
<span class="sd">        begin{itemize}</span>
<span class="sd">        item ??</span>
<span class="sd">        end{itemize}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">activityrec</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">specifycal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">caltable</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">spw</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">antenna</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">pol</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">caltype</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">parameter</span><span class="o">=</span><span class="p">[</span> <span class="nb">float</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span> <span class="p">],</span> <span class="n">infile</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">uniform</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function enables specifying calibration parameters externally.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">specifycal</span><span class="p">(</span><span class="n">caltable</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">spw</span><span class="p">,</span> <span class="n">antenna</span><span class="p">,</span> <span class="n">pol</span><span class="p">,</span> <span class="n">caltype</span><span class="p">,</span> <span class="n">parameter</span><span class="p">,</span> <span class="n">infile</span><span class="p">,</span> <span class="n">uniform</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">smooth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tablein</span><span class="p">,</span> <span class="n">tableout</span><span class="p">,</span> <span class="n">field</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">smoothtype</span><span class="o">=</span><span class="s1">&#39;median&#39;</span><span class="p">,</span> <span class="n">smoothtime</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="mf">60.0</span><span class="p">)):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function provides for time-dependent smoothing of sampled</span>
<span class="sd">        calibration solutions.  Currently supported types are &#39;G&#39;, &#39;B&#39;, and &#39;T&#39;.</span>
<span class="sd">        (Smoothing on the frequency axis for &#39;B&#39; will be supported in the near</span>
<span class="sd">        future.)</span>
<span class="sd">        </span>
<span class="sd">        Two (sliding) smoothing types are currenlty supported: &#39;median&#39; or</span>
<span class="sd">        &#39;mean&#39;, one of these options should be specified in {stfaf</span>
<span class="sd">        smoothtype}.  The full width (in seconds) of the smoothing filter</span>
<span class="sd">        should be specified in {stfaf smoothtime}.   Amplitude and</span>
<span class="sd">        (ambiguity-corrected) phase are smoothed separately.</span>
<span class="sd">        </span>
<span class="sd">        Use {stfaf field} to limit the smoothing operation to a subset of the</span>
<span class="sd">        fields (standard selection syntax) found in the calibration table</span>
<span class="sd">        (other fields will pass to the output table unsmoothed).  If {stfaf</span>
<span class="sd">        field} is left blank, all fields in the table will be smoothed.</span>
<span class="sd">        </span>
<span class="sd">        The smoothing is always done independently for each field, but</span>
<span class="sd">        scan boundaries are not observed.  Thus, if the {stfaf smoothtime}</span>
<span class="sd">        is large enough, smoothing may occur over many boundaries.</span>
<span class="sd">        </span>
<span class="sd">        Flagged solutions in the input table will not participate in the</span>
<span class="sd">        smoothing calculation, but will be replaced with smoothed values</span>
<span class="sd">        if the smoothing window covers one or more unflagged solutions when</span>
<span class="sd">        centered on the flagged point.</span>
<span class="sd">        </span>
<span class="sd">        Pending improvements:</span>
<span class="sd">        </span>
<span class="sd">        begin{itemize}</span>
<span class="sd">        item Add other smoothtypes?</span>
<span class="sd">        item Add spw and other selection on input table</span>
<span class="sd">        item Add A/P toggle</span>
<span class="sd">        end{itemize}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">smooth</span><span class="p">(</span><span class="n">tablein</span><span class="p">,</span> <span class="n">tableout</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">smoothtype</span><span class="p">,</span> <span class="n">smoothtime</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">rerefant</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tablein</span><span class="p">,</span> <span class="n">tableout</span><span class="p">,</span> <span class="n">refantmode</span><span class="o">=</span><span class="s1">&#39;flexible&#39;</span><span class="p">,</span> <span class="n">refant</span><span class="o">=</span><span class="p">[</span> <span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;TBD</span>
<span class="sd">        </span>
<span class="sd">        Pending improvements:</span>
<span class="sd">        </span>
<span class="sd">        begin{itemize}</span>
<span class="sd">        item TBD</span>
<span class="sd">        end{itemize}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">rerefant</span><span class="p">(</span><span class="n">tablein</span><span class="p">,</span> <span class="n">tableout</span><span class="p">,</span> <span class="n">refantmode</span><span class="p">,</span> <span class="n">refant</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">listcal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">caltable</span><span class="p">,</span> <span class="n">field</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">antenna</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">spw</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">listfile</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">pagerows</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">50</span><span class="p">)):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;calibrater.listcal() lists antenna gain solutions in tabular</span>
<span class="sd">        form.  The table is organized as follows.  Solutions are output by</span>
<span class="sd">        begin{enumerate}</span>
<span class="sd">        item Spectral window,</span>
<span class="sd">        item Antenna,</span>
<span class="sd">        item Time,</span>
<span class="sd">        item Channel,</span>
<span class="sd">        item and Polarization.</span>
<span class="sd">        end{enumerate}</span>
<span class="sd">        The inner-most loop is over polarization.</span>
<span class="sd">        A ``Spw Header&#39;&#39; row is printed each time the spectral window changes.</span>
<span class="sd">        In addition  to listing the spectral window ID (SpwID), the Spw Header</span>
<span class="sd">        also lists the date of observation (Date), the calibration table name (CalTable), and the measurement</span>
<span class="sd">        set name (MS name).  A lower-level ``antenna header&#39;&#39; is printed each time the antenna</span>
<span class="sd">        names change or every `pagerows&#39; of output, whichever comes first.</span>
<span class="sd">        The antenna header column are described here:</span>
<span class="sd">        </span>
<span class="sd">        begin{tabular}{ll}</span>
<span class="sd">        hline hline</span>
<span class="sd">        Column Name   &amp; Description </span>
<span class="sd">        hline</span>
<span class="sd">        Ant           &amp; Antenna name </span>
<span class="sd">        Time          &amp; Visibility timestamp corresponding to gain solution </span>
<span class="sd">        Field         &amp; Field name </span>
<span class="sd">        Chn           &amp; Channel number </span>
<span class="sd">        Amp           &amp; Complex solution amplitude </span>
<span class="sd">        Phs           &amp; Complex solution  phase </span>
<span class="sd">        F             &amp; Flag </span>
<span class="sd">        hline hline</span>
<span class="sd">        end{tabular}</span>
<span class="sd">        </span>
<span class="sd">        Elements of the ``F&#39;&#39; column contain an `F&#39; when the datum is flagged,</span>
<span class="sd">        and ` &#39; (whitespace) when the datum is not flagged.</span>
<span class="sd">        </span>
<span class="sd">        Presently, the polarization mode names (for example: R, L)</span>
<span class="sd">        are not given, but the ordering of the polrization modes (left-to-right) is</span>
<span class="sd">        equivalent to the order output by task listobs (see ``Feeds&#39;&#39; in listobs output).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">listcal</span><span class="p">(</span><span class="n">caltable</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">antenna</span><span class="p">,</span> <span class="n">spw</span><span class="p">,</span> <span class="n">listfile</span><span class="p">,</span> <span class="n">pagerows</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">posangcal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">posangcor</span><span class="p">,</span> <span class="n">tablein</span><span class="p">,</span> <span class="n">tableout</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function is used to apply position angle calibration for</span>
<span class="sd">        observations made using circularly polarized feeds.  According to the</span>
<span class="sd">        Measurement Equation formalism, this correction should be applied to a</span>
<span class="sd">        {tt D} (instrumental polarization) calibration table.</span>
<span class="sd">        </span>
<span class="sd">        If no {tt D} calibration is performed (and thus no such table is</span>
<span class="sd">        available), the correction can be applied to a {tt G} table, but it</span>
<span class="sd">        should NEVER be applied to both, and always applied to a {tt D} table</span>
<span class="sd">        if one is available.  An input table must be specified.  If no output</span>
<span class="sd">        table is specified, then the input table will be modified in place.</span>
<span class="sd">        </span>
<span class="sd">        Specify, as a vector of values, a position angle adjustment (in degrees)</span>
<span class="sd">        for each spectral window.  If only one value is specified, it will be</span>
<span class="sd">        duplicated to all spectral windows; otherwise, the number of values</span>
<span class="sd">        specified must match the number of spectral windows.  The sign</span>
<span class="sd">        convention for the position angle adjustment is such that the specified</span>
<span class="sd">        value is the that which, when added to the position angle implied by the</span>
<span class="sd">        data, will yield the correct position angle.  For example, if {tt G-},</span>
<span class="sd">        {tt D-}, and {tt P-}calibrated data for 3c286 suggests a position</span>
<span class="sd">        angle of 45 degrees, the posangcor value should be -12 degrees as this</span>
<span class="sd">        will yield the correct position angle of 33 degrees when added.  In</span>
<span class="sd">        general, posangcor equals correct position angle minus observed position</span>
<span class="sd">        angle.</span>
<span class="sd">        </span>
<span class="sd">        A future version of this function will have an option to recognize</span>
<span class="sd">        standard position angle calibrators and determine the correction</span>
<span class="sd">        automatically.</span>
<span class="sd">        </span>
<span class="sd">        (NB: It may be desirable to use solutions for &#39;X&#39; to handle</span>
<span class="sd">        position angle calibration, rather than this method.)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">posangcal</span><span class="p">(</span><span class="n">posangcor</span><span class="p">,</span> <span class="n">tablein</span><span class="p">,</span> <span class="n">tableout</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">linpolcor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tablein</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">tableout</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">fields</span><span class="o">=</span><span class="p">[</span>  <span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;THIS METHOD IS CURRENTLY DISABLED.</span>
<span class="sd">        </span>
<span class="sd">        This function can be used to correct the gains derived from secondary</span>
<span class="sd">        calibrators with unknown or variable polarization.  It should only be</span>
<span class="sd">        used for arrays with linear (X/Y) feeds and an Alt-Az mount for which</span>
<span class="sd">        the observed polarization varies with feed position angle on the sky.</span>
<span class="sd">        </span>
<span class="sd">        The function fits the gains with a sine and cosine term in feed position</span>
<span class="sd">        angle and extracts the Q and U components of the secondary calibrator.</span>
<span class="sd">        This is only possible if there is sufficient range in the position angle</span>
<span class="sd">        (i.e., minimum of about 6 scans spanning at least 90 degrees in position</span>
<span class="sd">        angle).  Check the error of the fit to judge if the fit was succesfull,</span>
<span class="sd">        it should generally be smaller than 0.5%.</span>
<span class="sd">        </span>
<span class="sd">        Use the {stfaf fields} argument to select calibrator fields to be</span>
<span class="sd">        fitted.  The function takes a calibration table as input, and can write</span>
<span class="sd">        the adjusted gain solutions to the same table on output, or create a new</span>
<span class="sd">        table containing these results.  The function also prints the derived</span>
<span class="sd">        polarization for each field for each spectral window.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">linpolcor</span><span class="p">(</span><span class="n">tablein</span><span class="p">,</span> <span class="n">tableout</span><span class="p">,</span> <span class="n">fields</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">plotcal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">antennas</span><span class="p">,</span> <span class="n">fields</span><span class="p">,</span> <span class="n">spwids</span><span class="p">,</span> <span class="n">plottype</span><span class="o">=</span><span class="s1">&#39;AMP&#39;</span><span class="p">,</span> <span class="n">tablename</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">polarization</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">multiplot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">nx</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">ny</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">psfile</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function plots a calibration table either to a plotter or</span>
<span class="sd">        to a file.</span>
<span class="sd">        </span>
<span class="sd">        The argument {stfaf plottype} can take the following values</span>
<span class="sd">        for all types of solutions:</span>
<span class="sd">        begin{description}</span>
<span class="sd">        item[AMP] Gain Amplitude vs. Time</span>
<span class="sd">        item[1/AMP] Inverse Gain Amplitude vs. Time (useful for</span>
<span class="sd">        comparing with classic AIPS)</span>
<span class="sd">        item[PHASE] Gain Phase vs. Time</span>
<span class="sd">        item[RI] Gain Real vs. Imaginary</span>
<span class="sd">        item[RLPHASE] Right/Left Gain phase difference (if polarizations are R,L)</span>
<span class="sd">        item[XYPHASE] X/Y Gain phase difference (if polarizations are X,Y)</span>
<span class="sd">        end{description}</span>
<span class="sd">        </span>
<span class="sd">        The argument {stfaf plottype} can take the following values</span>
<span class="sd">        for D tables</span>
<span class="sd">        </span>
<span class="sd">        begin{description}</span>
<span class="sd">        item[DAMP] Cross-polarized Gain Amplitude vs. Time</span>
<span class="sd">        item[DPHASE] Cross-polarized Gain Phase vs. Time</span>
<span class="sd">        item[DRI] Cross-polarized Gain Real vs. Imaginary</span>
<span class="sd">        end{description}</span>
<span class="sd">        </span>
<span class="sd">        The quality of the solutions can be examined with the following</span>
<span class="sd">        {stfaf plottype} choices:</span>
<span class="sd">        begin{description}</span>
<span class="sd">        item[FIT] Fit per spectral window</span>
<span class="sd">        item[FITWGT] Fit weight per spectral window</span>
<span class="sd">        item[TOTALFIT] Total fit</span>
<span class="sd">        end{description}</span>
<span class="sd">        </span>
<span class="sd">        By default, all antennas (as specified in the antennas argument) will</span>
<span class="sd">        appear on the same plot. Separate plots (all with the same scale)</span>
<span class="sd">        for each antenna can be activated by setting multiplot=T.  The multiplot</span>
<span class="sd">        argument only separates plots by antenna (not, e.g., by the field_id(s)</span>
<span class="sd">        specified in the fields argument).  If multiplot=T, the nx and ny</span>
<span class="sd">        arguments can be used to specify the number of plots per page.</span>
<span class="sd">        </span>
<span class="sd">        At the moment, only one polarization can be plotted per execution.</span>
<span class="sd">        This restriction will be relaxed in the near future.</span>
<span class="sd">        </span>
<span class="sd">        For B solutions, the plotting will loop over timestamps (if more than</span>
<span class="sd">        one).</span>
<span class="sd">        </span>
<span class="sd">        A hardcopy plot can be created by specifying the texttt{psfile}</span>
<span class="sd">        argument (which is especially useful for batch processing when a</span>
<span class="sd">        display screen is not available).  This will cause the plot to be</span>
<span class="sd">        written to a PostScript file which can be subsequently sent to a</span>
<span class="sd">        printer.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">plotcal</span><span class="p">(</span><span class="n">antennas</span><span class="p">,</span> <span class="n">fields</span><span class="p">,</span> <span class="n">spwids</span><span class="p">,</span> <span class="n">plottype</span><span class="p">,</span> <span class="n">tablename</span><span class="p">,</span> <span class="n">polarization</span><span class="p">,</span> <span class="n">multiplot</span><span class="p">,</span> <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">psfile</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">modelfit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vary</span><span class="p">,</span> <span class="n">niter</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">compshape</span><span class="o">=</span><span class="s1">&#39;P&#39;</span><span class="p">,</span> <span class="n">par</span><span class="o">=</span><span class="p">[</span> <span class="nb">float</span><span class="p">(</span><span class="mf">1.0</span><span class="p">),</span><span class="nb">float</span><span class="p">(</span><span class="mf">0.0</span><span class="p">),</span><span class="nb">float</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span> <span class="p">],</span> <span class="n">file</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This method fits single-component models (points, elliptical Gaussians or elliptical Disks_</span>
<span class="sd">        to the CORRECTED_DATA of the selected field.  A first guess for the component</span>
<span class="sd">        parameters may be specified in the {stfaf par} parameter.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">modelfit</span><span class="p">(</span><span class="n">vary</span><span class="p">,</span> <span class="n">niter</span><span class="p">,</span> <span class="n">compshape</span><span class="p">,</span> <span class="n">par</span><span class="p">,</span> <span class="n">file</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">createcaltable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">caltable</span><span class="p">,</span> <span class="n">partype</span><span class="p">,</span> <span class="n">caltype</span><span class="p">,</span> <span class="n">singlechan</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Creates an empty calibration table that can subsequently be filled</span>
<span class="sd">        with by using the table tool.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">createcaltable</span><span class="p">(</span><span class="n">caltable</span><span class="p">,</span> <span class="n">partype</span><span class="p">,</span> <span class="n">caltype</span><span class="p">,</span> <span class="n">singlechan</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">updatecaltable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">caltable</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This method can be used to update a caltable (from v3.4 or later)</span>
<span class="sd">        to the current version of CASA.</span>
<span class="sd">        </span>
<span class="sd">        The following updates are currently supported.</span>
<span class="sd">        </span>
<span class="sd">        o At CASA v4.1.0, the OBSERVATION subtable and OBSERVATION_ID column</span>
<span class="sd">        were added to caltables.  This method adds trivial versions of</span>
<span class="sd">        these elements to pre-v4.1 caltables.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">updatecaltable</span><span class="p">(</span><span class="n">caltable</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Close the {tt calibrater} tool, which is hardly ever necessary.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">done</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function is redundant with the {stfaf close} method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">done</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">parsecallibfile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filein</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;TBD</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">parsecallibfile</span><span class="p">(</span><span class="n">filein</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">setcorrdepflags</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">corrdepflags</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;TBD</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">setcorrdepflags</span><span class="p">(</span><span class="n">corrdepflags</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">setvi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">old</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">quiet</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Use this method to control whether the modern (old=False) or old-style (old=True)</span>
<span class="sd">        VisibilityIterator is used by the calibration application.  General users should</span>
<span class="sd">        avoid use of this function unless they understand what this means.</span>
<span class="sd">        </span>
<span class="sd">        This method will be removed from the calibrater tool in v5.1.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">setvi</span><span class="p">(</span><span class="n">old</span><span class="p">,</span> <span class="n">quiet</span><span class="p">)</span>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020–2024, Pipeline Dev. Team.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>