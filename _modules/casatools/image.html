

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>casatools.image &mdash; Pipeline unknown documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css?v=4ae1632d" />
      <link rel="stylesheet" type="text/css" href="../../_static/custom_theme.css?v=678032d9" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=3f1b9271"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            Pipeline
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Releases etc.</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../releases.html">Past Releases</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dependencies.html">Dependencies of <code class="docutils literal notranslate"><span class="pre">Pipeline</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modular.html">Run the Pipeline in a Conda environment</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../apisummary.html">Pipeline Tasks (from autosummary)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../apisummary.html#full-list">Full List</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">TaskRef (create_docs.py)</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../_taskdocs/taskdocs.html">List of Heuristics Tasks (Pipeline 2023)</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Pipeline Heuristics</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../heuristics/field_parameter.html">Field parameter</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../heuristics/FlaggingTasks.html">Pipeline Flagging Tasks</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Developer Notes</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../develdocmd/ways_to_run_the_pipeline.html">Ways to run the Pipeline</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../develdocmd/comparing_pipeline_executions.html">Comparing pipeline executions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../develdocmd/building_the_pipeline.html">Building the pipeline</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../develdocmd/ALMA-Imaging-Workflow.html">ALMA interferometry imaging workflow</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../develdocmd/VLA-Imaging-Workflow.html">VLA interferometry imaging workflow</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../develdocmd/VLASS-SE-CONT-Imaging-Workflow.html">VLASS-SE-CONT imaging workflow</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../develdocmd/VLASS-SE-CUBE-Imaging-Workflow.html">VLASS-SE-CUBE imaging workflow</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../develdocmd/selfcal_workflow.html">VLASS Selfcal &amp; Restore workflows</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../develdocmd/pipeline_tests.html">Pipeline testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../develdocmd/DataType_Testing.html">DataType Testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../develdocmd/QA_scores.html">Pipeline Quality Assurance (QA) Score Class Design</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../develdocmd/DeveloperDocumentation.html">Pipeline developer documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../develdocmd/python3_conversion_notes.html">Python 3 conversion notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../develdocmd/recipes.html">Pipeline Recipes</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Pipeline Domain/Context (automodapi)</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../basics.html"><code class="docutils literal notranslate"><span class="pre">pipeline.domain</span></code> module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../basics.html#module-pipeline.infrastructure.launcher"><code class="docutils literal notranslate"><span class="pre">pipeline.infrastructure.launcher</span></code> module</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Pipeline Domain/Context (autosummary)</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../_autosummary/pipeline.domain.html">pipeline.domain</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../_autosummary/pipeline.infrastructure.launcher.html">pipeline.infrastructure.launcher</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Pipeline Task/Inputs/Results Classes</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../classes.html">Classes in <code class="docutils literal notranslate"><span class="pre">pipeline.h*.tasks</span></code> modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../classes.html#inheritance-diagrams">Inheritance Diagrams</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Examples Notes (from Jupyter Notebooks)</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../examples/test1.html">test</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Example Notes (from .rst)</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../examples/test2.html">Example 1</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Pipeline</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">casatools.image</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for casatools.image</h1><div class="highlight"><pre>
<span></span><span class="c1">##################### generated by xml-casa (v2) from image.xml #####################</span>
<span class="c1">##################### 3ea432f56e8db3bb8bb80f239a929b71 ##############################</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">absolute_import</span> 
<span class="kn">from</span> <span class="nn">.__casac__.image</span> <span class="kn">import</span> <span class="n">image</span> <span class="k">as</span> <span class="n">_image</span>

<span class="kn">from</span> <span class="nn">.errors</span> <span class="kn">import</span> <span class="n">create_error_string</span>
<span class="kn">from</span> <span class="nn">.typecheck</span> <span class="kn">import</span> <span class="n">CasaValidator</span> <span class="k">as</span> <span class="n">_validator</span>
<span class="n">_pc</span> <span class="o">=</span> <span class="n">_validator</span><span class="p">(</span> <span class="p">)</span>
<span class="kn">from</span> <span class="nn">.coercetype</span> <span class="kn">import</span> <span class="n">coerce</span> <span class="k">as</span> <span class="n">_coerce</span>
<span class="kn">from</span> <span class="nn">.coordsys</span> <span class="kn">import</span> <span class="n">coordsys</span> <span class="k">as</span> <span class="n">_wrap_coordsys</span>
<span class="kn">from</span> <span class="nn">.componentlist</span> <span class="kn">import</span> <span class="n">componentlist</span> <span class="k">as</span> <span class="n">_wrap_componentlist</span>
<span class="n">_wrap_image</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">swig_object</span><span class="p">:</span> <span class="n">image</span><span class="p">(</span><span class="n">swig_object</span><span class="o">=</span><span class="n">swig_object</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">image</span><span class="p">:</span>
    <span class="n">_info_group_</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;images&quot;&quot;&quot;</span>
    <span class="n">_info_desc_</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;Operations on images&quot;&quot;&quot;</span>
    <span class="c1">### self</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;swig_object&#39;</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span> <span class="o">=</span> <span class="n">_image</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">newimage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">infile</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This method is identical to ia.newimagefromfile(). The description of how it works is in the help for that method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_wrap_image</span><span class="p">(</span><span class="n">swig_object</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">newimage</span><span class="p">(</span><span class="n">infile</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">newimagefromfile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">infile</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This method returns an image analysis tool associated with the specified image.</span>
<span class="sd">        Constructing a image analysis tool in addition to the default ia tool allows the</span>
<span class="sd">        user to operate on multiple images simultaneously. All ia.newimagefrom*()</span>
<span class="sd">        methods share this behavior.</span>
<span class="sd">        </span>
<span class="sd">        The parameter infile may refer to a CASA image, a Miriad image, or a FITS image.</span>
<span class="sd">        FITS images of types Float are supported.</span>
<span class="sd">        </span>
<span class="sd">        When finished with the newly created tool, the user should close it to free</span>
<span class="sd">        up system resources (eg memory).</span>
<span class="sd">        </span>
<span class="sd">        ia.newimage() is an alias for this method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_wrap_image</span><span class="p">(</span><span class="n">swig_object</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">newimagefromfile</span><span class="p">(</span><span class="n">infile</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">imagecalc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outfile</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">pixels</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">imagemd</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">prec</span><span class="o">=</span><span class="s1">&#39;float&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This method is used to evaluate a mathematical expression involving</span>
<span class="sd">        existing images. It fully supports float, double, and complex float, and complex</span>
<span class="sd">        double valued images.</span>
<span class="sd">        The syntax of the expression supplied via the pixels</span>
<span class="sd">        parameter (in what is called the Lattice Expression Language, or LEL) is</span>
<span class="sd">        explained in detail in htmladdnormallink{note</span>
<span class="sd">        223}{http://aips2.nrao.edu/docs/notes/223/223.html}. This is a rich</span>
<span class="sd">        mathematical language with allows all manner of mathematical operations</span>
<span class="sd">        to be applied to images.</span>
<span class="sd">        </span>
<span class="sd">        Any image files embedded in the expression may be native casa or</span>
<span class="sd">        fits (but not yet Miriad) images.</span>
<span class="sd">        </span>
<span class="sd">        If successful, this method always returns an image analysis tool that</span>
<span class="sd">        references the image resulting from the calculation. This returned tool</span>
<span class="sd">        should always be captured and closed as soon as the user is done with it</span>
<span class="sd">        to free up system resources (eg, memory). The image analysis tool on which</span>
<span class="sd">        the method is called (eg the ia tool when one runs ia.imagecalc()) remains</span>
<span class="sd">        unaltered, eg it still refers to the same image it did prior to the imagecalc()</span>
<span class="sd">        call.</span>
<span class="sd">        </span>
<span class="sd">        Values of the returned tool are evaluated &quot;on demand&quot;. That is, only when a method</span>
<span class="sd">        is run on the returned tool are the necessary values computed. And in fact, the</span>
<span class="sd">        values have to be reevaluated for each operation (method call). This means that</span>
<span class="sd">        there is a small performance hit for using the returned tool rather than the image</span>
<span class="sd">        written to disk and that none of the images which were used in the expression</span>
<span class="sd">        should be deleted while the returned tool is in use because they must be accessed</span>
<span class="sd">        for calculating the expression each time an operation of the returned tool is</span>
<span class="sd">        performed. These limitations do not apply to the ouput image if one is specified</span>
<span class="sd">        with the outfile parameter; it is a genuine CASA image with</span>
<span class="sd">        numerical values. If outfile is blank, no ouput image is written (although</span>
<span class="sd">        the resulting image can still be accessed via the returned image analysis tool</span>
<span class="sd">        as described below).</span>
<span class="sd">        </span>
<span class="sd">        Normally you should just write the image, close the returned</span>
<span class="sd">        tool, and open the results image with the default ia tool and operate on it. If</span>
<span class="sd">        you are interested in conserving disk space, you don&#39;t need to keep the result of</span>
<span class="sd">        the calculation around for very long, and/or you are only going to do a small</span>
<span class="sd">        number of operations on the result image, should you set outfile=&quot;&quot;.</span>
<span class="sd">        </span>
<span class="sd">        Note that when multiple image are used in the expression, there is</span>
<span class="sd">        no garauntee about which of those images will be used to create the metadata</span>
<span class="sd">        of the output image, unless imagemd is specified. If imagemd is specified, the following</span>
<span class="sd">        rules of metadata copying will be followed:</span>
<span class="sd">        </span>
<span class="sd">        1. The pixel data type of the image specified by imagemd and the output image must</span>
<span class="sd">        be the same.</span>
<span class="sd">        2. The metadata copied include the coordinate system (and so of course the dimensionality of</span>
<span class="sd">        the output image must correspond to the coordinate system to be copied), the image_info record</span>
<span class="sd">        (which contains things like the beam(s)), the misc_info record (should one exist in the image</span>
<span class="sd">        specified by imagemd), and the units.</span>
<span class="sd">        3. If the output image is a spectral image, the brightness units are set to the empty string.</span>
<span class="sd">        4. If the ouptut image is a polarization angle image, the brightness unit is set to &quot;deg&quot; and</span>
<span class="sd">        the stokes coordinate is set to have a single plane of type of Pangle.</span>
<span class="sd">        </span>
<span class="sd">        The precision (float or double) of the output image pixels is determined by</span>
<span class="sd">        the value specified by the prec parameter. The domain (real or complex) of</span>
<span class="sd">        the output pixel values is determined from the expression.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_wrap_image</span><span class="p">(</span><span class="n">swig_object</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">imagecalc</span><span class="p">(</span><span class="n">outfile</span><span class="p">,</span> <span class="n">pixels</span><span class="p">,</span> <span class="n">overwrite</span><span class="p">,</span> <span class="n">imagemd</span><span class="p">,</span> <span class="n">prec</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">collapse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">function</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">outfile</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">region</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">box</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">chans</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">stokes</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">stretch</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This method collapses an image along a specified axis or set of axes of length N pixels to a single pixel on each</span>
<span class="sd">        specified axis. Both float valued and complex valued images are supported. It computes a user-specified aggregate</span>
<span class="sd">        function for pixel values along the specified axes, and places those values in the single remaining plane of</span>
<span class="sd">        those axes in the output image. The method returns an image analysis tool containing the newly-created collapsed</span>
<span class="sd">        image. Valid choices of aggregate functions are: &#39;flux&#39; (see below for constraitns), &#39;madm&#39; (median absolute</span>
<span class="sd">        deviation from the median), &#39;max&#39;, &#39;mean&#39;, &#39;median&#39;, &#39;min&#39;, &#39;npts&#39;, &#39;rms&#39;, &#39;stddev&#39;, &#39;sum&#39;, &#39;variance&#39; and &#39;xmadm&#39;</span>
<span class="sd">        (median absolute deviation from the median multipied by x, where x is the reciprocal of Phi^-1(3/4), where Phi^-1</span>
<span class="sd">        is the reciprocal of the quantile function. Numerically, x = 1.482602218505602. See, eg,</span>
<span class="sd">        https://en.wikipedia.org/wiki/Median_absolute_deviation#Relation_to_standard_deviation). Minimal unique matching is</span>
<span class="sd">        supported for the function parameter (e.g. function = &#39;r&#39; will compute the rms of the pixel values, &#39;med&#39; will</span>
<span class="sd">        compute the median, etc.).</span>
<span class="sd">        </span>
<span class="sd">        If one specifies function=&#39;flux&#39;, the following constraints must be true:</span>
<span class="sd">        </span>
<span class="sd">        1. The image must have a direction coordinate,</span>
<span class="sd">        2. The image must have at least one beam,</span>
<span class="sd">        3. The specified axes must be exactly the direction coordinate axes,</span>
<span class="sd">        4. Only one of the non-directional axes may be non-degenerate,</span>
<span class="sd">        5. The iamge brightness unit must be conformant with x*yJy/beam, where x is an optional unit (such as km/s for moments images)</span>
<span class="sd">        and y is an optional SI prefix.</span>
<span class="sd">        </span>
<span class="sd">        Axes may be specified as a single integer or an array of integers indicating the zero-based</span>
<span class="sd">        axes along which to collapse the image. Axes may also be specified as a single or array of strings which</span>
<span class="sd">        minimally and uniquely match (ignoring case) world axis names in the image (e.g. &#39;dec&#39; for</span>
<span class="sd">        collapsing along the declination axis or [&#39;ri&#39;, &#39;d&#39;] for collapsing along both the right ascension and</span>
<span class="sd">        declination axes).</span>
<span class="sd">        </span>
<span class="sd">        If outfile is not specified (or contains only whitespace characters), no image is written but the</span>
<span class="sd">        collapsed image is still accessible via the image analysis tool this method always returns (which</span>
<span class="sd">        references the collapsed image). If the returned object is not wanted, it should still be</span>
<span class="sd">        captured and destroyed via its done() method.  If this is not done, there is no guarantee</span>
<span class="sd">        as to when the Python garbage collector will delete it. If the returned object is wanted, it</span>
<span class="sd">        should still be deleted as soon as possible for the same reasons, e.g.</span>
<span class="sd">        </span>
<span class="sd">        collapsed_image = ia.collapse(...)</span>
<span class="sd">        begin{verbatim}</span>
<span class="sd">        # do things (or not) with the collapsed_image and when finished working with the object, do</span>
<span class="sd">        end{verbatim}</span>
<span class="sd">        collapsed_image.done()</span>
<span class="sd">        </span>
<span class="sd">        The reference pixel of the collapsed axis is set to 0 and its reference value is set to the mean</span>
<span class="sd">        of the the first and last values of that axis in the specified region of the input image. The</span>
<span class="sd">        reference value is the world coordinate value of the reference pixel. For instance, if an axis</span>
<span class="sd">        to be collapsed were to be the frequency axis, in the collapsed image, the reference value would</span>
<span class="sd">        be the mean value of the frequency range spanned, and would be stored in pixel 0.</span>
<span class="sd">        </span>
<span class="sd">        If the input image has per plane beams, the beam at the origin of the subimage determined by</span>
<span class="sd">        the selected region is arbitrarily made the global beam of the output image. In general, the user</span>
<span class="sd">        should understand the pitfalls of collapsing images with multiple beams (i.e. that employing an</span>
<span class="sd">        aggregate function on pixels with varying beam sizes more often than not leads to ill-defined</span>
<span class="sd">        results).  Convolution to a common beam is not performed automatically as part of the preprocessing</span>
<span class="sd">        before the actual rebinning occurs.  In such cases, therefore, the user should probably first</span>
<span class="sd">        convolve the input image with a common restoring beam so that each plane has the same resolution,</span>
<span class="sd">        and/or use imsmooth to smooth the data to have the same beam.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_wrap_image</span><span class="p">(</span><span class="n">swig_object</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">collapse</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="n">axes</span><span class="p">,</span> <span class="n">outfile</span><span class="p">,</span> <span class="n">region</span><span class="p">,</span> <span class="n">box</span><span class="p">,</span> <span class="n">chans</span><span class="p">,</span> <span class="n">stokes</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">overwrite</span><span class="p">,</span> <span class="n">stretch</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">decimate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outfile</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">factor</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;copy&#39;</span><span class="p">,</span> <span class="n">region</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">stretch</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This application removes planes along the specified axis of an image. It supports both float valued and complex</span>
<span class="sd">        valued images. The factor parameter represents the factor by which to reduce the number</span>
<span class="sd">        of planes.</span>
<span class="sd">        </span>
<span class="sd">        The method parameter represents how to calculate the pixel values of the output image. A</span>
<span class="sd">        value of method=&quot;copy&quot; means that every factorth plane of the selected region in the input</span>
<span class="sd">        image will be directly copied to the corresponding plane in the output image. So, if one</span>
<span class="sd">        wanted to copy every third spectral plane in the input image to the output image, one would</span>
<span class="sd">        specify factor=3 and method=&quot;copy&quot;. If the selected region along the specified axis had 11</span>
<span class="sd">        planes, then there would be 4 output planes which would map to planes 0, 3, 6, and 9 of</span>
<span class="sd">        the specified region of input image. A value of method=&quot;mean&quot; indicates that each of</span>
<span class="sd">        factor number of planes in the range starting at each factorth plane should be averaged to</span>
<span class="sd">        produce the corresponding output plane. So, if one specified factor=3 and method=&quot;mean&quot; along</span>
<span class="sd">        an axis of the selected region of the input image which had 11 pixels, the corresponding axis</span>
<span class="sd">        in the output image would have three pixels and the pixel values for each of those output</span>
<span class="sd">        planes would corresponding to averaging along that axis planes 0-2, 3-5, and 6-8 of the</span>
<span class="sd">        selected region of the input image. Note that the remaining planes, 9 and 10, in the selected</span>
<span class="sd">        region of the input image would be ignored because the last interval must have exactly</span>
<span class="sd">        factor number of planes in order to be included in the output image.</span>
<span class="sd">        </span>
<span class="sd">        The coordinate system of the output image takes into account the decimation; that is, along the</span>
<span class="sd">        decimated axis, the increment of the output image is factor times that of the input image, and</span>
<span class="sd">        the reference pixel of the output image is located at pixel 1/factor times the reference pixel</span>
<span class="sd">        in the input image.</span>
<span class="sd">        </span>
<span class="sd">        This method returns an image analysis tool which references the output image. If this tool</span>
<span class="sd">        is not desired, one should capture it anyway and then close() it immediately to free up</span>
<span class="sd">        resources.</span>
<span class="sd">        </span>
<span class="sd">        Images with multiple beams are not supported; please convolve a multi-beam image to a single</span>
<span class="sd">        resolution before running this application.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_wrap_image</span><span class="p">(</span><span class="n">swig_object</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">decimate</span><span class="p">(</span><span class="n">outfile</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">factor</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">region</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">overwrite</span><span class="p">,</span> <span class="n">stretch</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">dohistory</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">enable</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This allows control over if tool methods record history of what parameters they were called</span>
<span class="sd">        with to the input and/or output image. By default, tool methods will write to the image</span>
<span class="sd">        history. By explicitly disabling history writing, tool methods will not write to the history.</span>
<span class="sd">        When created, an ia tool will have history writing enabled. Note that the setting is specific</span>
<span class="sd">        to the individual tool, and that methods such as open(), close(), done(), fromshape(), etc do</span>
<span class="sd">        not implicitly change the internal state of whether or not history writing by methods is</span>
<span class="sd">        enabled. One can explicitly enable/disable history writing even if the tool is not yet attached</span>
<span class="sd">        to an image. In the case where a method returns a new ia tool, the method will not write history</span>
<span class="sd">        to the output image, but the returned tool will have history writing enabled, so that running</span>
<span class="sd">        methods on the returned tool will cause history to be written to the image attached to that</span>
<span class="sd">        tool, or any new image created by running methods on that tool, unless dohistory(False) is</span>
<span class="sd">        explicitly run on that tool prior to running other methods.</span>
<span class="sd">        </span>
<span class="sd">        IMPORTANT NOTE: This setting will not affect the behavior of ia.sethistory(); this tool</span>
<span class="sd">        method will always write to the history, no matter if ia.dohistory(False) was run prior.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">dohistory</span><span class="p">(</span><span class="n">enable</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">imageconcat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outfile</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">infiles</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">relax</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">tempclose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">reorder</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;paged&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This application is used to concatenate two or more input CASA</span>
<span class="sd">        images into one output image.  For example, if you have two image cubes</span>
<span class="sd">        which are contiguous along one axis (say a spectral axis) and you would</span>
<span class="sd">        like to glue them together along this axis, then this function is the</span>
<span class="sd">        appropriate thing to use.</span>
<span class="sd">        </span>
<span class="sd">        The axis parameter is used to specify which zero-based axis the images</span>
<span class="sd">        should be concatenated along. A negative value indicates that the</span>
<span class="sd">        spectral axis should be used. If a negative value is given but there is no</span>
<span class="sd">        spectral axis, an exception will be thrown. The zero-based order of the</span>
<span class="sd">        axes of an image can be determined from ia.coordsys().names().</span>
<span class="sd">        </span>
<span class="sd">        If successful, this method will return an image analysis tool referencing</span>
<span class="sd">        the concatenated image. Even if it is not wanted, the returned tool should</span>
<span class="sd">        be captured and closed as soon as the user is finished with it to free up</span>
<span class="sd">        system resources (eg memory).</span>
<span class="sd">        </span>
<span class="sd">        If outfile is given, the image is written to the specified</span>
<span class="sd">        disk file.  If outfile is unset, the on-the-fly image tool</span>
<span class="sd">        created by the method actually references all of the input files.</span>
<span class="sd">        So if you deleted any of the input image disk files, it would render</span>
<span class="sd">        this tool useless. Note that a blank outfile name may only be given</span>
<span class="sd">        in the case where mode=&#39;p&#39; (see below).  When you destroy this tool</span>
<span class="sd">        done() method, the reference connections are broken.</span>
<span class="sd">        </span>
<span class="sd">        The input and output images must be of the same dimensionality.  Therefore,</span>
<span class="sd">        if you wish to concatenate 2-D images into a 3-D image, the 2-D images</span>
<span class="sd">        must have a third axis (of length unity) so that the output image</span>
<span class="sd">        coordinates are known along the concatenation axis.</span>
<span class="sd">        </span>
<span class="sd">        The input images are concatenated in the order in which they are listed unless</span>
<span class="sd">        the reorder parameter is set to True. If True, the images are reordered if necessary</span>
<span class="sd">        so that the world coordinate values along the selected axis monotonically increase</span>
<span class="sd">        or decrease. The direction of the increment is determined by the first listed image.</span>
<span class="sd">        If reorder=True, the world coordinate ranges of the images along the selected axis</span>
<span class="sd">        are not permitted to overlap, and the signs of the increments for this axis in all</span>
<span class="sd">        images must be the same. If reorder=False, the coordinate system of the first listed</span>
<span class="sd">        image is used as the coordinate system for the output image. If reorder=True, the</span>
<span class="sd">        coordinate system of the first image in the list of the reordered images is used</span>
<span class="sd">        as the coordinate system of the output image. Setting reorder=True can be especially</span>
<span class="sd">        useful if the infiles are specified using a wildcard character(s).</span>
<span class="sd">        </span>
<span class="sd">        If relax=False, the input images are checked to see that they are</span>
<span class="sd">        contiguous along the concatenation axis and an exception is thrown if</span>
<span class="sd">        they are not.  In addition, the coordinate descriptors (e.g.  reference</span>
<span class="sd">        pixel, reference value etc) for the non-concatenation axes must be the</span>
<span class="sd">        same or an error will result.</span>
<span class="sd">        </span>
<span class="sd">        The input disk image files may be in native (CASA or FITS) formats.</span>
<span class="sd">        </span>
<span class="sd">        The contiguous criterion and coordinate descriptor equality criteria can</span>
<span class="sd">        be relaxed by setting relax=True whereupon only warnings will be</span>
<span class="sd">        issued.  Dimension and shape must still be the same though.  When the</span>
<span class="sd">        concatenation axis is not contiguous (but still monotonically increasing</span>
<span class="sd">        or decreasing) and relax=True, a tabular coordinate will be used</span>
<span class="sd">        to correctly describe the axis.  But be aware that it means adjacent</span>
<span class="sd">        pixels are not regularly spaced.  However, methods like toworld() and</span>
<span class="sd">        topixel() will correctly interconvert world and pixel coordinates.</span>
<span class="sd">        </span>
<span class="sd">        In giving the input image names, the infiles argument can be a</span>
<span class="sd">        single string if you wild card it with standard shell symbols.  For</span>
<span class="sd">        example, infiles=&#39;cena_???.*&#39;, where the &#39;?&#39; represents one</span>
<span class="sd">        character and &#39;*&#39; any number of characters.</span>
<span class="sd">        </span>
<span class="sd">        Otherwise, you must input a vector of strings such as</span>
<span class="sd">        infiles=&quot;cena1 cena2 cena3&quot;.  An input such as infiles=&#39;files1,file2&#39;</span>
<span class="sd">        will be interpreted as one string naming one file and an exception will</span>
<span class="sd">        be thrown.  The reason for this is that although the latter could be</span>
<span class="sd">        parsed to extract two file names by recognizing comma delimiters, it</span>
<span class="sd">        is not possible because an expression such as infiles=&#39;cena.{a,b}&#39;</span>
<span class="sd">        (meaning files of name &#39;cena.a&#39; and &#39;cena.b&#39;) would confuse such</span>
<span class="sd">        parsing (you would get two files of name cena.{a} and {sff b}.</span>
<span class="sd">        </span>
<span class="sd">        You can look at the coordinate system of the output image using the</span>
<span class="sd">        ia.summary() method to ensure it&#39;s correct.</span>
<span class="sd">        </span>
<span class="sd">        The parameter tempclose is, by default, True.  This means that</span>
<span class="sd">        all internal reference copies of the input images are kept closed until</span>
<span class="sd">        they are needed. Then they are opened temporarily and then closed again.</span>
<span class="sd">        This enables you to effectively concatenate as many images as you like</span>
<span class="sd">        without encountering any operating system open file number limits.</span>
<span class="sd">        However, it comes at some performance loss, because opening and closing</span>
<span class="sd">        all those files takes time.  If you are concatenating a smallish number</span>
<span class="sd">        of files, you might use tempclose=False.  This will leave all internal</span>
<span class="sd">        reference copies permanently open, but performance, if you don&#39;t hit the</span>
<span class="sd">        file limit, will be better.</span>
<span class="sd">        </span>
<span class="sd">        The mode parameter controls the format of the output image. If mode=&#39;p&#39;,</span>
<span class="sd">        then a &quot;paged&quot; (normal persistent CASA format) image in which all the</span>
<span class="sd">        pixel values and metadata are copied to a single image is created. All</span>
<span class="sd">        the other modes will create a &quot;virtual concat&quot; image. In this format,</span>
<span class="sd">        a directory, named outfile, is created to store metadata about each image.</span>
<span class="sd">        The metadata are placed in a file in this directory named imageconcat.json,</span>
<span class="sd">        which is a plain text file in JSON format. In the json file are pointers</span>
<span class="sd">        to the actual disk images that make up the virtual concat image. In the</span>
<span class="sd">        case of mode=&#39;c&#39; (copy), alll the disk images are copied to the outfile</span>
<span class="sd">        directory and the json file references the images in the outfile directory.</span>
<span class="sd">        In the case of mode=&#39;m&#39; (move), the disk images are instead moved to the</span>
<span class="sd">        outfile directory, and again the json file references the images in the</span>
<span class="sd">        outfile directory. These two modes make it simple to deal with the</span>
<span class="sd">        virtual concat image as a single unit, for example, if the user needs</span>
<span class="sd">        to move the image or tar it up, the resulting moved image or untarred file</span>
<span class="sd">        will be accessible by the image tool as a valid image. The final option,</span>
<span class="sd">        mode=&#39;n&#39; (no copy) means the output directory only contains the json file</span>
<span class="sd">        and references the input image paths as given. In this case, moving the</span>
<span class="sd">        outfile directory without moving the reference images will normally cause</span>
<span class="sd">        problems, especially if the input images were given using relative path</span>
<span class="sd">        names. So, one must think carefully if mode=&#39;n&#39; will be the correct option</span>
<span class="sd">        for their use case in the long run.</span>
<span class="sd">        </span>
<span class="sd">        This method requires multiple images which are specified with the infiles</span>
<span class="sd">        parameter. Therefore calling ia.open() is not necessary, although calling</span>
<span class="sd">        imageconcat() using an already open image analysis tool will work and the</span>
<span class="sd">        state of that tool (eg the image it references) will not be changed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_wrap_image</span><span class="p">(</span><span class="n">swig_object</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">imageconcat</span><span class="p">(</span><span class="n">outfile</span><span class="p">,</span> <span class="n">infiles</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">relax</span><span class="p">,</span> <span class="n">tempclose</span><span class="p">,</span> <span class="n">overwrite</span><span class="p">,</span> <span class="n">reorder</span><span class="p">,</span> <span class="n">mode</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">fromarray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outfile</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">pixels</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">csys</span><span class="o">=</span><span class="p">{</span> <span class="p">},</span> <span class="n">linear</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s1">&#39;f&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This application converts a numerical numpy array of any size and dimensionality</span>
<span class="sd">        into a CASA image. It will create float, double, complex-float, and complex-double</span>
<span class="sd">        valued images.</span>
<span class="sd">        </span>
<span class="sd">        The image analysis tool on which this method is called will reference the created</span>
<span class="sd">        image; if this tool referenced another image before this call, that image will no</span>
<span class="sd">        longer be referenced by the tool after the creation of the new image. If you</span>
<span class="sd">        would rather have a new image analysis tool returned, keeping the one on which</span>
<span class="sd">        this method is called unaltered, use newimagefromarray() instead. If outfile is</span>
<span class="sd">        specified, a persistent image is written to disk, if not, the image tool on</span>
<span class="sd">        which this method was called will reference a temporary image (either in memory</span>
<span class="sd">        or on disk, depending on its size) that will be deleted when the tool is closed.</span>
<span class="sd">        </span>
<span class="sd">        The type parameter controls the data type/precision of the pixel values of the</span>
<span class="sd">        created image. &#39;f&#39; indicates that float precision point (32 bit precision) pixel</span>
<span class="sd">        values should be writted. &#39;d&#39; indicates that double precision (64 bit precision)</span>
<span class="sd">        pixel values should be written. If the input array has complex (as opposed to</span>
<span class="sd">        real) values, then complex pixel values, with each of the real and imaginary</span>
<span class="sd">        parts having the specified precision, will be written. Array values will be cast</span>
<span class="sd">        automatically to the specified precision, so that the precision of the input</span>
<span class="sd">        array values may be increased, decreased, or unchanged depending on the input</span>
<span class="sd">        array type.</span>
<span class="sd">        </span>
<span class="sd">        The coordinate system, provided as a a dictionary (use eg, cs.torecord() to do</span>
<span class="sd">        that), is optional. If specified, it must have the same number of dimensions</span>
<span class="sd">        as the pixels array. Call the naxes() method on the coordinate system tool to</span>
<span class="sd">        see how many dimensions the coordinate system has. A coordinate system can be</span>
<span class="sd">        created from scratch using the coordinate system (cs) tool and methods therein,</span>
<span class="sd">        but often users prefer to use a coordinate system from an already existing image.</span>
<span class="sd">        This can be gotten using ia.coordsys() which returns a coordinate system tool.</span>
<span class="sd">        A torecord() call on that tool will result in a python dictionary describing</span>
<span class="sd">        the coordinate system which is the necessary format for the csys input parameter</span>
<span class="sd">        of ia.fromarray().</span>
<span class="sd">        </span>
<span class="sd">        If csys is not specified, a default coordinate system will be created. If</span>
<span class="sd">        linear=False (the default), the created coordinate system will have standard</span>
<span class="sd">        RA/DEC/Stokes/Spectral Coordinate axes depending upon the shape of the pixels</span>
<span class="sd">        array (Stokes axis must be no longer than 4 pixels and the spectral axis may</span>
<span class="sd">        precede the Stokes axis if eg, shape=[64,64,32,4]. Extra dimensions are given</span>
<span class="sd">        linear coordinates.  If linear=True, then all the resulting coordinates</span>
<span class="sd">        are linear with the axes represent lengths. In this case each axis will have a</span>
<span class="sd">        value of 0.0 at its center pixel. The increment of each axis will be 1.0 km.</span>
<span class="sd">        </span>
<span class="sd">        The method returns True if creation of the image was successful, False otherwise,</span>
<span class="sd">        so a check can be made programmatically if the image creation was successful.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">fromarray</span><span class="p">(</span><span class="n">outfile</span><span class="p">,</span> <span class="n">pixels</span><span class="p">,</span> <span class="n">csys</span><span class="p">,</span> <span class="n">linear</span><span class="p">,</span> <span class="n">overwrite</span><span class="p">,</span> <span class="n">log</span><span class="p">,</span> <span class="nb">type</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">fromcomplist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outfile</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">[</span>  <span class="p">],</span> <span class="n">cl</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">csys</span><span class="o">=</span><span class="p">{</span> <span class="p">},</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This method allows one to create an image based on a component list. A component list</span>
<span class="sd">        is a list of simple models (point sources, Gaussians, disks, etc) that describe the</span>
<span class="sd">        sky brightness (cf the component list (cl) tool). Images that can be described in this</span>
<span class="sd">        way normally require significantly less space to store than traditional images in which</span>
<span class="sd">        all the pixel values are stored. For a component list image, pixel values are computed</span>
<span class="sd">        &quot;on the fly&quot;. Pixel values can be cached by specifying cache=True (the default value)</span>
<span class="sd">        while the image is attached to an image tool, which permits faster access to them after</span>
<span class="sd">        they are computed the first time. The trade off to caching is that resources such as</span>
<span class="sd">        memory and disk space must be used to cache the pixel values.</span>
<span class="sd">        </span>
<span class="sd">        The image is constrained to have two, three, or four dimensions. One must specify an</span>
<span class="sd">        image shape (the dimensionality of which must adhere to this constraint). One may also</span>
<span class="sd">        supply a coordinate system specification using the csys parameter. If a coordinate system</span>
<span class="sd">        is not specified, a default coordinate system is used. If specified, the coordinate system</span>
<span class="sd">        must have a direction coordinate which has two pixel axes. It can also have a spectral</span>
<span class="sd">        and/or polarization coordinate. The maximum length of the polarization coordinate is four</span>
<span class="sd">        pixels, and the world coordinate values of the polarization coordinate are constrained to</span>
<span class="sd">        be in the set of stokes parameters I, Q, U, and V.</span>
<span class="sd">        </span>
<span class="sd">        As is common with image creation methods, specifying an empty string for the outfile parameter</span>
<span class="sd">        results in a tempoary image being created that will be deleted when either the done() or</span>
<span class="sd">        close() method is run on the tool. By specifying a non-empty string, the image is saved to</span>
<span class="sd">        disk and can be opened with the open() method later. A persistent component list image is</span>
<span class="sd">        composed of a component list table that has metadata describing the image-related information,</span>
<span class="sd">        such as the coordinate system and the shape, as well as a history (log) table.</span>
<span class="sd">        </span>
<span class="sd">        Because pixel values are computed from the component models, altering pixel values is not</span>
<span class="sd">        supported. So methods such as putchunk(), putregion(), and addnoise() will fail on component</span>
<span class="sd">        list images when trying to modify pixel values. However, persistent image masks and on the fly</span>
<span class="sd">        masks are fully supported.</span>
<span class="sd">        </span>
<span class="sd">        The brightness unit of a component list image is constrained to be &quot;Jy/pixel&quot;. Attempts to</span>
<span class="sd">        modify this value using setbrightnessunit() will fail.</span>
<span class="sd">        </span>
<span class="sd">        Component list images do not support synthesized beams; attempting to run setrestoringbeam() on</span>
<span class="sd">        a component list image to add a beam(s) will fail.</span>
<span class="sd">        </span>
<span class="sd">        One can easily create an image in which the pixel values are persistently stored from a</span>
<span class="sd">        component list image by running methods such as fromimage(), subimage(), tofits(), etc. In</span>
<span class="sd">        general, any method run on a component list image that creates a new image will create a</span>
<span class="sd">        non-component list image (eg, a traditional CASA Paged image or Temporary image) in which the</span>
<span class="sd">        pixel values are explicitly stored.</span>
<span class="sd">        </span>
<span class="sd">        DISK MODELS</span>
<span class="sd">        </span>
<span class="sd">        Pixels with centers inside the disk will have the same values, even if a pixel straddles the</span>
<span class="sd">        edge of the disk. Pixels with straddle the edge of the disk which have centers outside the</span>
<span class="sd">        disk are given values of zero. Thus, one should not expect the flux density of the disk to</span>
<span class="sd">        be exactly the provided value to the component list; for a given size disk, the computed flux</span>
<span class="sd">        density will be closer to the expected value for images with smaller pixels.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">fromcomplist</span><span class="p">(</span><span class="n">outfile</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">cl</span><span class="p">,</span> <span class="n">csys</span><span class="p">,</span> <span class="n">overwrite</span><span class="p">,</span> <span class="n">log</span><span class="p">,</span> <span class="n">cache</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">fromfits</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outfile</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">infile</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">whichrep</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">whichhdu</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">zeroblanks</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function is used to convert a FITS disk image file (Float,</span>
<span class="sd">        Double, Short, Long are supported) to an</span>
<span class="sd">        casa imagefile.  If {stfaf outfile} is given, the image is written</span>
<span class="sd">        to the specified disk file.  If {stfaf outfile} is unset, the Image</span>
<span class="sd">        tool is associated with a temporary image.  This temporary image may</span>
<span class="sd">        be in memory or on disk, depending on its size.  When you close the</span>
<span class="sd">        Image tool (with the close function) this</span>
<span class="sd">        temporary image is deleted.</span>
<span class="sd">        </span>
<span class="sd">        This function reads from the FITS primary array (when the image is at</span>
<span class="sd">        the beginning of the FITS file; {stfaf whichhdu=0}), or an image</span>
<span class="sd">        extension (when the image is elsewhere in the FITS file, {stfaf</span>
<span class="sd">        whichhdu $&gt;$ 0}).</span>
<span class="sd">        </span>
<span class="sd">        By default, any blanked pixels will be converted to a mask value which</span>
<span class="sd">        is false, and a pixel value that is NaN.  If you set {stfaf</span>
<span class="sd">        zeroblanks=T} then the pixel value will be zero rather than NaN.  The</span>
<span class="sd">        mask will still be set to false.  See the function</span>
<span class="sd">        replacemaskedpixels if you</span>
<span class="sd">        need to replace masked pixel values after you have created the image.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">fromfits</span><span class="p">(</span><span class="n">outfile</span><span class="p">,</span> <span class="n">infile</span><span class="p">,</span> <span class="n">whichrep</span><span class="p">,</span> <span class="n">whichhdu</span><span class="p">,</span> <span class="n">zeroblanks</span><span class="p">,</span> <span class="n">overwrite</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">fromimage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outfile</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">infile</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">region</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">mask</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">dropdeg</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function applies a region to an imagefile, creates a new</span>
<span class="sd">        imagefile containing the (sub)image, and associates the imagetool</span>
<span class="sd">        with it.</span>
<span class="sd">        </span>
<span class="sd">        The input image file may be in native casa, fits, or Miriad</span>
<span class="sd">        format.  Look htmlref{here}{IMAGES:FOREIGNIMAGES}  for more</span>
<span class="sd">        information on foreign images.</span>
<span class="sd">        </span>
<span class="sd">        If {stfaf outfile} is given, the (sub)image is written to the specified</span>
<span class="sd">        disk file.</span>
<span class="sd">        </span>
<span class="sd">        If {stfaf outfile} is unset, the Image tool actually references</span>
<span class="sd">        the input image file.  So if you deleted the input image disk file, it</span>
<span class="sd">        would render this tool useless.  When you close this tool</span>
<span class="sd">        (with the close function)</span>
<span class="sd">        the reference connection is broken.</span>
<span class="sd">        </span>
<span class="sd">        Sometimes it is useful to drop axes of length one (degenerate axes).</span>
<span class="sd">        Use the {stfaf dropdeg} argument if you want to do this.</span>
<span class="sd">        </span>
<span class="sd">        The output mask is the combination (logical OR) of the default input</span>
<span class="sd">        pixelmask (if any) and the OTF mask.  Any other input pixelmasks</span>
<span class="sd">        will not be copied.  Use function</span>
<span class="sd">        maskhandler if you need to copy other</span>
<span class="sd">        masks too.</span>
<span class="sd">        </span>
<span class="sd">        See also the subimage function.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">fromimage</span><span class="p">(</span><span class="n">outfile</span><span class="p">,</span> <span class="n">infile</span><span class="p">,</span> <span class="n">region</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">dropdeg</span><span class="p">,</span> <span class="n">overwrite</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">fitsheader</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">retstr</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="p">[</span>  <span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This method constructs a FITS header dictionary which describes the current image. The</span>
<span class="sd">        exclude parameter can either be a string or a list of strings. It indicates FITS header</span>
<span class="sd">        keywords to exclude. This may be useful for the HISTORY keyword because the HISTORY can</span>
<span class="sd">        be very long. If the retstr parameter is set to True, then a string will be returned</span>
<span class="sd">        representing the FITS header. The exculde parameter has no effect when the header</span>
<span class="sd">        information is returned as a single string. An new IMAGENME keyword is added to the</span>
<span class="sd">        header. The value for IMAGENME is the string returned by name method, but the name is</span>
<span class="sd">        truncated to the maximum size for a FITS header value, 68 characters. The image name</span>
<span class="sd">        is truncated from the beginning of the string to reduce it to 68 characters, so the</span>
<span class="sd">        value will contain either the full name or the final 68 characters of the name.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">fitsheader</span><span class="p">(</span><span class="n">retstr</span><span class="p">,</span> <span class="n">exclude</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">fromshape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outfile</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">[</span> <span class="nb">int</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">],</span> <span class="n">csys</span><span class="o">=</span><span class="p">{</span> <span class="p">},</span> <span class="n">linear</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s1">&#39;f&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function creates a CASA image with the specified shape.  All the pixel</span>
<span class="sd">        values in the image are set to 0. One may create an image with float precision</span>
<span class="sd">        pixels (type=&#39;f&#39;), complex float precision pixels (type=&#39;c&#39;), double precision</span>
<span class="sd">        pixels (type=&#39;d&#39;), or complex double precision pixels (&#39;cd&#39;). To use a numpy</span>
<span class="sd">        array of values to create an image, use ia.fromarray(). To make a 2-D image from</span>
<span class="sd">        a packaged FITS file, use ia.maketestimage().</span>
<span class="sd">        </span>
<span class="sd">        If outfile is given, the image is written to the specified disk file.  If</span>
<span class="sd">        outfile is unset, the image analysis tool is associated with a temporary image.</span>
<span class="sd">        This temporary image may be in memory or on disk, depending on its size.  When</span>
<span class="sd">        you close the image analysis tool  (with the ia.close() method, the temporary</span>
<span class="sd">        image is deleted.</span>
<span class="sd">        </span>
<span class="sd">        The coordinate system, provided as a coordinate system tool record, is optional.</span>
<span class="sd">        If provided, it must be dimensionally consistent with the specified shape.</span>
<span class="sd">        </span>
<span class="sd">        If the coordinate system is not provided, a default coordinate system will be</span>
<span class="sd">        created.  If linear=False (the default), then it is a</span>
<span class="sd">        standard RA/DEC/Stokes/Spectral coordinate system depending exactly upon the</span>
<span class="sd">        shape (the Stokes axis must be no longer than 4 pixels and spectral axis may</span>
<span class="sd">        occur prior to the Stokes axis if eg, shape=[64,64,32,4]. Extra dimensions are</span>
<span class="sd">        given linear coordinates. If linear=True, then the coordinate system will have</span>
<span class="sd">        linear coordinates.</span>
<span class="sd">        </span>
<span class="sd">        The method returns True if successful, False otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">fromshape</span><span class="p">(</span><span class="n">outfile</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">csys</span><span class="p">,</span> <span class="n">linear</span><span class="p">,</span> <span class="n">overwrite</span><span class="p">,</span> <span class="n">log</span><span class="p">,</span> <span class="nb">type</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">maketestimage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outfile</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function converts a FITS file resident in the casa  system into</span>
<span class="sd">        a casa  image.</span>
<span class="sd">        </span>
<span class="sd">        If outfile is given, the image is written to the specified disk</span>
<span class="sd">        file. If outfile is unset, the Image tool is associated with a</span>
<span class="sd">        temporary image. This temporary image may be in memory or on disk,</span>
<span class="sd">        depending on its size. When you close the Image tool (with the close</span>
<span class="sd">        function) this temporary image is deleted.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">maketestimage</span><span class="p">(</span><span class="n">outfile</span><span class="p">,</span> <span class="n">overwrite</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">deviation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outfile</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">region</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">stretch</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">grid</span><span class="o">=</span><span class="p">[</span> <span class="nb">int</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="nb">int</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">],</span> <span class="n">anchor</span><span class="o">=</span><span class="s1">&#39;ref&#39;</span><span class="p">,</span> <span class="n">xlength</span><span class="o">=</span><span class="s1">&#39;1pix&#39;</span><span class="p">,</span> <span class="n">ylength</span><span class="o">=</span><span class="s1">&#39;1pix&#39;</span><span class="p">,</span> <span class="n">interp</span><span class="o">=</span><span class="s1">&#39;cubic&#39;</span><span class="p">,</span> <span class="n">stattype</span><span class="o">=</span><span class="s1">&#39;sigma&#39;</span><span class="p">,</span> <span class="n">statalg</span><span class="o">=</span><span class="s1">&#39;classic&#39;</span><span class="p">,</span> <span class="n">zscore</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">maxiter</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This application creates an image that reflects the statistics of the input image. The output image has</span>
<span class="sd">        the same dimensions and coordinate system as the (selected region in) input image. The grid parameter</span>
<span class="sd">        describes how many pixels apart &quot;grid&quot; pixels are. Statistics are computed around each grid pixel. Grid</span>
<span class="sd">        pixels are limited to the direction plane only; independent statistics are computed for each direction plane</span>
<span class="sd">        (ie at each frequency/stokes pixel should the input image happen to have such additional axes). Using the</span>
<span class="sd">        xlength and ylength parameters, one may specify either a rectangular or circular region around each grid</span>
<span class="sd">        point that defines which surrounding pixels are used in the statistic computation for individual grid points.</span>
<span class="sd">        If the ylength parameter is the empty string, then a circle of diameter provided by xlength centered on</span>
<span class="sd">        the grid point is used. If ylength is not empty, then a rectangular box of dimensions xlength x ylength centered</span>
<span class="sd">        on the grid pixel is used. These two parameters may be specified in pixels, using either numerical values or</span>
<span class="sd">        valid quantities with &quot;pix&quot; as the unit (eg &quot;4pix&quot;). Otherwise, they must be specified as valid angular</span>
<span class="sd">        quantities, with recognized units (eg &quot;4arcsec&quot;). As with other region selections in CASA, full pixels are</span>
<span class="sd">        included in the computation even if the specified region includes only a fraction of that pixel. BEWARE OF</span>
<span class="sd">        MACHINE PRECISION ISSUES, because you may get a smaller number of pixels included in a region than you</span>
<span class="sd">        expect if you specify, eg, an integer number of pixels. In such cases, you probably want to specify that</span>
<span class="sd">        number plus a small epsilon value (eg &quot;2.0001pix&quot; rather than &quot;2pix&quot;) to mitigate machine precision issues</span>
<span class="sd">        when computing region extents.</span>
<span class="sd">        </span>
<span class="sd">        The output image is formed by putting the statistics calculated at each grid point at the corresponding</span>
<span class="sd">        grid point in the output image. Interpolation of these output values is then used to compute values at</span>
<span class="sd">        non-grid-point pixels. The user may specify which interpolation algorithm to use for this computation</span>
<span class="sd">        using the interp parameter.</span>
<span class="sd">        </span>
<span class="sd">        The input image pixel mask is copied to the output image. If interpolation is performed, output pixels are</span>
<span class="sd">        masked where the interpolation fails.</span>
<span class="sd">        </span>
<span class="sd">        ANCHORING THE GRID</span>
<span class="sd">        </span>
<span class="sd">        The user may choose at which pixel to &quot;anchor&quot; the grid. For example, if one specifies grid=[4,4] and</span>
<span class="sd">        anchor=[0,0], grid points will be located at pixels [0,0], [0,4], [0,8] ... [4,0], [4,4], etc. This</span>
<span class="sd">        is exactly the same grid that would be produced if the user specified anchor=[4,4] or anchor=[20,44].</span>
<span class="sd">        If the user specifies anchor=[1, 2] and grid=[4,4], then the grid points will be at pixels [1,2], [5,2],</span>
<span class="sd">        [9,2]... [5,2], [5,6], etc. and the resulting grid is the same as it would be if the user specified eg</span>
<span class="sd">        anchor=[9,10] or anchor=[21, 18]. The value &quot;ref&quot;, which is the default, indicates that the reference</span>
<span class="sd">        pixel of the input image should be used to anchor the grid. The x and y values of this pixel will be</span>
<span class="sd">        rounded to the nearest integer if necessary.</span>
<span class="sd">        </span>
<span class="sd">        SUPPORTED STATISTICS AND STATISTICS ALGORITHMS</span>
<span class="sd">        </span>
<span class="sd">        One may specify which statistic should be represented using the stattype parameter. The following values</span>
<span class="sd">        are recognized (minimum match supported):</span>
<span class="sd">        </span>
<span class="sd">        +--------------------+-------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        | iqr                | inner quartile range (q3 - q1)                                                                        |</span>
<span class="sd">        +--------------------+-------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        | max                | maximum                                                                                               |</span>
<span class="sd">        +--------------------+-------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        | mean               | mean                                                                                                  |</span>
<span class="sd">        +--------------------+-------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        | medabsdevmed, madm | median absolute deviation from the median                                                             |</span>
<span class="sd">        +--------------------+-------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        | median             | median                                                                                                |</span>
<span class="sd">        +--------------------+-------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        | min                | minimum                                                                                               |</span>
<span class="sd">        +--------------------+-------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        | npts               | number of points                                                                                      |</span>
<span class="sd">        +--------------------+-------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        | q1                 | first quartile                                                                                        |</span>
<span class="sd">        +--------------------+-------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        | q3                 | third quartile                                                                                        |</span>
<span class="sd">        +--------------------+-------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        | rms                | rms                                                                                                   |</span>
<span class="sd">        +--------------------+-------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        | sigma, std         | standard deviation                                                                                    |</span>
<span class="sd">        +--------------------+-------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        | sumsq              | sum of squares                                                                                        |</span>
<span class="sd">        +--------------------+-------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        | sum                | sum                                                                                                   |</span>
<span class="sd">        +--------------------+-------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        | var                | variance                                                                                              |</span>
<span class="sd">        +--------------------+-------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        | xmadm              | median absolute deviation from the median multipied by x, where x is the reciprocal of Phi^-1(3/4),   |</span>
<span class="sd">        |                    | where Phi^-1 is the reciprocal of the quantile function. Numerically, x = 1.482602218505602. See, eg, |</span>
<span class="sd">        |                    | https://en.wikipedia.org/wiki/Median_absolute_deviation#Relation_to_standard_deviation                |</span>
<span class="sd">        +--------------------+-------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        </span>
<span class="sd">        Using the statalg parameter, one may also select whether to use the Classical or Chauvenet/ZScore statistics algorithm to</span>
<span class="sd">        compute the desired statistic (see the help for ia.statistics() or imstat for a full description of these algorithms).</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_wrap_image</span><span class="p">(</span><span class="n">swig_object</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">deviation</span><span class="p">(</span><span class="n">outfile</span><span class="p">,</span> <span class="n">region</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">overwrite</span><span class="p">,</span> <span class="n">stretch</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">anchor</span><span class="p">,</span> <span class="n">xlength</span><span class="p">,</span> <span class="n">ylength</span><span class="p">,</span> <span class="n">interp</span><span class="p">,</span> <span class="n">stattype</span><span class="p">,</span> <span class="n">statalg</span><span class="p">,</span> <span class="n">zscore</span><span class="p">,</span> <span class="n">maxiter</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">adddegaxes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outfile</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">spectral</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">stokes</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">linear</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">tabular</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">silent</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This method adds degenerate axes (i.e.</span>
<span class="sd">        axes of length 1) of the specified type.  Sometimes this can be useful</span>
<span class="sd">        although you will generally need to modify the coordinate system of the</span>
<span class="sd">        added axis to give it the coordinate you want (do this with the</span>
<span class="sd">        Coordsys tool). This method supports</span>
<span class="sd">        both float and complex valued images.</span>
<span class="sd">        </span>
<span class="sd">        You specify which type of axes you want to add.  You can&#39;t add</span>
<span class="sd">        an axis type that already exists in the image.  For the Stokes axis,</span>
<span class="sd">        the allowed value (a string such as  I, Q, XX, RR) can be found in the</span>
<span class="sd">        Coordsys newcoordsys function documentation.</span>
<span class="sd">        </span>
<span class="sd">        If {stfaf outfile} is given, the image is written to the specified</span>
<span class="sd">        disk file.  If {stfaf outfile} is unset, the on-the-fly Image tool</span>
<span class="sd">        returned by the function is associated with a temporary image.  This</span>
<span class="sd">        temporary image may be in memory or on disk, depending on its size.</span>
<span class="sd">        When you destroy the generated Image tool (with the done function) this</span>
<span class="sd">        temporary image is deleted.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_wrap_image</span><span class="p">(</span><span class="n">swig_object</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">adddegaxes</span><span class="p">(</span><span class="n">outfile</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span> <span class="n">spectral</span><span class="p">,</span> <span class="n">stokes</span><span class="p">,</span> <span class="n">linear</span><span class="p">,</span> <span class="n">tabular</span><span class="p">,</span> <span class="n">overwrite</span><span class="p">,</span> <span class="n">silent</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">addnoise</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s1">&#39;normal&#39;</span><span class="p">,</span> <span class="n">pars</span><span class="o">=</span><span class="p">[</span> <span class="nb">float</span><span class="p">(</span><span class="mf">0.0</span><span class="p">),</span><span class="nb">float</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span> <span class="p">],</span> <span class="n">region</span><span class="o">=</span><span class="p">{</span> <span class="p">},</span> <span class="n">zero</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">seeds</span><span class="o">=</span><span class="p">[</span>  <span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function adds noise to the image.  You may zero the image first</span>
<span class="sd">        before the noise is added if you wish.</span>
<span class="sd">        </span>
<span class="sd">        The noise can be drawn from one of many distributions.</span>
<span class="sd">        </span>
<span class="sd">        For each distribution, you must supply the type via the {stfaf type}</span>
<span class="sd">        argument (minimum match is active) and parameters via the {stfaf</span>
<span class="sd">        pars} argument.   Briefly:</span>
<span class="sd">        </span>
<span class="sd">        begin{itemize}</span>
<span class="sd">        </span>
<span class="sd">        item {binomial} -- the binomial distribution models successfully drawing</span>
<span class="sd">        items from a pool. Specify two parameters, $n$ and $p$, respectively.</span>
<span class="sd">        $n$ is the number of items in the pool, and $p$, is the probability of</span>
<span class="sd">        each item being successfully drawn. It is required that $n &gt; 0$ and</span>
<span class="sd">        $0 le p le 1$.</span>
<span class="sd">        </span>
<span class="sd">        item {discreteuniform} -- models a uniform random variable over the closed interval. Specify</span>
<span class="sd">        two parameters, the low and high values, respectively.</span>
<span class="sd">        The low parameter is the lowest possible return value and</span>
<span class="sd">        the high parameter is the highest. It is required that $low &lt; high$.</span>
<span class="sd">        </span>
<span class="sd">        item {erlang} -- Specify two parameters, the  mean and variance,</span>
<span class="sd">        respectively. It is required that the mean is non-zero and the variance</span>
<span class="sd">        is positive.</span>
<span class="sd">        </span>
<span class="sd">        item {geometric} -- Specify one parameter, the probability.</span>
<span class="sd">        It is required that $0 le probability &lt; 1$.</span>
<span class="sd">        </span>
<span class="sd">        item {hypergeometric} -- Specify two parameters, the mean and the variance.</span>
<span class="sd">        It is required that the variance is positive and that the mean is non-zero</span>
<span class="sd">        and not bigger than the square-root of the variance.</span>
<span class="sd">        </span>
<span class="sd">        item {normal} -- Specify two parameters, the mean and the variance.</span>
<span class="sd">        It is required that the variance is positive.</span>
<span class="sd">        </span>
<span class="sd">        item {lognormal} -- Specify two parameters, the mean and the variance.</span>
<span class="sd">        It is required that the supplied variance is positive and that the mean is non-zero.</span>
<span class="sd">        </span>
<span class="sd">        item {negativeexponential} -- Supply one parameter, the mean.</span>
<span class="sd">        </span>
<span class="sd">        item {poisson} -- Specify one parameter, the mean.</span>
<span class="sd">        It is required that the mean is non-negative.</span>
<span class="sd">        </span>
<span class="sd">        item {uniform} -- Model a uniform random variable over a closed</span>
<span class="sd">        interval. Specify two parameters, the low and high values.    The low</span>
<span class="sd">        parameter is the lowest possible return value and the high parameter can</span>
<span class="sd">        never be returned. It is required that $low &lt; high$.</span>
<span class="sd">        </span>
<span class="sd">        item {weibull} -- Specify two parameters, alpha and beta.</span>
<span class="sd">        It is required that the alpha parameter is not zero.</span>
<span class="sd">        </span>
<span class="sd">        The random number generator seeds may be specified as an array of integers. Only the first</span>
<span class="sd">        two values are used. If none or a single value is provided, the necessary remaining value(s)</span>
<span class="sd">        are generated based on the current time, using the algorithm</span>
<span class="sd">        begin{verbatim}</span>
<span class="sd">        seedBase = 1e7*MJD</span>
<span class="sd">        seed[1] = (Int)seedBase;</span>
<span class="sd">        # and if seed[0] is also not supplied</span>
<span class="sd">        seed[0] = (Int)((1e7*(seedBase - seed[1])))</span>
<span class="sd">        end{verbatim}</span>
<span class="sd">        </span>
<span class="sd">        where MJD is the Modidfied Julian Day.</span>
<span class="sd">        </span>
<span class="sd">        end{itemize}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">addnoise</span><span class="p">(</span><span class="nb">type</span><span class="p">,</span> <span class="n">pars</span><span class="p">,</span> <span class="n">region</span><span class="p">,</span> <span class="n">zero</span><span class="p">,</span> <span class="n">seeds</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">convolve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outfile</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">kernel</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">scale</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="p">),</span> <span class="n">region</span><span class="o">=</span><span class="p">{</span> <span class="p">},</span> <span class="n">mask</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">stretch</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function performs Fourier-based convolution of an image by the specified</span>
<span class="sd">        kernel. The input image must have real-valued pixels.</span>
<span class="sd">        </span>
<span class="sd">        If outfile is specified, a persistent image is written to the specified disk</span>
<span class="sd">        file.  If outfile is left set to the empty string, the on-the-fly image analysis</span>
<span class="sd">        tool generated by this function is associated with a temporary image.  This</span>
<span class="sd">        temporary image may be stored in memory or on disk, depending on its size.</span>
<span class="sd">        When the user destroys the generated image analysis tool with the close() or</span>
<span class="sd">        done() method, the temporary image is deleted.</span>
<span class="sd">        </span>
<span class="sd">        The kernel is provided as a multi-dimensional array or as the filename of a</span>
<span class="sd">        persistent image. The provided kernel can have fewer dimensions than the image</span>
<span class="sd">        being convolved. In this case, it will be padded with degenerate axes. An</span>
<span class="sd">        exception will be thrown if the kernel has more dimensions than the image. No</span>
<span class="sd">        additional scaling of the kernel is provided.</span>
<span class="sd">        </span>
<span class="sd">        The scaling of the output image is determined by the value of the scale</span>
<span class="sd">        parameter. If this is left unset, then the kernel is normalized to unit sum.</span>
<span class="sd">        If scale is not left unset, then the convolution kernel will be scaled</span>
<span class="sd">        (multiplied) by this value.</span>
<span class="sd">        </span>
<span class="sd">        Masked pixels will be assigned the value 0.0 before convolution.</span>
<span class="sd">        </span>
<span class="sd">        The output mask is the logical AND of the input image&#39;s default pixel mask (if</span>
<span class="sd">        any) and the OTF mask.  Any other pixel masks associated with the input image</span>
<span class="sd">        will not be copied.  The maskhandler method should be used if there is a need to</span>
<span class="sd">        copy other masks too.</span>
<span class="sd">        </span>
<span class="sd">        See also the other convolution methods convolve2d(), sepconvolve(), and</span>
<span class="sd">        hanning() for more specialized convolution algorithms.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_wrap_image</span><span class="p">(</span><span class="n">swig_object</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">outfile</span><span class="p">,</span> <span class="n">kernel</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">region</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">overwrite</span><span class="p">,</span> <span class="n">stretch</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">boundingbox</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">region</span><span class="o">=</span><span class="p">{</span> <span class="p">}):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function finds the bounding box of a</span>
<span class="sd">        region of interest when it is applied to a particular image. Both</span>
<span class="sd">        float and complex valued images are supported. It is</span>
<span class="sd">        returned in a record which has fields {cf &#39;blc&#39;, &#39;trc&#39;, &#39;inc&#39;,</span>
<span class="sd">        &#39;bbShape&#39;, &#39;regionShape&#39;, &#39;imageShape&#39;, &#39;blcf&#39;} and {cf &#39;trcf&#39;}</span>
<span class="sd">        containing the bottom-left corner, the top-right corner (in absolute</span>
<span class="sd">        image pixel coordinates), the increment (stride) of the region, the</span>
<span class="sd">        shape of the boundingbox, the shape of the region, the shape of the</span>
<span class="sd">        image,  the blc in formatted absolute world coordinates and the trc in</span>
<span class="sd">        formatted absolute world  coordinates, respectively.</span>
<span class="sd">        </span>
<span class="sd">        Note that the shape of the bounding box will be different from the shape</span>
<span class="sd">        of the region if a non-unit stride (increment) is involved (see the example</span>
<span class="sd">        below).</span>
<span class="sd">        </span>
<span class="sd">        Note that the integer size of the elements in blc, trc, inc, regionShape,</span>
<span class="sd">        bbShape, and imageShape are 32 bits, even on a 64 bit machine. This means that,</span>
<span class="sd">        on 64 bit machines, you may have to convert them to 64 bit ints using eg</span>
<span class="sd">        numpy.int64, before being able to use them as direct input to other</span>
<span class="sd">        methods such as ia.getchunk().</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">boundingbox</span><span class="p">(</span><span class="n">region</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">boxcar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outfile</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">region</span><span class="o">=</span><span class="p">{</span> <span class="p">},</span> <span class="n">mask</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">width</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">dmethod</span><span class="o">=</span><span class="s1">&#39;copy&#39;</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">stretch</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This application performs boxcar convolution of one axis of an image</span>
<span class="sd">        defined by</span>
<span class="sd">        </span>
<span class="sd">        z[i] = (y[i] + y[i+i] + ... + y[i+w-1])/w</span>
<span class="sd">        </span>
<span class="sd">        where z[i] is the value at pixel i in the box car smoothed image, y[k]</span>
<span class="sd">        is the pixel value of the input image at pixel k, and w is a postivie integer</span>
<span class="sd">        representing the width of the boxcar in pixels. Both float and complex</span>
<span class="sd">        valued images are supported. The length of the axis along which the</span>
<span class="sd">        convolution is to occur must be at least w pixels in the selected region,</span>
<span class="sd">        unless decimation using the mean function is chosen in which case the axis</span>
<span class="sd">        length must be at least 2*w (see below). Masked pixel values are set to</span>
<span class="sd">        zero prior to convolution. All nondefault pixel masks are ignored during</span>
<span class="sd">        the calculation. The convolution is done in the image domain (i.e., not</span>
<span class="sd">        with an FFT).</span>
<span class="sd">        </span>
<span class="sd">        If drop=False (no decimation), the length of the output axis will be equal</span>
<span class="sd">        to the length of the input axis - w + 1. The pixel mask, ORed with the OTF mask</span>
<span class="sd">        if specified, is copied from the selected region of the input image to the</span>
<span class="sd">        output image. Thus for example, if the selected region in the input image has</span>
<span class="sd">        six planes along the convolution axis, if the specified boxcar width is 2,</span>
<span class="sd">        and if the pixel values, which are all unmasked, on a slice along this axis</span>
<span class="sd">        are [1, 2, 5, 10, 17, 26], then the corresponding output slice will be of</span>
<span class="sd">        length five and the output pixel values will be [1.5, 3.5, 7.5, 13.5, 21.5].</span>
<span class="sd">        </span>
<span class="sd">        If drop=True and dmethod=&quot;copy&quot;, the output image is the image calculated</span>
<span class="sd">        if drop=True, except that only every wth plane is kept. Both the pixel and mask</span>
<span class="sd">        values of these planes are copied directly to the output image, without further</span>
<span class="sd">        processing. Thus for example, if the selected region in the input image has six</span>
<span class="sd">        planes along the convolution axis, the boxcar width is chosen to be 2, and if</span>
<span class="sd">        the pixel values, which are all unmasked, on a slice along this axis are [1, 2,</span>
<span class="sd">        5, 10, 17, 26], the corresponding output pixel values will be [1.5, 7.5, 21.5].</span>
<span class="sd">        </span>
<span class="sd">        If drop=True and dmethod=&quot;mean&quot;, first the image described in the drop=False</span>
<span class="sd">        case is calculated. Then, the ith plane of the output image is calculated by</span>
<span class="sd">        averaging the i*w to the (i+1)*w-1  planes of this intermediate image. Thus, for</span>
<span class="sd">        example, if the selected region in the input image has six planes along the</span>
<span class="sd">        convolution axis, the boxcar width is chosen to be 2, and if the pixel values,</span>
<span class="sd">        which are all unmasked, on a slice along this axis are [1, 2, 5, 10, 17, 26],</span>
<span class="sd">        then the corresponding output pixel values will be [2.5, 10.5]. Any pixels at the</span>
<span class="sd">        end of the plane of the intermediate image that do not fall into a complete bin of</span>
<span class="sd">        width w are ignored. Masked values are taken into consideration when forming this</span>
<span class="sd">        average, so if one of the values is masked, it is not used in the average. If at</span>
<span class="sd">        least one of the valuesin the intermediate image bin is not masked, the</span>
<span class="sd">        corresponding output pixel will not be masked.</span>
<span class="sd">        </span>
<span class="sd">        The smoothed image is written to disk with name {stfaf outfile}, if specified.</span>
<span class="sd">        If not, no image is written but the image is still accessible via the returned</span>
<span class="sd">        image analysis tool (see below).</span>
<span class="sd">        </span>
<span class="sd">        This method always returns an image analysis tool which is attached to the smoothed</span>
<span class="sd">        image. This tool should always be captured and closed after any desired manipulations</span>
<span class="sd">        have been done. Closing the tool frees up system resources (eg memory), eg,</span>
<span class="sd">        </span>
<span class="sd">        begin{verbatim}</span>
<span class="sd">        smoothedim = ia.boxcar(...)</span>
<span class="sd">        # do things (or not) with smoothedim</span>
<span class="sd">        ...</span>
<span class="sd">        # close the returned tool promptly upon finishing with it.</span>
<span class="sd">        smoothedim.done()</span>
<span class="sd">        end{verbatim}</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_wrap_image</span><span class="p">(</span><span class="n">swig_object</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">boxcar</span><span class="p">(</span><span class="n">outfile</span><span class="p">,</span> <span class="n">region</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">drop</span><span class="p">,</span> <span class="n">dmethod</span><span class="p">,</span> <span class="n">overwrite</span><span class="p">,</span> <span class="n">stretch</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">brightnessunit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function gets the image brightness unit. Both float and complex</span>
<span class="sd">        valued images are supported.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">brightnessunit</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">calc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pixels</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function is used to evaluate a mathematical expression involving</span>
<span class="sd">        casa images, assigning the result to the current (already existing)</span>
<span class="sd">        image. Both float and complex valued images are supported, although the</span>
<span class="sd">        image which results from the calculation must have the same type of pixel</span>
<span class="sd">        values as the image already attached to the tool. That is, one cannot</span>
<span class="sd">        create a complex valued image using this method if the associated ia tool</span>
<span class="sd">        is currently attached to a float valued image.  It complements the imagecalc</span>
<span class="sd">        function which returns a newly constructed on-the-fly image tool.  See htmladdnormallink{note 223}{../../notes/223/223.html}</span>
<span class="sd">        which describes the the syntax and functionality in detail.</span>
<span class="sd">        </span>
<span class="sd">        If the expression, supplied via the {stfaf pixels} argument, is not a</span>
<span class="sd">        scalar, the shapes and coordinates of the image and expression must</span>
<span class="sd">        conform.</span>
<span class="sd">        </span>
<span class="sd">        If the image (that associated with the tool) has a pixelmask, then only</span>
<span class="sd">        pixels for which that mask is good will be changed.  See the function</span>
<span class="sd">        maskhandler for managing image pixelmasks.</span>
<span class="sd">        </span>
<span class="sd">        Note that when multiple image are used in the expression, there is no garauntee about which of</span>
<span class="sd">        those images will be used to create the header of the output image. Therefore, one may have</span>
<span class="sd">        to modify the output header as needed if the input headers differ.</span>
<span class="sd">        </span>
<span class="sd">        See the related functions set and</span>
<span class="sd">        putregion.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">calc</span><span class="p">(</span><span class="n">pixels</span><span class="p">,</span> <span class="n">verbose</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">calcmask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">asdefault</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This method is used to create a new pixel mask via a boolean LEL expression.</span>
<span class="sd">        </span>
<span class="sd">        See http://casa.nrao.edu/aips2_docs/notes/223/index.shtml which describes the</span>
<span class="sd">        the syntax and functionality of LEL in detail. Also in this document is a</span>
<span class="sd">        description of ways to escape image names that contain certain non-alphanumeric</span>
<span class="sd">        characters so they are compatible with LEL syntax.</span>
<span class="sd">        </span>
<span class="sd">        If the expression is not a scalar, the shapes and coordinates of the image and</span>
<span class="sd">        expression must conform. If the expression is a scalar then the entire pixel</span>
<span class="sd">        mask will be set to that value.</span>
<span class="sd">        </span>
<span class="sd">        By specifying the name parameter to be an empty string, the method automatically</span>
<span class="sd">        determines the name of the output mask. Otherwise, the output mask is named the</span>
<span class="sd">        value specified by the name parameter. If a mask by that name already exists,</span>
<span class="sd">        it is overwritten. Use method ia.summary() to view existing mask names.</span>
<span class="sd">        </span>
<span class="sd">        The asdefault parameter specifies if the new mask should be set as the default</span>
<span class="sd">        pixel mask of the image. This value is set to True by default.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">calcmask</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">asdefault</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function closes the imagetool.  This means that it detaches the</span>
<span class="sd">        tool from its imagefile (flushing all the changes first).  The</span>
<span class="sd">        imagetool is ``null&#39;&#39; after this change (it is not destroyed) and</span>
<span class="sd">        calling any toolfunction other than open</span>
<span class="sd">        will result in an error.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">continuumsub</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outline</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">outcont</span><span class="o">=</span><span class="s1">&#39;continuumsub.im&#39;</span><span class="p">,</span> <span class="n">region</span><span class="o">=</span><span class="p">{</span> <span class="p">},</span> <span class="n">channels</span><span class="o">=</span><span class="p">[</span> <span class="nb">int</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">],</span> <span class="n">pol</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">fitorder</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function packages the relevant image tool functionality for simple</span>
<span class="sd">        specification and application of image plane continuum subtraction.  All</span>
<span class="sd">        that is required of the input image is that it have a non-degenerate</span>
<span class="sd">        spectral axis.</span>
<span class="sd">        </span>
<span class="sd">        The user specifies region, the region of the input image over which</span>
<span class="sd">        continuum subtraction is desired (otherwise the whole image will be</span>
<span class="sd">        treated); channels, the subset of channels on the spectral axis to use</span>
<span class="sd">        in the continuum estimation, specified as a vector;</span>
<span class="sd">        fitorder, the polynomial order to use in the</span>
<span class="sd">        estimation.  Optionally, output line and continuum images may be written</span>
<span class="sd">        by specifying outline and outcont, respectively.  If outline is not</span>
<span class="sd">        specified, a virtual image tool is all that is produced.  If outcont is</span>
<span class="sd">        not specified, the output continuum image will be written in</span>
<span class="sd">        &#39;continuumsub.im&#39;. Note that the pol parameter is no longer supported; one</span>
<span class="sd">        should use the region parameter if polarization selection is desired, in</span>
<span class="sd">        conformance with other ia tool methods.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_wrap_image</span><span class="p">(</span><span class="n">swig_object</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">continuumsub</span><span class="p">(</span><span class="n">outline</span><span class="p">,</span> <span class="n">outcont</span><span class="p">,</span> <span class="n">region</span><span class="p">,</span> <span class="n">channels</span><span class="p">,</span> <span class="n">pol</span><span class="p">,</span> <span class="n">fitorder</span><span class="p">,</span> <span class="n">overwrite</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">convertflux</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">major</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">minor</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="nb">type</span><span class="o">=</span><span class="s1">&#39;Gaussian&#39;</span><span class="p">,</span> <span class="n">topeak</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">channel</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">polarization</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function interconverts between peak intensity and flux density for a</span>
<span class="sd">        Gaussian component.  The image must hold a restoring beam.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">convertflux</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">major</span><span class="p">,</span> <span class="n">minor</span><span class="p">,</span> <span class="nb">type</span><span class="p">,</span> <span class="n">topeak</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">polarization</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">convolve2d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outfile</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">[</span> <span class="nb">int</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="nb">int</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">],</span> <span class="nb">type</span><span class="o">=</span><span class="s1">&#39;gaussian&#39;</span><span class="p">,</span> <span class="n">major</span><span class="o">=</span><span class="s1">&#39;0deg&#39;</span><span class="p">,</span> <span class="n">minor</span><span class="o">=</span><span class="s1">&#39;0deg&#39;</span><span class="p">,</span> <span class="n">pa</span><span class="o">=</span><span class="s1">&#39;0deg&#39;</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">region</span><span class="o">=</span><span class="p">{</span> <span class="p">},</span> <span class="n">mask</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">stretch</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">targetres</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">beam</span><span class="o">=</span><span class="p">{</span> <span class="p">}):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function performs Fourier-based convolution of an imagefile</span>
<span class="sd">        using the provided 2D kernel.</span>
<span class="sd">        </span>
<span class="sd">        If {stfaf outfile} is left unset, the image is written to the specified</span>
<span class="sd">        disk file.  If {stfaf outfile} is not given, the newly constructed</span>
<span class="sd">        on-the-fly Image tool is associated with a temporary image.  This</span>
<span class="sd">        temporary image may be stored in memory or on disk, depending on its size.</span>
<span class="sd">        When the user destroys the on-the-fly Image tool (with the done function) this</span>
<span class="sd">        temporary image is deleted.</span>
<span class="sd">        </span>
<span class="sd">        The user specifies which 2 pixel axes of the image are to be convolved</span>
<span class="sd">        via the {stfaf axes} argument. The pixels must be square or an error will result.</span>
<span class="sd">        </span>
<span class="sd">        The user specifies the type of convolution kernel with {stfaf type} (minimum</span>
<span class="sd">        match is supported); currently only {cf &#39;gaussian&#39;}  is available.</span>
<span class="sd">        </span>
<span class="sd">        The user specifies the parameters of the convolution kernel via the arguments</span>
<span class="sd">        {stfaf major}, {stfaf minor}, and {stfaf pa}.   These arguments can</span>
<span class="sd">        be specified in one of three ways:</span>
<span class="sd">        </span>
<span class="sd">        begin{itemize}</span>
<span class="sd">        </span>
<span class="sd">        item Quantity - for example {stfaf major=qa.quantity(1, &#39;arcsec&#39;)}</span>
<span class="sd">        Note that you pixel units can be used, viz. {stfaf major=qa.quantity(1, &#39;pix&#39;)},</span>
<span class="sd">        see below.</span>
<span class="sd">        </span>
<span class="sd">        item String - for example {stfaf minor=&#39;1km&#39;} (i.e. one that the</span>
<span class="sd">        Quanta quantity function accepts).</span>
<span class="sd">        </span>
<span class="sd">        item Numeric - for example {stfaf major=10}.  In this case, the units</span>
<span class="sd">        of {stfaf major} and {stfaf minor} are assumed to be in pixels.  Using</span>
<span class="sd">        pixel units allows the user to convolve unlike axes (see one of the provided</span>
<span class="sd">        example for this use case). For the position angle, units of degrees are assumed.</span>
<span class="sd">        </span>
<span class="sd">        end{itemize}</span>
<span class="sd">        </span>
<span class="sd">        The interpretation of {stfaf major} and {stfaf minor} depends upon the</span>
<span class="sd">        kernel type.</span>
<span class="sd">        </span>
<span class="sd">        begin{itemize}</span>
<span class="sd">        </span>
<span class="sd">        item Gaussian - {stfaf major} and {stfaf minor} are</span>
<span class="sd">        the Full Width at Half Maximum (FWHM) of the major and minor</span>
<span class="sd">        axes of the Gaussian.</span>
<span class="sd">        </span>
<span class="sd">        end{itemize}</span>
<span class="sd">        </span>
<span class="sd">        The position angle is measured North through East when a</span>
<span class="sd">        plane holding a celestial coordinate (the usual astronomical</span>
<span class="sd">        convention) is convolved.  For other axis/coordinate combinations,</span>
<span class="sd">        a positive position angle is measured from +x to +y in the</span>
<span class="sd">        absolute pixel coordinate frame  (x is the first axis that is</span>
<span class="sd">        specified, with argument {stfaf axes}).</span>
<span class="sd">        </span>
<span class="sd">        In the case of a Gaussian, the {stfaf beam} parameter offers an alternate way of</span>
<span class="sd">        describing the convolving Gaussian. If used, neither {stfaf major}, {stfaf minor},</span>
<span class="sd">        nor {stfaf pa} can be specified. The {stfaf beam} parameter must have exactly three</span>
<span class="sd">        fields: &quot;major&quot;, &quot;minor&quot;, and &quot;pa&quot; (or &quot;positionangle&quot;). This is, not coincidentally,</span>
<span class="sd">        the record format for the output of ia.restoringbeam().</span>
<span class="sd">        </span>
<span class="sd">        The scaling of the output image is determined by the argument {stfaf scale}.</span>
<span class="sd">        If this is left unset then autoscaling will be invoked.</span>
<span class="sd">        </span>
<span class="sd">        If the user is not convolving the sky, then autoscaling means that the convolution</span>
<span class="sd">        kernel will be normalized to have unit volume so as to conserve flux.</span>
<span class="sd">        </span>
<span class="sd">        If the user is convolving the sky, then there are two cases</span>
<span class="sd">        for which autoscaling is useful:</span>
<span class="sd">        </span>
<span class="sd">        Firstly, if the input image units are Jy/pixel, then the output image</span>
<span class="sd">        will have units of Jy/beam and be appropriately scaled.  In addition,</span>
<span class="sd">        the restoring beam of the output image will be the same as the</span>
<span class="sd">        convolution kernel.</span>
<span class="sd">        </span>
<span class="sd">        Secondly,if the input image units are Jy/beam, then the output</span>
<span class="sd">        image will also have units of Jy/beam and be appropriately</span>
<span class="sd">        scaled.  In addition, the restoring beam of the output image</span>
<span class="sd">        will be the convolution of the input image restoring beam and the</span>
<span class="sd">        convolution kernel. In the case of an image with per-plane beams, for</span>
<span class="sd">        each plane, the kernel is convolved with the appropriate beam and the</span>
<span class="sd">        result is associated with that plane in the output image.</span>
<span class="sd">        </span>
<span class="sd">        If the user sets a value for {stfaf scale}, then the convolution kernel</span>
<span class="sd">        will be scaled by this value. Note that it has peak of unity before the</span>
<span class="sd">        application of this scale factor.</span>
<span class="sd">        </span>
<span class="sd">        If the units on the original image include Jy/beam, the units on the</span>
<span class="sd">        output image will be rescaled by the ratio of the input and output</span>
<span class="sd">        beams as well as rescaling by the area of convolution kernel.</span>
<span class="sd">        </span>
<span class="sd">        If the units on the original image include K, then only the image</span>
<span class="sd">        convolution kernel rescaling is done.</span>
<span class="sd">        </span>
<span class="sd">        If targetres=True and type=&quot;gaussian&quot; and the input image has a restoring beam,</span>
<span class="sd">        this method will interpret the values of major, minor, and pa as the resolution</span>
<span class="sd">        of the final image and will calculate the parameters of the Gaussian to use</span>
<span class="sd">        in the convolution so that this target resolution is achieved.</span>
<span class="sd">        </span>
<span class="sd">        Masked pixels will be assigned the value 0.0 before convolution.</span>
<span class="sd">        The output mask is the intersection (logical AND) of the default input</span>
<span class="sd">        pixelmask (if any) and the OTF mask.  Any other input pixelmasks</span>
<span class="sd">        will not be copied.  The function</span>
<span class="sd">        maskhandler</span>
<span class="sd">        can be used if there is a need to copy other masks too.</span>
<span class="sd">        </span>
<span class="sd">        See also the other convolution functions:</span>
<span class="sd">        </span>
<span class="sd">        convolve,</span>
<span class="sd">        hanning, and</span>
<span class="sd">        sepconvolve.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_wrap_image</span><span class="p">(</span><span class="n">swig_object</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">convolve2d</span><span class="p">(</span><span class="n">outfile</span><span class="p">,</span> <span class="n">axes</span><span class="p">,</span> <span class="nb">type</span><span class="p">,</span> <span class="n">major</span><span class="p">,</span> <span class="n">minor</span><span class="p">,</span> <span class="n">pa</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">region</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">overwrite</span><span class="p">,</span> <span class="n">stretch</span><span class="p">,</span> <span class="n">targetres</span><span class="p">,</span> <span class="n">beam</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">coordsys</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">[</span> <span class="nb">int</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function returns the Coordinate System of an image in a {stf</span>
<span class="sd">        Coordsys} tool. Both float and complex valued images are supported.</span>
<span class="sd">        </span>
<span class="sd">        By default, the Coordinate System describes all of the axes in the</span>
<span class="sd">        image.  If you desire, you can select a subset of the axes, thus</span>
<span class="sd">        reducing the dimensionality of the Coordinate System.   This may be</span>
<span class="sd">        useful if you are supplying a Coordinate System to the</span>
<span class="sd">        functions fromarray or</span>
<span class="sd">        fromshape.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_wrap_coordsys</span><span class="p">(</span><span class="n">swig_object</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">coordsys</span><span class="p">(</span><span class="n">axes</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">coordmeasures</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pixel</span><span class="o">=</span><span class="p">[</span> <span class="nb">float</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">],</span> <span class="n">dframe</span><span class="o">=</span><span class="s1">&#39;cl&#39;</span><span class="p">,</span> <span class="n">sframe</span><span class="o">=</span><span class="s1">&#39;cl&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;You can use this function to get the world coordinates for a specified</span>
<span class="sd">        absolute pixel coordinate in the image.  You specify a pixel coordinate</span>
<span class="sd">        (0-rel) for each axis in the image.</span>
<span class="sd">        </span>
<span class="sd">        If you supply fewer pixel values then there are axes in the image, your</span>
<span class="sd">        value will be padded out with the reference pixel for the missing axes.</span>
<span class="sd">        Excess values will be ignored.</span>
<span class="sd">        </span>
<span class="sd">        The parameters dframe and sframe allow one to specify to which reference frame</span>
<span class="sd">        the direction and spectral measures, respectively, should be converted. These</span>
<span class="sd">        values are case-insensitive. &quot;native&quot; means use the native reference frame of</span>
<span class="sd">        the coordinate in question. &quot;cl&quot; means use the conversion layer frame if one</span>
<span class="sd">        exists (if not, the native frame will be used).</span>
<span class="sd">        </span>
<span class="sd">        The world coordinate is returned as a record of measures.  This</span>
<span class="sd">        function is just a wrapper for the Coordsys tool toworld function</span>
<span class="sd">        (invoked with argument {stfaf format=&#39;m&#39;}).  Please see its</span>
<span class="sd">        documentation for discussion about the formatting and meaning of the</span>
<span class="sd">        measures.</span>
<span class="sd">        </span>
<span class="sd">        This Image tool function adds two additional fields to the return record.</span>
<span class="sd">        </span>
<span class="sd">        The {cf mask} field contains the value of the image pixelmask at the</span>
<span class="sd">        specified position. It is either T (pixel is good) or F (pixel is masked</span>
<span class="sd">        as bad or the specified position was off the image).</span>
<span class="sd">        </span>
<span class="sd">        The {cf intensity} field contains the value of the image (at the</span>
<span class="sd">        nearest pixel to that given) and its units.  This is actually stored</span>
<span class="sd">        as a Quantity. This field does not exist</span>
<span class="sd">        if the specified pixel coordinate is off the image.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">coordmeasures</span><span class="p">(</span><span class="n">pixel</span><span class="p">,</span> <span class="n">dframe</span><span class="p">,</span> <span class="n">sframe</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">decompose</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">region</span><span class="o">=</span><span class="p">{</span> <span class="p">},</span> <span class="n">mask</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">simple</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">ncontour</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">11</span><span class="p">),</span> <span class="n">minrange</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">naxis</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">fit</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">maxrms</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">maxretry</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">maxiter</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">256</span><span class="p">),</span> <span class="n">convcriteria</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="mf">0.0001</span><span class="p">),</span> <span class="n">stretch</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function is an image decomposition tool that performs several tasks,</span>
<span class="sd">        with the end result being that a strongly blended image is separated into</span>
<span class="sd">        components - both in the sense that it determines the parameters for each</span>
<span class="sd">        component (assuming a Gaussian model) and that it physically assigns each</span>
<span class="sd">        pixel in the image to an individual object.  The products of these two</span>
<span class="sd">        operations are called the component list and the component map,</span>
<span class="sd">        respectively.  The fitting process (which determines the component list) and</span>
<span class="sd">        the pixel-decomposition process (which determines the component map) are</span>
<span class="sd">        designed to work cooperatively to increase the efficiency and accuracy of</span>
<span class="sd">        both.</span>
<span class="sd">        </span>
<span class="sd">        The algorithm behind the decomposition is based on the function clfind,</span>
<span class="sd">        described in Williams et al 1994, which uses a contouring procedure whereby</span>
<span class="sd">        a closed contour designates a separate component.  The program first</span>
<span class="sd">        separates the image into clearly distint &#39;regions&#39; of blended emission, then</span>
<span class="sd">        contours each region to determine the areas constituting each component and</span>
<span class="sd">        passes this information on to the fitter, which determines the component</span>
<span class="sd">        list.</span>
<span class="sd">        </span>
<span class="sd">        The contour deblending can optionally be replaced with a simpler local maximum</span>
<span class="sd">        scan, and the fitting can be replaced with a moment-based estimation method to</span>
<span class="sd">        speed up calculations on very large images or if either primary method causes</span>
<span class="sd">        trouble, but in general this will impede the accuracy of the fit.</span>
<span class="sd">        </span>
<span class="sd">        The function works with both two and three dimensional images.</span>
<span class="sd">        </span>
<span class="sd">        The return value is a record (or dictionary) that has 3 keys: {tt &#39;components&#39;, &#39;blc&#39;, &#39;trc&#39;}.</span>
<span class="sd">        The {tt &#39;components&#39;} element is a matrix each row of which contains the gaussian parameters of the component fitted.</span>
<span class="sd">        The {tt &#39;blc&#39;} element is a matrix of the bottom left corners (blc) of the regions found. Each row correspond to a region blc.</span>
<span class="sd">        The {tt &#39;trc&#39;} element is a matrix of the top right corners (trc) of the regions found. Each row correspond to a region trc.</span>
<span class="sd">        {bf Please Note} that the returned blc&#39;s and trc&#39;s are relative to {tt region} defined by the user. A {tt blc } of  [0,0] implies the bottom left of the region selected and not  the bottom left of the image. Obviously if no region is defined then it is the bottom left of the image.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">decompose</span><span class="p">(</span><span class="n">region</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">simple</span><span class="p">,</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">ncontour</span><span class="p">,</span> <span class="n">minrange</span><span class="p">,</span> <span class="n">naxis</span><span class="p">,</span> <span class="n">fit</span><span class="p">,</span> <span class="n">maxrms</span><span class="p">,</span> <span class="n">maxretry</span><span class="p">,</span> <span class="n">maxiter</span><span class="p">,</span> <span class="n">convcriteria</span><span class="p">,</span> <span class="n">stretch</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">deconvolvecomponentlist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">complist</span><span class="p">,</span> <span class="n">channel</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">polarization</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This method deconvolves (a</span>
<span class="sd">        record representation of) a Componentlist tool from the restoring</span>
<span class="sd">        beam, returning (a record representation of) a new Componentlist tool.</span>
<span class="sd">        If there is no restoring beam, a fail is generated.</span>
<span class="sd">        </span>
<span class="sd">        Currently, only deconvolution of Gaussian components is supported.</span>
<span class="sd">        </span>
<span class="sd">        For images with per-plane beam, the user must choose which beam is used for</span>
<span class="sd">        the deconvolution by setting channel and/or polarization. Only a single beam</span>
<span class="sd">        is used to deconvolve all components.</span>
<span class="sd">        </span>
<span class="sd">        See also functions setrestoringbeam and</span>
<span class="sd">        restoringbeam.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">deconvolvecomponentlist</span><span class="p">(</span><span class="n">complist</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">polarization</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">deconvolvefrombeam</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">beam</span><span class="o">=</span><span class="p">[</span> <span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This is a helper function. It is to provide a way to deconvolve gaussians from other gaussians if that is what is needed for example removing a beam Gaussian from a Gaussian source. To run this function the tool need not be attached to an image.</span>
<span class="sd">        </span>
<span class="sd">        The return value is a record that contains the fit param and the return value is a boolean which is set to true if fit model is a point source</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">deconvolvefrombeam</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">beam</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">beamforconvolvedsize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">convolved</span><span class="o">=</span><span class="p">[</span> <span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Determine the size of the beam necessary to convolve with the given source to reach the</span>
<span class="sd">        given convolved (source+beam) size. Because the problem is completely specified by the</span>
<span class="sd">        input parameters, no image needs to be attached to the associated tool; eg ia.open() need</span>
<span class="sd">        not be called prior to calling this method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">beamforconvolvedsize</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">convolved</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">commonbeam</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Determine a beam to which all beams in an image can be convolved.</span>
<span class="sd">        If the image does not have a beam, an exception will be thrown.</span>
<span class="sd">        If the image has a single beam, that beam will be returned.</span>
<span class="sd">        If the image has multiple beams, this will be the beam with the largest area in the image</span>
<span class="sd">        beam set if all the other beams can be convolved to that beam. If not, this is guaranteed to be the minimum area beam to which</span>
<span class="sd">        all beams in the set can be convolved if all but one of the beams in the set can be convolved to the beam in the set with the</span>
<span class="sd">        largest area. Otherwise, the returned beam may or may not be the smallest possible beam to which all the beams in the set</span>
<span class="sd">        can be convolved.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">commonbeam</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">done</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function first closes the</span>
<span class="sd">        imagetool which detaches it from its underlying imagefile.  It then</span>
<span class="sd">        deletes that imagefile.  If {stfaf done=False}, the imagetool is still</span>
<span class="sd">        viable, and can be used with function open</span>
<span class="sd">        to open a new imagefile.  Otherwise the imagetool is destroyed.  If {stfaf verbose=True}, the logger will receive a progress report.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">done</span><span class="p">,</span> <span class="n">verbose</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">removefile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function deletes the specified image file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">removefile</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">done</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">remove</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;When the user no longer needs to use an imagetool, calling this function</span>
<span class="sd">        will free up its resources.  That is, it destroys the tool.  This means</span>
<span class="sd">        that the user can no longer call any functions on the tool after it</span>
<span class="sd">        has been {stff done}.</span>
<span class="sd">        </span>
<span class="sd">        If the Image tool is associated with a disk file, then (unlike the</span>
<span class="sd">        {stff close} function, the user can also choose to delete that by</span>
<span class="sd">        setting {stfaf remove=true}.  By default, any associated disk file is</span>
<span class="sd">        not deleted.</span>
<span class="sd">        </span>
<span class="sd">        Note that this function is different from the {stff close} function</span>
<span class="sd">        because the latter does not destroy the imagetool.  For example, the</span>
<span class="sd">        user can use the {stff open} function straight after the {stff close}</span>
<span class="sd">        function on the same tool.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">done</span><span class="p">(</span><span class="n">remove</span><span class="p">,</span> <span class="n">verbose</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">fft</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">imag</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">amp</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">phase</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">[</span> <span class="nb">int</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">],</span> <span class="n">region</span><span class="o">=</span><span class="p">{</span> <span class="p">},</span> <span class="n">mask</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">stretch</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="nb">complex</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This method fast Fourier Transforms the supplied image to the Fourier plane.</span>
<span class="sd">        If the axes parameter is left unset, then the direction plane of the image (if</span>
<span class="sd">        there is one) is transformed.  Otherwise, the user can specify which axes are</span>
<span class="sd">        to be transformed.  Note that if the direction plane is to be transformed, both</span>
<span class="sd">        axes associated with it must be specified.</span>
<span class="sd">        </span>
<span class="sd">        The user specifies which form is desired in the result by specifying the</span>
<span class="sd">        desired output image file name(s).</span>
<span class="sd">        </span>
<span class="sd">        Before the FFT is performed, any masked pixels are set to values of zero. The</span>
<span class="sd">        output mask is the result of ANDing the default input pixel mask (if any) and</span>
<span class="sd">        the OTF mask.  Any other input pixel masks will not be copied.  The method</span>
<span class="sd">        maskhandler() can be used if there is a need to copy other masks.</span>
<span class="sd">        </span>
<span class="sd">        The following rules are used to set the brightness units of the output images.</span>
<span class="sd">        1. The phase image always has units of radians.</span>
<span class="sd">        For the other output images,</span>
<span class="sd">        2. if the input image has units of Jy/beam or Jy/pixel</span>
<span class="sd">        (ie it is an image-plane image), the output (uv-plane) images will have units</span>
<span class="sd">        of Jy. In the case of the input image having a synthesized beam, the beam</span>
<span class="sd">        will be copied to the output images (which is important for transforming back).</span>
<span class="sd">        3. If the input image has units of Jy (ie is a uv-plane image), the output</span>
<span class="sd">        images will have either units of Jy/beam or Jy/pixel, depending on if the</span>
<span class="sd">        input image has a beam or not.</span>
<span class="sd">        </span>
<span class="sd">        For some transformations (e.g., UV domain to image domain transforms), it is</span>
<span class="sd">        not possible to automatically generate an expected coordinate system for</span>
<span class="sd">        the output image(s); only the FFT numerics are performed and the coordinate</span>
<span class="sd">        system is generated using generic conventions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">real</span><span class="p">,</span> <span class="n">imag</span><span class="p">,</span> <span class="n">amp</span><span class="p">,</span> <span class="n">phase</span><span class="p">,</span> <span class="n">axes</span><span class="p">,</span> <span class="n">region</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">stretch</span><span class="p">,</span> <span class="nb">complex</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">findsources</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nmax</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">20</span><span class="p">),</span> <span class="n">cutoff</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="mf">0.1</span><span class="p">),</span> <span class="n">region</span><span class="o">=</span><span class="p">{</span> <span class="p">},</span> <span class="n">mask</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">point</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span> <span class="n">negfind</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function  finds strong point sources in</span>
<span class="sd">        the image.  The sources are returned in a record that can be used by a</span>
<span class="sd">        Componentlist tool.</span>
<span class="sd">        </span>
<span class="sd">        An efficient method is used to locate sources under the assumption that</span>
<span class="sd">        they are point-like and not too close to the noise.  Only sources with a</span>
<span class="sd">        peak greater than the {stfaf cutoff} fraction of the strongest source</span>
<span class="sd">        will be found.  Only positive sources will be found, unless the {stfaf</span>
<span class="sd">        negfind=T} whereupon positive and negative sources will be found.</span>
<span class="sd">        </span>
<span class="sd">        After the list of point sources has been made, you may choose to make a</span>
<span class="sd">        Gaussian fit for each one ({stfaf point=F}) so that shape information</span>
<span class="sd">        can be recovered as well.    You can specify the half-width of the</span>
<span class="sd">        fitting grid with argument {stfaf width} which defaults to 5 (fitting</span>
<span class="sd">        grid would then be [11,11] pixels). If you set {stfaf width=0}, this is</span>
<span class="sd">        a signal that you would still like Gaussian components returned, but a</span>
<span class="sd">        default  width should be used for the Gaussian shapes.  The default is</span>
<span class="sd">        such that the component is circular with a FWHM of {stfaf width}</span>
<span class="sd">        pixels.</span>
<span class="sd">        </span>
<span class="sd">        Thus, if {stfaf point=T}, the components in the returned Componentlist</span>
<span class="sd">        are Point components.  If {stfaf point=F}  then Gaussian components are</span>
<span class="sd">        returned.</span>
<span class="sd">        </span>
<span class="sd">        The region must be 2-dimensional and it must hold a region of the sky.</span>
<span class="sd">        Any degenerate trailing dimensions in the region are discarded.</span>
<span class="sd">        </span>
<span class="sd">        See also the function fitcomponents (for which {stff</span>
<span class="sd">        findsources} can provide an initial estimate).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">findsources</span><span class="p">(</span><span class="n">nmax</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">,</span> <span class="n">region</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">point</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">negfind</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">fitprofile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">box</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">region</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">chans</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">stokes</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">mask</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">ngauss</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">poly</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">estimates</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">minpts</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">multifit</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">residual</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">amp</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">amperr</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">centererr</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">fwhm</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">fwhmerr</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">integral</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">integralerr</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">stretch</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">logresults</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">pampest</span><span class="o">=</span><span class="p">[</span>  <span class="p">],</span> <span class="n">pcenterest</span><span class="o">=</span><span class="p">[</span>  <span class="p">],</span> <span class="n">pfwhmest</span><span class="o">=</span><span class="p">[</span>  <span class="p">],</span> <span class="n">pfix</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">gmncomps</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">gmampcon</span><span class="o">=</span><span class="p">[</span>  <span class="p">],</span> <span class="n">gmcentercon</span><span class="o">=</span><span class="p">[</span>  <span class="p">],</span> <span class="n">gmfwhmcon</span><span class="o">=</span><span class="p">[</span>  <span class="p">],</span> <span class="n">gmampest</span><span class="o">=</span><span class="p">[</span> <span class="nb">float</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span> <span class="p">],</span> <span class="n">gmcenterest</span><span class="o">=</span><span class="p">[</span> <span class="nb">float</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span> <span class="p">],</span> <span class="n">gmfwhmest</span><span class="o">=</span><span class="p">[</span> <span class="nb">float</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span> <span class="p">],</span> <span class="n">gmfix</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">spxtype</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">spxest</span><span class="o">=</span><span class="p">[</span>  <span class="p">],</span> <span class="n">spxfix</span><span class="o">=</span><span class="p">[</span>  <span class="p">],</span> <span class="n">div</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">spxsol</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">spxerr</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">logfile</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">pfunc</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">goodamprange</span><span class="o">=</span><span class="p">[</span> <span class="nb">float</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span> <span class="p">],</span> <span class="n">goodcenterrange</span><span class="o">=</span><span class="p">[</span> <span class="nb">float</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span> <span class="p">],</span> <span class="n">goodfwhmrange</span><span class="o">=</span><span class="p">[</span> <span class="nb">float</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span> <span class="p">],</span> <span class="n">sigma</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">outsigma</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">planes</span><span class="o">=</span><span class="p">[</span>  <span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This application simultaneously fits any number of gaussian singlets, any number of lorentzian singlets, and any number of gaussian multiplets,</span>
<span class="sd">        and/or a polynomial to one dimensional profiles using the non-linear, least squares Levenberg-Marquardt algorithm. A description of the</span>
<span class="sd">        fitting algorithm may be found in AIPS++ Note 224 (http://www.astron.nl/casacore/trunk/casacore/doc/notes/224.html) and in Numerical Recipes</span>
<span class="sd">        by W.H. Press et al., Cambridge University Press. A gaussian/lorentzian singlet is a gaussian/lorentzian whose parameters (amplitude,</span>
<span class="sd">        center position, and width) are all independent from any other feature that may be simultaneously fit. A gaussian multiplet is a set of two or</span>
<span class="sd">        more gaussian lines in which at least one (and possibly two or three) parameter of each line is dependent on the parameter of another,</span>
<span class="sd">        single (reference) profile in the multiplet. For example, one can specify a doublet in which the amplitude of the first line is 0.6 times the</span>
<span class="sd">        amplitude of the zeroth line and/or the center of the first line is 20 pixels from the center of the zeroth line, and/or the fwhm of the first</span>
<span class="sd">        line is identical (in pixels) to that of the zeroth line. There is no limit to the number of components one can specify in a multiplet</span>
<span class="sd">        (except of course that the number of parameters to be fit should be significantly less than the number of data points), but there can be only</span>
<span class="sd">        a single reference profile in a multiplet to which to tie constraints of parameters of the other profiles in the set.</span>
<span class="sd">        </span>
<span class="sd">        Additionally, a power logarithmic polynomial (plp) or a logarithmic tranformed polynomial (ltp) can be fit. In this case, each of these functions</span>
<span class="sd">        cannot be fit simultaneously with any other supported function. These functions are most often used for fitting the spectral index and</span>
<span class="sd">        higher order terms of a spectrum. A power logarithmic polynomial has the form</span>
<span class="sd">        </span>
<span class="sd">        y = c0*x/div**(c1 + c2*ln(x/div) + c3*ln(x/div)**2 + ... + cn*ln(x/div)**(n - 1))</span>
<span class="sd">        </span>
<span class="sd">        and a logarithmic transformed polynomial is simply the result of this equation after taking the natural log of both sides so that it has the form</span>
<span class="sd">        </span>
<span class="sd">        ln(y) = c0 + c1*ln(x/div) + c2*ln(x/div)**2 +  ... + cn*ln(x/div)**n</span>
<span class="sd">        </span>
<span class="sd">        The coefficients of the two forms correspond with each other except that c0 in the second equation is equal to</span>
<span class="sd">        ln(c0) of the first. In the case of fitting a spectral index, the spectral index, traditionally represented as alpha, is</span>
<span class="sd">        equal to c1.</span>
<span class="sd">        </span>
<span class="sd">        In both cases, div is a numerical value used to scale abscissa values so they are closer to unity when they are sent to the fitter. This generally</span>
<span class="sd">        improves the probability that the fit will converge. This parameter may be specified via the div parameter. A value of 0</span>
<span class="sd">        (the default) indicates that the application should determine a reasonable value for div, which is determined via</span>
<span class="sd">        </span>
<span class="sd">        div = 10**int(log10(sqrt(min(x)*max(x))))</span>
<span class="sd">        </span>
<span class="sd">        where min(x) and max(x) are the minimum and maximum abscissa values, respectively.</span>
<span class="sd">        </span>
<span class="sd">        So, for example, if S(nu) is proportional to nu**alpha and you expect alpha to be near -0.8 and the value of S(nu) is 1.5 at</span>
<span class="sd">        1e9 Hz and your image(s) have spectral units of Hz, you would specify spxest=[1.5, -0.8] and div=1e9 when fitting a plp function,</span>
<span class="sd">        or spxest=[0.405, -0.8] and div=1e9 if fitting an ltp function.</span>
<span class="sd">        </span>
<span class="sd">        More details of fitting all of these functions are described in following sections.</span>
<span class="sd">        </span>
<span class="sd">        A CAUTIONARY NOTE</span>
<span class="sd">        Note that the likelihood of getting a reliable solution increases with the number of good data points as well as the goodness</span>
<span class="sd">        of the initial estimate. It is possible that the first solution found might not be the best one, and</span>
<span class="sd">        so, if a solution is found, it is recommended that the fit be repeated using the solution of the previous fit as the</span>
<span class="sd">        initial estimatE for the new fit. This process should be repeated until the solutions from one fit to the next differ only insignificantly.</span>
<span class="sd">        The convergent solution is very likely the best solution.</span>
<span class="sd">        </span>
<span class="sd">        AXIS</span>
<span class="sd">        The axis parameter indicates on which axis profiles should be fit; a value &lt;0 indicates the spectral axis should be used, or if one does not exist,</span>
<span class="sd">        that the zeroth axis should be used.</span>
<span class="sd">        </span>
<span class="sd">        MINIMUM NUMBER OF PIXELS</span>
<span class="sd">        The minpts parameter indicates the minimum number of unmasked pixels that must be present in order for a fit</span>
<span class="sd">        to be attempted. When multifit=True, positions with too few good points will be masked in any output images.</span>
<span class="sd">        </span>
<span class="sd">        ONE FIT OF REGION AVERAGE OR PIXEL BY PIXEL FIT</span>
<span class="sd">        The multifit parameter indicates if profiles should be fit at each pixel in the selected region (true), or if the profiles in that region should be</span>
<span class="sd">        averaged and the fit done to that average profile (false).</span>
<span class="sd">        </span>
<span class="sd">        POLYNOMIAL FITTING</span>
<span class="sd">        The order of the polynomial to fit is specified only via the poly parameter. If poly&lt;0, no polynomial will be fit. No initial estimates of</span>
<span class="sd">        coefficients can be specified; these are determined automatically.</span>
<span class="sd">        </span>
<span class="sd">        GAUSSIAN SINGLET FITTING</span>
<span class="sd">        In the absence of an estimates file and no estimates being specified by the p*est parameters, and gmncomps=0 or is empty, the ngauss parameter</span>
<span class="sd">        indicates the maximum number of gaussian singlets that should be fit. The initial estimates of the parameters for these gaussians will be attempted</span>
<span class="sd">        automatically in this case. If it deems appropriate, the fitter will fit fewer than this number. In the case where an estimates file is supplied,</span>
<span class="sd">        ngauss is ignored (see below). ngauss is also ignored if the p*est parameters are specified or if gmncomps is not an empty array or, if an integer,</span>
<span class="sd">        is greater than zero. If estimates is not specified or the p*est parameters are not specified and ngauss=0, gmncomps is empty or 0, and poly&lt;0,</span>
<span class="sd">        an error will occur as this indicates there is nothing to fit.</span>
<span class="sd">        </span>
<span class="sd">        One can specify initial estimates of gaussian singlet parameters via an estimates file or the pampest, pcenterest, pfwhmest, and optionally, the</span>
<span class="sd">        pfix parameters. The latter is the recommended way to specify these estimates as support for estimates files may be deprecated in the future. No matter</span>
<span class="sd">        which option is used, an amplitude initial estimate must always be nonzero.  A negative fwhm estimate will be silently changed to positve.</span>
<span class="sd">        </span>
<span class="sd">        SPECIFYING INITIAL ESTIMATES FOR GAUSSIAN AND LORENTZIAN SINGLETS (RECOMMENDED METHOD)</span>
<span class="sd">        One may specify initial estimates via the pampest, pcenterest, and pfwhmest parameters. In the case of a single gaussian or lorentzian singlet,</span>
<span class="sd">        these parameters can be numbers. pampest must be specified in image brightness units, pcenterest must be given in the number of pixels from the</span>
<span class="sd">        zeroth pixel, and pfwhmest must be given in pixels. Optionally pfix can be specified and in the case of a single gaussian or lorentzian singlet</span>
<span class="sd">        can be a string. In it is coded which parameters should be held constant during the fix. Any combination of &quot;p&quot; (amplitude), &quot;c&quot; (center), or &quot;f&quot;</span>
<span class="sd">        (fwhm) is allowed; eg pfix=&quot;pc&quot; means fix both the amplitude and center during the fit. In the case of more than one gaussian and/or lorentzian</span>
<span class="sd">        singlets, these parameters must be specified as arrays of numbers. The length of the arrays indicates the number of singlets to fit and must be</span>
<span class="sd">        the same for all the p*est parameters.</span>
<span class="sd">        </span>
<span class="sd">        If no parameters are to be fixed for any of the singlets, pfix can be set to the empty string. However, if at least one parameter of one singlet</span>
<span class="sd">        is to be fixed, pfix must be an array of strings and have a length equal to the p*est arrays. Singlets which are not to have any parameters fixed</span>
<span class="sd">        should be represented as an empty string in the pfix array. So, for example, if one desires to fit three singlets and fix the fwhm of the middle</span>
<span class="sd">        one, one must specify pfix=[&quot;&quot;, &quot;f&quot;, &quot;&quot;], the empty strings indicating no parameters of the zeroth and second singlet should be held constant.</span>
<span class="sd">        </span>
<span class="sd">        In the case of multifit=True, the initial estimates, whether from the p*est parameters or from a file (see below), will be applied to the location</span>
<span class="sd">        of the first fit. This is normally the bottom left corner of the region selected. If masked, not enough good points to perform a fit, or the</span>
<span class="sd">        attempted fit fails, the fitting proceeds to the next pixel with the pixel value of the lowest numbered axis changing the fastest. Once a</span>
<span class="sd">        successful fit has been performed, subsequent fits will use the results of a fit for a nearest pixel for which a previous fit was successful as the</span>
<span class="sd">        initial estimate for the parameters at the current location. The fixed parameter string will be honored for every fit performed when multifit=True.</span>
<span class="sd">        </span>
<span class="sd">        One specifies what type of PCF profile to fit via the pfunc parameter. A PCF function is one that can be parameterized by a peak, center, and FWHM,</span>
<span class="sd">        as both gaussian and lorentzian singlets can. If all singlets to be fit are gaussians, one can set pfunc equal to the empty string and all snglets</span>
<span class="sd">        will be assumed to be gaussians. If at least one lorentzian is to be fit, pfunc must be specified as a string (in the case of a single singlet) or</span>
<span class="sd">        an array of strings (in the case of multiple singlets). The position of each string corresponds to the positions of the initial estimates in the</span>
<span class="sd">        p*est and pfix arrays. Minimal match (&quot;g&quot;, &quot;G&quot;, &quot;l&quot;, or &quot;L&quot;) is supported. So, if one wanted to simultaneously fit two gaussian and two lorentzian</span>
<span class="sd">        singlets, the zeroth and last of which were lorentzians, one would specify pfunc=[&quot;L&quot;, &quot;G&quot;, &quot;G&quot;, &quot;L&quot;].</span>
<span class="sd">        </span>
<span class="sd">        ESTIMATES FILE FOR GAUSSIAN SINGLETS (NONRECOMMENDED METHOD)</span>
<span class="sd">        Initial estimates for gaussian singlets can be specified in an estimates file. Estimates files may be deprecated in the future in favor of the</span>
<span class="sd">        p*est parameters, so it is recommended users use those parameters instead. If an estimates file is desired to be used, the p*est parameters</span>
<span class="sd">        must be 0 or empty and mgncomps must be 0 or empty. Only gaussian singlets can be specified in an estimates file. If one desires to fit one or</span>
<span class="sd">        more gaussian multiplets and/or one or more lorentzian singlets simultaneously, the p*est parameters must be used to specify the initial parameters</span>
<span class="sd">        of all gaussian singlets to fit; one cannot use an estimates file in this case. If an estimates file is specified, a polynomial</span>
<span class="sd">        can be fit simultaneously by specifying the poly parameter. The estimates file must contain initial estimates of parameters</span>
<span class="sd">        for all gaussian singlets to be fit. The number of gaussian singlets to fit is gotten from the number of estimates in the file. The file can contain</span>
<span class="sd">        comments which are indicated by a &quot;#&quot; at the beginning of a line. All non-comment lines will be interpreted as initial estimates. The</span>
<span class="sd">        format of such a line is</span>
<span class="sd">        </span>
<span class="sd">        [peak intensity], [center], [fwhm], [optional fixed parameter string]</span>
<span class="sd">        </span>
<span class="sd">        The first three values are required and must be numerical values. The peak intensity must be expressed in image brightness units, while the</span>
<span class="sd">        center must be specified in pixels offset from the zeroth pixel, and fwhm must be specified in pixels. The fourth value is optional and if present,</span>
<span class="sd">        represents the parameter(s) that should be held constant during the fit. Any combination of the characters &#39;p&#39; (peak), &#39;c&#39; (center), and &#39;f&#39; (fwhm) are</span>
<span class="sd">        permitted, eg &quot;fc&quot; means hold the fwhm and the center constant during the fit. Fixed parameters will have no error associated with them. Here is an</span>
<span class="sd">        example file:</span>
<span class="sd">        </span>
<span class="sd">        begin{verbatim}</span>
<span class="sd">        # estimates file indicating that two gaussians should be fit</span>
<span class="sd">        # first guassian estimate, peak=40, center at pixel number 10.5, fwhm = 5.8 pixels, all parameters allowed to vary during</span>
<span class="sd">        # fit</span>
<span class="sd">        40, 10.5, 5.8</span>
<span class="sd">        # second gaussian, peak = 4, center at pixel number 90.2, fwhm = 7.2 pixels, hold fwhm constant</span>
<span class="sd">        4, 90.2, 7.2, f</span>
<span class="sd">        # end file</span>
<span class="sd">        end{verbatim}</span>
<span class="sd">        </span>
<span class="sd">        GAUSSIAN MULTIPLET FITTING</span>
<span class="sd">        Any number of gaussian multiplets, each containing any number of two or more components, can be simultaneously fit, optionally with a</span>
<span class="sd">        polynomial and/or any number of gaussian and/or lorentzian singlets, the only caveat being that the number of parameters to be fit should be</span>
<span class="sd">        significantly less than the number of data points. The gmncomps parameter indicates the number of multiplets to fit and the number of</span>
<span class="sd">        components in each multiplet. In the case of a single multiplet, an integer (&gt;1) can be specified. For example, mgncomps=4 means fit a</span>
<span class="sd">        single quadruplet of gaussians. In the case of 2 or more multiplets, and array of integers (all &gt;1) must be specified. For example,</span>
<span class="sd">        gmncomps=[2, 4, 3] means 3 seperate multiples are to be fit, the zeroth being a doublet, the first being a quadruplet, and the second</span>
<span class="sd">        being a triplet.</span>
<span class="sd">        </span>
<span class="sd">        Initial estimates of all gaussians in all multiplets are specified via the gm*est parameters which must be arrays of numbers. The order</span>
<span class="sd">        starts with the zeroth component of the zeroth multiplet to the last component of the zeroth multiplet, then the zeroth component of</span>
<span class="sd">        the first multiplet to the last compoenent of the first multiplet, etc to the zeroth component of the last multiplet to the last</span>
<span class="sd">        element of the last multiplet. The zeroth element of a multiplet is defined as the reference component of that multiplet and has the special</span>
<span class="sd">        significance that it is the profile to which all constraints of all other profiles in that multiplet are referenced (see below). So,</span>
<span class="sd">        in our example of gmncomps=[2, 4, 3], gmampest, gmcenterest, and gmfwhmest must each be nine (the total number of individual gaussian</span>
<span class="sd">        profiles summed over all multiplets) element arrays. The zeroth, second, and sixth elements represent parameters of the reference profiles</span>
<span class="sd">        in the zeroth, first, and second multiplet, respectively.</span>
<span class="sd">        </span>
<span class="sd">        The fixed relationships between the non-reference profile(s) and the reference profile of a multiplet are specified via the gmampcon,</span>
<span class="sd">        gmcentercon, and gmfwhmcon parameters. At least one, and any combination, of constraints can be specified for any non-reference</span>
<span class="sd">        component of a multiplet. The amplitude ratio of a non-reference line to that of the reference line is set in gmampcon. The ratio of</span>
<span class="sd">        the fwhm of a non-reference line to that of the reference line is set in gmfwhmcon. The offset in pixels of the center position of</span>
<span class="sd">        a non-reference line to that of the reference line is set in gmcentercon. In the case where a parameter is not constrained for any</span>
<span class="sd">        non-reference line of any multiplet, the value of the associated parameter must be 0. In the case of</span>
<span class="sd">        a single doublet, a constraint may be specified as a number or an array of a single number. For example, mgncomps=2 and gmampcon=0.65</span>
<span class="sd">        and gmcentercon=[32.4] means there is a single doublet to fit where the amplitude ratio of the first to the zeroth line is constained</span>
<span class="sd">        to be 0.65 and the center of the first line is constrained to be offset by 32.4 pixels from the center of the zeroth line. In cases</span>
<span class="sd">        of a total of three or more gaussians, the constraints parameters must be specified as arrays with lengths equal to the total number</span>
<span class="sd">        of gaussians summed over all multiplets minus the number of reference lines (one per multiplet, or just number of multiplets, since</span>
<span class="sd">        reference lines cannot be constrained by themselves). In the cases where an array must be specified but a component in that array</span>
<span class="sd">        does not have that constraint, 0 should be specified. Here&#39;s an example</span>
<span class="sd">        </span>
<span class="sd">        gmncomps=[2, 4, 3]</span>
<span class="sd">        gmampcon=  [ 0  ,  0.2,  0  , 0.1,   4.5,   0  ]</span>
<span class="sd">        gcentercon=[24.2, 45.6, 92.7, 0  , -22.8, -33.5]</span>
<span class="sd">        gfwhmcon=&quot;&quot;</span>
<span class="sd">        </span>
<span class="sd">        In this case we have our previous example of one doublet, one quadruplet, and one triplet. The first component of the doublet has the constraint</span>
<span class="sd">        that its center is offset by 24.2 pixels from the zeroth (reference) component. The first component of the quadruplet is constrained to have</span>
<span class="sd">        an amplitude of 0.2 times that of the quadruplet&#39;s zeroth component and its center is constrained to be offset by 45.6 pixels from the</span>
<span class="sd">        reference component. The second component of the quadruplet is constained to have its center offset by 92.7 pixels from the associated</span>
<span class="sd">        reference component and the third component is constrained to have an amplitude of 0.1 times that of the associated reference component.</span>
<span class="sd">        The first component of the triplet is constrained to have an amplitude of 4.5 times that of its associated reference component and its center</span>
<span class="sd">        is constrained to be offset by -22.8 pixels from the reference component&#39;s center. The second component of the triplet is constrained to have</span>
<span class="sd">        its center offset by -33.5 pixels from the center of the reference component. No lines have FWHM constraints, so the empty string can be given</span>
<span class="sd">        for that parameter. Note that using 0 to indicate no constraint for line center means that one cannot specify a line centered at the same</span>
<span class="sd">        position as the reference component but having a different FWHM from the reference component. If you must specify this very unusual case,</span>
<span class="sd">        try using a very small positive (or even negative) value for the center constraint.</span>
<span class="sd">        </span>
<span class="sd">        Note that when a parameter for a line is constrained, the corresponding value for that component in the corresponding gm*est array is</span>
<span class="sd">        ignored and the value of the constrained parameter is automatically used instead. So let&#39;s say, for our example above, we had specified</span>
<span class="sd">        the following estimates:</span>
<span class="sd">        </span>
<span class="sd">        gmampest =     [ 1,   .2,  2,   .1,    .1,   .5,  3,    2, 5]</span>
<span class="sd">        gmcenterest =  [20, 10  , 30, 45.2, 609  , -233, 30, -859, 1]</span>
<span class="sd">        </span>
<span class="sd">        Before any fitting is done, the constraints would be taken into account and these arrays would be implicitly rewritten as:</span>
<span class="sd">        </span>
<span class="sd">        gmampest =     [ 1,   .2,  2,   .4,    .1,   .2,  3, 13.5,  5  ]</span>
<span class="sd">        gmcenterest =  [20, 44.2, 30, 75.6, 127.7, -233, 30,  7.2, -3.5]</span>
<span class="sd">        </span>
<span class="sd">        The value of gmfwhmest would be unchanged since there are no FWHM constraints in this example.</span>
<span class="sd">        </span>
<span class="sd">        In addition to be constrained by values of the reference component, parameters of individual components can be fixed. Fixed parameters</span>
<span class="sd">        are specified via the gmfix parameter. If no parameters are to be fixed, gmfix can be specified as the empty string or a zero element</span>
<span class="sd">        array. In the case where any parameter is to be fixed, gmfix must be specified as an array of strings with length equal to the total number of</span>
<span class="sd">        components summed over all multiplets. These strings encode which parameters to be fixed for the corresponding components. If</span>
<span class="sd">        a component is to have no parameters fixed, an empty string is used. In other cases one or more of any combination of parameters can</span>
<span class="sd">        be fixed using &quot;p&quot;, &quot;c&quot;, and/or &quot;f&quot; described above for fixing singlet parameters. There are a couople of special cases</span>
<span class="sd">        to be aware of. In the case where a non-reference component parameter is constrained and the corresponding reference component parameter is</span>
<span class="sd">        set as fixed, that parameter in the non-reference parameter will automatically be fixed even if it was specified not to be fixed in</span>
<span class="sd">        the gmfix array. This is the only way the constraint can be honored afterall. In the converse case of when a constrained parameter of a</span>
<span class="sd">        non-reference component is specified as fixed, but the corresponding parameter in the reference component is not specified to be fixed,</span>
<span class="sd">        an error will occur. Fixing an unconstrained parameter in a non-reference component is always legal as is fixing any combination of</span>
<span class="sd">        parameters in a reference component (with the above caveat that corresponding constrained parameters in non-reference components will</span>
<span class="sd">        be silently held fixed as well).</span>
<span class="sd">        </span>
<span class="sd">        The same rules that apply to singlets when multifit=True apply to multiplets.</span>
<span class="sd">        </span>
<span class="sd">        LIMITING RANGES FOR SOLUTION PARAMETERS</span>
<span class="sd">        In cases of low (or no) signal to noise spectra, it is still possible for the fit to converge, but often to a</span>
<span class="sd">        nonsensical solution. The astronomer can use her knowledge of the source to filter out obviously bogus solutions.</span>
<span class="sd">        Any solution which contains a NaN value as a value or error in any one of its parameters is automatically marked as</span>
<span class="sd">        invalid.</span>
<span class="sd">        </span>
<span class="sd">        One can also limit the ranges of solution parameters to known &quot;good&quot; values via the goodamprange, goodcenterrange, and goodfwhmrange</span>
<span class="sd">        parameters. Any combination can be specified and the limit constraints will be ANDed together. The ranges apply to all PCF components</span>
<span class="sd">        that might be fit; choosing ranges on a component by component basis is not supported. If specified,</span>
<span class="sd">        an array of exactly two numerical values must be given to indicate the range of acceptable solution values for</span>
<span class="sd">        that parameter.  goodamprange is expressed in terms of image brightness units. goodcenterrange is expressed in terms of pixels</span>
<span class="sd">        from the zeroth pixel in the specified region. goodfwhmrange is expressed in terms of pixels (only non-negative values should be</span>
<span class="sd">        given for FWHM range endpoints). In the case of a multiple-PCF fit, if any of the corresponding solutions are outside the specified</span>
<span class="sd">        ranges, the entire solution is considered to be invalid.</span>
<span class="sd">        </span>
<span class="sd">        In addition, solutions for which the absolute value of the ratio of the amplitude error to the amplitude exceeds 100 or the</span>
<span class="sd">        ratio of the FWHM error to the FWHM exceeds 100 are automatically marked as invalid.</span>
<span class="sd">        </span>
<span class="sd">        POWER LOGARITHMIC POLYNOMIAL  AND LOGARITHMIC TRANSFORMED POLYNOMIAL FITTING</span>
<span class="sd">        Fitting of a sngle power logarithmic polynomial or a single logarithmic transformed polynomial function is supported.</span>
<span class="sd">        No other functions may be fit simultaneously with either of these; if parameters relating to other functions are supplied</span>
<span class="sd">        simultaneously with parameters relating</span>
<span class="sd">        to these functions, an exception will occur. For details of the functional forms, see the introduction of this</span>
<span class="sd">        document.</span>
<span class="sd">        </span>
<span class="sd">        The set of c0 ... cn coefficients (as defined previously) can</span>
<span class="sd">        be solved for. Initial estimates for the c values should be supplied via the plpest or ltpest parameters, depending on which</span>
<span class="sd">        form is being fit. The number of values given</span>
<span class="sd">        in this array will be the number of coeffecients that are solved for. One may specify which coefficients should be held</span>
<span class="sd">        fixed during the fit in the plpfix or ltpfix array. If supplied, this array should have the same number of elements as its respective</span>
<span class="sd">        initial estimates array. A value</span>
<span class="sd">        of True means the corresponding coefficient will be held fixed during the fit. An empty array indicates that no</span>
<span class="sd">        parameters will be held fixed. This is the default.</span>
<span class="sd">        </span>
<span class="sd">        Because the logarithm of the ordinate values must be taken before fitting a logarithmic transformed polynomial,</span>
<span class="sd">        all non-positive pixel values are effectively masked for the purposes of fitting.</span>
<span class="sd">        </span>
<span class="sd">        INCLUDING STANDARD DEVIATIONS OF PIXEL VALUES</span>
<span class="sd">        If the standard deviations of the pixel values in the input image are known and they vary in the image (eg they are higher for pixels</span>
<span class="sd">        near the edge of the band), they can be included in the sigma parameter. This parameter takes either an array or an image name. The</span>
<span class="sd">        array or image must have one of three shapes: 1. the shape of the input image, 2. the same dimensions as the input image with the lengths</span>
<span class="sd">        of all axes being one except for the fit axis which must have length corresponding to its length in the input image, or 3. be one</span>
<span class="sd">        dimensional with lenght equal the the length of the fit axis in the input image. In cases 2 and 3, the array or pixels in sigma will</span>
<span class="sd">        be replicated such that the image that is ultimately used is the same shape as the input image. The values of sigma must be non-negative.</span>
<span class="sd">        It is only the relative values that are important. A value of 0 means that pixel should not be used in the fit. Other than that, if pixel</span>
<span class="sd">        A has a higher standard deviation than pixel B, then pixel A is noisier than pixel B and will receive a lower weight when the fit is done.</span>
<span class="sd">        The weight of a pixel is the usual</span>
<span class="sd">        </span>
<span class="sd">        weight = 1/(sigma*sigma)</span>
<span class="sd">        </span>
<span class="sd">        In the case of multifit=False, the sigma values at each pixel along the fit axis in the hyperplane perpendicular to the fit axis which includes</span>
<span class="sd">        that pixel are averaged and the resultant averaged standard deviation spectrum is the one used in the fit. Internally, sigma values are normalized</span>
<span class="sd">        such that the maximum value is 1. This mitigates a known overflow issue.</span>
<span class="sd">        </span>
<span class="sd">        One can write the normalized standard deviation image used in the fit but specifying its name in outsigma. This image can then be</span>
<span class="sd">        used as sigma for subsequent runs.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        RETURNED DICTIONARY STRUCTURE</span>
<span class="sd">        The returned dictionary has a (necessarily) complex structure. First, there are keys &quot;xUnit&quot; and &quot;yUnit&quot; whose values are</span>
<span class="sd">        the abscissa unit and the ordinate unit described by simple strings. Next there are arrays giving a broad overview of the</span>
<span class="sd">        fit quality. These arrays have the shape of the specified region collapsed along the fit axis with the axis corresponding to the fit</span>
<span class="sd">        axis having length of 1:</span>
<span class="sd">        </span>
<span class="sd">        attempted: a boolean array indicating which fits were attempted (eg if too few unmasked points, a fit will not be attempted).</span>
<span class="sd">        converged: a boolean array indicating which fits converged. False if the fit was not attempted.</span>
<span class="sd">        valid:     a boolean array indicating which solutions fall within the specified valid ranges of parameter space (see</span>
<span class="sd">        .          section LIMITING RANGES FOR SOLUTION PARAMETERS for details).</span>
<span class="sd">        niter:     an int array indicating the number of iterations for each profile, &lt;0 if the fit did not converge</span>
<span class="sd">        ncomps:    the number of components (gaussian singlets + lorentzian singlets + gaussian multiplets + polynomial) fit for the profile,</span>
<span class="sd">        .          &lt;0 if the fit did not converge</span>
<span class="sd">        direction: a string array containing the world direction coordinate for each profile</span>
<span class="sd">        </span>
<span class="sd">        There is a &quot;type&quot; array having number of dimensions equal to the number of dimensions in the above arrays plus one. The shape of</span>
<span class="sd">        the first n-1 dimensions is the same as the shape of the above arrays. The length of the last dimension is equal to the number of</span>
<span class="sd">        components fit. The values of this array are strings describing the components that were fit at each possition (&quot;POLYNOMIAL&quot;,</span>
<span class="sd">        &quot;GAUSSIAN&quot; in the case of gaussian singlets, &quot;LORENTZIAN&quot; in the case of lorentzian singlets, and &quot;&quot;GAUSSIAN MULTPLET&quot;).</span>
<span class="sd">        </span>
<span class="sd">        If any gaussian singlets were fit, there will be a subdictionary accessible via the &quot;gs&quot; key which will have subkeys &quot;amp&quot;, &quot;ampErr&quot;, &quot;center&quot;,</span>
<span class="sd">        &quot;centerErr&quot;, &quot;fwhm&quot;, &quot;fwhmErr, &quot;integral&quot;, and &quot;integralErr&quot;. Each of these arrays will have one more dimension than the overview arrays described</span>
<span class="sd">        above. The shape of the first n-1 dimensions will be the same as the shape of the arrays described above, while the final dimension will</span>
<span class="sd">        have length equal to the maximum number of gaussian singlets that were fit. Along this axis will be the</span>
<span class="sd">        corresponding fit result or associated error (depending on the array&#39;s associated key) of the fit for that singlet component number. In cases where</span>
<span class="sd">        the fit did not converge, or that particular component was excluded from the fit, a value of NAN will be present.</span>
<span class="sd">        </span>
<span class="sd">        If any lorentzian singlets were fit, their solutions will be accessible via the &quot;ls&quot; key. These arrays follow the same rules</span>
<span class="sd">        as the &quot;gs&quot; arrays described above.</span>
<span class="sd">        </span>
<span class="sd">        If any gaussian multiplets were fit, there will be subdictionaries accessible by keys &quot;gm0&quot;, &quot;gm1&quot;, ..., &quot;gm{n-1}&quot; where n is the number of gaussian</span>
<span class="sd">        muliplets that were fit. Each of these dictionaries will have the same arrays described above for gaussian singlets. The last dimension</span>
<span class="sd">        will have length equal to the number of components in that particular multiplet. Each pixel along the last axis will be the parameter solution</span>
<span class="sd">        value or error for that component number in the multiplet, eg the zeroth pixel along that axis contains</span>
<span class="sd">        the parameter solution or error for the reference component of the multiplet.</span>
<span class="sd">        </span>
<span class="sd">        The polynomial coefficient solutions and errors are not returned, although they are logged.</span>
<span class="sd">        </span>
<span class="sd">        If a power logarithmic polynomial was fit, there will be a subdictionary accessible via the &quot;plp&quot; key which will have</span>
<span class="sd">        subkeys &quot;soltuion&quot; and &quot;error&quot; which will each have an array value. Each of these arrays will have one more dimension than the overview arrays</span>
<span class="sd">        described above. The shape of the first n-1 dimensions will be the same as the shape of the overview arrays described above, while the</span>
<span class="sd">        final dimension will have length equal to the number of parameters that were fit. Along this axis will be the</span>
<span class="sd">        corresponding fit result or associated error (depending on the array&#39;s associated key) of the fit. In cases where</span>
<span class="sd">        the fit was not attempted or did not converge, a value of NAN will be present.</span>
<span class="sd">        </span>
<span class="sd">        OUTPUT IMAGES</span>
<span class="sd">        In addition to the returned dictionary, optionally one or more of any combination of output images can be written.</span>
<span class="sd">        The model and residual parameters indicate the names of the model and residual images to be written; blank values inidcate that these images</span>
<span class="sd">        should not be written.</span>
<span class="sd">        </span>
<span class="sd">        One can also write none, any or all of the solution and error images for gaussian singlet, lorentzian singlet,  and gaussian multiplet fits</span>
<span class="sd">        via the parameters amp, amperr, center, centererr, fwhm, fwhmerr, integral, integralerr when doing multi-pixel fits. For a power logarithmic</span>
<span class="sd">        polynomial or a logarithmic transformed polynomial fit, plpsol or ltpsol and plperr or ltpsol are the names of the solution and error</span>
<span class="sd">        images to write, respectively.</span>
<span class="sd">        </span>
<span class="sd">        These images contain the arrays described for the associated parameter solutions or errors described in previous sections. Each</span>
<span class="sd">        component is written to a different image, and each image is distiguished by the component it represents by its name ending</span>
<span class="sd">        in an uderscore and the relevant component number (&quot;_0&quot;, &quot;_1&quot;, etc). In the case of Gaussian multiplets, the image name ends</span>
<span class="sd">        with the number of the mulitplet group followed by the number of the component in that group (eg &quot;_3_4&quot; represents component</span>
<span class="sd">        4 in multiplet group 3). In the case of lorentzian singlets, &quot;_ls&quot; is appended to the image names (but before the</span>
<span class="sd">        identifying component number), in the case of gaussian multiplets. Similarly &quot;_gm&quot; is included in the name of Gaussian multiplet</span>
<span class="sd">        images. Pixels for which fits were not attempted, did not converge, or converged but have values of NaN (not a number) or</span>
<span class="sd">        INF (infinity) will be masked as bad.</span>
<span class="sd">        </span>
<span class="sd">        Writing analogous images for polynomial coefficients is not supported.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">fitprofile</span><span class="p">(</span><span class="n">box</span><span class="p">,</span> <span class="n">region</span><span class="p">,</span> <span class="n">chans</span><span class="p">,</span> <span class="n">stokes</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">ngauss</span><span class="p">,</span> <span class="n">poly</span><span class="p">,</span> <span class="n">estimates</span><span class="p">,</span> <span class="n">minpts</span><span class="p">,</span> <span class="n">multifit</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">residual</span><span class="p">,</span> <span class="n">amp</span><span class="p">,</span> <span class="n">amperr</span><span class="p">,</span> <span class="n">center</span><span class="p">,</span> <span class="n">centererr</span><span class="p">,</span> <span class="n">fwhm</span><span class="p">,</span> <span class="n">fwhmerr</span><span class="p">,</span> <span class="n">integral</span><span class="p">,</span> <span class="n">integralerr</span><span class="p">,</span> <span class="n">stretch</span><span class="p">,</span> <span class="n">logresults</span><span class="p">,</span> <span class="n">pampest</span><span class="p">,</span> <span class="n">pcenterest</span><span class="p">,</span> <span class="n">pfwhmest</span><span class="p">,</span> <span class="n">pfix</span><span class="p">,</span> <span class="n">gmncomps</span><span class="p">,</span> <span class="n">gmampcon</span><span class="p">,</span> <span class="n">gmcentercon</span><span class="p">,</span> <span class="n">gmfwhmcon</span><span class="p">,</span> <span class="n">gmampest</span><span class="p">,</span> <span class="n">gmcenterest</span><span class="p">,</span> <span class="n">gmfwhmest</span><span class="p">,</span> <span class="n">gmfix</span><span class="p">,</span> <span class="n">spxtype</span><span class="p">,</span> <span class="n">spxest</span><span class="p">,</span> <span class="n">spxfix</span><span class="p">,</span> <span class="n">div</span><span class="p">,</span> <span class="n">spxsol</span><span class="p">,</span> <span class="n">spxerr</span><span class="p">,</span> <span class="n">logfile</span><span class="p">,</span> <span class="n">append</span><span class="p">,</span> <span class="n">pfunc</span><span class="p">,</span> <span class="n">goodamprange</span><span class="p">,</span> <span class="n">goodcenterrange</span><span class="p">,</span> <span class="n">goodfwhmrange</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">outsigma</span><span class="p">,</span> <span class="n">planes</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">fitcomponents</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">box</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">region</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">chans</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">stokes</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">includepix</span><span class="o">=</span><span class="p">[</span> <span class="nb">float</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">],</span> <span class="n">excludepix</span><span class="o">=</span><span class="p">[</span> <span class="nb">float</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">],</span> <span class="n">residual</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">estimates</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">logfile</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">newestimates</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">complist</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">dooff</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="mf">0.0</span><span class="p">),</span> <span class="n">fixoffset</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">stretch</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">rms</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">noisefwhm</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">summary</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;OVERVIEW</span>
<span class="sd">        </span>
<span class="sd">        This application is used to fit one or more two dimensional gaussians to sources in an image as</span>
<span class="sd">        well as an optional zero-level offset. Fitting is limited to a single polarization</span>
<span class="sd">        but can be performed over several contiguous spectral channels.</span>
<span class="sd">        If the image has a clean beam, the report and returned dictionary will contain both the convolved</span>
<span class="sd">        and the deconvolved fit results.</span>
<span class="sd">        </span>
<span class="sd">        When dooff is False, the method returns a dictionary with keys named &#39;converged&#39;, &#39;pixelsperarcsec&#39;,</span>
<span class="sd">        &#39;results&#39;, and &#39;deconvolved&#39;. The value of &#39;converged&#39; is a boolean array which indicates if the</span>
<span class="sd">        fit converged on a channel by channel basis. The value of &#39;pixelsperarcsec&#39; is a two element double</span>
<span class="sd">        array with the absolute values of the direction coordinate pixel increments (longitude-like and</span>
<span class="sd">        latitude-like coordinate, respectively) in arcsec. The value of &#39;results&#39; is a dictionary</span>
<span class="sd">        representing a component list reflecting the fit results. In the case of an image containing beam</span>
<span class="sd">        information, the sizes and position angles in the &#39;results&#39; dictionary are those of the source(s)</span>
<span class="sd">        convolved with the restoring beam, while the same parameters in the &#39;deconvolved&#39; dictionary</span>
<span class="sd">        represent the source sizes deconvolved from the beam. In the case where the image does not</span>
<span class="sd">        contain a beam, &#39;deconvolved&#39; will be absent. Both the &#39;results&#39; and &#39;deconvolved&#39; dictionaries can</span>
<span class="sd">        be read into a component list tool (default tool is named cl) using the fromrecord() method for</span>
<span class="sd">        easier inspection using tool methods, eg</span>
<span class="sd">        </span>
<span class="sd">        cl.fromrecord(res[&#39;results&#39;])</span>
<span class="sd">        </span>
<span class="sd">        although this only works if the flux density units are conformant with Jy.</span>
<span class="sd">        </span>
<span class="sd">        There are also values in each component subdictionary not used by cl.fromrecord() but meant to</span>
<span class="sd">        supply additional information. There is a &#39;peak&#39; subdictionary for each component that provides the</span>
<span class="sd">        peak intensity of the component. It is present for both &#39;results&#39; and &#39;deconvolved&#39; components.</span>
<span class="sd">        There is also a &#39;sum&#39; subdictionary for each component indicated the simple sum of pixel values in</span>
<span class="sd">        the the original image enclosed by the fitted ellipse. There is a &#39;channel&#39; entry in the &#39;spectrum&#39;</span>
<span class="sd">        subdictionary which provides the zero-based channel number in the input image for which the solution</span>
<span class="sd">        applies. In addtion, if the image has a beam(s), then there will be a &#39;beam&#39; subdictionary associated</span>
<span class="sd">        with each component in both the &#39;results&#39; and &#39;deconvolved&#39; dictionaries. This subdictionary will</span>
<span class="sd">        have three keys: &#39;beamarcsec&#39; will be a subdictionary giving the beam dimensions in arcsec,</span>
<span class="sd">        &#39;beampixels&#39; will have the value of the beam area expressed in pixels, and &#39;beamster&#39; will have the</span>
<span class="sd">        value of the beam area epressed in steradians. Also, if the image has a beam(s), in the component level</span>
<span class="sd">        dictionaries will be an &#39;ispoint&#39; entry with an associated boolean value describing if the component</span>
<span class="sd">        is consistent with a point source. Each component level dictionary will have a &#39;pixelcoords&#39; entry</span>
<span class="sd">        which has the value of a two element numeric array which provides the direction pixel coordinates</span>
<span class="sd">        of the fitted position.</span>
<span class="sd">        </span>
<span class="sd">        If dooff is True, in addtion to the specified number of</span>
<span class="sd">        gaussians, a zero-level offset will also be fit. The initial estimate for this</span>
<span class="sd">        offset is specified using the offset parameter. Units are assumed to be the</span>
<span class="sd">        same as the image brightness units. The zero level offset can be held constant during</span>
<span class="sd">        the fit by specifying fixoffset=True. In the case of dooff=True, the returned</span>
<span class="sd">        dictionary contains two additional keys, &#39;zerooff&#39; and &#39;zeroofferr&#39;, which are both</span>
<span class="sd">        dictionaries containing &#39;unit&#39; and &#39;value&#39; keys. The values associated with the &#39;value&#39;</span>
<span class="sd">        keys are arrays containing the the fitted zero level offset value and its error, respectively,</span>
<span class="sd">        for each channel. In cases where the fit did not converge, these values are set to NaN.</span>
<span class="sd">        The value associated with &#39;unit&#39; is just the image brightness unit.</span>
<span class="sd">        </span>
<span class="sd">        The region can either be specified by a box(es) or a region.</span>
<span class="sd">        Ranges of pixel values can be included or excluded from the fit. If specified using</span>
<span class="sd">        the box parameter, multiple boxes can be given using the format</span>
<span class="sd">        box=&quot;blcx1, blcy1, trcx1, trcy1, blcx2, blcy2, trcx2, trcy2, ... , blcxN, blcyN, trcxN, trcyN&quot;</span>
<span class="sd">        where N is the number of boxes. In this case, the union of the specified boxes will be used.</span>
<span class="sd">        </span>
<span class="sd">        If specified, the residual and/or model images for successful fits will be written.</span>
<span class="sd">        </span>
<span class="sd">        If an estimates file is not specified, an attempt is made to estimate</span>
<span class="sd">        initial parameters and fit a single Gaussian. If a multiple Gaussian fit</span>
<span class="sd">        is desired, the user must specify initial estimates via a text file</span>
<span class="sd">        (see below for details).</span>
<span class="sd">        </span>
<span class="sd">        The user has the option of writing the result of the fit to a log file,</span>
<span class="sd">        and has the option of either appending to or overwriting an existing file.</span>
<span class="sd">        </span>
<span class="sd">        The user has the option of writing the (convolved) parameters of a successful</span>
<span class="sd">        fit to a file which can be fed back to fitcomponents() as the estimates file for a</span>
<span class="sd">        subsequent run.</span>
<span class="sd">        </span>
<span class="sd">        The user has the option of writing the fit results in tabular format to a file whose</span>
<span class="sd">        name is specified using the summary parameter.</span>
<span class="sd">        </span>
<span class="sd">        If specified and positive, the value of rms is used to calculate the parameter uncertainties,</span>
<span class="sd">        otherwise, the rms in the selected region in the relevant channel is used for these calculations.</span>
<span class="sd">        </span>
<span class="sd">        The noisefwhm parameter represents the noise-correlation beam FWHM. If specified as a quantity,</span>
<span class="sd">        it should have angular units. If specified as a numerical value, it is set equal to that number</span>
<span class="sd">        of pixels. If specified and greater than or equal to the pixel size, it is used to calculate</span>
<span class="sd">        parameter uncertainties using the correlated noise equations (see below). If it is specified but</span>
<span class="sd">        less than a pixel width, the the uncorrelated noise equations (see below) are used to</span>
<span class="sd">        compute the parameter uncertainties. If it is not specified and the image has a restoring beam(s),</span>
<span class="sd">        the the correlated noise equations are used to compute parameter uncertainties using the</span>
<span class="sd">        geometric mean of the relevant beam major and minor axes as the noise-correlation beam FWHM. If</span>
<span class="sd">        noisefwhm is not specified and the image does not have a restoring beam, then the uncorrelated</span>
<span class="sd">        noise equations are used to compute the parameter uncertainties.</span>
<span class="sd">        </span>
<span class="sd">        SUPPORTED UNITS</span>
<span class="sd">        </span>
<span class="sd">        Currently only images with brightness units conformant with Jy/beam, Jy.km/s/beam, and K are fully</span>
<span class="sd">        supported for fitting. If your image has some other base brightness unit, that unit will be assumed</span>
<span class="sd">        to be equivalent to Jy/pixel and results will be calculated accordingly. In particular,</span>
<span class="sd">        the flux density (reported as Integrated Flux in the logger and associated with the &quot;flux&quot; key</span>
<span class="sd">        in the returned component subdictionary(ies)) for such a case represents the sum of pixel values.</span>
<span class="sd">        </span>
<span class="sd">        Note also that converting the returned results subdictionary to a component list via cl.fromrecord() currently</span>
<span class="sd">        only works properly if the flux density units in the results dictionary are conformant with Jy.</span>
<span class="sd">        If you need to be able to run cl.fromrecord() on the resulting dictionary you can first modify the</span>
<span class="sd">        flux density units by hand to be (some prefix)Jy and then run cl.fromrecord() on that dictionary,</span>
<span class="sd">        bearing in mind your unit conversion.</span>
<span class="sd">        </span>
<span class="sd">        If the input image has units of K, the flux density of components will be reported in units</span>
<span class="sd">        of [prefix]K*rad*rad, where prefix is an SI prefix used so that the numerical value is between</span>
<span class="sd">        1 and 1000. To convert to units of K*beam, determine the area of the appropriate beam,</span>
<span class="sd">        which is given by pi/(4*ln(2))*bmaj*bmin, where bmaj and bmin are the major and minor axes</span>
<span class="sd">        of the beam, and convert to steradians (=rad*rad). This value is included in the beam portion</span>
<span class="sd">        of the component subdictionary (key &#39;beamster&#39;). Then divide the numerical value of the</span>
<span class="sd">        logged flux density by the beam area in steradians. So, for example</span>
<span class="sd">        </span>
<span class="sd">        begin{verbatim}</span>
<span class="sd">        # run on an image with K brightness units</span>
<span class="sd">        res = imfit(...)</span>
<span class="sd">        # get the I flux density in K*beam of component 0</span>
<span class="sd">        comp = res[&#39;results&#39;][&#39;component0&#39;]</span>
<span class="sd">        flux_density_kbeam = comp[&#39;flux&#39;][&#39;value&#39;][0]/comp[&#39;beam&#39;][&#39;beamster&#39;]</span>
<span class="sd">        end{verbatim}</span>
<span class="sd">        </span>
<span class="sd">        FITTING OVER MULTIPLE CHANNELS</span>
<span class="sd">        </span>
<span class="sd">        For fitting over multiple channels, the result of the previous successful fit is used as</span>
<span class="sd">        the estimate for the next channel. The number of gaussians fit cannot be varied on a channel</span>
<span class="sd">        by channel basis. Thus the variation of source structure should be reasonably smooth in</span>
<span class="sd">        frequency to produce reliable fit results.</span>
<span class="sd">        </span>
<span class="sd">        MASK SPECIFICATION</span>
<span class="sd">        </span>
<span class="sd">        Mask specification can be done using an LEL expression. For example</span>
<span class="sd">        </span>
<span class="sd">        mask = &#39;&quot;myimage&quot;&gt;5&#39; will use only pixels with values greater than 5.</span>
<span class="sd">        </span>
<span class="sd">        INCLUDING AND EXCLUDING PIXELS</span>
<span class="sd">        </span>
<span class="sd">        Pixels can be included or excluded from the fit based on their values</span>
<span class="sd">        using these parameters. Note that specifying both is not permitted and</span>
<span class="sd">        will cause an error. If specified, both take an array of two numeric</span>
<span class="sd">        values.</span>
<span class="sd">        </span>
<span class="sd">        ESTIMATES</span>
<span class="sd">        </span>
<span class="sd">        Initial estimates of fit parameters may be specified via an estimates</span>
<span class="sd">        text file. Each line of this file should contain a set of parameters for</span>
<span class="sd">        a single gaussian. Optionally, some of these parameters can be fixed during</span>
<span class="sd">        the fit. The format of each line is</span>
<span class="sd">        </span>
<span class="sd">        peak intensity, peak x-pixel value, peak y-pixel value, major axis, minor axis, position angle, fixed</span>
<span class="sd">        </span>
<span class="sd">        The fixed parameter is optional. The peak intensity is assumed to be in the</span>
<span class="sd">        same units as the image pixel values (eg Jy/beam). The peak coordinates are specified</span>
<span class="sd">        in pixel coordinates. The major and minor axes and the position angle are the convolved</span>
<span class="sd">        parameters if the image has been convolved with a clean beam and are specified as quantities.</span>
<span class="sd">        The fixed parameter is optional and is a string. It may contain any combination of the</span>
<span class="sd">        following characters &#39;f&#39; (peak intensity), &#39;x&#39; (peak x position), &#39;y&#39; (peak y position),</span>
<span class="sd">        &#39;a&#39; (major axis), &#39;b&#39; (axial ratio, R = (major axis FWHM)/(minor axis FWHM)),</span>
<span class="sd">        &#39;p&#39; (position angle). NOTE: One cannot hold the minor axis fixed without holding the major</span>
<span class="sd">        axis fixed. If the major axis is not fixed, specifying &quot;b&quot; in the fixed string will hold</span>
<span class="sd">        the axial ratio fixed during the fit.</span>
<span class="sd">        </span>
<span class="sd">        In addition, lines in the file starting with a # are considered comments.</span>
<span class="sd">        </span>
<span class="sd">        An example of such a file is:</span>
<span class="sd">        </span>
<span class="sd">        begin{verbatim}</span>
<span class="sd">        # peak intensity must be in map units</span>
<span class="sd">        120, 150, 110, 23.5arcsec, 18.9arcsec, 120deg</span>
<span class="sd">        90, 60, 200, 46arcsec, 23arcsec, 140deg, fxp</span>
<span class="sd">        end{verbatim}</span>
<span class="sd">        </span>
<span class="sd">        This is a file which specifies that two gaussians are to be simultaneously fit,</span>
<span class="sd">        and for the second gaussian the specified peak intensity, x position, and position angle</span>
<span class="sd">        are to be held fixed during the fit.</span>
<span class="sd">        </span>
<span class="sd">        ERROR ESTIMATES</span>
<span class="sd">        </span>
<span class="sd">        Error estimates are based on the work of Condon 1997, PASP, 109, 166. Key assumptions made are:</span>
<span class="sd">        </span>
<span class="sd">        - The given model (elliptical Gaussian, or elliptical Gaussian plus constant offset) is an</span>
<span class="sd">        adequate representation of the data</span>
<span class="sd">        - An accurate estimate of the pixel noise is provided or can be derived (see above). For the</span>
<span class="sd">        case of correlated noise (e.g., a CLEAN map), the fit region should contain many &quot;beams&quot; or</span>
<span class="sd">        an independent value of rms should be provided.</span>
<span class="sd">        - The signal-to-noise ratio (SNR) or the Gaussian component is large. This is necessary because</span>
<span class="sd">        a Taylor series is used to linearize the problem. Condon (1997) states that the fractional</span>
<span class="sd">        bias in the fitted amplitude due to this assumption is of order 1/(S*S), where S is the overall</span>
<span class="sd">        SNR of the Gaussian with respect to the given data set (defined more precisely below). For a 5</span>
<span class="sd">        sigma &quot;detection&quot; of the Gaussian, this is a 4% effect.</span>
<span class="sd">        - All (or practically all) of the flux in the component being fit falls within the selected region.</span>
<span class="sd">        If a constant offset term is simultaneously fit and not fixed, the region of interest should be</span>
<span class="sd">        even larger. The derivations of the expressions summarized in this note assume an effectively</span>
<span class="sd">        infinite region.</span>
<span class="sd">        </span>
<span class="sd">        Two sets of equations are used to calculate the parameter uncertainties, based on if</span>
<span class="sd">        the noise is correlated or uncorrelated. The rules governing which set of equations are</span>
<span class="sd">        used have been described above in the description of the noisefwhm parameter.</span>
<span class="sd">        </span>
<span class="sd">        In the case of uncorrelated noise, the equations used are</span>
<span class="sd">        </span>
<span class="sd">        f(A) = f(I) = f(M) = f(m) = k*s(x)/M = k*s(y)/m = (s(p)/sqrt(2))*((M*M - m*m)/(M*m))</span>
<span class="sd">        = sqrt(2)/S</span>
<span class="sd">        </span>
<span class="sd">        where s(z) is the uncertainty associated with parameter z, f(z) = s(z)/abs(z) is the</span>
<span class="sd">        fractional uncertainty associated with parameter z, A is the peak intensity, I is the flux</span>
<span class="sd">        density, M  and m are the FWHM major and minor axes, p is the position angle of the</span>
<span class="sd">        component, and k = sqrt(8*ln(2)). s(x) and s(y) are the direction</span>
<span class="sd">        uncertainties of the component measured along the major and minor axes; the resulting</span>
<span class="sd">        uncertainties measured along the principle axes of the image direction coordinate are</span>
<span class="sd">        calculated by propagation of errors using the 2D rotation matrix which enacts the rotation through</span>
<span class="sd">        the position angle plus 90 degrees. S is the overall signal to noise ratio of the component,</span>
<span class="sd">        which, for the uncorrelated noise case is given by</span>
<span class="sd">        </span>
<span class="sd">        S = (A/(k*h*r))*sqrt(pi*M*m)</span>
<span class="sd">        </span>
<span class="sd">        where h is the pixel width of the direction coordinate and r is the rms noise (see the</span>
<span class="sd">        discussion above for the rules governing how the value of r is determined).</span>
<span class="sd">        </span>
<span class="sd">        For the correlated noise case, the same equations are used to determine the uncertainties</span>
<span class="sd">        as in the uncorrelated noise case, except for the uncertainty in I (see below). However,</span>
<span class="sd">        S is given by</span>
<span class="sd">        </span>
<span class="sd">        S = (A/(2*r*N)) * sqrt(M*m) * (1 + ((N*N/(M*M)))**(a/2)) * (1 + ((N*N/(m*m)))**(b/2))</span>
<span class="sd">        </span>
<span class="sd">        where N is the noise-correlation beam FWHM (see discussion of the noisefwhm parameter for</span>
<span class="sd">        rules governing how this value is determined). &quot;**&quot; indicates exponentiation and a and b</span>
<span class="sd">        depend on which uncertainty is being calculated. For sigma(A), a = b = 3/2. For M and x,</span>
<span class="sd">        a = 5/2 and b = 1/2. For m, y, and p, a = 1/2 and b = 5/2. f(I) is calculated in the</span>
<span class="sd">        correlated noise case according to</span>
<span class="sd">        </span>
<span class="sd">        f(I) = sqrt( f(A)*f(A) + (N*N/(M*m))*(f(M*f(M) + f(m)*f(m))) )</span>
<span class="sd">        </span>
<span class="sd">        Note well the following caveats:</span>
<span class="sd">        - Fixing Gaussian component parameters will tend to cause the parameter uncertainties reported for free</span>
<span class="sd">        parameters to be overestimated.</span>
<span class="sd">        - Fitting a zero level offset that is not fixed will tend to cause the reported parameter</span>
<span class="sd">        uncertainties to be slightly underestimated.</span>
<span class="sd">        - The parameter uncertainties will be inaccurate at low SNR (a ~10% for SNR = 3).</span>
<span class="sd">        - If the fitted region is not considerably larger than the largest component that is fit,</span>
<span class="sd">        parameter uncertainties may be mis-estimated.</span>
<span class="sd">        - An accurate rms noise measurement, r, for the region in question must be supplied.</span>
<span class="sd">        Alternatively, a sufficiently large signal-free region must be present in the selected region</span>
<span class="sd">        (at least about 25 noise beams in area) to auto-derive such an estimate.</span>
<span class="sd">        - If the image noise is not statistically independent from pixel to pixel, a reasonably accurate noise</span>
<span class="sd">        correlation scale, N, must be provided. If the noise correlation function is not approximately Gaussian,</span>
<span class="sd">        the correlation length can be estimated using</span>
<span class="sd">        </span>
<span class="sd">        N = sqrt(2*ln(2)/pi)* double-integral(dx dy C(x,y))/sqrt(double-integral(dx dy C(x, y) * C(x,y)))</span>
<span class="sd">        </span>
<span class="sd">        where C(x,y) is the associated noise-smoothing function</span>
<span class="sd">        - If fitted model components have significan spatial overlap, the parameter uncertainties are likely to</span>
<span class="sd">        be mis-estimated (i.e., correlations between the parameters of separate components are not accounted</span>
<span class="sd">        for).</span>
<span class="sd">        - If the image being analyzed is an interferometric image with poor uv sampling, the parameter</span>
<span class="sd">        uncertainties may be significantly underestimated.</span>
<span class="sd">        </span>
<span class="sd">        The deconvolved size and position angle errors are computed by taking the maximum of the absolute values of the</span>
<span class="sd">        differences of the best fit deconvolved value of the given parameter and the deconvolved size of the eight</span>
<span class="sd">        possible combinations of (FWHM major axis +/- major axis error), (FWHM minor axis +/- minor axis error),</span>
<span class="sd">        and (position andle +/- position angle error). If the source cannot be deconvolved from the beam (if the best</span>
<span class="sd">        fit convolved source size cannot be deconvolved from the beam), upper limits on the deconvolved source size</span>
<span class="sd">        are sometimes reported. These limits simply come from the maximum major and minor axes of the deconvolved</span>
<span class="sd">        gaussians taken from trying all eight of the aforementioned combinations. In the case none of these combinations</span>
<span class="sd">        produces a deconvolved size, no upper limit is reported.</span>
<span class="sd">        </span>
<span class="sd">        EXAMPLE:</span>
<span class="sd">        </span>
<span class="sd">        Here is how one might fit two gaussians to multiple channels of a cube using the fit</span>
<span class="sd">        from the previous channel as the initial estimate for the next. It also illustrates</span>
<span class="sd">        how one can specify a region in the associated continuum image as the region to use</span>
<span class="sd">        as the fit for the channel.</span>
<span class="sd">        </span>
<span class="sd">        begin{verbatim}</span>
<span class="sd">        imagename = &quot;co_cube.im&quot;</span>
<span class="sd">        # specify region using region from continuum</span>
<span class="sd">        region = &quot;continuum.im:source.rgn&quot;</span>
<span class="sd">        chans = &quot;2~20&quot;</span>
<span class="sd">        # only use pixels with positive values in the fit</span>
<span class="sd">        excludepix = [-1e10,0]</span>
<span class="sd">        # estimates file contains initial parameters for two Gaussians in channel 2</span>
<span class="sd">        estimates = &quot;initial_estimates.txt&quot;</span>
<span class="sd">        logfile = &quot;co_fit.log&quot;</span>
<span class="sd">        # append results to the log file for all the channels</span>
<span class="sd">        append = &quot;True&quot;</span>
<span class="sd">        ia.open(imagename)</span>
<span class="sd">        ia.fitcomponents(region=region, chans=chans, excludepix=excludepix, estimates=estimates, logfile=logfile, append=append)</span>
<span class="sd">        end{verbatim}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">fitcomponents</span><span class="p">(</span><span class="n">box</span><span class="p">,</span> <span class="n">region</span><span class="p">,</span> <span class="n">chans</span><span class="p">,</span> <span class="n">stokes</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">includepix</span><span class="p">,</span> <span class="n">excludepix</span><span class="p">,</span> <span class="n">residual</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">estimates</span><span class="p">,</span> <span class="n">logfile</span><span class="p">,</span> <span class="n">append</span><span class="p">,</span> <span class="n">newestimates</span><span class="p">,</span> <span class="n">complist</span><span class="p">,</span> <span class="n">overwrite</span><span class="p">,</span> <span class="n">dooff</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">fixoffset</span><span class="p">,</span> <span class="n">stretch</span><span class="p">,</span> <span class="n">rms</span><span class="p">,</span> <span class="n">noisefwhm</span><span class="p">,</span> <span class="n">summary</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">fromrecord</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">record</span><span class="p">,</span> <span class="n">outfile</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;You can convert an associated image to a record</span>
<span class="sd">        (torecord) or  imagepol tool functions  will sometimes give you a record.  This function</span>
<span class="sd">        (fromrecord) allows you to set the contents of an image tool to the content of the record.</span>
<span class="sd">        This and torecord are used for deserialization and serialization.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">fromrecord</span><span class="p">(</span><span class="n">record</span><span class="p">,</span> <span class="n">outfile</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">getchunk</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">blc</span><span class="o">=</span><span class="p">[</span> <span class="nb">int</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">],</span> <span class="n">trc</span><span class="o">=</span><span class="p">[</span> <span class="nb">int</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">],</span> <span class="n">inc</span><span class="o">=</span><span class="p">[</span> <span class="nb">int</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">],</span> <span class="n">axes</span><span class="o">=</span><span class="p">[</span> <span class="nb">int</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">],</span> <span class="nb">list</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">dropdeg</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">getmask</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function returns the pixels (or optionally the pixel mask) from the</span>
<span class="sd">        attached image between blc and trc, inclusive. Images with float, complex</span>
<span class="sd">        float, double, and complex double precision pixel values are supported.</span>
<span class="sd">        An increment may be specified with inc. Note that if too many pixel values</span>
<span class="sd">        are retrieved, swapping may occur, result in a decrease in performance,</span>
<span class="sd">        since the pixel values are stored in memory.</span>
<span class="sd">        </span>
<span class="sd">        Any illegal blc values are set to zero.  Any illegal trc values are set to</span>
<span class="sd">        the end of the image.  If any trc values are less than corresponding blc</span>
<span class="sd">        values, all the pixel values for that axis are returned.  Any illegal inc</span>
<span class="sd">        values are set to unity.</span>
<span class="sd">        </span>
<span class="sd">        The axes parameter can be used to reduce the dimensionality of the output</span>
<span class="sd">        array. It specifies which pixel axes of the image over which to average</span>
<span class="sd">        the data.  For example, consider a 3-D image, with axes=[0,1] and all</span>
<span class="sd">        other parameters set to their defaults. The result would be a 1-D vector,</span>
<span class="sd">        a profile along the third axis, with the data averaged over the first two</span>
<span class="sd">        axes.</span>
<span class="sd">        </span>
<span class="sd">        A related function is getregion(), which retrieves the pixel values or</span>
<span class="sd">        pixel mask from a potentially more complex region.  Method getchunk() is</span>
<span class="sd">        retained because it is faster and therefore preferable for repeated</span>
<span class="sd">        operations in loops if the pixel mask is not required and the region is a</span>
<span class="sd">        simple box.</span>
<span class="sd">        </span>
<span class="sd">        If getmask=True, the return value is the pixel mask values, rather than</span>
<span class="sd">        the pixel values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">getchunk</span><span class="p">(</span><span class="n">blc</span><span class="p">,</span> <span class="n">trc</span><span class="p">,</span> <span class="n">inc</span><span class="p">,</span> <span class="n">axes</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="n">dropdeg</span><span class="p">,</span> <span class="n">getmask</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">getregion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">region</span><span class="o">=</span><span class="p">{</span> <span class="p">},</span> <span class="n">axes</span><span class="o">=</span><span class="p">[</span> <span class="nb">int</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">],</span> <span class="n">mask</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="nb">list</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">dropdeg</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">getmask</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">stretch</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function recovers the image pixel or pixel mask values in the given region</span>
<span class="sd">        of interest. Regardless of the shape of the specified, the shape of the pixels and</span>
<span class="sd">        pixelmask arrays must necessarily be the bounding box of the specified region.  If</span>
<span class="sd">        the region extends beyond the image, it is truncated.</span>
<span class="sd">        </span>
<span class="sd">        Recall that the recovered pixelmask will reflect both the pixelmask stored in the</span>
<span class="sd">        image, and the region (their masks are &#39;anded&#39; together).</span>
<span class="sd">        </span>
<span class="sd">        The argument axes can be used to reduce the dimensionality of the output array. It</span>
<span class="sd">        specifies which pixel axes of the image to average the data over.  For example,</span>
<span class="sd">        consider a 3-D image. With axes=[0,1] and all other arguments left at their</span>
<span class="sd">        defaults, the result would be a 1-D vector, a profile along the third axis, with</span>
<span class="sd">        the data averaged over the first two axes.</span>
<span class="sd">        </span>
<span class="sd">        This method differs in a couple of ways from the getchunk() method.  For example,</span>
<span class="sd">        the specified region can be much more complex (eg, a union of polygons) than the</span>
<span class="sd">        limited, simple regions that can be specified in getchunk(), which must be</span>
<span class="sd">        rectangular. On the other hand, getregion() is less effective than getchunk()</span>
<span class="sd">        for the same region specification. So if one is interested in say, iterating</span>
<span class="sd">        through an image, getting a regular hyper-cube of pixels and doing something</span>
<span class="sd">        with them, then getchunk() will be faster. This would be especially noticeable if</span>
<span class="sd">        you iterated line by line through a large image (and of course, in both cases,</span>
<span class="sd">        retrieving very large regions will become very resource intensive, as these</span>
<span class="sd">        returned arrays are completely stored in memory).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">getregion</span><span class="p">(</span><span class="n">region</span><span class="p">,</span> <span class="n">axes</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="n">dropdeg</span><span class="p">,</span> <span class="n">getmask</span><span class="p">,</span> <span class="n">stretch</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">getprofile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">function</span><span class="o">=</span><span class="s1">&#39;mean&#39;</span><span class="p">,</span> <span class="n">region</span><span class="o">=</span><span class="p">{</span> <span class="p">},</span> <span class="n">mask</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">stretch</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">spectype</span><span class="o">=</span><span class="s1">&#39;default&#39;</span><span class="p">,</span> <span class="n">restfreq</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">frame</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">logfile</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This application returns information on a one-dimensional profile taken along a specified image axis.</span>
<span class="sd">        The region of interest is collapsed (a&#39;la ia.collapse() along all axes orthogonal to the one specified, and)</span>
<span class="sd">        the specified aggregate function is applied to these pixels to generate the returned values.</span>
<span class="sd">        </span>
<span class="sd">        The aggregate function must be one of the functions supported by ia.collapse; ie, &#39;flux&#39;, &#39;madm&#39;, &#39;max&#39;, &#39;mean&#39;,</span>
<span class="sd">        &#39;median&#39;, &#39;min&#39;, &#39;rms&#39;, &#39;stdev&#39;, &#39;sum&#39;, &#39;variance&#39;, and &#39;xmadm&#39;. See the help for ia.collapse() for details regarding</span>
<span class="sd">        these functions. Minimum match and case insenstivity is supported. In addition, single binary (addition,</span>
<span class="sd">        subtraction, multiplication, and division) operations of these functions are supported, eg function=&#39;max*min&#39;</span>
<span class="sd">        will return data that is the product of the maximum and the mininum for each plane along the specified</span>
<span class="sd">        axis.</span>
<span class="sd">        </span>
<span class="sd">        One may specify the unit of the returned coordinate values.  Unless axis is the spectral axis, unit must be</span>
<span class="sd">        conformant with the corresponding axis unit in the image coordinate system or it must be &#39;pixel&#39; which signifies,</span>
<span class="sd">        pixel, rather than world, coordinate values should be calculated. If axis is the spectral axis, unit may be a</span>
<span class="sd">        velocity unit (assuming the coordinate system has a rest frequency or restfreq is specified) or a length unit.</span>
<span class="sd">        In these cases, the returned coordinate values will be converted to velocity or wavelength, respectively.</span>
<span class="sd">        </span>
<span class="sd">        The parameter spectype may be used to specify the velocity or wavelength type for the returned coordinate values</span>
<span class="sd">        if profile is taken along spectral axis. Supported (minimum match, case insensitive) values) are &quot;relativistic</span>
<span class="sd">        velocity&quot;, &quot;beta&quot;, &quot;radio velocity&quot;, &quot;optical velocity&quot;, &quot;wavelength&quot;, &quot;air wavelength&quot;, &quot;default&quot;. The &quot;default&quot;</span>
<span class="sd">        value is equivalent to &quot;relativistic&quot; if unit is a velocity unit or &quot;wavelength&quot; if unit is a length unit.</span>
<span class="sd">        </span>
<span class="sd">        The restfreq parameter allows one to set the rest frequency for the coordinates to be returned if axis is the</span>
<span class="sd">        spectral axis and unit is a velocity unit. If blank, the rest frequency associated with the image coordinate</span>
<span class="sd">        system is used.</span>
<span class="sd">        </span>
<span class="sd">        The frame allows one to specify which kinematic reference frame that the returned coordinate values should be</span>
<span class="sd">        calculated in. It is only used if axis is the spectral axis and unit is unspecified or is specified and a</span>
<span class="sd">        frequency unit. If blank, the reference frame associated with the image coordinate system is used.</span>
<span class="sd">        </span>
<span class="sd">        The returned dictionary</span>
<span class="sd">        contains the keys:</span>
<span class="sd">        </span>
<span class="sd">        values:  one-dimensional array along the specified axis containing values resulting from applying the specified</span>
<span class="sd">        aggregate function to corresponding pixels at the same location along that axis.</span>
<span class="sd">        mask:    one-dimensional array of booleans of the resulting mask after applying the aggregate function, formed in the</span>
<span class="sd">        same way as that formed by ia.collapse.</span>
<span class="sd">        coords   One-dimensional array of corresponding coordinate values along the specified axis in the specified unit</span>
<span class="sd">        (or the unit associated with the axis in the image coordinate system if unspecified).</span>
<span class="sd">        xUnit    The unit used for calculating the values the coords array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">getprofile</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">region</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">unit</span><span class="p">,</span> <span class="n">stretch</span><span class="p">,</span> <span class="n">spectype</span><span class="p">,</span> <span class="n">restfreq</span><span class="p">,</span> <span class="n">frame</span><span class="p">,</span> <span class="n">logfile</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">getslice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">[</span> <span class="nb">int</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="nb">int</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">],</span> <span class="n">coord</span><span class="o">=</span><span class="p">[</span> <span class="nb">int</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">],</span> <span class="n">npts</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function returns a 1-D slice (the pixels and opionally the pixel mask) from</span>
<span class="sd">        the attached image. The slice is constrained to lie in a plane of two cardinal</span>
<span class="sd">        axes (e.g. XY or YZ). Interpolation is permitted between pixels, and a set of</span>
<span class="sd">        interpolation schemes is available.</span>
<span class="sd">        </span>
<span class="sd">        The slice is specified as a polyline giving the x and y coordinates and the axes</span>
<span class="sd">        of the plane holding that slice.  The absolute pixel coordinates of the other</span>
<span class="sd">        axes may be specified using the coord parameter. If not specified, these values</span>
<span class="sd">        default to pixel 0 on the relevant axes.</span>
<span class="sd">        </span>
<span class="sd">        The npts parameter allows the number of values to be returned.</span>
<span class="sd">        </span>
<span class="sd">        The method parameter allows specification of the interpolation method to be</span>
<span class="sd">        used. Allowed values are &#39;nearest&#39;, &#39;linear&#39;, and &#39;cubic&#39;. In the case of an</span>
<span class="sd">        image with complex valued pixels, the interpolation is done independently on the</span>
<span class="sd">        real and imaginary values. For example, the linearly interpolated value midway</span>
<span class="sd">        between pixels with values of 1 + 5j and 2 + 7j would be 1.5 + 6j.</span>
<span class="sd">        </span>
<span class="sd">        The return value is a dictionary with keys &#39;pixels&#39; (interpolated pixel values),</span>
<span class="sd">        &#39;mask&#39; (interpolated mask), &#39;xpos&#39; (x-location in absolute pixel coordinates),</span>
<span class="sd">        &#39;ypos&#39; (y-location in absolute pixel coordinates), &#39;distance&#39; (distance along</span>
<span class="sd">        slice in pixels), and &#39;axes&#39; (the x and y axes of slice).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">getslice</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">axes</span><span class="p">,</span> <span class="n">coord</span><span class="p">,</span> <span class="n">npts</span><span class="p">,</span> <span class="n">method</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">hanning</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outfile</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">region</span><span class="o">=</span><span class="p">{</span> <span class="p">},</span> <span class="n">mask</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">),</span> <span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">stretch</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">dmethod</span><span class="o">=</span><span class="s1">&#39;copy&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This application performs Hanning convolution of one axis of an image defined by</span>
<span class="sd">        </span>
<span class="sd">        z[i] = 0.25*y[i-1] + 0.5*y[i] + 0.25*y[i+1]       (equation 1)</span>
<span class="sd">        </span>
<span class="sd">        where z[i] is the value at pixel i in the hanning smoothed image, and</span>
<span class="sd">        y[i-1], y[i], and y[i+1] are the values of the input image at pixels i-1,</span>
<span class="sd">        i, and i+1 respectively. It supports both float and complex valued images.</span>
<span class="sd">        The length of the axis along which the convolution is to occur must be at least</span>
<span class="sd">        three pixels in the selected region. Masked pixel values are set to zero prior to</span>
<span class="sd">        convolution. All nondefault pixel masks are ignored during the calculation.</span>
<span class="sd">        </span>
<span class="sd">        The convolution is done in the image domain (i.e., not with an FFT).</span>
<span class="sd">        </span>
<span class="sd">        If drop=False, the length of the output axis will be the same as that of the input</span>
<span class="sd">        axis. The output pixel values along the convolution axis will be related to those</span>
<span class="sd">        of the input values according to equation 1, except the first and last pixels. In that</span>
<span class="sd">        case,</span>
<span class="sd">        </span>
<span class="sd">        z[0] = 0.5*(y[0] + y[1])</span>
<span class="sd">        </span>
<span class="sd">        and,</span>
<span class="sd">        </span>
<span class="sd">        z[N-1] = 0.5*(y[N-2] + y[N-1])</span>
<span class="sd">        </span>
<span class="sd">        where N is the number of pixels along the convolution aixs.</span>
<span class="sd">        The pixel mask, ORed with the OTF mask if specified, is copied from the selected</span>
<span class="sd">        region of the input image to the output image. Thus for example, if the selected</span>
<span class="sd">        region in the input image has six planes along the convolution axis, and if the pixel</span>
<span class="sd">        values, which are all unmasked, on a slice along this axis are [1, 2, 5, 10, 17, 26],</span>
<span class="sd">        the corresponding output pixel values will be [1.5, 2.5, 5.5, 10.5, 17.5, 21.5].</span>
<span class="sd">        </span>
<span class="sd">        If drop=True and dmethod=&quot;copy&quot;, the output image is the image calculated if</span>
<span class="sd">        drop=True, except that only the odd-numbered planes are kept. Furthermore, if the</span>
<span class="sd">        number of planes along the convolution axis in the selected region of the input image</span>
<span class="sd">        is even, the last odd number plane is also discarded. Thus, if the selected region</span>
<span class="sd">        has N pixels along the convolution axis in the input image, along the convolution</span>
<span class="sd">        axis the output image will have (N-1)/2 planes if N is odd, or (N-2)/2 planes if N</span>
<span class="sd">        is even. In this case, the pixel and mask values are copied directly, without further</span>
<span class="sd">        processing. Thus for example, if the selected region in the input image has six planes</span>
<span class="sd">        along the convolution axis, and if the pixel values, which are all unmasked, on a slice</span>
<span class="sd">        along this axis are [1, 2, 5, 10, 17, 26], the corresponding output pixel values will be</span>
<span class="sd">        [2.5, 10.5].</span>
<span class="sd">        </span>
<span class="sd">        If drop=True and dmethod=&quot;mean&quot;, first the image described in the drop=False case</span>
<span class="sd">        is calculated. The first plane and last plane(s) of that image are then discarded as</span>
<span class="sd">        described in the drop=True, dmethod=&quot;copy&quot; case. Then, the ith plane of the output</span>
<span class="sd">        image is calculated by averaging the (2*i)th and (2*i + 1)th planes of the intermediate</span>
<span class="sd">        image.Thus for example, if the selected region in the input image has six planes</span>
<span class="sd">        along the convolution axis, and if the pixel values, which are all unmasked, on a slice</span>
<span class="sd">        along this axis are [1, 2, 5, 10, 17, 26], the corresponding output pixel values will be</span>
<span class="sd">        [4.0, 14.0]. Masked values are taken into consideration when forming this average, so if</span>
<span class="sd">        one of the values is masked, it is not used in the average. If at least one of the values</span>
<span class="sd">        in the input pair is not masked, the corresponding output pixel will not be masked.</span>
<span class="sd">        </span>
<span class="sd">        The hanning smoothed image is written to disk with name {stfaf outfile}, if</span>
<span class="sd">        specified. If not, no image is written but the image is still accessible via</span>
<span class="sd">        the returned image analysis tool (see below).</span>
<span class="sd">        </span>
<span class="sd">        This method always returns an image analysis tool which is attached to the</span>
<span class="sd">        hanning smoothed image. This tool should always be captured and closed after</span>
<span class="sd">        any desired manipulations have been done. Closing the tool frees up system</span>
<span class="sd">        resources (eg memory), eg,</span>
<span class="sd">        </span>
<span class="sd">        hanning_image = ia.hanning(...)</span>
<span class="sd">        begin{verbatim}</span>
<span class="sd">        # do things (or not) with hanning_image</span>
<span class="sd">        ...</span>
<span class="sd">        # close the returned tool promptly upon finishing with it.</span>
<span class="sd">        end{verbatim}</span>
<span class="sd">        hanning_image.done()</span>
<span class="sd">        </span>
<span class="sd">        See also the other convolution functions</span>
<span class="sd">        convolve2d,</span>
<span class="sd">        sepconvolve and</span>
<span class="sd">        convolve.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_wrap_image</span><span class="p">(</span><span class="n">swig_object</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">hanning</span><span class="p">(</span><span class="n">outfile</span><span class="p">,</span> <span class="n">region</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">drop</span><span class="p">,</span> <span class="n">overwrite</span><span class="p">,</span> <span class="n">stretch</span><span class="p">,</span> <span class="n">dmethod</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">haslock</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function can be used to find out whether the image has a read or a</span>
<span class="sd">        write lock set.  It is not of general user interest.   It returns</span>
<span class="sd">        a vector of Booleans of length 2.  Position 1 says whether</span>
<span class="sd">        a read lock is set, position 2 says whether a write lock is set.</span>
<span class="sd">        </span>
<span class="sd">        In general locking is handled automatically, with a built in lock</span>
<span class="sd">        release cycle.  However, this function can be useful in scripts when a</span>
<span class="sd">        file is being shared between more than one process.  See also functions</span>
<span class="sd">        unlock and</span>
<span class="sd">        lock.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">haslock</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">histograms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">[</span> <span class="nb">int</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">],</span> <span class="n">region</span><span class="o">=</span><span class="p">{</span> <span class="p">},</span> <span class="n">mask</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">nbins</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">25</span><span class="p">),</span> <span class="n">includepix</span><span class="o">=</span><span class="p">[</span> <span class="nb">float</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">],</span> <span class="n">cumu</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">stretch</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This method computes histograms of the pixel values in the image.</span>
<span class="sd">        The values are returned in a dictionary.</span>
<span class="sd">        </span>
<span class="sd">        The chunk of the image over which you compute the histograms is</span>
<span class="sd">        specified by a vector of axis numbers (argument {stfaf axes}).  For</span>
<span class="sd">        example, consider a 3-dimensional image for which you specify {stfaf</span>
<span class="sd">        axes=[0,2]}.  The histograms would be computed for each XZ (axes 0 and</span>
<span class="sd">        2) plane in the image.  You could then examine those histograms as a</span>
<span class="sd">        function of the Y (axis 1) axis.  Or perhaps you set {stfaf axes=[2]},</span>
<span class="sd">        whereupon you could examine the histogram for each Z (axis 2) profile as</span>
<span class="sd">        a function of X and Y location in the image.</span>
<span class="sd">        </span>
<span class="sd">        You have control over the number of bins for each histogram ({stfaf</span>
<span class="sd">        nbins}).  The bin width is worked out automatically for each histogram</span>
<span class="sd">        and may vary from histogram to histogram (the range of pixel values is</span>
<span class="sd">        worked out for each chunk being histogrammed).</span>
<span class="sd">        </span>
<span class="sd">        You have control over which pixels are included in the histograms via</span>
<span class="sd">        the {stfaf includepix} argument.  This vector specifies a range of</span>
<span class="sd">        pixel values to be included in the histograms.  If you only give one</span>
<span class="sd">        value for this, say {stfaf includepix=[b]}, then this is interpreted as</span>
<span class="sd">        {stfaf includepix=[-abs(b),abs(b)]}.  If you specify an inclusion</span>
<span class="sd">        range, then the range of pixel intensities over which the histograms are</span>
<span class="sd">        binned is given by this range too.  This is a way to make the bin width</span>
<span class="sd">        the same for each histogram.</span>
<span class="sd">        </span>
<span class="sd">        You can control if the histogram is cumulative or non-cumulative via the</span>
<span class="sd">        cumu parameter.</span>
<span class="sd">        </span>
<span class="sd">        You have countrol over how the bin counts are returned. If log = false,</span>
<span class="sd">        the actual counts are returned. If true, the values returned are the log10</span>
<span class="sd">        values of the actual counts.</span>
<span class="sd">        </span>
<span class="sd">        The results are returned as a dictionary. The counts (field &quot;counts&quot;) and</span>
<span class="sd">        the abscissa values (field &quot;values&quot;) for all bins in each histogram are returned.</span>
<span class="sd">        The shape of the first dimension of those arrays contained in those fields is {stfaf nbins}.</span>
<span class="sd">        The number and shape of the remaining dimensions are those of the display axes(the</span>
<span class="sd">        axes in the image for which you did not compute the histograms).  For example, if one</span>
<span class="sd">        has a three dimensional image and sets {stfaf axes=[2]}, the display axes are 0 and 1,</span>
<span class="sd">        so the shape of each counts and values array is then [nbins,nx,ny], where nx and ny</span>
<span class="sd">        are the length of the zeroth and first axes, respectively.</span>
<span class="sd">        </span>
<span class="sd">        In addition, the mean (field &quot;mean&quot;) and standard deviation (field &quot;sigma&quot;) computed</span>
<span class="sd">        using the data in each histogram is returned. The shape of these arrays is equal to</span>
<span class="sd">        the shape of the display axes. So,</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">histograms</span><span class="p">(</span><span class="n">axes</span><span class="p">,</span> <span class="n">region</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">nbins</span><span class="p">,</span> <span class="n">includepix</span><span class="p">,</span> <span class="n">cumu</span><span class="p">,</span> <span class="n">log</span><span class="p">,</span> <span class="n">stretch</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">history</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">list</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This method interogates the history of an image.</span>
<span class="sd">        </span>
<span class="sd">        The history is returned as an array of strings, where each element represents</span>
<span class="sd">        an individual history entry. If True, the list parameter will also cause the</span>
<span class="sd">        history to be emitted by the logger.</span>
<span class="sd">        </span>
<span class="sd">        Note that entries can be permanently added to the image history by using the</span>
<span class="sd">        ia.sethistory() method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">history</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">infile</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">region</span><span class="o">=</span><span class="p">{</span> <span class="p">},</span> <span class="n">locate</span><span class="o">=</span><span class="p">[</span> <span class="nb">float</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">],</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function inserts the specified image (or part of it) into the image</span>
<span class="sd">        referenced by this tool.</span>
<span class="sd">        The specified image may be given via argument {stfaf infile}</span>
<span class="sd">        as a disk file name (it may be in native casa, fits, or Miriad</span>
<span class="sd">        format; Look htmlref{here}{IMAGES:FOREIGNIMAGES}  for more</span>
<span class="sd">        information on foreign images).</span>
<span class="sd">        </span>
<span class="sd">        If the {stfaf locate} vector is not given, then the images are</span>
<span class="sd">        aligned (to an integer pixel shift) by their reference pixels.</span>
<span class="sd">        </span>
<span class="sd">        If {stfaf locate} vector is given, then those values that are given,</span>
<span class="sd">        give the absolute pixel in the output (this) image of the bottom left</span>
<span class="sd">        corner of the input (sub)image.  For those values that are not given,</span>
<span class="sd">        the input image is symmetrically placed in the output image.</span>
<span class="sd">        </span>
<span class="sd">        The image referenced by this tool is modified in place; no new image</span>
<span class="sd">        is created. The method returns True if successful.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">infile</span><span class="p">,</span> <span class="n">region</span><span class="p">,</span> <span class="n">locate</span><span class="p">,</span> <span class="n">verbose</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">isopen</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This method returns True if the image tool has an attached image.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">isopen</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">ispersistent</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function can be used to find out whether the image is persistent on</span>
<span class="sd">        disk or not.  There is a subtle difference from the image being</span>
<span class="sd">        virtual.  For example, a virtual image which references another</span>
<span class="sd">        which is on disk is termed persistent.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">ispersistent</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">lock</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">writelock</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">nattempts</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">0</span><span class="p">)):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function can be used to acquire a Read or a Read/Write lock</span>
<span class="sd">        on the imagefile.   It is not of general user interest.</span>
<span class="sd">        </span>
<span class="sd">        In general locking is handled automatically, with a built in lock</span>
<span class="sd">        release cycle.  However, this function can be useful in scripts when a</span>
<span class="sd">        file is being shared between more than one process.  See also functions</span>
<span class="sd">        unlock and haslock.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">lock</span><span class="p">(</span><span class="n">writelock</span><span class="p">,</span> <span class="n">nattempts</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">makecomplex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outfile</span><span class="p">,</span> <span class="n">imag</span><span class="p">,</span> <span class="n">region</span><span class="o">=</span><span class="p">{</span> <span class="p">},</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function combines the current image with another image to make</span>
<span class="sd">        a complex image.  The current image (i.e. that associated with this</span>
<span class="sd">        Image must have real valued pixels).  The image used for generating the</span>
<span class="sd">        imaginary part of the pixel values is specified using the imag parameter, and</span>
<span class="sd">        it must persistent. The image attached to this tool and the image specified</span>
<span class="sd">        using the imag parameter must have the same precision, or else an exception</span>
<span class="sd">        will be thrown. If both are float precision, the resulting image will have</span>
<span class="sd">        float precision pixel values. If both are double precision, the resulting image</span>
<span class="sd">        will have double precision pixel values. The coordinate systems of the two</span>
<span class="sd">        input images must be conformant. The metadata written to the resulting image is</span>
<span class="sd">        copied from the image attached to this tool.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">makecomplex</span><span class="p">(</span><span class="n">outfile</span><span class="p">,</span> <span class="n">imag</span><span class="p">,</span> <span class="n">region</span><span class="p">,</span> <span class="n">overwrite</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">maskhandler</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op</span><span class="o">=</span><span class="s1">&#39;default&#39;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="p">[</span>  <span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This method is used to manage or handle pixel masks . A CASA image may contain</span>
<span class="sd">        zero, one, or more pixel masks.  Any of these masks can be designated the</span>
<span class="sd">        default pixel mask assoicated with the given image.  The default mask is acted</span>
<span class="sd">        upon and/or used by CASA applications. For example, if ia.statistics() will</span>
<span class="sd">        exclude pixels which are masked as bad (False) from the calculations.</span>
<span class="sd">        </span>
<span class="sd">        This method does not modify the individual boolean values of any masks.</span>
<span class="sd">        </span>
<span class="sd">        The op parameter is used to specify the behaviour.  In all cases, the specified</span>
<span class="sd">        operation can be specified by a three character string. Supported values of the</span>
<span class="sd">        op parameter are:</span>
<span class="sd">        </span>
<span class="sd">        &#39;default&#39;: Retrieve the name of the default pixel mask associated with the</span>
<span class="sd">        image. A one element array containing the empty string is returned if the image</span>
<span class="sd">        has no default mask.</span>
<span class="sd">        </span>
<span class="sd">        &#39;get&#39;: Retrieve the name(s) of all the existing pixel masks. Note that the</span>
<span class="sd">        ia.summary() method may also be used to view the pixel masks associated with an</span>
<span class="sd">        image.</span>
<span class="sd">        </span>
<span class="sd">        &#39;set&#39;: Set the default pixel mask to the value specified by the name parameter.</span>
<span class="sd">        If the value of the name parameter is the empty string, then the default mask is</span>
<span class="sd">        unset (ie, all the pixels will be treated as being unmasked).</span>
<span class="sd">        </span>
<span class="sd">        &#39;delete&#39;: Delete the pixel mask(s) specified by the name parameter. To delete</span>
<span class="sd">        more than one mask, the name parameter can be an array of strings. Any supplied</span>
<span class="sd">        pixel mask name that does not exist is silently ignored.</span>
<span class="sd">        </span>
<span class="sd">        &#39;rename&#39;: Rename the mask specified as the first element of the name array</span>
<span class="sd">        parameter (name[0]) to the value specified in the second element of the name</span>
<span class="sd">        array parameter (name[1]]. In this case, the name array parameter must have</span>
<span class="sd">        exactly two elements.</span>
<span class="sd">        </span>
<span class="sd">        &#39;copy&#39;: Copy the mask specified in the first element of the name array</span>
<span class="sd">        parameter (name[0]) to the a mask name specified in the second element of the</span>
<span class="sd">        name array parameter (name[1]]. In this case, the name array parameter must have</span>
<span class="sd">        exactly two elements. A mask from another image can be copied by using the</span>
<span class="sd">        imagename:maskname syntax for the first element in the name array, eg,</span>
<span class="sd">        &#39;myimage:mask2&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">maskhandler</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">miscinfo</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A casa imagefile can accumulate miscellaneous information</span>
<span class="sd">        during its lifetime.  This information is stored in a record called the {stff</span>
<span class="sd">        miscinfo} record.  For example, the fits filler puts header keywords</span>
<span class="sd">        it doesn&#39;t otherwise use into the {stff miscinfo} record.  This {stff</span>
<span class="sd">        miscinfo} record is not guaranteed to have any entries, so it&#39;s up to</span>
<span class="sd">        you to check for any fields that you require.</span>
<span class="sd">        </span>
<span class="sd">        You can also put things into this record (see</span>
<span class="sd">        setmiscinfo) yourself, to keep</span>
<span class="sd">        information that the system might not otherwise store for you.</span>
<span class="sd">        </span>
<span class="sd">        When the image is written out to fits, the items in the</span>
<span class="sd">        {stff miscinfo} record are written to the fits file</span>
<span class="sd">        as keywords with the corresponding record field name.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">miscinfo</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">modify</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">region</span><span class="o">=</span><span class="p">{</span> <span class="p">},</span> <span class="n">mask</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">subtract</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="nb">list</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">stretch</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function applies a model of the sky to the image. You can add or</span>
<span class="sd">        subtract the model which is contained in a</span>
<span class="sd">        Componentlist tool.</span>
<span class="sd">        </span>
<span class="sd">        The pixel values are only changed where the total mask</span>
<span class="sd">        (combination of the default pixel mask [if any] and the OTF mask)</span>
<span class="sd">        is good (True). If the computation fails for a particular</span>
<span class="sd">        pixel (e.g. coordinate undefined) that pixel will be</span>
<span class="sd">        masked bad.</span>
<span class="sd">        </span>
<span class="sd">        DISK MODELS</span>
<span class="sd">        </span>
<span class="sd">        Pixels with centers inside the disk will have the same values, even if a pixel straddles the</span>
<span class="sd">        edge of the disk. Pixels with straddle the edge of the disk which have centers outside the</span>
<span class="sd">        disk are given values of zero. Thus, one should not expect the flux density of the disk to</span>
<span class="sd">        be exactly the provided value to the component list; for a given size disk, the computed flux</span>
<span class="sd">        density will be closer to the expected value for images with smaller pixels.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">modify</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">region</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">subtract</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="n">stretch</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">maxfit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">region</span><span class="o">=</span><span class="p">{</span> <span class="p">},</span> <span class="n">point</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span> <span class="n">negfind</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="nb">list</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function finds the pixel with the maximum value in the region, and</span>
<span class="sd">        then uses function findsources</span>
<span class="sd">        to generate a Componentlist with one component.   The component</span>
<span class="sd">        will be of type Point ({stfaf point=T}) or Gaussian ({stfaf point=F}).</span>
<span class="sd">        </span>
<span class="sd">        If {stfaf negfind=F} the maximum pixel value is found in the region and fit.</span>
<span class="sd">        If {stfaf negfind=T} the absolute maximum pixel value is found in the region</span>
<span class="sd">        and fit.</span>
<span class="sd">        </span>
<span class="sd">        See function findsources for</span>
<span class="sd">        a description of arguments {stfaf point} and {stfaf width}.</span>
<span class="sd">        </span>
<span class="sd">        See also the function fitcomponents.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">maxfit</span><span class="p">(</span><span class="n">region</span><span class="p">,</span> <span class="n">point</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">negfind</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">moments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">moments</span><span class="o">=</span><span class="p">[</span> <span class="nb">int</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">),</span> <span class="n">region</span><span class="o">=</span><span class="p">{</span> <span class="p">},</span> <span class="n">mask</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="p">[</span>  <span class="p">],</span> <span class="n">smoothaxes</span><span class="o">=</span><span class="p">[</span> <span class="nb">int</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">],</span> <span class="n">smoothtypes</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">smoothwidths</span><span class="o">=</span><span class="p">[</span> <span class="nb">float</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span> <span class="p">],</span> <span class="n">includepix</span><span class="o">=</span><span class="p">[</span> <span class="nb">float</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">],</span> <span class="n">excludepix</span><span class="o">=</span><span class="p">[</span> <span class="nb">float</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">],</span> <span class="n">peaksnr</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="mf">3.0</span><span class="p">),</span> <span class="n">stddev</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="mf">0.0</span><span class="p">),</span> <span class="n">doppler</span><span class="o">=</span><span class="s1">&#39;RADIO&#39;</span><span class="p">,</span> <span class="n">outfile</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">smoothout</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">stretch</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;noindent{bf Summary}</span>
<span class="sd">        </span>
<span class="sd">        The primary goal of this function is to enable you to analyze a</span>
<span class="sd">        multi-dimensional image by generating moments of a specified axis.</span>
<span class="sd">        This is a time-honoured spectral-line analysis technique used for</span>
<span class="sd">        extracting information about spectral lines.</span>
<span class="sd">        </span>
<span class="sd">        You can generate one or more output moment images.  The return value</span>
<span class="sd">        of this function is an on-the-fly Image tool holding the {bf first}</span>
<span class="sd">        of the output moment images.</span>
<span class="sd">        </span>
<span class="sd">        The word &#39;moment&#39; is used loosely here.  It refers to collapsing an axis</span>
<span class="sd">        (the moment axis) to one pixel and setting the value of that pixel (for</span>
<span class="sd">        all of the other non-collapsed axes) to something computed from the data</span>
<span class="sd">        values along the moment axis.  For example, take an RA-DEC-Velocity</span>
<span class="sd">        cube, collapse the velocity axis by computing the mean intensity at each</span>
<span class="sd">        RA-DEC pixel.  This function offers many different moments and a variety</span>
<span class="sd">        of automatic methods to compute them.</span>
<span class="sd">        </span>
<span class="sd">        We try to make a distinction between a &#39;moment&#39; and a &#39;method&#39;.  This</span>
<span class="sd">        boundary is a little blurred, but it claims to refer to the distinction</span>
<span class="sd">        between what you are computing, and how the pixels that were included in</span>
<span class="sd">        that computation were selected.  For example, a &#39;moment&#39; would be the</span>
<span class="sd">        average value of some pixel values in a spectrum.  A &#39;method&#39; for</span>
<span class="sd">        selecting those pixels would be a simple pixel value range specifying</span>
<span class="sd">        which pixels should be included.</span>
<span class="sd">        </span>
<span class="sd">        There are many available moments, and you specify each one with an</span>
<span class="sd">        integer code as it would get rather cumbersome to refer to them via</span>
<span class="sd">        strings.  In the list below, the value of the $i$th pixel of the</span>
<span class="sd">        spectrum is $I_i$, the coordinate of this pixel is $v_i$ (of course it</span>
<span class="sd">        may not be velocity), and there are $n$ pixels in the spectrum.  The</span>
<span class="sd">        available moments are:</span>
<span class="sd">        </span>
<span class="sd">        begin{itemize}</span>
<span class="sd">        item{$-1$} -- the mean value of the spectrum</span>
<span class="sd">        begin{displaymath}</span>
<span class="sd">        { {1over n}  {sum {I_i}}}</span>
<span class="sd">        end{displaymath}</span>
<span class="sd">        medskip</span>
<span class="sd">        </span>
<span class="sd">        item{0} -- the integrated value of the spectrum</span>
<span class="sd">        begin{displaymath}</span>
<span class="sd">        M_0 = Delta v sum I_i</span>
<span class="sd">        end{displaymath}</span>
<span class="sd">        </span>
<span class="sd">        where $Delta v$ is the width (in world coordinate units) of a pixel</span>
<span class="sd">        along the moment axis</span>
<span class="sd">        medskip</span>
<span class="sd">        </span>
<span class="sd">        item{1} -- the intensity weighted coordinate (this is</span>
<span class="sd">        traditionally used to get &#39;velocity fields&#39;)</span>
<span class="sd">        </span>
<span class="sd">        begin{displaymath}</span>
<span class="sd">        M_1 = { {sum {I_i v_i}} over {M_0}}</span>
<span class="sd">        end{displaymath}</span>
<span class="sd">        medskip</span>
<span class="sd">        </span>
<span class="sd">        item{2} -- the intensity weighted dispersion of the coordinate</span>
<span class="sd">        (this is traditionally used to get &#39;velocity dispersion fields&#39;)</span>
<span class="sd">        </span>
<span class="sd">        begin{displaymath}</span>
<span class="sd">        sqrt{ { {sum {I_i left(v_i - M_1right)^2}} over {M_0}}}</span>
<span class="sd">        end{displaymath}</span>
<span class="sd">        medskip</span>
<span class="sd">        </span>
<span class="sd">        item{3} -- the median of $I$</span>
<span class="sd">        medskip</span>
<span class="sd">        </span>
<span class="sd">        item{4} -- the median coordinate.  Here we treat the spectrum as a</span>
<span class="sd">        probability distribution, generate the cumulative distribution, and then</span>
<span class="sd">        find the coordinate corresponding to the 50% value.  This moment is not</span>
<span class="sd">        very robust, but it is useful for quickly generating a velocity field in</span>
<span class="sd">        a way that is not sensitive to noise.  However, it will only give</span>
<span class="sd">        sensible results under certain conditions.  The generation of the</span>
<span class="sd">        cumulative distribution and the finding of the 50% level really only</span>
<span class="sd">        makes sense if the cumulative distribution is monotonic.  This</span>
<span class="sd">        essentially means only selecting pixels which are positive or negative.</span>
<span class="sd">        For this reason, this moment type is only supported with the basic</span>
<span class="sd">        method (see below -- i.e.  no smoothing, no windowing, no fitting) with</span>
<span class="sd">        a pixel selection range that is either all positive, or all negative</span>
<span class="sd">        medskip</span>
<span class="sd">        </span>
<span class="sd">        item{5} -- the standard deviation about the mean of the spectrum</span>
<span class="sd">        begin{displaymath}</span>
<span class="sd">        sqrt{ {1over {left(n-1right)}}  sum{left(I_i - bar{I}right)^2 }}</span>
<span class="sd">        end{displaymath}</span>
<span class="sd">        medskip</span>
<span class="sd">        </span>
<span class="sd">        item{6} -- the root mean square of the spectrum</span>
<span class="sd">        begin{displaymath}</span>
<span class="sd">        sqrt{ {1 over n} sum{I_i^2}}</span>
<span class="sd">        end{displaymath}</span>
<span class="sd">        medskip</span>
<span class="sd">        </span>
<span class="sd">        item{7} -- the absolute mean deviation of the spectrum</span>
<span class="sd">        begin{displaymath}</span>
<span class="sd">        {1 over n} sum {|(I_i - bar{I})|}</span>
<span class="sd">        end{displaymath}</span>
<span class="sd">        medskip</span>
<span class="sd">        </span>
<span class="sd">        item{8} -- the maximum value of the spectrum</span>
<span class="sd">        medskip</span>
<span class="sd">        item{9} -- the coordinate of the maximum value of the spectrum</span>
<span class="sd">        medskip</span>
<span class="sd">        item{10} -- the minimum value of the spectrum</span>
<span class="sd">        medskip</span>
<span class="sd">        item{11} -- the coordinate of the minimum value of the spectrum</span>
<span class="sd">        medskip</span>
<span class="sd">        end{itemize}</span>
<span class="sd">        </span>
<span class="sd">        bigskip</span>
<span class="sd">        noindent {Smoothing}</span>
<span class="sd">        </span>
<span class="sd">        The purpose of the smoothing functionality is purely to provide</span>
<span class="sd">        a mask.  Thus, you can smooth the input image, apply a pixel</span>
<span class="sd">        include or exclude range, and generate a smoothed mask which is then</span>
<span class="sd">        applied before the moments are generated.  The smoothed data</span>
<span class="sd">        are not used to compute the actual moments; that is always done</span>
<span class="sd">        from the original data.</span>
<span class="sd">        </span>
<span class="sd">        bigskip</span>
<span class="sd">        noindent{bf Basic Method}</span>
<span class="sd">        </span>
<span class="sd">        The basic method is to just compute moments directly from the pixel</span>
<span class="sd">        values.  This can be modified by applying pixel value inclusion or</span>
<span class="sd">        exclusion ranges (arguments {stfaf includepix} and {stfaf excludepix}).</span>
<span class="sd">        </span>
<span class="sd">        You can then also convolve the image (arguments {stfaf smoothaxes}, {stfaf</span>
<span class="sd">        smoothtypes}, and {stfaf smoothwidths}) and find a mask based on the inclusion</span>
<span class="sd">        or exclusion ranges applied to the convolved image.  This mask is then</span>
<span class="sd">        applied to the unsmoothed data for moment computation.</span>
<span class="sd">        </span>
<span class="sd">        bigskip</span>
<span class="sd">        noindent{bf Window Method}</span>
<span class="sd">        </span>
<span class="sd">        The window method (invoked with argument {stfaf method=&#39;window&#39;}) does</span>
<span class="sd">        no pixel-value-based selection.  Instead a window is found (hopefully</span>
<span class="sd">        surrounding the spectral line feature) and only the pixels in that</span>
<span class="sd">        window are used for computation.  This window can be found from the</span>
<span class="sd">        convolved or unconvolved image (arguments {stfaf smoothaxes}, {stfaf</span>
<span class="sd">        smoothtypes}, and {stfaf smoothwidths}).</span>
<span class="sd">        </span>
<span class="sd">        The moments are always computed from the unconvolved data.  The window</span>
<span class="sd">        can be found (for each spectrum) automatically.  The</span>
<span class="sd">        automatic methods are via Bosma&#39;s converging mean algorithm ({stfaf</span>
<span class="sd">        method=&#39;window&#39;}) or by fitting Gaussians and taking $pm 3sigma$ as</span>
<span class="sd">        the window ({stfaf method=&#39;window,fit&#39;}).</span>
<span class="sd">        In Bosma&#39;s algorithm, an initial guess for a range of pixels surrounding</span>
<span class="sd">        a spectral feature is refined by widening until the mean of the pixels</span>
<span class="sd">        outside of the range converges (to the noise).</span>
<span class="sd">        </span>
<span class="sd">        bigskip</span>
<span class="sd">        noindent{bf Fit Method}</span>
<span class="sd">        </span>
<span class="sd">        The fit method ({stfaf method=&#39;fit&#39;}) fits Gaussians to spectral</span>
<span class="sd">        features automatically. The moments are then computed from the</span>
<span class="sd">        Gaussian fits (not the data themselves).</span>
<span class="sd">        </span>
<span class="sd">        bigskip</span>
<span class="sd">        noindent{bf Other Arguments}</span>
<span class="sd">        </span>
<span class="sd">        begin{itemize}</span>
<span class="sd">        </span>
<span class="sd">        item {stfaf outfile} - If you are creating just one moment image,</span>
<span class="sd">        and you specify {stfaf outfile}, then the image is created</span>
<span class="sd">        on disk with this name.  If you leave {stfaf outfile} empty</span>
<span class="sd">        then a temporary image is created.  In both cases, you can</span>
<span class="sd">        access this image with the returned Image tool.  If you are</span>
<span class="sd">        making more than one moment image, then theses images are always</span>
<span class="sd">        created on disk.  If you specify {stfaf outfile} then this is</span>
<span class="sd">        the root for the output file names.  If you don&#39;t specify it,</span>
<span class="sd">        then the input image name is used as the root.</span>
<span class="sd">        </span>
<span class="sd">        item {stfaf smoothing} - If you smooth the image to generate a</span>
<span class="sd">        mask, you  specify the kernel widths via the {stfaf smoothwidths}</span>
<span class="sd">        argument in the same way as in the</span>
<span class="sd">        sepconvolve function.  See it for</span>
<span class="sd">        details.</span>
<span class="sd">        </span>
<span class="sd">        item {stfaf stddev} - Some of the automatic methods also require an</span>
<span class="sd">        estimate of the noise level in the image.  This is used to assess</span>
<span class="sd">        whether a spectrum is purely noise or not, and whether there is any</span>
<span class="sd">        signal worth digging out.  If you don&#39;t give it via the {stfaf stddev}</span>
<span class="sd">        argument, it will be worked out automatically from a Gaussian fit to the</span>
<span class="sd">        bins above 25% from a histogram of the entire image.</span>
<span class="sd">        </span>
<span class="sd">        item {stfaf includepix, excludepix} - The vectors given by arguments</span>
<span class="sd">        {stfaf includepix} and {stfaf excludepix} specify a range of pixel</span>
<span class="sd">        values for which pixels are either included or excluded.  They are</span>
<span class="sd">        mutually exclusive; you can specify one or the other, but not both.  If</span>
<span class="sd">        you only give one value for either of these, say {stfaf includepix=b},</span>
<span class="sd">        then this is interpreted as {stfaf includepix=[-abs(b),abs(b)]}.</span>
<span class="sd">        </span>
<span class="sd">        The convolving point-spread function is normalized to have a volume of</span>
<span class="sd">        unity.  This means that point sources are depressed in value, but</span>
<span class="sd">        extended sources that are large with respect to the PSF remain</span>
<span class="sd">        essentially on the same intensity scale; these are the structures you</span>
<span class="sd">        are trying to find with the convolution so this is what you want.</span>
<span class="sd">        If you convolve the image, then arguments like {stfaf includepix} select</span>
<span class="sd">        based upon the convolved image pixel values.  If you are having trouble</span>
<span class="sd">        getting these right, you can output the convolved image ({stfaf smoothout})</span>
<span class="sd">        and assess the validity of your pixel ranges.  Note also that if you are</span>
<span class="sd">        Hanning convolving (usually used on a velocity axis), then the width for</span>
<span class="sd">        this kernel must be 3 pixels (triangular smoothing kernels of other</span>
<span class="sd">        widths have no valid theoretical basis).</span>
<span class="sd">        </span>
<span class="sd">        item {stfaf doppler} - If you compute the moments along a spectral</span>
<span class="sd">        axis, it is conventional to compute the world coordinate (needed for</span>
<span class="sd">        moments 0, 1 and 2) along that axis in &quot;km/s&quot;.   The argument {stfaf</span>
<span class="sd">        doppler} lets you specify what doppler convention the velocity will be</span>
<span class="sd">        calculated in. You can choose from {stfaf doppler=radio, optical,</span>
<span class="sd">        true}.   See function summary for the</span>
<span class="sd">        definitions of these codes.  For other moment-axis types, the world coordinate</span>
<span class="sd">        is computed in the native units.</span>
<span class="sd">        </span>
<span class="sd">        item {stfaf mask} - The total input mask is the combination  of the</span>
<span class="sd">        default pixelmask (if any) and the OTF mask.  Once this mask</span>
<span class="sd">        has been established, then the moment method may make additional</span>
<span class="sd">        pixel selections.</span>
<span class="sd">        </span>
<span class="sd">        item {stfaf drop} - If this is true (the default) then the moment axis</span>
<span class="sd">        is dropped from the output image.  Otherwise, the output images have  a</span>
<span class="sd">        moment axis of unit length and coordinate information that is the same</span>
<span class="sd">        as for the input image.  This coordinate information may be totally</span>
<span class="sd">        meaningless for the moment images.</span>
<span class="sd">        </span>
<span class="sd">        end{itemize}</span>
<span class="sd">        </span>
<span class="sd">        Finally, if you ask for a moment which requires the coordinate to be</span>
<span class="sd">        computed for each profile pixel (these are the intensity weighted mean</span>
<span class="sd">        coordinate [moment 1] and the intensity weighted dispersion of the</span>
<span class="sd">        coordinate [moment 2]), and the profile axis is not separable then there</span>
<span class="sd">        will be a performance loss.  Examples of non-separable axes are RA and</span>
<span class="sd">        Dec.  If the axis is separable (e.g.  a spectral axis) there is no</span>
<span class="sd">        penalty.  In the latter case, the vector of coordinates for one profile</span>
<span class="sd">        is the same as the vector for another profile, and it can be precomputed</span>
<span class="sd">        (once).</span>
<span class="sd">        </span>
<span class="sd">        Note that this function has no ``virtual&#39;&#39; output file capability. All</span>
<span class="sd">        output files are written to disk.   The output mask for these images is</span>
<span class="sd">        good (T) unless the moment method fails to generate a value (e.g.  the</span>
<span class="sd">        total input pixel mask was all bad for the profile) in which case it will be bad (F).</span>
<span class="sd">        </span>
<span class="sd">        If an image has multiple (per-channel beams) and the moment axis is equal to the</span>
<span class="sd">        spectral axis, each channel will be convolved with a beam that is equal to the beam</span>
<span class="sd">        having the largest area in the beamset prior to moment determination.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_wrap_image</span><span class="p">(</span><span class="n">swig_object</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">moments</span><span class="p">(</span><span class="n">moments</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">region</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">smoothaxes</span><span class="p">,</span> <span class="n">smoothtypes</span><span class="p">,</span> <span class="n">smoothwidths</span><span class="p">,</span> <span class="n">includepix</span><span class="p">,</span> <span class="n">excludepix</span><span class="p">,</span> <span class="n">peaksnr</span><span class="p">,</span> <span class="n">stddev</span><span class="p">,</span> <span class="n">doppler</span><span class="p">,</span> <span class="n">outfile</span><span class="p">,</span> <span class="n">smoothout</span><span class="p">,</span> <span class="n">overwrite</span><span class="p">,</span> <span class="n">drop</span><span class="p">,</span> <span class="n">stretch</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">strippath</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function returns the name of the imagefile By default, this</span>
<span class="sd">        function returns the full absolute path of the imagefile.  You can</span>
<span class="sd">        strip this path off if you wish with the {stfaf strippath} argument and</span>
<span class="sd">        just recover the imagefile name itself.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">name</span><span class="p">(</span><span class="n">strippath</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">open</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">infile</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This method detaches from the current image (if an image is attached to the tool), and</span>
<span class="sd">        reattaches it (opens) to the new image.</span>
<span class="sd">        </span>
<span class="sd">        The input image file may be in native CASA, FITS, or Miriad format. In the case</span>
<span class="sd">        of CASA images, images with float, complex float, double, and complex double</span>
<span class="sd">        valued pixels are supported. Note that only FITS images with float valued pixels</span>
<span class="sd">        are supported.</span>
<span class="sd">        </span>
<span class="sd">        The cache parameter applies only to component list images and indicates if pixel</span>
<span class="sd">        values should be cached after they are computed for faster retrieval. It is not</span>
<span class="sd">        used for other image types.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">infile</span><span class="p">,</span> <span class="n">cache</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">pad</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outfile</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">npixels</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">value</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">padmask</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">region</span><span class="o">=</span><span class="p">{</span> <span class="p">},</span> <span class="n">box</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">chans</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">stokes</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">stretch</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">wantreturn</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This method pads the directional plane of an image with a specified number of pixels on each side. The</span>
<span class="sd">        numerical and mask values of the padding pixels may also be specified. If a region is selected, a subimage</span>
<span class="sd">        of that region is created and then padded with the specified pixel parameters. Thus, padding an image of</span>
<span class="sd">        shape (ra, dec, freq) = (512, 512, 10) specifying npixels = 3 results in an image of size (518, 518, 10), with</span>
<span class="sd">        the blc of the directional plane of the original pixel set corresponding to the directional pixel of (3, 3)</span>
<span class="sd">        in the output.</span>
<span class="sd">        If wantreturn is True, an image analysis tool attached to the output image is returned. If False, none is</span>
<span class="sd">        returned.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_wrap_image</span><span class="p">(</span><span class="n">swig_object</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">outfile</span><span class="p">,</span> <span class="n">npixels</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">padmask</span><span class="p">,</span> <span class="n">overwrite</span><span class="p">,</span> <span class="n">region</span><span class="p">,</span> <span class="n">box</span><span class="p">,</span> <span class="n">chans</span><span class="p">,</span> <span class="n">stokes</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">stretch</span><span class="p">,</span> <span class="n">wantreturn</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">crop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outfile</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">[</span>  <span class="p">],</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">region</span><span class="o">=</span><span class="p">{</span> <span class="p">},</span> <span class="n">box</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">chans</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">stokes</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">stretch</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">wantreturn</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This method crops masked slices from the perimeter of an image. The axes parameter specifies which axes to</span>
<span class="sd">        consider. Axes not specified will not be cropped. An empty array implies that all axes should be considered.</span>
<span class="sd">        If wantreturn is True, an image analysis tool attached to the output image is returned. If False, none is</span>
<span class="sd">        returned.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_wrap_image</span><span class="p">(</span><span class="n">swig_object</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">crop</span><span class="p">(</span><span class="n">outfile</span><span class="p">,</span> <span class="n">axes</span><span class="p">,</span> <span class="n">overwrite</span><span class="p">,</span> <span class="n">region</span><span class="p">,</span> <span class="n">box</span><span class="p">,</span> <span class="n">chans</span><span class="p">,</span> <span class="n">stokes</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">stretch</span><span class="p">,</span> <span class="n">wantreturn</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">pixelvalue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pixel</span><span class="o">=</span><span class="p">[</span> <span class="nb">int</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function gets the value of the image and the mask at the specified</span>
<span class="sd">        pixel coordinate.  The values are returned in a record with fields</span>
<span class="sd">        &#39;value&#39;, &#39;mask&#39; and &#39;pixel&#39;.  The value is returned as a quantity, the mask</span>
<span class="sd">        as a Bool (T is good).  The &#39;pixel&#39; field holds the actual</span>
<span class="sd">        pixel coordinate used.</span>
<span class="sd">        </span>
<span class="sd">        If the specified pixel coordinate is off the image, &quot;{}&quot; is returned.</span>
<span class="sd">        </span>
<span class="sd">        Excessive elements in {stfaf pixel} are silently discarded.</span>
<span class="sd">        Missing elements are given the (nearest integer) value of the reference pixel.</span>
<span class="sd">        This is reflected in the output record &#39;pixel&#39; field.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">pixelvalue</span><span class="p">(</span><span class="n">pixel</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">putchunk</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pixels</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">blc</span><span class="o">=</span><span class="p">[</span> <span class="nb">int</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">],</span> <span class="n">inc</span><span class="o">=</span><span class="p">[</span> <span class="nb">int</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">],</span> <span class="nb">list</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">locking</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">replicate</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This method puts an array into the image (which must be writable, eg it</span>
<span class="sd">        will fail on FITS images). If there is a default pixel mask, it is</span>
<span class="sd">        ignored. It is the complement of the getchunk() method. The blc, trc,</span>
<span class="sd">        and increment (inc) may be specified. If they are unspecified, they</span>
<span class="sd">        default to the beginning of the image and an increment of one.</span>
<span class="sd">        </span>
<span class="sd">        Any illegal blc values are set to zero.  Any illegal inc values are set</span>
<span class="sd">        to unity.</span>
<span class="sd">        </span>
<span class="sd">        An error will result if an attempt is made to put an array the extends</span>
<span class="sd">        beyond the image edge (i.e., it is not truncated or decimated).</span>
<span class="sd">        </span>
<span class="sd">        If there are fewer axes in the array than in the image, the array is</span>
<span class="sd">        assumed to have trailing axes of length unity.  Thus, if you have a 2D</span>
<span class="sd">        array and want to put it in as the YZ plane rather than the XY plane,</span>
<span class="sd">        you must ensure that the shape of the array is [1,nx,ny].</span>
<span class="sd">        </span>
<span class="sd">        However, the replicate parameter can be used to replicate the array</span>
<span class="sd">        throughout the image (from the blc to the trc).  For example, if a 2D</span>
<span class="sd">        array is provided for a 3D image, it can be replicated along the third</span>
<span class="sd">        axis by setting replicate=True. The replication is done from the</span>
<span class="sd">        specified blc to the end of the image. Method putregion() can be used</span>
<span class="sd">        to terminate the replication at a trc value.</span>
<span class="sd">        </span>
<span class="sd">        The locking parameter controls two aspects. If True, then after the</span>
<span class="sd">        method is called, the image is unlocked (so some other process can</span>
<span class="sd">        acquire a lock) and it is indicated that the image has</span>
<span class="sd">        changed. The reason for having this argument is that the unlocking and</span>
<span class="sd">        updating processes are quite expensive.  If putchunk() is called</span>
<span class="sd">        repeatedly in eg, a loop, it is advisable to set this parameter to True.</span>
<span class="sd">        </span>
<span class="sd">        A related function is putregion(), which supports putting the pixel and</span>
<span class="sd">        mask values into a more complex region. Method putchunk() is faster and</span>
<span class="sd">        therefore preferable for repeated operation in loops if the pixel mask</span>
<span class="sd">        is not required.</span>
<span class="sd">        </span>
<span class="sd">        See also the methods set() and calc() which can also be used to change</span>
<span class="sd">        pixel values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">putchunk</span><span class="p">(</span><span class="n">pixels</span><span class="p">,</span> <span class="n">blc</span><span class="p">,</span> <span class="n">inc</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="n">locking</span><span class="p">,</span> <span class="n">replicate</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">putregion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pixels</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">pixelmask</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">region</span><span class="o">=</span><span class="p">{</span> <span class="p">},</span> <span class="nb">list</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">usemask</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">locking</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">replicate</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function replaces data and/or pixel mask values in the image in the</span>
<span class="sd">        specified region. The pixels and/or pixelmask arrays must be the shape of</span>
<span class="sd">        the bounding box, and the whole bounding box is replaced in the image. The</span>
<span class="sd">        region is only used to specify the bounding box.  If the region extends</span>
<span class="sd">        beyond the image, it is truncated.  If the pixels or pixelmask array shapes</span>
<span class="sd">        do not match the bounding box, an error will result. Values in the pixels</span>
<span class="sd">        array must share the same domain as the pixel values in the image. If the</span>
<span class="sd">        pixels array contains real values and the image pixels contain complex</span>
<span class="sd">        values (or vice versa), an exception will be thrown.</span>
<span class="sd">        </span>
<span class="sd">        When you put a pixel mask, it either replaces the current default pixel mask,</span>
<span class="sd">        or is created.</span>
<span class="sd">        </span>
<span class="sd">        The usemask parameter is only relevant when you are putting pixel values and</span>
<span class="sd">        there is a pixel mask (meaning also the one you might have just put in place).</span>
<span class="sd">        If usemask=True, then only pixels for which the mask is good (True) are</span>
<span class="sd">        altered.  If usemask=False, then all the pixels in the region are altered.</span>
<span class="sd">        </span>
<span class="sd">        The replicate parameter can be used to replicate the array throughout the</span>
<span class="sd">        image (from the blc to the trc).  For example, if a two dimensional array is</span>
<span class="sd">        provided for a three dimensional image, it can be replicated along the third</span>
<span class="sd">        axis by setting replicate=True. The replication is done in the specified</span>
<span class="sd">        region.</span>
<span class="sd">        </span>
<span class="sd">        The locking parameter controls two things.  If True, then after the method</span>
<span class="sd">        is called, the image is unlocked (so some other process can acquire a lock)</span>
<span class="sd">        and it is indicated that the image has changed. The reason for this</span>
<span class="sd">        parameter is that the unlocking and updating processes are quite expensive.</span>
<span class="sd">        If putregion() is being called multiple times, in a for loop, for example,</span>
<span class="sd">        it is recommended to set locking=True (and to consider using putchunk()</span>
<span class="sd">        instead).</span>
<span class="sd">        </span>
<span class="sd">        See the related functions putchunk, set and calc.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">putregion</span><span class="p">(</span><span class="n">pixels</span><span class="p">,</span> <span class="n">pixelmask</span><span class="p">,</span> <span class="n">region</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="n">usemask</span><span class="p">,</span> <span class="n">locking</span><span class="p">,</span> <span class="n">replicate</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">rebin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outfile</span><span class="p">,</span> <span class="nb">bin</span><span class="p">,</span> <span class="n">region</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">dropdeg</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">stretch</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">crop</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This application rebins the current image by the specified integer binning</span>
<span class="sd">        factors for each axis. It supports both float valued and complex valued images.</span>
<span class="sd">        The corresponding output pixel value is the average of the</span>
<span class="sd">        input pixel values. The output pixel will be masked bad if there</span>
<span class="sd">        were no good input pixels.  A polarization axis cannot be rebinned.</span>
<span class="sd">        </span>
<span class="sd">        The binning factors array must contain at least one element and no more</span>
<span class="sd">        elements than the number of input image axes. If the number of elements</span>
<span class="sd">        specified is less than the number of image axes, then the remaining axes</span>
<span class="sd">        not specified are not rebinned. All specified values must be positive. A</span>
<span class="sd">        value of one indicates that no rebinning of the associated axis will occur.</span>
<span class="sd">        </span>
<span class="sd">        Binning starts from the origin pixel of the bounding box of the selected region or</span>
<span class="sd">        the origin pixel of the input image if no region is specified. The value of crop</span>
<span class="sd">        is used to determine how to handle cases where there are pixels</span>
<span class="sd">        at the end of the axis that do not form a complete bin. If crop=True,</span>
<span class="sd">        extra pixels at the end of the axis are discarded. If crop=False, the remaining</span>
<span class="sd">        pixels are averaged into the final bin along that axis. Should the length</span>
<span class="sd">        of the axis to be rebinned be an integral multiple of the associated binning</span>
<span class="sd">        factor, the value of crop is irrelevant.</span>
<span class="sd">        </span>
<span class="sd">        A value of dropdeg=True will result in the output image not containing</span>
<span class="sd">        axes that are degenerate in the specified region or in the input image if no</span>
<span class="sd">        region is specified. Note that, however, the binning</span>
<span class="sd">        factors array must still account for degenerate axes, and the binning</span>
<span class="sd">        factor associated with a degenerate axis must always be 1.</span>
<span class="sd">        </span>
<span class="sd">        If {stfaf outfile} is given, the image is written to the specified</span>
<span class="sd">        disk file.  If {stfaf outfile} is unset, the Image tool is</span>
<span class="sd">        associated with a temporary image.  This temporary image may be in</span>
<span class="sd">        memory or on disk, depending on its size.  When you destroy the</span>
<span class="sd">        on-the-fly Image tool returned by this function (with the done function) this</span>
<span class="sd">        temporary image is deleted.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_wrap_image</span><span class="p">(</span><span class="n">swig_object</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">rebin</span><span class="p">(</span><span class="n">outfile</span><span class="p">,</span> <span class="nb">bin</span><span class="p">,</span> <span class="n">region</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">dropdeg</span><span class="p">,</span> <span class="n">overwrite</span><span class="p">,</span> <span class="n">stretch</span><span class="p">,</span> <span class="n">crop</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">regrid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outfile</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">[</span> <span class="nb">int</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">],</span> <span class="n">csys</span><span class="o">=</span><span class="p">{</span> <span class="p">},</span> <span class="n">axes</span><span class="o">=</span><span class="p">[</span> <span class="nb">int</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">],</span> <span class="n">region</span><span class="o">=</span><span class="p">{</span> <span class="p">},</span> <span class="n">mask</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="n">decimate</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span> <span class="n">replicate</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">doref</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">dropdeg</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">asvelocity</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">stretch</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function regrids the current image onto a grid specified by the given</span>
<span class="sd">        coordinate system. The shape of the output image may also be specified.</span>
<span class="sd">        </span>
<span class="sd">        The coordinate system must be specified via a cs tool (using cs.torecord()). It</span>
<span class="sd">        is optional; if not specified, the coordinate system from the input image (ie,</span>
<span class="sd">        the one to which you are applying the regrid function) is used. The order of the</span>
<span class="sd">        coordinates and axes in the output image is always the same as the input image.</span>
<span class="sd">        It simply finds the relevant coordinate in the supplied coordinate system in</span>
<span class="sd">        order to determine the regridding parameters. The supplied coordinate system</span>
<span class="sd">        must have at least as many coordinates as are required to accomodate the axes</span>
<span class="sd">        that are to be regridded (eg, if the first two axes are to be regridded, and</span>
<span class="sd">        these belong to a direction coordinate, one direction coordinate in the supplied</span>
<span class="sd">        coordinate system is required). Coordinates pertaining to axes that are not</span>
<span class="sd">        being regridded are supplied from the input image, not the specified coordinate</span>
<span class="sd">        system.</span>
<span class="sd">        </span>
<span class="sd">        Reference changes are handled (eg, J2000 to B1950, LSR to TOPO). In general, the</span>
<span class="sd">        conversion machinery attempts to work out how sophisticated it needs to be (eg,</span>
<span class="sd">        is the regridding being done from LSR to LSR or from LSR to TOPO). However, it</span>
<span class="sd">        errs on the side of caution if the conversion machine requires more information</span>
<span class="sd">        than it actually needs. For full frame conversions, one needs to know things</span>
<span class="sd">        like the position on the earth&#39;s surface where the observation occurred,</span>
<span class="sd">        direction (celestial coordinates) of observation, and time of observation.</span>
<span class="sd">        </span>
<span class="sd">        If you get such errors and you are doing a frame conversion, then that means you</span>
<span class="sd">        must insert some extra information into the coordinate system of your image.</span>
<span class="sd">        Most likely it&#39;s the time (in which case you can use cs.setepoch()) and/or</span>
<span class="sd">        position (in which case you can use cs.settelescope()) that are missing. If you</span>
<span class="sd">        get these errors and you are certain that you are not specifying a frame change</span>
<span class="sd">        (eg, regrid LSR to LSR) then try setting doref=False. This will (silently)</span>
<span class="sd">        bypass all possible frame conversions. Note that if you are requesting a frame</span>
<span class="sd">        conversion and you set doref=False, no warnings will be emitted and the output</span>
<span class="sd">        image will likely be nonsensical.</span>
<span class="sd">        </span>
<span class="sd">        If you regrid a plane holding a direction coordinate and the units are Jy/pixel,</span>
<span class="sd">        then the output is scaled to conserve flux (roughly; just one scale factor at</span>
<span class="sd">        the reference pixel is computed).</span>
<span class="sd">        </span>
<span class="sd">        Regridding of complex-valued images is supported. The real and imaginary parts</span>
<span class="sd">        are regridded independently and the resulting regridded pixel values are</span>
<span class="sd">        combined to form the regridded, complex-valued image.</span>
<span class="sd">        </span>
<span class="sd">        A variety of interpolation schemes are provided (you need only specify the first</span>
<span class="sd">        three characters to the method parameter).  The cubic interpolation is</span>
<span class="sd">        substantially slower than linear, and often the improvement is modest. By</span>
<span class="sd">        default, linear interpolation is used.</span>
<span class="sd">        </span>
<span class="sd">        You specify the shape of the output image using the shape parameter and which</span>
<span class="sd">        output axes you want to regrid.  Note that a Stokes axis cannot be regridded</span>
<span class="sd">        (you will get a warning if you try).</span>
<span class="sd">        </span>
<span class="sd">        The axes parameter cannot be used to discard axes from the output image; it can</span>
<span class="sd">        only be used to specify which output axes are going to be regridded and which</span>
<span class="sd">        are not. Any axis that you are not regridding must have the same output shape as</span>
<span class="sd">        the input image shape for that axis.</span>
<span class="sd">        </span>
<span class="sd">        The axes parameter can also be used to specify the order in which the output</span>
<span class="sd">        axes are regridded. This may give you significant performance benefits. For</span>
<span class="sd">        example, imagine we are going to regrid a spectral-line cube of shape</span>
<span class="sd">        [512,512,1204] to shape [256,256,32]. If you specified axes=[0,1,2] then first,</span>
<span class="sd">        the direction axes would be regridded for each of the 1024 pixels (and stored in</span>
<span class="sd">        a temporary image). Then each spectral profile at each spatial location in the</span>
<span class="sd">        temporary image would be regridded to 32 pixels.  You could speed this process</span>
<span class="sd">        up significantly by setting axes=[2,0,1]. In this case, first each spectral</span>
<span class="sd">        profile would be regridded to 32 pixels, and then each plane of the 32 pixels</span>
<span class="sd">        would be regridded. Note that the order of axes does not affect the order of the</span>
<span class="sd">        shape parameter; ie, it should be given in the natural pixel axis order of the</span>
<span class="sd">        image ()[256,256,32] in both cases of this example).</span>
<span class="sd">        </span>
<span class="sd">        You can also specify a region to be applied to the input image. If you do this,</span>
<span class="sd">        you need to be careful with the output shape for non-regridded axes (must match</span>
<span class="sd">        that of the region - use function ia.boundingbox() to determine that).</span>
<span class="sd">        </span>
<span class="sd">        If the outfile parameter is specified, the image is written to the specified</span>
<span class="sd">        disk file.  If this parameter is unset, the on-the-fly image analysis tool</span>
<span class="sd">        returned by this method is associated with a temporary image.  This temporary</span>
<span class="sd">        image may be in memory or on disk, depending on its size. When you destroy the</span>
<span class="sd">        on-the-fly image analysis tool (with either the ia.close() or ia.done()</span>
<span class="sd">        methods), this temporary image is deleted.</span>
<span class="sd">        </span>
<span class="sd">        The replicate parameter can be used to simply replicate pixels rather than</span>
<span class="sd">        regridding them.  Normally replicate=False, for every output pixel, its world</span>
<span class="sd">        coordinate is computed and the corresponding input pixel found (then a little</span>
<span class="sd">        interpolation grid is generated).  If replicate=True, then for every output</span>
<span class="sd">        axis, a vector of regularly sampled input pixels is generated (based on the</span>
<span class="sd">        ratio of the output and input axis shapes).  So this just means the pixels get</span>
<span class="sd">        replicated (by whatever interpolation scheme you use) rather than regridded in</span>
<span class="sd">        world coordinate space.  This process is much faster, but its not a true world</span>
<span class="sd">        coordinate based regrid.</span>
<span class="sd">        </span>
<span class="sd">        As decribed above, when replicate=False, a coordinate is computed for each</span>
<span class="sd">        output pixel; this is an expensive operation.  The decimate parameter allows you</span>
<span class="sd">        to decimate the computation of that coordinate grid to a sparse grid, which is</span>
<span class="sd">        then filled in via fast interpolation.  The default is decimate=10. The number</span>
<span class="sd">        of pixels per axis in the sparse grid is the number of output pixels for that</span>
<span class="sd">        axis divided by the decimation factor. A factor of 10 does pretty well. You may</span>
<span class="sd">        find that for very non-linear coordinate systems (e.g. very close to the pole)</span>
<span class="sd">        that you have to reduce the decimation factor. You may also have to reduce the</span>
<span class="sd">        decimation factor if the number of pixels in the output image along an axis to</span>
<span class="sd">        be regridded is less than about 50, or the output image may be completely</span>
<span class="sd">        masked.</span>
<span class="sd">        </span>
<span class="sd">        If one of the axes to be regridded is a spectral axis and asvelocity=True, the</span>
<span class="sd">        axis will be regridded to match the velocity, not the frequency, description of</span>
<span class="sd">        the template spectral coordinate. Thus the output pixel values will correspond</span>
<span class="sd">        only to the velocity, not the frequency, of the output axis.</span>
<span class="sd">        </span>
<span class="sd">        Sometimes it is useful to drop axes of length one (degenerate axes). Setting</span>
<span class="sd">        the dropdeg parameter to True will do that. It will discard the axes from the</span>
<span class="sd">        input image.  Therefore the output shape and coordinate system that you supply</span>
<span class="sd">        must be consistent with the input image after the degenerate axes are dropped.</span>
<span class="sd">        </span>
<span class="sd">        The force parameter can be used to force all specified axes to be regridded,</span>
<span class="sd">        even if the algorithm determines that they don&#39;t need to be (because the input</span>
<span class="sd">        and output coordinate information is identical).</span>
<span class="sd">        </span>
<span class="sd">        The cs tool has a useful method, cs.setreferencelocation(), that can be used to</span>
<span class="sd">        keep a specific world coordinate in the center of an image when regridding (see</span>
<span class="sd">        example below).</span>
<span class="sd">        </span>
<span class="sd">        The output pixel mask will be True (good) unless the regridding failed to find a</span>
<span class="sd">        value for that output pixel in which case it will be False. For example, if the</span>
<span class="sd">        total input mask (default input pixel mask plus OTF mask) for all of the</span>
<span class="sd">        relevant input pixels were masked bad then the output pixel would be masked</span>
<span class="sd">        (False).</span>
<span class="sd">        </span>
<span class="sd">        MULTIPLE AXIS COORDINATES LIMITATION</span>
<span class="sd">        Some cooordinates contain multiple axes. For example, a direction coordinate</span>
<span class="sd">        contains both longitude-like and latitude-like axes. A linear coordinate can</span>
<span class="sd">        also contain multiple axes.  When you regrid *any* axis from a coordinate which</span>
<span class="sd">        contains multiple axes, you must fully specify the coordinate information for</span>
<span class="sd">        all axes in that coordinate in the coordinate system that you provide. For</span>
<span class="sd">        example, if you have a linear coordinate with two axes and you want to regrid</span>
<span class="sd">        axis one only. In the coordinate system you provide, the coordinate information</span>
<span class="sd">        for axis two (not being regridded) must correctly be a copy from the input</span>
<span class="sd">        coordinate system (it won&#39;t be filled in for you).</span>
<span class="sd">        </span>
<span class="sd">        If an image has per-plane beams and one attempts to regrid the spectral axis,</span>
<span class="sd">        an exception is thrown.</span>
<span class="sd">        </span>
<span class="sd">        IMPORTANT NOTE ABOUT FLUX CONSERVATION</span>
<span class="sd">        in general regridding is inaccurate for images that the angular resolution is</span>
<span class="sd">        poorly sampled. A check is done for such cases and a warning message is emitted</span>
<span class="sd">        if a beam present. However, no such check is done if there is no beam present.</span>
<span class="sd">        To add a restoring beam to an image, use ia.setrestoringbeam().</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_wrap_image</span><span class="p">(</span><span class="n">swig_object</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">regrid</span><span class="p">(</span><span class="n">outfile</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">csys</span><span class="p">,</span> <span class="n">axes</span><span class="p">,</span> <span class="n">region</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">decimate</span><span class="p">,</span> <span class="n">replicate</span><span class="p">,</span> <span class="n">doref</span><span class="p">,</span> <span class="n">dropdeg</span><span class="p">,</span> <span class="n">overwrite</span><span class="p">,</span> <span class="n">force</span><span class="p">,</span> <span class="n">asvelocity</span><span class="p">,</span> <span class="n">stretch</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">transpose</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outfile</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="p">[</span> <span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This method transposes the axes in the input image to the specified</span>
<span class="sd">        order. The associated pixel and mask values and coordinate system are transposed.</span>
<span class="sd">        </span>
<span class="sd">        If the outfile parameter is empty, only a temporary image is created; no output image</span>
<span class="sd">        is written to disk.</span>
<span class="sd">        </span>
<span class="sd">        The order parameter describes the mapping of the input axes to the output axes.</span>
<span class="sd">        It can be one of three types: a non-negative integer, a string, or a list of</span>
<span class="sd">        strings. If a string or non-negative integer, it should contain</span>
<span class="sd">        zero-based digits describing the new order of the input axes. It must</span>
<span class="sd">        contain the same number of (unique) digits as the number of input axes. For example,</span>
<span class="sd">        specifying reorder=&quot;1032&quot; or reorder=1032 for a four axes image maps input axes</span>
<span class="sd">        1, 0, 3, 2 to output axes 0, 1, 2, 3. In the case of order being a nonnegative integer</span>
<span class="sd">        and the zeroth axis in the input being mapped to zeroth axis in the output, the zeroth</span>
<span class="sd">        digit is implicitly understood to be 0 so that to transpose an image where one would</span>
<span class="sd">        use a string order=&quot;0321&quot;, one could equivalently specify an int order=321.</span>
<span class="sd">        IMPORTANT: When specifying a non-negative integer and mapping the zeroth axis of</span>
<span class="sd">        the input to the zeroth axis of the output, do *not* explicitly specify the leading</span>
<span class="sd">        0; eg, specify order=321 rather than order=0321. Python interprets an integer with</span>
<span class="sd">        a leading 0 as an octal number.</span>
<span class="sd">        </span>
<span class="sd">        Because of ambiguity for axes numbers greater than nine, using string or integer order</span>
<span class="sd">        specifications cannot handle images containing more than 10 axes.</span>
<span class="sd">        The order parameter can also be specified as a list of strings which uniquely minimally match,</span>
<span class="sd">        ignoring case, the image axis names (ia.coordsys().names()).</span>
<span class="sd">        So to reorder an image with right ascension, declination, and frequency axes, one could</span>
<span class="sd">        specify order=[&quot;d&quot;, &quot;f&quot;, &quot;r&quot;] or equivalently [&quot;decl&quot;, &quot;frequ&quot;, &quot;right a&quot;]. Note that</span>
<span class="sd">        specifying &quot;ra&quot; for the right ascension axis will result in an error because &quot;ra&quot; does</span>
<span class="sd">        not match the first two characters of right ascension.</span>
<span class="sd">        Axes can be simultaneously inverted in cases where order is a string or an array of</span>
<span class="sd">        strings by specifying negative signs in front of the axis/axes to be inverted. So,</span>
<span class="sd">        in a 4-D image, order=&quot;-10-3-2&quot; maps input axes 1, 0, 3, 2 to output axes 0, 1, 2, 3</span>
<span class="sd">        and reverses the direction and values of input axes 1, 3, and 2.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_wrap_image</span><span class="p">(</span><span class="n">swig_object</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">outfile</span><span class="p">,</span> <span class="n">order</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">rotate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outfile</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">[</span> <span class="nb">int</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">],</span> <span class="n">pa</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">region</span><span class="o">=</span><span class="p">{</span> <span class="p">},</span> <span class="n">mask</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;cubic&#39;</span><span class="p">,</span> <span class="n">decimate</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">replicate</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">dropdeg</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">stretch</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function rotates two axes of an image.  These axes are either</span>
<span class="sd">        those associated with a Direction coordinate or with a Linear</span>
<span class="sd">        coordinate. The Direction coordinate takes precedence.</span>
<span class="sd">        If rotating a Linear coordinate, it must hold precisely two axes.</span>
<span class="sd">        </span>
<span class="sd">        The method is that the Coordinate is rotated and then the input</span>
<span class="sd">        image is regridded to the rotated Coordinate System.</span>
<span class="sd">        </span>
<span class="sd">        If the image brightness units are Jy/pixel then the output is scaled to</span>
<span class="sd">        conserve flux (roughly; just one scale factor at the reference pixel is</span>
<span class="sd">        computed).</span>
<span class="sd">        </span>
<span class="sd">        A variety of interpolation schemes are provided (you need only specify</span>
<span class="sd">        the first three characters to {stfaf method}).  The cubic</span>
<span class="sd">        interpolation is substantially slower than linear.  By default you get</span>
<span class="sd">        cubic interpolation.</span>
<span class="sd">        </span>
<span class="sd">        You can specify the shape of the output image ({stfaf shape}).</span>
<span class="sd">        However, all axis that are not regrided retain the same output shape</span>
<span class="sd">        as the input image shape for that axis.  Only the direction coordinate</span>
<span class="sd">        axes are regridded.</span>
<span class="sd">        </span>
<span class="sd">        You can also specify a region to be applied to the input image.  If</span>
<span class="sd">        you do this, you need to be careful with the output shape for</span>
<span class="sd">        non-regridded axes (must match that of the region - use function</span>
<span class="sd">        boundingbox to find that out).</span>
<span class="sd">        </span>
<span class="sd">        If {stfaf outfile} is given, the image is written to the specified</span>
<span class="sd">        disk file.  If {stfaf outfile} is unset, the on-the-fly Image tool</span>
<span class="sd">        returned by this function is associated with a temporary image.  This</span>
<span class="sd">        temporary image may be in memory or on disk, depending on its size.</span>
<span class="sd">        When you destroy the on-the-fly Image tool (with the done function) this</span>
<span class="sd">        temporary image is deleted.</span>
<span class="sd">        </span>
<span class="sd">        The argument {stfaf replicate} can be used to simply replicate pixels</span>
<span class="sd">        rather than regridding them.  Normally ({stfaf replicate=F}), for every</span>
<span class="sd">        output pixel, its world coordinate is computed and the corresponding</span>
<span class="sd">        input pixel found (then a little interpolation grid is generated).  If</span>
<span class="sd">        you set {stfaf replicate=T}, then what happens is that for every output</span>
<span class="sd">        axis, a vector of regularly sampled input pixels is generated (based on</span>
<span class="sd">        the ratio of the output and input axis shapes).  So this just means the</span>
<span class="sd">        pixels get replicated (by whatever interpolation scheme you use) rather</span>
<span class="sd">        than regridded in world coordinate space.  This process is much faster,</span>
<span class="sd">        but its not a true world coordinate based regrid.</span>
<span class="sd">        </span>
<span class="sd">        As decribed above, when {stfaf replicate} is False, a coordinate is</span>
<span class="sd">        computed for each output pixel; this is an expensive operation.  The</span>
<span class="sd">        argument {stfaf decimate} allows you to decimate the computation of</span>
<span class="sd">        that coordinate grid to a sparse grid, which is then filled in via</span>
<span class="sd">        fast interpolation.  The default for {stfaf decimate} is 0 (no</span>
<span class="sd">        decimation).  The number of pixels per axis in the sparse grid is the</span>
<span class="sd">        number of output pixels for that axis divided by the decimation</span>
<span class="sd">        factor.  A factor of 10 does pretty well.  You may find that for very</span>
<span class="sd">        non-linear coordinate systems (e.g.  very close to the pole) that you</span>
<span class="sd">        have to reduce the decimation factor.</span>
<span class="sd">        </span>
<span class="sd">        The output pixelmask will be good (T) unless the regridding failed to</span>
<span class="sd">        find a value for that output pixel in which case it will be bad (F).</span>
<span class="sd">        For example, if the total input mask (default input pixelmask plus OTF</span>
<span class="sd">        mask) for all of the relevant input pixels were masked bad</span>
<span class="sd">        then the output pixel would be masked bad (F).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_wrap_image</span><span class="p">(</span><span class="n">swig_object</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">outfile</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">pa</span><span class="p">,</span> <span class="n">region</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">decimate</span><span class="p">,</span> <span class="n">replicate</span><span class="p">,</span> <span class="n">dropdeg</span><span class="p">,</span> <span class="n">overwrite</span><span class="p">,</span> <span class="n">stretch</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">rotatebeam</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">angle</span><span class="o">=</span><span class="p">[</span> <span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This method rotates the attached image&#39;s beam(s) counterclockwise through the specified angle.</span>
<span class="sd">        This is the same thing as increasing the position angle(s) of the beam(s) by the specified angle.</span>
<span class="sd">        If the image does not have a beam, no changes to the image are made. If the image has multiple</span>
<span class="sd">        beams, all the beams are rotated through the same angle.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">rotatebeam</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">rename</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function renames the imagefile associated with the imagetool.</span>
<span class="sd">        If a file with name {stfaf name} already exists, you can overwrite it</span>
<span class="sd">        with the argument {stfaf overwrite}; otherwise a fail will</span>
<span class="sd">        result.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">overwrite</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">replacemaskedpixels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pixels</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">region</span><span class="o">=</span><span class="p">{</span> <span class="p">},</span> <span class="n">mask</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">update</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="nb">list</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">stretch</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This application replaces the values of all pixels whose total input mask</span>
<span class="sd">        (default input pixelmask and OTF mask) is bad (F) with the specified</span>
<span class="sd">        value. It supports both float valued and compplex valued images.</span>
<span class="sd">        </span>
<span class="sd">        If the argument {stfaf update} is F (the default), the actual pixelmask</span>
<span class="sd">        is left unchanged.  That is, masked pixels remain masked.   However, if</span>
<span class="sd">        you set {stfaf update=T} then the pixelmask will be updated so that the</span>
<span class="sd">        pixelmask will now be T (good) where the {bf total} input mask was F</span>
<span class="sd">        (bad).</span>
<span class="sd">        </span>
<span class="sd">        See maskhandler for information</span>
<span class="sd">        on how to set the default pixelmask.</span>
<span class="sd">        </span>
<span class="sd">        There are a few ways in which you can specify what to replace the</span>
<span class="sd">        masked pixel values by.</span>
<span class="sd">        </span>
<span class="sd">        begin{itemize}</span>
<span class="sd">        </span>
<span class="sd">        item First, you can give the {stfaf pixels} argument a simple numeric</span>
<span class="sd">        scalar (e.g.  {cf pixels=1.0}).  Then, all masked values will be</span>
<span class="sd">        replaced by that value.</span>
<span class="sd">        </span>
<span class="sd">        item Second, you can give a scalar</span>
<span class="sd">        htmladdnormallink{LEL}{../../notes/223/223.html} expression string</span>
<span class="sd">        (e.g.  {cf pixels=&#39;min(myimage)&#39;}).  Then, all masked values will be</span>
<span class="sd">        replaced by the scalar that results from the expression.  If the scalar expression</span>
<span class="sd">        is illegal (e.g.  in the expression {cf pixels=&#39;min(myimage)&#39;} there</span>
<span class="sd">        were no good pixels in {sff myimage}) then the value 0 is used for</span>
<span class="sd">        replacement.</span>
<span class="sd">        </span>
<span class="sd">        item Third, you can give a</span>
<span class="sd">        htmladdnormallink{LEL}{../../notes/223/223.html} expression string</span>
<span class="sd">        which has the same shape as the imagefile you are applying the</span>
<span class="sd">        function to.  For example, putting {cf pixels=&#39;myotherimage&#39;} means</span>
<span class="sd">        replace all masked pixels in this imagefile with the equivalent pixel</span>
<span class="sd">        in the imagefile called {sff myotherimage}.</span>
<span class="sd">        </span>
<span class="sd">        Your expression might be quite complex, and you can think of it as</span>
<span class="sd">        producing another masked lattice.  However, in the replace process, the</span>
<span class="sd">        mask of that expression lattice is ignored.  Thus, only the mask of</span>
<span class="sd">        the imagefile you are replacing and the pixel values of the expression</span>
<span class="sd">        lattice are relevant.</span>
<span class="sd">        </span>
<span class="sd">        The expression must conform with the subimage formed by applying the</span>
<span class="sd">        region to the image (i.e.  that associated with this Image tool).  If</span>
<span class="sd">        you use the {stfaf mask} argument as well, the region is applied to</span>
<span class="sd">        it as well (see examples).</span>
<span class="sd">        </span>
<span class="sd">        end{itemize}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">replacemaskedpixels</span><span class="p">(</span><span class="n">pixels</span><span class="p">,</span> <span class="n">region</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">update</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="n">stretch</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">beamarea</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">channel</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">polarization</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the area of the image&#39;s restoring beam. If a non-negative channel and non-negative polarization</span>
<span class="sd">        are specified, the area for the beam associated with that channel and polarization will be</span>
<span class="sd">        returned. The return value will be a dictionary containing the keys &#39;arcsec2&#39; and &#39;pixels&#39;, and</span>
<span class="sd">        the associated values will be the beam area in arcsec2 and in pixels, respectively. If both</span>
<span class="sd">        channel and polarization are set to negative values, then a dictionary with the same keys will</span>
<span class="sd">        be returned, and the values will be either scalars (if the image has a single traditional</span>
<span class="sd">        beam) or arrays if the image has multiple beams. In the latter case, the arrays will have</span>
<span class="sd">        shapes indicative of the number of channels and number of polarizations. If the image has</span>
<span class="sd">        a spectral axis but not a polarization axis, the returned arrays will be one dimensional and</span>
<span class="sd">        have a length equal to the number of channels. Similarly, if the image has a polarization</span>
<span class="sd">        axis but not a spectral axis, the arrays will be one dimensional and have a lenghts equal</span>
<span class="sd">        to the number of polarizations. If the image has both a spectral and polarization axis,</span>
<span class="sd">        the returned arrays will be two dimensional with shape (m, n) where m is the length</span>
<span class="sd">        of the first channel or polarization axis, and n is the length of the second channel or</span>
<span class="sd">        polarization axis. So, if an image has shape [200, 200, 10, 4] with 10 channels and</span>
<span class="sd">        4 stokes, the returned arrays will have shapes of (10, 4) representing the spectral</span>
<span class="sd">        axis as the first axis and the polarization axis as the second. If, instead, the image</span>
<span class="sd">        shape is [200, 200, 4, 10] again with 10 channels and 4 stokes, the shape of the</span>
<span class="sd">        returned arrays will be (4, 10) since the polarization axis precedes the spectral</span>
<span class="sd">        axis.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">beamarea</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">polarization</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">restoringbeam</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">channel</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">polarization</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">mbret</span><span class="o">=</span><span class="s1">&#39;list&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function returns the restoring beam(s), if any, of the attached image.</span>
<span class="sd">        </span>
<span class="sd">        If mbret=&quot;matrix&quot; (or &quot;m&quot;), an exception will be thrown if the attached image</span>
<span class="sd">        does not have per-plane beams, or if channel or polarization is specified to be</span>
<span class="sd">        non-negative. See below for more information on the mbret parameter.</span>
<span class="sd">        </span>
<span class="sd">        If mbret=&quot;list&quot; (or &quot;l&quot;) and the attached image has no restoring beam(s), an</span>
<span class="sd">        empty dictionary is returned.</span>
<span class="sd">        </span>
<span class="sd">        If the image has a single traditional restoring beam and mbret=&quot;list&quot;,</span>
<span class="sd">        the beam is returned as a dictionary no matter what channel and polarization</span>
<span class="sd">        values are specified. This dictionary has keys &quot;major&quot;,</span>
<span class="sd">        &quot;minor&quot;, andi &quot;positionangle&quot;, and each of these fields</span>
<span class="sd">        contains a dictionary with &quot;value&quot; and &quot;unit&quot; keys which</span>
<span class="sd">        provide the quantity associated with each beam parameter.</span>
<span class="sd">        </span>
<span class="sd">        If mbret=&quot;list&quot;, and if the image has per-plane beams, and the image</span>
<span class="sd">        has both spectral and polarization axes, and if both channel and polarization</span>
<span class="sd">        are set to non-negative values that are less than the number of planes along</span>
<span class="sd">        each parameter&#39;s representative axis, the beam for that particular</span>
<span class="sd">        channel/polarization pair is returned. If at least one of these values is set</span>
<span class="sd">        to greater or equal to the number of planes along that parameter&#39;s</span>
<span class="sd">        representative axis, and that axis exists and is not degenerate, then an</span>
<span class="sd">        exception will be thrown. In the case of a non-extant axis or a degenerate axis,</span>
<span class="sd">        the parameter associated with that axis can be set to any value and a beam will</span>
<span class="sd">        be returned, because in that case there is exactly one beam for each plane</span>
<span class="sd">        along the other parameter&#39;s representative axis, and so there is no ambiguity</span>
<span class="sd">        regarding which beam to return. In the case where both spectral and polarization</span>
<span class="sd">        axes exist and are not degenerate, an exception will be thrown if one of channel</span>
<span class="sd">        or polarization is set to a non-negative value and the other is set to a</span>
<span class="sd">        negative value. In the above cases in which a beam is returned, the returned</span>
<span class="sd">        dictionary will have the same structure as that previously described in the</span>
<span class="sd">        single beam case.</span>
<span class="sd">        </span>
<span class="sd">        If the image contains multiple beams and both channel and polarization are</span>
<span class="sd">        specified to be negative, the structure of the returned dictionary depends on</span>
<span class="sd">        the specified value of mbret. Supported values of this parameter are</span>
<span class="sd">        &quot;list&quot; and &quot;matrix&quot; (case insensitive, mimimum match</span>
<span class="sd">        supported). In both cases, the returned dictionary will contain the keys</span>
<span class="sd">        &quot;nChannels&quot;, which contains an integer value equal to the number of</span>
<span class="sd">        channels, and &quot;nStokes&quot;, which contains an integer value equal to the</span>
<span class="sd">        number of polarizations. In the case where one axis doesn&#39;t exist, the</span>
<span class="sd">        associated value will be 1.</span>
<span class="sd">        </span>
<span class="sd">        In the case of mbret=&quot;list&quot;, the returned dictionary will contain the</span>
<span class="sd">        key &quot;beams&quot;, which contains a sub-dictionary of information for all</span>
<span class="sd">        beams. This subdictionary contains keys &quot;*0&quot; through</span>
<span class="sd">        &quot;*(c-1)&quot;, where c is the value associated with the</span>
<span class="sd">        &quot;nChannels&quot; key. Each of these keys has an associated value which is a</span>
<span class="sd">        subdictionary containing keys &quot;*0&quot; through &quot;*(p-1)&quot;, where p</span>
<span class="sd">        is the value associated associated with the &quot;nStokes&quot; key. Each</span>
<span class="sd">        of these keys has an assciated value of a beam dictionary, the structure of</span>
<span class="sd">        which is the same as described previously for a single beam image, which is</span>
<span class="sd">        associated with that particular channel/polarization pair.</span>
<span class="sd">        </span>
<span class="sd">        In the case of mbret=&quot;matrix&quot;, the returned dictionary will have keys</span>
<span class="sd">        &quot;major&quot;, &quot;minor&quot;, and &quot;pa&quot; which hold values</span>
<span class="sd">        representing the major axes, the minor axes, and the position angle,</span>
<span class="sd">        respectively, of all beams. Each of these fields contains a dictionary which</span>
<span class="sd">        represents a quantity with keys &quot;unit&quot; and &quot;value&quot;. The</span>
<span class="sd">        &quot;unit&quot; field contains a string representing the unit of the</span>
<span class="sd">        associated value. The &quot;value&quot; field contains a matrix with values</span>
<span class="sd">        corresponding to the associated parameter for the associated beam. In the case</span>
<span class="sd">        where an image does not have both a spectral and polarization axis, these</span>
<span class="sd">        matrices will have shape (n, 1), where n is the number of planes on the extant</span>
<span class="sd">        axis. In the case where an image has both spectral and polarization axes, the</span>
<span class="sd">        matrices will have shape (m, n) where m is the number of channels if the</span>
<span class="sd">        spectral axis precedes the polarization axis, or the number of polarization</span>
<span class="sd">        planes otherwise, and n is the number of planes on the axis not represented by</span>
<span class="sd">        m. So, an image with a spectral axis that has 5 channels and precedes the</span>
<span class="sd">        polarization axis that has 4 planes, the returned matrix shape will be (5, 4).</span>
<span class="sd">        In the case where the number of spectral and polarization planes are the same</span>
<span class="sd">        as in the previous example, but the polarization axis precedes the spectral</span>
<span class="sd">        axis, the matrix shape will be (4, 5). Thus, the matrix shape pair follows the</span>
<span class="sd">        order of the image spectral and polarization axes. This mode is useful for</span>
<span class="sd">        returning to the python UI the major axes, minor axes, and position angles</span>
<span class="sd">        directly as numpy arrays.</span>
<span class="sd">        </span>
<span class="sd">        The restoring beam(s) of an image may be set with image tool method</span>
<span class="sd">        setrestoringbeam.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">restoringbeam</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">polarization</span><span class="p">,</span> <span class="n">mbret</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">sepconvolve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outfile</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">[</span> <span class="nb">int</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">],</span> <span class="n">types</span><span class="o">=</span><span class="p">[</span> <span class="s1">&#39;&#39;</span> <span class="p">],</span> <span class="n">widths</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">scale</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">region</span><span class="o">=</span><span class="p">{</span> <span class="p">},</span> <span class="n">mask</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">stretch</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function  does Fourier-based</span>
<span class="sd">        convolution of an imagefile by a specified separable kernel.</span>
<span class="sd">        </span>
<span class="sd">        If {stfaf outfile} is given, the image is written to the specified</span>
<span class="sd">        disk file.  If {stfaf outfile} is unset, the on-the-fly Image tool</span>
<span class="sd">        returned by this function is associated with a temporary image.  This</span>
<span class="sd">        temporary image may be in memory or on disk, depending on its size.</span>
<span class="sd">        When you destroy the Image tool (with the done function) this</span>
<span class="sd">        temporary image is deleted.</span>
<span class="sd">        </span>
<span class="sd">        You specify which axes of the image you wish to convolve, by what kernel</span>
<span class="sd">        of what width. The kernel types can be shortened to {cf &#39;gauss&#39;,</span>
<span class="sd">        &#39;hann&#39;} and {cf &#39;box&#39;}.</span>
<span class="sd">        </span>
<span class="sd">        You specify the widths of the convolution kernels via the argument</span>
<span class="sd">        {stfaf widths}.  The values can be specified as a vector of three</span>
<span class="sd">        different types.</span>
<span class="sd">        </span>
<span class="sd">        begin{itemize}</span>
<span class="sd">        </span>
<span class="sd">        item Quantity - for example {stfaf widths=qa.quantity(&quot;1arcsec 0.00001rad&quot;)}.</span>
<span class="sd">        Note that you can use pixel units, viz. {stfaf widths=qa.quantity(&quot;10pix 0.00001rad&quot;)}</span>
<span class="sd">        see below.</span>
<span class="sd">        </span>
<span class="sd">        item String - for example {stfaf widths=&quot;1km 2arcsec&quot;} (i.e. a string that</span>
<span class="sd">        qa.quantity() accepts).</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        item Numeric - for example {stfaf widths=[10,20]}.  In this case,</span>
<span class="sd">        the units of the widths are assumed to be in pixels.</span>
<span class="sd">        </span>
<span class="sd">        end{itemize}</span>
<span class="sd">        </span>
<span class="sd">        The interpretation of {stfaf widths} depends upon the kernel type.</span>
<span class="sd">        </span>
<span class="sd">        begin{itemize}</span>
<span class="sd">        </span>
<span class="sd">        item Gaussian - the specified width is the full-width at</span>
<span class="sd">        half-maximum.</span>
<span class="sd">        </span>
<span class="sd">        item Boxcar (tophat) - the specified width is</span>
<span class="sd">        the full width.</span>
<span class="sd">        </span>
<span class="sd">        item Hanning - The kernel is $z[i] = 0.25*y[i-1] + 0.5*y[i] +</span>
<span class="sd">        0.25*y[i+1]$.  The width is always 3 pixels, regardless of what</span>
<span class="sd">        you give (but you still have to give it !).</span>
<span class="sd">        </span>
<span class="sd">        end{itemize}</span>
<span class="sd">        </span>
<span class="sd">        The scaling of the output image is determined by the argument {stfaf scale}.</span>
<span class="sd">        If you leave it unset, then autoscaling will be invoked which means that</span>
<span class="sd">        the convolution kernels will all be normalized to have unit volume</span>
<span class="sd">        to as to conserve flux.</span>
<span class="sd">        </span>
<span class="sd">        If you do not leave {stfaf scale} unset, then the convolution kernel</span>
<span class="sd">        will be scaled by this value (it has peak unity before application</span>
<span class="sd">        of this scale factor).</span>
<span class="sd">        </span>
<span class="sd">        Masked pixels will be assigned the value 0.0 before convolution.</span>
<span class="sd">        The output mask is the combination (logical OR) of the default input</span>
<span class="sd">        pixelmask (if any) and the OTF mask.  Any other input pixelmasks</span>
<span class="sd">        will not be copied.  Use function</span>
<span class="sd">        maskhandler if you need to copy other</span>
<span class="sd">        masks too.</span>
<span class="sd">        </span>
<span class="sd">        See also the other convolution functions</span>
<span class="sd">        convolve2d,</span>
<span class="sd">        convolve and</span>
<span class="sd">        hanning.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_wrap_image</span><span class="p">(</span><span class="n">swig_object</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">sepconvolve</span><span class="p">(</span><span class="n">outfile</span><span class="p">,</span> <span class="n">axes</span><span class="p">,</span> <span class="n">types</span><span class="p">,</span> <span class="n">widths</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">region</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">overwrite</span><span class="p">,</span> <span class="n">stretch</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pixels</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">pixelmask</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">region</span><span class="o">=</span><span class="p">{</span> <span class="p">},</span> <span class="nb">list</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function replaces data and/or mask values within the image in the</span>
<span class="sd">        specified region.  You can think of it as a simplified version of the</span>
<span class="sd">        image calculator.</span>
<span class="sd">        </span>
<span class="sd">        Unlike the calc function, you can</span>
<span class="sd">        only set a scalar value for all pixels in the specified region.  For</span>
<span class="sd">        example, it can be useful to set a whole image to one value, or a mask</span>
<span class="sd">        in a region to one value.  Although you could do that with the related</span>
<span class="sd">        functions putregion and</span>
<span class="sd">        putchunk, you would have to make an</span>
<span class="sd">        array of the shape of the image and if that is large, it could be</span>
<span class="sd">        resource expensive.</span>
<span class="sd">        </span>
<span class="sd">        The value for the pixels is specified with the {stfaf pixels} argument.  It can</span>
<span class="sd">        be given as either a Lattice Expression Language (or LEL) expression</span>
<span class="sd">        string or a simple numeric scalar.  See htmladdnormallink{note</span>
<span class="sd">        223}{../../notes/223/223.html} for a detailed description of the LEL</span>
<span class="sd">        expression syntax.  If you give a LEL expression it must be a scalar</span>
<span class="sd">        expression.</span>
<span class="sd">        </span>
<span class="sd">        Note that any default mask is {em ignored} by this function when you</span>
<span class="sd">        set pixel values.  This is different from</span>
<span class="sd">        calc where the extant mask is</span>
<span class="sd">        honoured.</span>
<span class="sd">        </span>
<span class="sd">        The value for the pixel mask is specified with the {stfaf pixelmask}</span>
<span class="sd">        argument ({cf T, F, unset}).  If it&#39;s {cf unset} then the mask is not</span>
<span class="sd">        changed.</span>
<span class="sd">        </span>
<span class="sd">        If you specify {stfaf pixelmask=} T or F, then the mask that is affected is</span>
<span class="sd">        the current default mask (see</span>
<span class="sd">        maskhandler).  If there is no mask, a</span>
<span class="sd">        mask is created for you and made the default mask.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">pixels</span><span class="p">,</span> <span class="n">pixelmask</span><span class="p">,</span> <span class="n">region</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">setbrightnessunit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unit</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function sets the image brightness unit. Both float and complex</span>
<span class="sd">        valued images are supported.</span>
<span class="sd">        You can get the brightness unit with function</span>
<span class="sd">        brightnessunit.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">setbrightnessunit</span><span class="p">(</span><span class="n">unit</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">setcoordsys</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">csys</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This method replaces the coordinate system in the image. Coordinate systems are</span>
<span class="sd">        manipulated with the cs (coordintate system) tool. The coordinate system can be</span>
<span class="sd">        recovered from an image via the coordsys() method of the image analysis (ia)</span>
<span class="sd">        tool.</span>
<span class="sd">        </span>
<span class="sd">        Note that changing the coordinate system using the cs tool has no effect on the</span>
<span class="sd">        original image, until it is replaced with this method; the value returned</span>
<span class="sd">        by coordsys() is a copy of, not a reference to, the image&#39;s coordinate system.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">setcoordsys</span><span class="p">(</span><span class="n">csys</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">sethistory</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">history</span><span class="o">=</span><span class="p">[</span>  <span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A casa imagefile can accumulate history information</span>
<span class="sd">        from  an input fits file or by you writing something into</span>
<span class="sd">        it explicitly with this function.     Each element of</span>
<span class="sd">        the input vector is one line of history.  The new</span>
<span class="sd">        history is appended to the old.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        You can recover the history information with function</span>
<span class="sd">        history.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">sethistory</span><span class="p">(</span><span class="n">origin</span><span class="p">,</span> <span class="n">history</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">setmiscinfo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">info</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A CASA image can include user-specified or miscellaneous metadata. This metadata</span>
<span class="sd">        is stored in a data structure referred to as a miscinfo record. For example, the</span>
<span class="sd">        FITS reader ia.fromfits() puts header keywords it doesn&#39;t otherwise use into</span>
<span class="sd">        such a record.  The miscinfo record is not required to be populated, though.</span>
<span class="sd">        </span>
<span class="sd">        This method sets the  miscinfo record of an image. Note that this method will</span>
<span class="sd">        overwrite, not add to, an existing miscinfo record. Thus if the user wishes</span>
<span class="sd">        to augment an existing record, they must first capture the existing record using</span>
<span class="sd">        the ia.miscinfo() method, modify the captured record, and then replace the</span>
<span class="sd">        record in the image using setmiscinfo() by passing it the modified record. The</span>
<span class="sd">        FITS writer will attempt to write all the fields in the miscinfo record to the</span>
<span class="sd">        FITS file it creates. It can do so for scalars and 1-dimensional arrays. Records</span>
<span class="sd">        will be omitted, and multi-dimensional arrays will be flattened into</span>
<span class="sd">        one dimensional arrays.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">setmiscinfo</span><span class="p">(</span><span class="n">info</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The shape of an image is a vector holding the length of each axis of</span>
<span class="sd">        the image.  Although this information is also available in the summary function, it is</span>
<span class="sd">        so useful that it can be obtained directly. Both Float and Complex valued</span>
<span class="sd">        images are supported.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">shape</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">setrestoringbeam</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">major</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">minor</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">pa</span><span class="o">=</span><span class="s1">&#39;Not specified&#39;</span><span class="p">,</span> <span class="n">beam</span><span class="o">=</span><span class="p">{</span> <span class="p">},</span> <span class="n">remove</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">channel</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">polarization</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">imagename</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This method sets the restoring beam(s) for an image or removes an existing beam(s).</span>
<span class="sd">        </span>
<span class="sd">        An image must have exactly one of the following states:</span>
<span class="sd">        </span>
<span class="sd">        1. An image can have a single &quot;traditional&quot; or global beam. In that case, the</span>
<span class="sd">        beam applies to every channel and polarization in the image.</span>
<span class="sd">        </span>
<span class="sd">        2. If an image has more than one spectral channel or more than one polarization,</span>
<span class="sd">        it can have a set of beams. In this case, each channel and/or polarization will</span>
<span class="sd">        have its own beam.</span>
<span class="sd">        </span>
<span class="sd">        3. An image can have neither a global beam nor a beam set.</span>
<span class="sd">        </span>
<span class="sd">        It is never permissible for an image to have both a traditional (global) beam</span>
<span class="sd">        and a set of per-plane beams. Task and method behavior is undefined in that case</span>
<span class="sd">        and any resulting products are considered corrupt.</span>
<span class="sd">        </span>
<span class="sd">        RULES FOR BEAM MODIFICATION</span>
<span class="sd">        </span>
<span class="sd">        1. If remove=true, any existing beam(s) are removed.</span>
<span class="sd">        </span>
<span class="sd">        2. Else if imagename is specified, the beam(s) from the specified image will</span>
<span class="sd">        be copied to the image being accessed by the image tool. Multiple beams</span>
<span class="sd">        may be copied, but the two images must have the same number of frequency</span>
<span class="sd">        channels and polarization planes. If not, an exception is thrown.</span>
<span class="sd">        </span>
<span class="sd">        3. Else if the beam parameter is specified, it will be used. It must be fully</span>
<span class="sd">        specified. It must have exactly three items with keys &quot;major&quot;,</span>
<span class="sd">        &quot;minor&quot;, and &quot;positionangle&quot;. Each of these keys</span>
<span class="sd">        must be a proper quantity dictionary with keys &quot;value&quot; and</span>
<span class="sd">        &quot;unit&quot;. The units for all three items should be angular. The</span>
<span class="sd">        &quot;major&quot; and &quot;minor&quot; items must have non-negative values.</span>
<span class="sd">        If any of these conditions is not met, an exception will be thrown.</span>
<span class="sd">        </span>
<span class="sd">        4. Else the &quot;major&quot;, &quot;minor&quot;, and &quot;pa&quot;</span>
<span class="sd">        parameters must be specified. Any or all of these may be a quantity string</span>
<span class="sd">        (eg, &quot;2arcsec&quot;, a quantity dictionary with keys &quot;value&quot;</span>
<span class="sd">        and &quot;unit&quot;. or a numerical value. &quot;major&quot; and</span>
<span class="sd">        &quot;minor&quot; must have non-negative values. If any of these conditions</span>
<span class="sd">        is not met, an exception will be thrown. In the case of a quantity</span>
<span class="sd">        being specified the &quot;unit&quot; should be an angular unit or no unit.</span>
<span class="sd">        In the case of no unit or a numerical value specified, if the image already</span>
<span class="sd">        has a beam then the corresponding unit for that parameter in the current beam</span>
<span class="sd">        will be used. If the image has no beam, then &quot;arcsec&quot; is used for</span>
<span class="sd">        &quot;major&quot; and &quot;minor&quot;, and &quot;deg&quot; is used for</span>
<span class="sd">        &quot;pa&quot;.</span>
<span class="sd">        </span>
<span class="sd">        If an image has no beams, a traditional (global) beam can be added by setting</span>
<span class="sd">        both channel and polarization to negative values.</span>
<span class="sd">        </span>
<span class="sd">        If an image has no beams, a set of per-plane beams can be added by setting</span>
<span class="sd">        either or both channel and/or polarization to a non-negative value. In this</span>
<span class="sd">        case, a number of per-plane beams are added consistent with the image and they</span>
<span class="sd">        are all set to be the same with parameters equal to those specified by either</span>
<span class="sd">        the beam or major/minor/pa parameters.</span>
<span class="sd">        </span>
<span class="sd">        If an image has a traditional beam, it can be modified by setting both channel</span>
<span class="sd">        and polarization to negative values. If one or both is not set to a negative</span>
<span class="sd">        value, an exception is thrown, and nothing is modified.</span>
<span class="sd">        </span>
<span class="sd">        If an image has a set of per plane beams, one at a time of these can be modified</span>
<span class="sd">        by setting the appropriate channel number and/or polarization number. All the</span>
<span class="sd">        per-plane beams can be modified to the same values in one go by setting both</span>
<span class="sd">        channel and polarization to negative values. Also, in the case where an image</span>
<span class="sd">        has multiple channels, the beams associated with all channels for a given</span>
<span class="sd">        polarization can be modified to the same beam by setting polarization equal to</span>
<span class="sd">        the desired polarization plane number and by setting channel to a negative</span>
<span class="sd">        value. Similarly, in the case where an image has multiple polarizations, the</span>
<span class="sd">        beams associated with all polarizations for a given spectral channel can be</span>
<span class="sd">        modified to the same beam by setting channel equal to the desired spectral</span>
<span class="sd">        channel number and by setting polarization to a negative value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">setrestoringbeam</span><span class="p">(</span><span class="n">major</span><span class="p">,</span> <span class="n">minor</span><span class="p">,</span> <span class="n">pa</span><span class="p">,</span> <span class="n">beam</span><span class="p">,</span> <span class="n">remove</span><span class="p">,</span> <span class="n">log</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">polarization</span><span class="p">,</span> <span class="n">imagename</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">statistics</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">[</span> <span class="nb">int</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">],</span> <span class="n">region</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">includepix</span><span class="o">=</span><span class="p">[</span> <span class="nb">float</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">],</span> <span class="n">excludepix</span><span class="o">=</span><span class="p">[</span> <span class="nb">float</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">],</span> <span class="nb">list</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">disk</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">robust</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">stretch</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">logfile</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;classic&#39;</span><span class="p">,</span> <span class="n">fence</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">center</span><span class="o">=</span><span class="s1">&#39;mean&#39;</span><span class="p">,</span> <span class="n">lside</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">zscore</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">maxiter</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">clmethod</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="n">niter</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">3</span><span class="p">)):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This method computes statistics from the pixel values in the image.  You can</span>
<span class="sd">        then list them and retrieve them (into a record) for further analysis. This</span>
<span class="sd">        method supports only real valued images.</span>
<span class="sd">        </span>
<span class="sd">        The names of the fields in the returned record are summarized below:</span>
<span class="sd">        </span>
<span class="sd">        - npts: the number of unmasked points used</span>
<span class="sd">        </span>
<span class="sd">        - sum: the sum of the pixel values: $sum I_i$</span>
<span class="sd">        </span>
<span class="sd">        - flux: flux or flux density, see below for details</span>
<span class="sd">        </span>
<span class="sd">        - sumsq: the sum of the squares of the pixel values: $sum I_i^2$</span>
<span class="sd">        </span>
<span class="sd">        - mean: the mean of pixel values: $bar{I} = sum I_i / n$</span>
<span class="sd">        </span>
<span class="sd">        - sigma: the standard deviation about the</span>
<span class="sd">        mean: $sigma^2 = (sum I_i - bar{I})^2 / (n-1)$</span>
<span class="sd">        </span>
<span class="sd">        - rms: the root mean square: $sqrt {sum I_i^2 / n}$</span>
<span class="sd">        </span>
<span class="sd">        - min: minimum pixel value</span>
<span class="sd">        </span>
<span class="sd">        - max: the maximum pixel value</span>
<span class="sd">        </span>
<span class="sd">        - median: the median pixel value (if {stfaf robust=T})</span>
<span class="sd">        </span>
<span class="sd">        - medabsdevmed: the median of the absolute deviations from the median</span>
<span class="sd">        (if {stfaf robust=T})</span>
<span class="sd">        </span>
<span class="sd">        - quartile: the inter-quartile range (if {stfaf</span>
<span class="sd">        robust=T}).  Find the points which are 25% largest and 75% largest</span>
<span class="sd">        (the median is 50% largest).</span>
<span class="sd">        </span>
<span class="sd">        - q1: The first quartile. Reported only if robust=T.</span>
<span class="sd">        </span>
<span class="sd">        - q3: The third quartile. Reported only if robust=T.</span>
<span class="sd">        </span>
<span class="sd">        - blc: the absolute pixel coordinate of the bottom left</span>
<span class="sd">        corner of the bounding box of the region of interest.  If &#39;region&#39; is</span>
<span class="sd">        unset, this will be the bottom left corner of the whole image.</span>
<span class="sd">        </span>
<span class="sd">        - blcf: the formatted absolute world coordinate of the bottom left corner of the bounding box of the region of interest.</span>
<span class="sd">        </span>
<span class="sd">        - trc: the absolute pixel coordinate of the top right corner of the bounding box of the region of interest.</span>
<span class="sd">        </span>
<span class="sd">        - trcf: the formatted absolute world coordinate of the top right corner of the bounding box of the region of interest.</span>
<span class="sd">        </span>
<span class="sd">        - minpos: absolute pixel coordinate of minimum pixel value</span>
<span class="sd">        </span>
<span class="sd">        - maxpos: absolute pixel coordinate of maximum pixel value</span>
<span class="sd">        </span>
<span class="sd">        - minposf: formatted string of the world coordinate of</span>
<span class="sd">        the minimum pixel value</span>
<span class="sd">        </span>
<span class="sd">        - maxposf: formatted string of the world coordinate of</span>
<span class="sd">        the maximum pixel value</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        The last four fields only appear if you evaluate the statistics over all</span>
<span class="sd">        axes in the image.  As an example, if the returned record is captured in</span>
<span class="sd">        {stfaf &#39;mystats&#39;}, then you could access the &#39;mean&#39; field via</span>
<span class="sd">        {cf print mystats[&#39;mean&#39;]}.</span>
<span class="sd">        </span>
<span class="sd">        If there are no good points (e.g.  all pixels are masked bad in the</span>
<span class="sd">        region), then the length of these fields will be 0 (e.g.  {cf</span>
<span class="sd">        len(mystats[&#39;npts&#39;])==0}).</span>
<span class="sd">        </span>
<span class="sd">        You have no control over which statistics are listed to the logger,</span>
<span class="sd">        you always get the same selection.  You can choose to list the</span>
<span class="sd">        statistics or not (argument {stfaf list}).</span>
<span class="sd">        </span>
<span class="sd">        As well as the simple (and faster to calculate) statistics like means</span>
<span class="sd">        and sums, you can also compute some robust (quantile-like) statistics.  Currently</span>
<span class="sd">        these are the median, median absolute deviations from the median,</span>
<span class="sd">        the first and third quartiles, and the inner-quartile range.  Because these are computationally</span>
<span class="sd">        expensive, they are only computed if robust=True.</span>
<span class="sd">        </span>
<span class="sd">        Note that if the axes are set to all of the axes in the image (which is</span>
<span class="sd">        the default) there is just one value per statistic.</span>
<span class="sd">        </span>
<span class="sd">        You have control over which pixels are included in the statistics computations</span>
<span class="sd">        via the {stfaf includepix} and {stfaf excludepix} arguments.  These vectors</span>
<span class="sd">        specify a range of pixel values for which pixels are either included or</span>
<span class="sd">        excluded.  They are mutually exclusive; you can specify one or the</span>
<span class="sd">        other, but not both.  If you only give one value for either of these,</span>
<span class="sd">        say {stfaf includepix=b}, then this is interpreted as {stfaf</span>
<span class="sd">        includepix=[-abs(b),abs(b)]}.</span>
<span class="sd">        </span>
<span class="sd">        This function generates a &#39;storage&#39; lattice, into which the statistics</span>
<span class="sd">        are written as a means to improve performance on successive identical runs.</span>
<span class="sd">        After the initial execution of this method, it is only regenerated as</span>
<span class="sd">        necessary.  For example, if you run the method twice with</span>
<span class="sd">        identical arguments, the statistics will be directly retrieved from the</span>
<span class="sd">        storage lattice the second time, and the statistics will not be recomputed.</span>
<span class="sd">        However, you can force regeneration of the statistics if you set force=True.</span>
<span class="sd">        VERY IMPORTANT NOTE. If you have an open image tool on which you&#39;ve run</span>
<span class="sd">        statistics(), and</span>
<span class="sd">        change the pixel values of the opened image via another tool or a task, the</span>
<span class="sd">        opened image tool has no knowledge that pixel values have been changed, and</span>
<span class="sd">        so if you run ia.statistics() again with that tool, you will very likely</span>
<span class="sd">        get incorrect results since they come from the statistics stored from a previous</span>
<span class="sd">        run. First of all, it is highly discouraged that you do anything like this.</span>
<span class="sd">        Tools maintain state that only they know about internally; if you change</span>
<span class="sd">        an image that is already opened with another image tool or task, the general</span>
<span class="sd">        outcome will be undefined when you run methods on the already opened tool.</span>
<span class="sd">        However, if for some reason you must do this,</span>
<span class="sd">        first consider changing your algorithm because there should be no reason</span>
<span class="sd">        to have to do this. But, if you decide to continue down that path that will</span>
<span class="sd">        likely lead you over the edge of a cliff, then you can set force=True to</span>
<span class="sd">        ensure statistics are always recomputed.</span>
<span class="sd">        </span>
<span class="sd">        The storage medium is either in memory or on disk,</span>
<span class="sd">        depending upon its size.  You can force it to disk if you set {stfaf</span>
<span class="sd">        disk=T}, otherwise it decides for itself.</span>
<span class="sd">        </span>
<span class="sd">        CURSOR AXES</span>
<span class="sd">        The axes parameter allows one to set the cursor axes over which statistics</span>
<span class="sd">        are computed. For example, consider a 3-dimensional image for which axes=[0,2].</span>
<span class="sd">        The statistics would be computed for each XZ (axes 0 and 2) plane in the</span>
<span class="sd">        image.  One could then examine those statistics as a function of the Y</span>
<span class="sd">        (axis 1) axis.</span>
<span class="sd">        </span>
<span class="sd">        Each statistic is stored in an array in its own field in the returned dictionary.</span>
<span class="sd">        The dimensionality of these arrays is equal to the number of axes over which the</span>
<span class="sd">        statistics were not evaluated (called the display axes). For example, if the input</span>
<span class="sd">        image has four axes, and axes=[0], the output statistic arrays will have three dimensions.</span>
<span class="sd">        If axes=[0, 1], the output statistic arrays will have two dimensions.</span>
<span class="sd">        </span>
<span class="sd">        The shape of the output arrays when axes has a positive number of elements is based on</span>
<span class="sd">        the region selection. If there is no region selection, the shape of the statistic arrays</span>
<span class="sd">        is just the shape of the image along the display (non-cursor) axes. For example, if the</span>
<span class="sd">        input image has dimensions of 300x400x4x80 and axes=[0, 1], in the absence of a region</span>
<span class="sd">        selection, the shape of the output statistic arrays will be 4x80. If there is a region</span>
<span class="sd">        selection, the shape of the output statistic arrays will be determined by the number of</span>
<span class="sd">        planes along the display axes chosen in the region selection. For example, continuing with</span>
<span class="sd">        our example, if axes=[0,1] and region=rg.box([0, 0, 1, 20], [299,399, 2, 60]), the output</span>
<span class="sd">        statistic arrays will have shapes of 2x41. Only the selected planes will be displayed in the</span>
<span class="sd">        logger output if verbose=True.</span>
<span class="sd">        </span>
<span class="sd">        In the case where the image has a pixel mask, and/or the mask parameter is specified, and because</span>
<span class="sd">        of this specification a plane is entirely masked, this element is included in the statistic arrays</span>
<span class="sd">        (usually with a value of 0). It is not included in the logger output if verbose=True. One can</span>
<span class="sd">        exclude such elements from computations on the output arrays by using the numpy.extract() method.</span>
<span class="sd">        For example, to compute the minimum rms value, not including any fully masked planes, one could</span>
<span class="sd">        use</span>
<span class="sd">        </span>
<span class="sd">        stats = ia.statistics(...)</span>
<span class="sd">        rmsmin = numpy.min(numpy.extract(stats[&#39;npts&#39;]&gt;0, stats[&#39;rms&#39;]))</span>
<span class="sd">        </span>
<span class="sd">        Thus in the computation of rmsmin, only the rms elements are considered which have</span>
<span class="sd">        associated values of npts that are not zero.</span>
<span class="sd">        </span>
<span class="sd">        ALGORITHMS</span>
<span class="sd">        </span>
<span class="sd">        Several types of statistical algorithms are supported:</span>
<span class="sd">        </span>
<span class="sd">        - classic: This is the familiar algorithm, in which all unmasked pixels, subject to any</span>
<span class="sd">        specified pixel ranges, are used. One may choose one of two methods, which vary only by</span>
<span class="sd">        performance, for computing classic statistics, via the clmethod parameter. The &quot;tiled&quot;</span>
<span class="sd">        method is the old method and is fastest in cases where there are a large number of</span>
<span class="sd">        individual sets of statistics to be computed and a small number of data points per set.</span>
<span class="sd">        This can occur when one sets the axes parameter, which causes several individual sets of</span>
<span class="sd">        statistics to be computed. The &quot;framework&quot; method uses the new statistics framework to</span>
<span class="sd">        compute statistics. This method is fastest in the regime where one has a small number of</span>
<span class="sd">        individual sets of statistics to calculate, and each set has a large number of points.</span>
<span class="sd">        For example, this method is fastest when computing statistics over an entire image in one</span>
<span class="sd">        go (no axes specified). A third option, &quot;auto&quot;, chooses which method to use by predicting</span>
<span class="sd">        which be faster based on the number of pixels in the image and the choice of the axes</span>
<span class="sd">        parameter.</span>
<span class="sd">        </span>
<span class="sd">        - fit-half: This algorithm calculates statistics on a dataset created from real and virtual pixel values.</span>
<span class="sd">        The real values are determined by the input parameters center and lside. The parameter center</span>
<span class="sd">        tells the algorithm where the center value of the combined real+virtual dataset should be. Options</span>
<span class="sd">        are the mean or the median of the input image&#39;s pixel values, or at zero. The lside parameter tells</span>
<span class="sd">        the algorithm on which side of this center the real pixel values are located. True indicates that</span>
<span class="sd">        the real pixel values to be used are &lt;= center. False indicates the real pixel values to be used</span>
<span class="sd">        are &gt;= center. The virtual part of the dataset is then created by reflecting all the real values</span>
<span class="sd">        through the center value, to create a perfectly symmetric dataset composed of a real and a virtual</span>
<span class="sd">        component. Statistics are then calculated on this resultant dataset. These two parameters are</span>
<span class="sd">        ignored if algorithm is not &quot;fit-half&quot;. Because the maximum value is virtual if lside is True and the</span>
<span class="sd">        minimum value is virtual if lside is False, the value of the maximum position (if lside=True) or</span>
<span class="sd">        minimum position (if lside=False) is not reported in the returned record.</span>
<span class="sd">        </span>
<span class="sd">        - hinges-fences: This algorithm calculates statistics by including data in a range</span>
<span class="sd">        between Q1 - f*D and Q3 + f*D, inclusive, where Q1 is the first quartile of the distribution</span>
<span class="sd">        of unmasked data, subject to any specified pixel ranges, Q3 is the third quartile, D = Q3 - Q1</span>
<span class="sd">        (the inner quartile range), and f is the user-specified fence factor. Negative values of f</span>
<span class="sd">        indicate that the full distribution is to be used (ie, the classic algorithm is used). Sufficiently</span>
<span class="sd">        large values of f will also be equivalent to using the classic algorithm. For f = 0, only data</span>
<span class="sd">        in the inner quartile range is used for computing statistics. The value of fence is silently</span>
<span class="sd">        ignored if algortihm is not &quot;hinges-fences&quot;.</span>
<span class="sd">        </span>
<span class="sd">        - chauvenet: The idea behind this algorithm is to eliminate outliers based on a maximum z-score value.</span>
<span class="sd">        A z-score is the number of standard deviations a point is from the mean of a distribution. This</span>
<span class="sd">        method thus is meant to be used for (nearly) normal distributions. In general, this is an iterative</span>
<span class="sd">        process, with successive iterations discarding additional outliers as the remaining points become</span>
<span class="sd">        closer to forming a normal distribution. Iterating stops when no additional points lie beyond the</span>
<span class="sd">        specified zscore value, or, if zscore is negative, when Chauvenet&#39;s criterion is met (see below).</span>
<span class="sd">        The parameter maxiter can be set to a non-negative value to prematurely abort this iterative</span>
<span class="sd">        process. When verbose=True, the &quot;N iter&quot; column in the table that is logged represents the number</span>
<span class="sd">        of iterations that were executed.</span>
<span class="sd">        </span>
<span class="sd">        Chauvenet&#39;s criterion allows the target z-score to decrease as the number of points in the</span>
<span class="sd">        distribution decreases on subsequent iterations. Essentially, the criterion is that the probability</span>
<span class="sd">        of having one point in a normal distribution at a maximum z-score of z_max must be at least 0.5.</span>
<span class="sd">        z_max is therefore a function of (only) the number of points in the distrbution and is given by</span>
<span class="sd">        </span>
<span class="sd">        npts = 0.5/erfc(z_max/sqrt(2))</span>
<span class="sd">        </span>
<span class="sd">        where erfc() is the complementary error function. As iterating proceeds, the number of remaining</span>
<span class="sd">        points decreases as outliers are discarded, and so z_max likewise decreases. Convergence occurs when</span>
<span class="sd">        all remaining points fall within a z-score of z_max. Below is an illustrative table of z_max values</span>
<span class="sd">        and their corresponding npts values. For example, it is likely that there will be a 5-sigma &quot;noise</span>
<span class="sd">        bump&quot; in a perfectly noisy image with one million independent elements.</span>
<span class="sd">        </span>
<span class="sd">        z_max    npts</span>
<span class="sd">        1.0                1</span>
<span class="sd">        1.5                3</span>
<span class="sd">        2.0               10</span>
<span class="sd">        2.5               40</span>
<span class="sd">        3.0              185</span>
<span class="sd">        3.5            1,074</span>
<span class="sd">        4.0            7,893</span>
<span class="sd">        4.5           73,579</span>
<span class="sd">        5.0          872,138</span>
<span class="sd">        5.5       13,165,126</span>
<span class="sd">        6.0      253,398,672</span>
<span class="sd">        6.5    6,225,098,696</span>
<span class="sd">        7.0  195,341,107,722</span>
<span class="sd">        </span>
<span class="sd">        - biweight: The biweight algorithm is a robust iterative algorithm that computes two</span>
<span class="sd">        quantities called the &quot;location&quot; and the &quot;scale&quot;, which are analogous to the mean</span>
<span class="sd">        and the standard deviation. In this case, the only keys present in the returned</span>
<span class="sd">        dictionary are &#39;mean&#39; (location), &#39;sigma&#39; (scale), &#39;npts&#39;, &#39;min&#39;, and &#39;max&#39;. The</span>
<span class="sd">        last three represent the values using the entire distribution. Note that the</span>
<span class="sd">        biweight algorithm does not support computation of quantile-like values (median,</span>
<span class="sd">        madm, q1, q3, and iqr), so setting robust=True will cause a warning message to</span>
<span class="sd">        be logged regarding that, and the computation will proceed.</span>
<span class="sd">        </span>
<span class="sd">        Important equations for the biweight algorithm are</span>
<span class="sd">        </span>
<span class="sd">        A. How to compute u_i values, which are related to the weights w_i = (1 - u_i*u_i),</span>
<span class="sd">        using the</span>
<span class="sd">        equation</span>
<span class="sd">        </span>
<span class="sd">        ``u_i = (x_i - c_bi)/(6.0*s_bi)                  (1)``</span>
<span class="sd">        </span>
<span class="sd">        where x_i are the data values, c_bi is the biweight location and s_bi is the</span>
<span class="sd">        biweight scale. For the initial computation of the u_i values, c_bi is set</span>
<span class="sd">        equal to the median of the distribution and s_bi is set equal to</span>
<span class="sd">        the normalized median of the absolute deviation about the median (that is the</span>
<span class="sd">        median of the absolute deviation about the median multiplied by the value of</span>
<span class="sd">        the probit function at 0.75).</span>
<span class="sd">        </span>
<span class="sd">        B. The location, c_bi, is computed from</span>
<span class="sd">        </span>
<span class="sd">        ``c_bi = sum(x_i * w_i^2)/sum(w_i^2)             (2)``</span>
<span class="sd">        </span>
<span class="sd">        where only values of u_i which satisfy abs(u_i) &lt; 1 (w_i &gt; 0) are used in the sums.</span>
<span class="sd">        </span>
<span class="sd">        C. The scale value is computed using::</span>
<span class="sd">        </span>
<span class="sd">        .             n * sum((x_i - c_bi)^2 * w_i^4)</span>
<span class="sd">        . s_bi^2 =    _______________________________    (3)</span>
<span class="sd">        .                    p * max(1, p - 1)</span>
<span class="sd">        </span>
<span class="sd">        where n is the number of points for the entire distribution (which includes all</span>
<span class="sd">        the data, even for which abs(u_i) &gt;= 1) and p is given by::</span>
<span class="sd">        </span>
<span class="sd">        p = abs(sum((w_i) * (5*w_i - 4)))</span>
<span class="sd">        </span>
<span class="sd">        Again, the sums include only data for which abs(u_i) &lt; 1.</span>
<span class="sd">        </span>
<span class="sd">        The algorithm proceeds as follows.</span>
<span class="sd">        1. Compute initial u_i values (and hence w_i values) from equation (1), setting</span>
<span class="sd">        c_bi equal to the median of the distribution and s_bi equal to the normalized</span>
<span class="sd">        median of the absolute deviation about the median.</span>
<span class="sd">        2. Compute the initial value of the scale using the w_i values computed in</span>
<span class="sd">        step 1. using equation 3.</span>
<span class="sd">        3. Recompute u_i/w_i values using the most recent previous scale and location</span>
<span class="sd">        values.</span>
<span class="sd">        4. Compute the location using the u_i.w_i values from step 3 and equation (2).</span>
<span class="sd">        5. Recompute u_i/w_i values using the most recent previous scale and location</span>
<span class="sd">        values.</span>
<span class="sd">        6. Compute the new scale value using the the u_i/w_i values computed in</span>
<span class="sd">        step 5 and the value of the location computed in step 4.</span>
<span class="sd">        7. Steps 3. - 6. are repeated until convergence occurs or the maximum number of</span>
<span class="sd">        iterations (specified in the niter parameter) is reached. The convergence</span>
<span class="sd">        criterion is given by</span>
<span class="sd">        </span>
<span class="sd">        abs(s_bi - s_bi,prev) &lt; 0.03 * sqrt(0.5/(n - 1))</span>
<span class="sd">        </span>
<span class="sd">        where s_bi,prev is the value of the scale computed in the previous iteration.</span>
<span class="sd">        </span>
<span class="sd">        In the special case where niter is specified to be negative, the faster,</span>
<span class="sd">        non-iterative algorithm proceeds as follows:</span>
<span class="sd">        </span>
<span class="sd">        1. Compute u_i/w_i values using the median for the location and the normalized</span>
<span class="sd">        median of the absolute deviation about the median as the scale</span>
<span class="sd">        2. Compute the location and scale (which can be carried out simultaneously)</span>
<span class="sd">        using the u_i/w_i values computed in step 1. The value of the location is</span>
<span class="sd">        just the median that is used in equation (3) to compute the scale</span>
<span class="sd">        </span>
<span class="sd">        NOTES ON FLUX DENSITIES AND FLUXES</span>
<span class="sd">        </span>
<span class="sd">        Fluxes and flux densities are not computed if any of the following conditions is met:</span>
<span class="sd">        </span>
<span class="sd">        1. The image does not have a direction coordinate</span>
<span class="sd">        2. The image does not have a intensity-like brightness unit. Examples of such units</span>
<span class="sd">        are Jy/beam (in which case the image must also have a beam) and K.</span>
<span class="sd">        3. There are no direction axes in the cursor axes that are used.</span>
<span class="sd">        4. If the (specified region of the) image has a non-degenerate spectral axis,</span>
<span class="sd">        and the image has a tablular spectral axis (axis with varying increments)</span>
<span class="sd">        5. Any axis that is not a direction nor a spectral axis that is included in the cursor</span>
<span class="sd">        axes is not degenerate within in the specified region</span>
<span class="sd">        </span>
<span class="sd">        Note that condition 4 may be removed in the future.</span>
<span class="sd">        </span>
<span class="sd">        In cases where none of the above conditions is met, the flux density(ies) (intensities</span>
<span class="sd">        integrated over direction planes) will be computed if any of the following conditions</span>
<span class="sd">        are met:</span>
<span class="sd">        </span>
<span class="sd">        1. The image has no spectral coordinate</span>
<span class="sd">        2. The cursor axes do not include the spectral axis</span>
<span class="sd">        3. The spectral axis in the chosen region is degenerate</span>
<span class="sd">        </span>
<span class="sd">        In the case where there is a nondegenerate spectral axis that is included in the cursor</span>
<span class="sd">        axes, the flux (flux density integrated over spectral planes) will be computed. In this</span>
<span class="sd">        case, the spectral portion of the flux unit will be the velocity unit of the spectral</span>
<span class="sd">        coordinate if it has one (eg, if the brightness unit is Jy/beam and the velocity unit is</span>
<span class="sd">        km/s, the flux will have units of Jy.km/s). If not, the spectral portion of the flux unit</span>
<span class="sd">        will be the frequency unit of the spectral axis (eg, if the brightness unit is K and the</span>
<span class="sd">        frequency unit is Hz, the resulting flux unit will be K.arcsec2.Hz).</span>
<span class="sd">        </span>
<span class="sd">        In both cases of flux density or flux being computed, the resulting numerical value is</span>
<span class="sd">        assigned to the &quot;flux&quot; key in the output dictionary.</span>
<span class="sd">        </span>
<span class="sd">        If the image has units of Jy/beam, the flux density is just the mean intensity multiplied</span>
<span class="sd">        by the number of beam areas included in the region. The beam area is defined as the volume</span>
<span class="sd">        of the elliptical Gaussian defined by the synthesized beam, divided by the maximum of</span>
<span class="sd">        that function, which is equivalent to</span>
<span class="sd">        </span>
<span class="sd">        pi/(4*ln(2)) * major * minor</span>
<span class="sd">        </span>
<span class="sd">        where ln() is the natural logarithm and major and minor are the major and minor FWHM axes</span>
<span class="sd">        of the beam, respectively.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">statistics</span><span class="p">(</span><span class="n">axes</span><span class="p">,</span> <span class="n">region</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">includepix</span><span class="p">,</span> <span class="n">excludepix</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="n">force</span><span class="p">,</span> <span class="n">disk</span><span class="p">,</span> <span class="n">robust</span><span class="p">,</span> <span class="n">verbose</span><span class="p">,</span> <span class="n">stretch</span><span class="p">,</span> <span class="n">logfile</span><span class="p">,</span> <span class="n">append</span><span class="p">,</span> <span class="n">algorithm</span><span class="p">,</span> <span class="n">fence</span><span class="p">,</span> <span class="n">center</span><span class="p">,</span> <span class="n">lside</span><span class="p">,</span> <span class="n">zscore</span><span class="p">,</span> <span class="n">maxiter</span><span class="p">,</span> <span class="n">clmethod</span><span class="p">,</span> <span class="n">niter</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">twopointcorrelation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outfile</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">region</span><span class="o">=</span><span class="p">{</span> <span class="p">},</span> <span class="n">mask</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">[</span> <span class="nb">int</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">],</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;structurefunction&#39;</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">stretch</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function  computes</span>
<span class="sd">        two-point auto-correlation functions from an image.</span>
<span class="sd">        </span>
<span class="sd">        By default, the auto-correlation function is computed for the Sky axes.</span>
<span class="sd">        If there is no sky in the image, then the first two axes are used.</span>
<span class="sd">        Otherwise you can specify which axes the auto-correlation function lags</span>
<span class="sd">        are computed over with the {stfaf axes} argument (must be of length 2).</span>
<span class="sd">        </span>
<span class="sd">        Presently, only the Structure Function is implemented.  This is defined as :</span>
<span class="sd">        </span>
<span class="sd">        begin{displaymath}</span>
<span class="sd">        S(lx,ly) = &lt; (data(i,j) - data(i+lx,j+ly))^2 &gt;</span>
<span class="sd">        end{displaymath}</span>
<span class="sd">        </span>
<span class="sd">        where $lx, ly$ are integer lags in the x (0-axis) and y (1-axis)</span>
<span class="sd">        directions.  The ensemble average is over all the values at the same</span>
<span class="sd">        lag pair.  This process is extremely compute intensive and so you may</span>
<span class="sd">        have to be patient.</span>
<span class="sd">        </span>
<span class="sd">        In an auto-correlation function image there are some symmetries.  The</span>
<span class="sd">        first and third quadrants are symmetric, and the second and fourth are</span>
<span class="sd">        symmetric.  So in principle, all the information is in the top or bottom</span>
<span class="sd">        half of the image.  We just write it all out to look nice.  The long</span>
<span class="sd">        lags don&#39;t have a lot of contributing values of course.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">twopointcorrelation</span><span class="p">(</span><span class="n">outfile</span><span class="p">,</span> <span class="n">region</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">axes</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">overwrite</span><span class="p">,</span> <span class="n">stretch</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">subimage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outfile</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">region</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">dropdeg</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="nb">list</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">stretch</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">wantreturn</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">keepaxes</span><span class="o">=</span><span class="p">[</span>  <span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function copies all or part of the image to another on-the-fly Image tool.</span>
<span class="sd">        Both float and complex valued images are supported.</span>
<span class="sd">        </span>
<span class="sd">        If {stfaf outfile} is given, the subimage is written to the specified</span>
<span class="sd">        disk file.  If {stfaf outfile} is unset, the returned Image tool actually</span>
<span class="sd">        references the input image file (i.e.  that associated with the Image</span>
<span class="sd">        tool to which you are applying this function).  So if you deleted the</span>
<span class="sd">        input image disk file, it would render this tool useless.  When you</span>
<span class="sd">        destroy this tool (with the done function)</span>
<span class="sd">        the reference connection is broken.</span>
<span class="sd">        </span>
<span class="sd">        Sometimes it is useful to drop axes of length one (degenerate axes).</span>
<span class="sd">        Use the {stfaf dropdeg} argument if you want to do this. Further control</span>
<span class="sd">        is provided via the keepaxes parameter. If dropdeg=True, you may specify</span>
<span class="sd">        a list of degenerate axes to keep in the keep axes parameter. This allows</span>
<span class="sd">        you to drop only a subset of degenerate axes. This parameter is ignored if</span>
<span class="sd">        dropdeg=False. If dropdeg=True, all degenerate axes are dropped if keepaxes</span>
<span class="sd">        is set to an empty list (this is the default behavior). Nondegenerate</span>
<span class="sd">        axes are implicitly kept, even if they are included in the keepaxes list.</span>
<span class="sd">        </span>
<span class="sd">        The output mask is the combination (logical OR) of the default input</span>
<span class="sd">        pixelmask (if any) and the OTF mask.  Any other input pixelmasks</span>
<span class="sd">        will not be copied.  Use function maskhandler if you</span>
<span class="sd">        need to copy other masks too.</span>
<span class="sd">        </span>
<span class="sd">        If the mask has fewer dimensions than the image and if the shape</span>
<span class="sd">        of the dimensions the mask and image have in common are the same,</span>
<span class="sd">        the mask will automatically have the missing dimensions added so</span>
<span class="sd">        it conforms to the image.</span>
<span class="sd">        </span>
<span class="sd">        If stretch is true and if the number of mask dimensions is less than</span>
<span class="sd">        or equal to the number of image dimensions and some axes in the</span>
<span class="sd">        mask are degenerate while the corresponding axes in the image are not,</span>
<span class="sd">        the mask will be stetched in the degenerate dimensions. For example,</span>
<span class="sd">        if the input image has shape [100, 200, 10] and the input</span>
<span class="sd">        mask has shape [100, 200, 1] and stretch is true, the mask will be</span>
<span class="sd">        stretched along the third dimension to shape [100, 200, 10]. However if</span>
<span class="sd">        the mask is shape [100, 200, 2], stretching is not possible and an</span>
<span class="sd">        error will result.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_wrap_image</span><span class="p">(</span><span class="n">swig_object</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">subimage</span><span class="p">(</span><span class="n">outfile</span><span class="p">,</span> <span class="n">region</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">dropdeg</span><span class="p">,</span> <span class="n">overwrite</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="n">stretch</span><span class="p">,</span> <span class="n">wantreturn</span><span class="p">,</span> <span class="n">keepaxes</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">summary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">doppler</span><span class="o">=</span><span class="s1">&#39;RADIO&#39;</span><span class="p">,</span> <span class="nb">list</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">pixelorder</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function summarizes various metadata such as shape, Coordinate System,</span>
<span class="sd">        restoring beams, and masks.</span>
<span class="sd">        </span>
<span class="sd">        If called without any arguments, this function displays a summary of the image</span>
<span class="sd">        metadata to the logger; where appropriate, values will be formatted nicely (e.g.</span>
<span class="sd">        HH:MM:SS.SS for the reference value of RA axes).</span>
<span class="sd">        </span>
<span class="sd">        For spectral axes, the information is listed in both the velocity and frequency</span>
<span class="sd">        domains.  The doppler parameter allows one to specify what velocity doppler</span>
<span class="sd">        convention it is listed in.  Supported values are: &quot;radio&quot;, &quot;optical&quot;, and</span>
<span class="sd">        &quot;true&quot;. Alternative values are &quot;z&quot; for &quot;optical&quot;, and &quot;beta&quot; or &quot;relativistic&quot;</span>
<span class="sd">        for true.  The default is &quot;radio&quot;.  The definitions are</span>
<span class="sd">        </span>
<span class="sd">        begin{itemize}</span>
<span class="sd">        item radio: $1 - F$</span>
<span class="sd">        item optical: $-1 + 1/F$</span>
<span class="sd">        item true: $(1 - F^2)/(1 + F^2)$</span>
<span class="sd">        end{itemize}</span>
<span class="sd">        where $F = nu/nu_0$ and $nu_0$ is the rest frequency.  If the rest frequency</span>
<span class="sd">        has not been set in your image, you can set it via a coordinate system (cs) tool</span>
<span class="sd">        using the setrestfrequency() method().</span>
<span class="sd">        </span>
<span class="sd">        The keys of the returned dictionary are</span>
<span class="sd">        </span>
<span class="sd">        begin{itemize}</span>
<span class="sd">        item ndim: Dimension of the image.</span>
<span class="sd">        item shape: Length of each axis in the image.</span>
<span class="sd">        item tileshape: Shape of the chunk which is most efficient for I/O.</span>
<span class="sd">        item axisnames: Name of each axis.</span>
<span class="sd">        item refpix: Reference pixel for each axis (0-relative)</span>
<span class="sd">        item refval: Reference value for each axis.</span>
<span class="sd">        item incr: Increment for each axis.</span>
<span class="sd">        item axisunits: Unit name for each axis.</span>
<span class="sd">        item unit: Brightness units for the pixels.</span>
<span class="sd">        item hasmask: True if the image has a mask.</span>
<span class="sd">        item defaultmask: The name of the mask which is applied by default.</span>
<span class="sd">        item masks: The names of all the masks stored in this image.</span>
<span class="sd">        item restoringbeam: The restoring beam(s) if present.</span>
<span class="sd">        item imagetype: The image type.</span>
<span class="sd">        end{itemize}</span>
<span class="sd">        </span>
<span class="sd">        For an image with multiple beams, the restoringbeam field is a dictionary of</span>
<span class="sd">        dictionaries with keys of names &quot;*&quot; followed by the channel number, if the image</span>
<span class="sd">        has a spectral coordinate, or the polarization number if it does not. That is,</span>
<span class="sd">        the keys have names &quot;*0&quot;, &quot;*1&quot;, &quot;*2&quot;, etc. If the image has both a spectral and</span>
<span class="sd">        a polarization coordinate, each of these dictionaries is a dictionary with keys</span>
<span class="sd">        of the same form which range from 0 to the number of polarizations minus 1;</span>
<span class="sd">        &quot;*0&quot;, &quot;*1&quot;, ... The dictionaries pointed to by the channel and/or polarization</span>
<span class="sd">        number contain information for the beam at that position.</span>
<span class="sd">        </span>
<span class="sd">        If the list parameter is set to False, then the summary will not be written to</span>
<span class="sd">        the logger.  The return value of the method, in the &quot;header&quot; field is a vector</span>
<span class="sd">        string containing the formatted output that would have been logged in the</span>
<span class="sd">        list=True case.</span>
<span class="sd">        </span>
<span class="sd">        If verbose is True and the image contains multiple beams, the formatted output,</span>
<span class="sd">        whether it is written to the logger or placed in the output record, will have</span>
<span class="sd">        information on every beam in the dataset. If verbose=False and the image has</span>
<span class="sd">        multiple beams, only a summary of beams for each polarization is listed. In this</span>
<span class="sd">        case, the beams with the maximum area, the minimum area, and the median area for</span>
<span class="sd">        each polarization are listed. However, all the beams can still be found in the</span>
<span class="sd">        restoringbeam field of the returned dictionary. If the image does not have</span>
<span class="sd">        multiple beams, verbose is not used.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">summary</span><span class="p">(</span><span class="n">doppler</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="n">pixelorder</span><span class="p">,</span> <span class="n">verbose</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">tofits</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outfile</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">velocity</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">optical</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">bitpix</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="o">-</span><span class="mi">32</span><span class="p">),</span> <span class="n">minpix</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">maxpix</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">region</span><span class="o">=</span><span class="p">{</span> <span class="p">},</span> <span class="n">mask</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">dropdeg</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">deglast</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">dropstokes</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">stokeslast</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">wavelength</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">airwavelength</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">stretch</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">history</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function converts the image into a fits file.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        If the image has a rest frequency associated with it, it will always</span>
<span class="sd">        write velocity information into the fits file.  By default the</span>
<span class="sd">        frequency information will be primary as it is the internal native format.</span>
<span class="sd">        If you select {stfaf velocity=T} then by default</span>
<span class="sd">        the velocity is written in the optical convention, but if {stfaf</span>
<span class="sd">        optical=F} it will use the radio convention instead.</span>
<span class="sd">        Alternatively, if you use  {stfaf velocity=F} and {stfaf wavelength=T},</span>
<span class="sd">        the spectral axis will be written in wavelength.</span>
<span class="sd">        </span>
<span class="sd">        The fits definition demands equal increment pixels.  Therefore, if you</span>
<span class="sd">        write wavelength or optical velocity information as primary, the increment</span>
<span class="sd">        is computed at the spectral reference pixel.</span>
<span class="sd">        If the bandwidth is large, this may incur non-negligible coordinate</span>
<span class="sd">        calculation errors far from the reference pixel if the spectral</span>
<span class="sd">        bins are not originally equidistant in wavelength.</span>
<span class="sd">        Images generated by the CASA clean task have spectral axes which</span>
<span class="sd">        are always equidistant in frequency.</span>
<span class="sd">        </span>
<span class="sd">        By default the image is written as a floating point fits file</span>
<span class="sd">        ({stfaf bitpix= -32}).  Under rare circumstances you might want to</span>
<span class="sd">        save space and write it as scaled 16 bit integers ({stfaf bitpix =</span>
<span class="sd">        16}).  You can have {stff tofits} calculate the scaling factors by</span>
<span class="sd">        using the default {stfaf minpix} and {stfaf maxpix}.  If you set</span>
<span class="sd">        {stfaf minpix} and {stfaf maxpix}, values outside of that range will</span>
<span class="sd">        be truncated.  This can be useful if all of the fits images dynamic</span>
<span class="sd">        range is being used by a few high or low values and you are not</span>
<span class="sd">        interested in preserving those values exactly.  Besides the factor of</span>
<span class="sd">        two space savings you get by using 16 instead of 32 bits, integer</span>
<span class="sd">        images usually also compress well (for example, with the standard GNU</span>
<span class="sd">        software facility {tt gzip}).</span>
<span class="sd">        </span>
<span class="sd">        If the specified region extends beyond the image, it is truncated.</span>
<span class="sd">        </span>
<span class="sd">        The output mask is the combination (logical OR) of the default input</span>
<span class="sd">        pixelmask (if any) and the OTF mask.</span>
<span class="sd">        </span>
<span class="sd">        Sometimes it is useful to drop axes of length one (degenerate axes)</span>
<span class="sd">        because not all FITS readers can handle them.  Use the {stfaf dropdeg}</span>
<span class="sd">        argument if you want to do this.</span>
<span class="sd">        If you want to specifically only drop a degenerate Stokes axis, use the {stfaf dropstokes}</span>
<span class="sd">        argument.</span>
<span class="sd">        </span>
<span class="sd">        If you want to place degenerate axes last in the FITS header,</span>
<span class="sd">        use the {stfaf deglast} argument.</span>
<span class="sd">        If you want to make sure that the Stokes axis is placed last in the FITS header,</span>
<span class="sd">        use the {stfaf stokeslast} argument.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">tofits</span><span class="p">(</span><span class="n">outfile</span><span class="p">,</span> <span class="n">velocity</span><span class="p">,</span> <span class="n">optical</span><span class="p">,</span> <span class="n">bitpix</span><span class="p">,</span> <span class="n">minpix</span><span class="p">,</span> <span class="n">maxpix</span><span class="p">,</span> <span class="n">region</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">overwrite</span><span class="p">,</span> <span class="n">dropdeg</span><span class="p">,</span> <span class="n">deglast</span><span class="p">,</span> <span class="n">dropstokes</span><span class="p">,</span> <span class="n">stokeslast</span><span class="p">,</span> <span class="n">wavelength</span><span class="p">,</span> <span class="n">airwavelength</span><span class="p">,</span> <span class="n">stretch</span><span class="p">,</span> <span class="n">history</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">torecord</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;You can convert an associated image to a record for manipulation or passing it</span>
<span class="sd">        to inputs of other methods of other tools. This method and fromrecord() are used</span>
<span class="sd">        for serialization and deserialization.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">torecord</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function returns the string &#39;image&#39;.  It can be used in</span>
<span class="sd">        a script to make sure this variable is an Image</span>
<span class="sd">        tool.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">type</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">topixel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="p">[</span> <span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This method converts from world to pixel coordinates. The world coordinate can</span>
<span class="sd">        be provided in many formats (numeric, string, quantum etc.) via the value</span>
<span class="sd">        parameter.  These match the output of the toworld() method.</span>
<span class="sd">        </span>
<span class="sd">        This function is just a wrapper for the coordsys tool method of the same name,</span>
<span class="sd">        so see that documentation for a description and more examples.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">topixel</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">toworld</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;n&#39;</span><span class="p">,</span> <span class="n">dovelocity</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This method converts between pixel and world coordinates. A variety of return</span>
<span class="sd">        formats is supported. If format=&#39;n&#39;, numerical values are returned.</span>
<span class="sd">        If format=&#39;q&#39;, values formatted as quantities are returned. If format=&#39;s&#39;,</span>
<span class="sd">        values formatted as strings are returned. If format=&#39;m&#39;, values formatted as</span>
<span class="sd">        measures are returned. If format=&#39;m&#39;, one can choose to have the corresponding</span>
<span class="sd">        velcocites of an extant spectral coordinate computed as well by specifyting</span>
<span class="sd">        dovelocity=True (dovelocity is ignored if format is not equal to &#39;m&#39; or if the</span>
<span class="sd">        image does not have a spectral coordinate).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">toworld</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">format</span><span class="p">,</span> <span class="n">dovelocity</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">unlock</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function releases any lock set on the imagefile (and also flushes</span>
<span class="sd">        any outstanding I/O to disk).  It is not of general user interest.  It</span>
<span class="sd">        can be useful in scripts when a file is being shared between more than</span>
<span class="sd">        one process.  See also functions lock and</span>
<span class="sd">        haslock.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">unlock</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">newimagefromarray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outfile</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">pixels</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">csys</span><span class="o">=</span><span class="p">{</span> <span class="p">},</span> <span class="n">linear</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s1">&#39;f&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This application converts a numpy array of any size into a CASA image.</span>
<span class="sd">        </span>
<span class="sd">        If outfile is specified, the image is written to the specified</span>
<span class="sd">        (persistent) disk file.  If outfile is unset, the returned image tool</span>
<span class="sd">        is associated with a temporary image.  This temporary image may be in</span>
<span class="sd">        memory or on disk, depending on its size. In this case, when the</span>
<span class="sd">        close() or done() method is called on the returned image tool, the</span>
<span class="sd">        associated temporary image is deleted.</span>
<span class="sd">        </span>
<span class="sd">        The type parameter controls the data type/precision of the pixel values of the</span>
<span class="sd">        created image. &#39;f&#39; indicates that float precision point (32 bit precision) pixel</span>
<span class="sd">        values should be writted. &#39;d&#39; indicates that double precision (64 bit precision)</span>
<span class="sd">        pixel values should be written. If the input array has complex (as opposed to</span>
<span class="sd">        real) values, then complex pixel values, with each of the real and imaginary</span>
<span class="sd">        parts having the specified precision, will be written. Array values will be cast</span>
<span class="sd">        automatically to the specified precision, so that the precision of the input</span>
<span class="sd">        array values may be increased, decreased, or unchanged depending on the input</span>
<span class="sd">        array type.</span>
<span class="sd">        </span>
<span class="sd">        The coordinate system, provided as a a dictionary (use eg, cs.torecord() to do</span>
<span class="sd">        that), is optional. If specified, it must have the same number of dimensions</span>
<span class="sd">        as the pixels array. Call the naxes() method on the coordinate system tool to</span>
<span class="sd">        see how many dimensions the coordinate system has. A coordinate system can be</span>
<span class="sd">        created from scratch using the coordinate system (cs) tool and methods therein,</span>
<span class="sd">        but often users prefer to use a coordinate system from an already existing image.</span>
<span class="sd">        This can be gotten using ia.coordsys() which returns a coordinate system tool.</span>
<span class="sd">        A torecord() call on that tool will result in a python dictionary describing</span>
<span class="sd">        the coordinate system which is the necessary format for the csys input parameter</span>
<span class="sd">        of ia.fromarray().</span>
<span class="sd">        </span>
<span class="sd">        If csys is not specified, a default coordinate system will be created. If</span>
<span class="sd">        linear=False (the default), the created coordinate system will have standard</span>
<span class="sd">        RA/DEC/Stokes/Spectral Coordinate axes depending upon the shape of the pixels</span>
<span class="sd">        array (Stokes axis must be no longer than 4 pixels and the spectral axis may</span>
<span class="sd">        precede the Stokes axis if eg, shape=[64,64,32,4]. Extra dimensions are given</span>
<span class="sd">        linear coordinates.  If linear=True, then all the resulting coordinates</span>
<span class="sd">        are linear with the axes represent lengths. In this case each axis will have a</span>
<span class="sd">        value of 0.0 at its center pixel. The increment of each axis will be 1.0 km.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_wrap_image</span><span class="p">(</span><span class="n">swig_object</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">newimagefromarray</span><span class="p">(</span><span class="n">outfile</span><span class="p">,</span> <span class="n">pixels</span><span class="p">,</span> <span class="n">csys</span><span class="p">,</span> <span class="n">linear</span><span class="p">,</span> <span class="n">overwrite</span><span class="p">,</span> <span class="n">log</span><span class="p">,</span> <span class="nb">type</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">newimagefromfits</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outfile</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">infile</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">whichrep</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">whichhdu</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">zeroblanks</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function is used to convert a FITS disk image file (Float,</span>
<span class="sd">        Double, Short, Long are supported) to an casa imagefile.  If</span>
<span class="sd">        {stfaf outfile} is given, the image is written to the specified disk</span>
<span class="sd">        file.  If {stfaf outfile} is unset, the on-the-fly Image tool</span>
<span class="sd">        returned by this function is associated with a temporary image.  This</span>
<span class="sd">        temporary image may be in memory or on disk, depending on its size.</span>
<span class="sd">        When you destroy the on-the-fly Image tool (with the done function) this</span>
<span class="sd">        temporary image is deleted.</span>
<span class="sd">        </span>
<span class="sd">        This function reads from the FITS primary array (when the image is at</span>
<span class="sd">        the beginning of the FITS file; {stfaf whichhdu=0}), or an image</span>
<span class="sd">        extension (when the image is elsewhere in the FITS file, {stfaf</span>
<span class="sd">        whichhdu $&gt;$ 0}).</span>
<span class="sd">        </span>
<span class="sd">        By default, any blanked pixels will be converted to a mask value which</span>
<span class="sd">        is false, and a pixel value that is NaN.  If you set {stfaf</span>
<span class="sd">        zeroblanks=T} then the pixel value will be zero rather than NaN.  The</span>
<span class="sd">        mask will still be set to false.  See the function</span>
<span class="sd">        replacemaskedpixels if you</span>
<span class="sd">        need to replace masked pixel values after you have created the image.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_wrap_image</span><span class="p">(</span><span class="n">swig_object</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">newimagefromfits</span><span class="p">(</span><span class="n">outfile</span><span class="p">,</span> <span class="n">infile</span><span class="p">,</span> <span class="n">whichrep</span><span class="p">,</span> <span class="n">whichhdu</span><span class="p">,</span> <span class="n">zeroblanks</span><span class="p">,</span> <span class="n">overwrite</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">newimagefromimage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">infile</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">outfile</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">region</span><span class="o">=</span><span class="p">{</span> <span class="p">},</span> <span class="n">mask</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">dropdeg</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function applies a region to a disk imagefile, creates a new</span>
<span class="sd">        imagefile containing the (sub)image, and associates a new imagetool</span>
<span class="sd">        with it.</span>
<span class="sd">        </span>
<span class="sd">        The input disk image file may be in native casa, fits (Float,</span>
<span class="sd">        Double, Short, Long are supported), or Miriad format.  Look</span>
<span class="sd">        htmlref{here}{IMAGES:FOREIGNIMAGES} for more information on foreign</span>
<span class="sd">        images.</span>
<span class="sd">        </span>
<span class="sd">        If {stfaf outfile} is given, the (sub)image is written to the specified</span>
<span class="sd">        disk file.</span>
<span class="sd">        </span>
<span class="sd">        If {stfaf outfile} is unset, the Image tool actually references the</span>
<span class="sd">        input image file.  So if you deleted the input image disk file, it</span>
<span class="sd">        would render this tool useless.  When you destroy this on-the-fly</span>
<span class="sd">        tool (with the done</span>
<span class="sd">        function) the reference connection is broken.</span>
<span class="sd">        </span>
<span class="sd">        Sometimes it is useful to drop axes of length one (degenerate axes).</span>
<span class="sd">        Use the {stfaf dropdeg} argument if you want to do this.</span>
<span class="sd">        </span>
<span class="sd">        The output mask is the combination (logical OR) of the default input</span>
<span class="sd">        pixelmask (if any) and the OTF mask.  Any other input pixelmasks</span>
<span class="sd">        will not be copied.  Use function</span>
<span class="sd">        maskhandler if you need to copy other</span>
<span class="sd">        masks too.</span>
<span class="sd">        </span>
<span class="sd">        See also the subimage function.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_wrap_image</span><span class="p">(</span><span class="n">swig_object</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">newimagefromimage</span><span class="p">(</span><span class="n">infile</span><span class="p">,</span> <span class="n">outfile</span><span class="p">,</span> <span class="n">region</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">dropdeg</span><span class="p">,</span> <span class="n">overwrite</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">newimagefromshape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outfile</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">[</span> <span class="nb">int</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">],</span> <span class="n">csys</span><span class="o">=</span><span class="p">{</span> <span class="p">},</span> <span class="n">linear</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s1">&#39;f&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function creates a CASA image with the specified shape. It is similar to</span>
<span class="sd">        ia.fromshape(), but instead returns a new image analysis tool attached to the</span>
<span class="sd">        new image, rather than attaching the new image to the current tool. All the</span>
<span class="sd">        pixel values in the image are set to 0. One may create an image with float</span>
<span class="sd">        precision pixels (type=&#39;f&#39;), complex float precision pixels (type=&#39;c&#39;), double</span>
<span class="sd">        precision pixels (type=&#39;d&#39;), or complex double precision pixels (&#39;cd&#39;). To use a</span>
<span class="sd">        numpy array of values to create an image, use ia.(newimage)fromarray(). To make</span>
<span class="sd">        a 2-D image from a packaged FITS file, use ia.maketestimage().</span>
<span class="sd">        </span>
<span class="sd">        If outfile is given, the image is written to the specified disk file.  If</span>
<span class="sd">        outfile is unset, the image analysis tool is associated with a temporary image.</span>
<span class="sd">        This temporary image may be in memory or on disk, depending on its size.  When</span>
<span class="sd">        you close the image analysis tool  (with the ia.close() method, the temporary</span>
<span class="sd">        image is deleted.</span>
<span class="sd">        </span>
<span class="sd">        The coordinate system, provided as a coordinate system tool record, is optional.</span>
<span class="sd">        If provided, it must be dimensionally consistent with the specified shape.</span>
<span class="sd">        </span>
<span class="sd">        If the coordinate system is not provided, a default coordinate system will be</span>
<span class="sd">        created.  If linear=False (the default), then it is a</span>
<span class="sd">        standard RA/DEC/Stokes/Spectral coordinate system depending exactly upon the</span>
<span class="sd">        shape (the Stokes axis must be no longer than 4 pixels and spectral axis may</span>
<span class="sd">        occur prior to the Stokes axis if eg, shape=[64,64,32,4]. Extra dimensions are</span>
<span class="sd">        given linear coordinates. If linear=True, then the coordinate system will have</span>
<span class="sd">        linear coordinates.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_wrap_image</span><span class="p">(</span><span class="n">swig_object</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">newimagefromshape</span><span class="p">(</span><span class="n">outfile</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">csys</span><span class="p">,</span> <span class="n">linear</span><span class="p">,</span> <span class="n">overwrite</span><span class="p">,</span> <span class="n">log</span><span class="p">,</span> <span class="nb">type</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">pbcor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pbimage</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">outfile</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">box</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">region</span><span class="o">=</span><span class="p">{</span> <span class="p">},</span> <span class="n">chans</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">stokes</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;divide&#39;</span><span class="p">,</span> <span class="n">cutoff</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="p">),</span> <span class="n">stretch</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Correct an image for primary beam attenuation using an image of the primary beam pattern.</span>
<span class="sd">        The primary beam pattern can be provided as an image, in which case 1. it must have the same</span>
<span class="sd">        shape as the input image and its coordinate system must be the same, or 2. it must</span>
<span class="sd">        be a 2-D image in which case its coordinate system must consist of a (2-D) direction</span>
<span class="sd">        coordinate which is the same as the direction coordinate in the input image and</span>
<span class="sd">        its direction plane must be the same shape as that of the input image. Alternatively,</span>
<span class="sd">        pbimage can be an array of pixel values in which case the same dimensionality and</span>
<span class="sd">        shape constraints apply.</span>
<span class="sd">        An image tool referencing the corrected image is returned. The corrected image will also</span>
<span class="sd">        be written to disk if outfile is not empty (and overwrite=True if outfile already exists).</span>
<span class="sd">        One can choose between dividing the image by the primary beam pattern (mode=&quot;divide&quot;) or</span>
<span class="sd">        multiplying the image by the primary beam pattern (mode=&quot;multiply&quot;). One can also choose</span>
<span class="sd">        to specify a cutoff limit for the primary beam pattern. For mode=&quot;divide&quot;, for all pixels</span>
<span class="sd">        below this cutoff in the primary beam pattern, the output image will be masked. In the</span>
<span class="sd">        case of mode=&quot;multiply&quot;, all pixels in the output will be masked corresponding to pixels</span>
<span class="sd">        with values greater than the cutoff in the primary beam pattern. A negative value for</span>
<span class="sd">        cutoff means that no cutoff will be applied, which is the default.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_wrap_image</span><span class="p">(</span><span class="n">swig_object</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">pbcor</span><span class="p">(</span><span class="n">pbimage</span><span class="p">,</span> <span class="n">outfile</span><span class="p">,</span> <span class="n">overwrite</span><span class="p">,</span> <span class="n">box</span><span class="p">,</span> <span class="n">region</span><span class="p">,</span> <span class="n">chans</span><span class="p">,</span> <span class="n">stokes</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">,</span> <span class="n">stretch</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">pixeltype</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This application returns the data type of the pixels of the attached image as a string.</span>
<span class="sd">        The possible values are: &quot;float&quot; which indicates real valued, floating point, 32 bit pixel</span>
<span class="sd">        values, &quot;complex&quot; which indicates complex valued, floating point, 32 bit (for each of the</span>
<span class="sd">        real and imaginary parts) pixel values, &quot;double&quot; which indicates real valued, floating</span>
<span class="sd">        point, 64 bit pixel values, and &quot;dcomplex&quot; which indicates complex valued, floating point,</span>
<span class="sd">        64 bit (for each of the real and imaginary parts) pixel values.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">pixeltype</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">pv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outfile</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">end</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">center</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">length</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">pa</span><span class="o">=</span><span class="p">[</span> <span class="p">],</span> <span class="n">width</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;arcsec&#39;</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">region</span><span class="o">=</span><span class="p">{</span> <span class="p">},</span> <span class="n">chans</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">stokes</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">stretch</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">wantreturn</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a position-velocity image by specifying either two points between which a slice is taken in the direction</span>
<span class="sd">        coordinate or a center, position angle, and length describing the slice. The spectral extent of the resulting image</span>
<span class="sd">        will be that provided by the region specification or the entire spectral range of the input image if no region is</span>
<span class="sd">        specified. One may not specify a region in direction space; that is accomplished by specifying the start and end</span>
<span class="sd">        points or the center, length, and position angle of the slice. The parameters start and end may be specified as two</span>
<span class="sd">        element arrays of numerical values, in which case these values will be interpreted as pixel locations in the input</span>
<span class="sd">        image. Alternatively, they may be expressed as arrays of two strings each representing the direction. These strings</span>
<span class="sd">        can either represent quantities (eg [&quot;40.5deg&quot;, &quot;0.5rad&quot;) or be sexigesimal format (eg [&quot;14h20m20.5s&quot;,&quot;-30d45m25.4s&quot;],</span>
<span class="sd">        [&quot;14:20:20.5s&quot;,&quot;-30.45.25.4&quot;]). In addition, they may be expressed as a single string containing the longitude and</span>
<span class="sd">        latitude values and optionally a reference frame value, eg &quot;J2000 14:20:20.5s -30.45.25.4&quot;. The center parameter is</span>
<span class="sd">        specified in the same way. The length parameter may be specified as a single numerical value, in which case it is</span>
<span class="sd">        interpreted as the length in pixels, or a valid quantity, in which case it must have units conformant with the direction</span>
<span class="sd">        axes units. The pa (position angle) parameter must be specified as a valid quantity with angular units. The position</span>
<span class="sd">        angle is interpreted in the usual astronomical sense; ie measured from north through east. Either start/end or</span>
<span class="sd">        center/pa/length must be specified; if a parameter from one of these sets is specified, a parameter from the other set may</span>
<span class="sd">        not be specified. In either case, the end points of the segment must fail within the input image, and they both must be at</span>
<span class="sd">        least 2 pixels from the edge of the input image to facilite rotation (see below).</span>
<span class="sd">        </span>
<span class="sd">        One may specify a width, which is the number of pixels centered along and perpendicular</span>
<span class="sd">        to the direction slice that are used for averaging along the slice. The width may be specified as an integer, in which</span>
<span class="sd">        case it must be positive and odd. Alternatively, it may be specified as a valid quantity string (eg, &quot;4arcsec&quot;) or</span>
<span class="sd">        quantity record (eg qa.quantity(&quot;4arcsec&quot;). In this case, units must be conformant to the direction axes units (usually</span>
<span class="sd">        angular units) and the specified quantity will be rounded up, if necessary, to the next highest equivalent odd integer number</span>
<span class="sd">        of pixels. The default value of 1 represents no averaging.</span>
<span class="sd">        A value of 3 means average one pixel on each side of the slice and the pixel on the slice.</span>
<span class="sd">        Note that this width is applied to pixels in the image after it has been rotated (see below for a description</span>
<span class="sd">        of the algorithm used). The end points of the specified segment must fail within the input</span>
<span class="sd">        image, and they both must be at least 2 pixels from the edge of the input image to facilite rotation (see below).</span>
<span class="sd">        </span>
<span class="sd">        One may specify the unit for the angular offset axis.</span>
<span class="sd">        </span>
<span class="sd">        A true value for the wantreturn parameter indicates that an image analysis tool attached to the created</span>
<span class="sd">        image should be returned. Nothing is returned if wantreturn is false, but then outfile should be specified</span>
<span class="sd">        (unless perhaps you are debugging).</span>
<span class="sd">        </span>
<span class="sd">        Internally, the image is first rotated, padding first if necessary to include relevant pixels that would otherwise</span>
<span class="sd">        be excluded by the rotation operation, so that the slice is horizontal, with the starting pixel left of the</span>
<span class="sd">        ending pixel. Then, the pixels within the specified width of the slice are averaged and the resulting image is</span>
<span class="sd">        written and/or returned. The output image has a linear coordinate in place of the direction coordinate of the</span>
<span class="sd">        input image, and the corresponding axis represents angular offset with the center pixel having a value of 0.</span>
<span class="sd">        </span>
<span class="sd">        The equivalent coordinate system, with a (usually) rotated direction coordinate (eg, RA and Dec) is written</span>
<span class="sd">        to the output image as a table record. It can be retrieved using the table tool as shown in the example below.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_wrap_image</span><span class="p">(</span><span class="n">swig_object</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">pv</span><span class="p">(</span><span class="n">outfile</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">center</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">pa</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">unit</span><span class="p">,</span> <span class="n">overwrite</span><span class="p">,</span> <span class="n">region</span><span class="p">,</span> <span class="n">chans</span><span class="p">,</span> <span class="n">stokes</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">stretch</span><span class="p">,</span> <span class="n">wantreturn</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">makearray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="mf">0.0</span><span class="p">),</span> <span class="n">shape</span><span class="o">=</span><span class="p">[</span> <span class="nb">int</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function takes two arguments. The first argument is the initial</span>
<span class="sd">        value for the new array.  The second is a vector giving the lengths of</span>
<span class="sd">        the dimensions of the array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">makearray</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">shape</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">isconform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns True if the shape, coordinate system, and axes order of the specified image</span>
<span class="sd">        matches the current image.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swigobj</span><span class="o">.</span><span class="n">isconform</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020–2024, Pipeline Dev. Team.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>