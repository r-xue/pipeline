

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>scipy.optimize._minimize &mdash; Pipeline unknown documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css?v=4ae1632d" />
      <link rel="stylesheet" type="text/css" href="../../../_static/custom_theme.css?v=678032d9" />

  
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=3f1b9271"></script>
      <script src="../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            Pipeline
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Releases etc.</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../releases.html">Past Releases</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../dependencies.html">Dependencies of <code class="docutils literal notranslate"><span class="pre">Pipeline</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../modular.html">Run the Pipeline in a Conda environment</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../apisummary.html">Pipeline Tasks (from autosummary)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../apisummary.html#full-list">Full List</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">TaskRef (create_docs.py)</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../_taskdocs/taskdocs.html">List of Heuristics Tasks (Pipeline 2023)</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Pipeline Heuristics</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../heuristics/field_parameter.html">Field parameter</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../heuristics/FlaggingTasks.html">Pipeline Flagging Tasks</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Developer Notes</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../develdocmd/ways_to_run_the_pipeline.html">Ways to run the Pipeline</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../develdocmd/comparing_pipeline_executions.html">Comparing pipeline executions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../develdocmd/building_the_pipeline.html">Building the pipeline</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../develdocmd/ALMA-Imaging-Workflow.html">ALMA interferometry imaging workflow</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../develdocmd/VLA-Imaging-Workflow.html">VLA interferometry imaging workflow</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../develdocmd/VLASS-SE-CONT-Imaging-Workflow.html">VLASS-SE-CONT imaging workflow</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../develdocmd/VLASS-SE-CUBE-Imaging-Workflow.html">VLASS-SE-CUBE imaging workflow</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../develdocmd/selfcal_workflow.html">VLASS Selfcal &amp; Restore workflows</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../develdocmd/pipeline_tests.html">Pipeline testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../develdocmd/DataType_Testing.html">DataType Testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../develdocmd/QA_scores.html">Pipeline Quality Assurance (QA) Score Class Design</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../develdocmd/DeveloperDocumentation.html">Pipeline developer documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../develdocmd/python3_conversion_notes.html">Python 3 conversion notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../develdocmd/recipes.html">Pipeline Recipes</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Pipeline Domain/Context (automodapi)</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../basics.html"><code class="docutils literal notranslate"><span class="pre">pipeline.domain</span></code> module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../basics.html#module-pipeline.infrastructure.launcher"><code class="docutils literal notranslate"><span class="pre">pipeline.infrastructure.launcher</span></code> module</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Pipeline Domain/Context (autosummary)</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../_autosummary/pipeline.domain.html">pipeline.domain</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../_autosummary/pipeline.infrastructure.launcher.html">pipeline.infrastructure.launcher</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Pipeline Task/Inputs/Results Classes</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../classes.html">Classes in <code class="docutils literal notranslate"><span class="pre">pipeline.h*.tasks</span></code> modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../classes.html#inheritance-diagrams">Inheritance Diagrams</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Examples Notes (from Jupyter Notebooks)</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/test1.html">test</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Example Notes (from .rst)</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/test2.html">Example 1</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">Pipeline</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">scipy.optimize._minimize</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for scipy.optimize._minimize</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Unified interfaces to minimization algorithms.</span>

<span class="sd">Functions</span>
<span class="sd">---------</span>
<span class="sd">- minimize : minimization of a function of several variables.</span>
<span class="sd">- minimize_scalar : minimization of a function of one variable.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;minimize&#39;</span><span class="p">,</span> <span class="s1">&#39;minimize_scalar&#39;</span><span class="p">]</span>


<span class="kn">from</span> <span class="nn">warnings</span> <span class="kn">import</span> <span class="n">warn</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="c1"># unconstrained minimization</span>
<span class="kn">from</span> <span class="nn">._optimize</span> <span class="kn">import</span> <span class="p">(</span><span class="n">_minimize_neldermead</span><span class="p">,</span> <span class="n">_minimize_powell</span><span class="p">,</span> <span class="n">_minimize_cg</span><span class="p">,</span>
                        <span class="n">_minimize_bfgs</span><span class="p">,</span> <span class="n">_minimize_newtoncg</span><span class="p">,</span>
                        <span class="n">_minimize_scalar_brent</span><span class="p">,</span> <span class="n">_minimize_scalar_bounded</span><span class="p">,</span>
                        <span class="n">_minimize_scalar_golden</span><span class="p">,</span> <span class="n">MemoizeJac</span><span class="p">,</span> <span class="n">OptimizeResult</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">._trustregion_dogleg</span> <span class="kn">import</span> <span class="n">_minimize_dogleg</span>
<span class="kn">from</span> <span class="nn">._trustregion_ncg</span> <span class="kn">import</span> <span class="n">_minimize_trust_ncg</span>
<span class="kn">from</span> <span class="nn">._trustregion_krylov</span> <span class="kn">import</span> <span class="n">_minimize_trust_krylov</span>
<span class="kn">from</span> <span class="nn">._trustregion_exact</span> <span class="kn">import</span> <span class="n">_minimize_trustregion_exact</span>
<span class="kn">from</span> <span class="nn">._trustregion_constr</span> <span class="kn">import</span> <span class="n">_minimize_trustregion_constr</span>

<span class="c1"># constrained minimization</span>
<span class="kn">from</span> <span class="nn">._lbfgsb_py</span> <span class="kn">import</span> <span class="n">_minimize_lbfgsb</span>
<span class="kn">from</span> <span class="nn">._tnc</span> <span class="kn">import</span> <span class="n">_minimize_tnc</span>
<span class="kn">from</span> <span class="nn">._cobyla_py</span> <span class="kn">import</span> <span class="n">_minimize_cobyla</span>
<span class="kn">from</span> <span class="nn">._slsqp_py</span> <span class="kn">import</span> <span class="n">_minimize_slsqp</span>
<span class="kn">from</span> <span class="nn">._constraints</span> <span class="kn">import</span> <span class="p">(</span><span class="n">old_bound_to_new</span><span class="p">,</span> <span class="n">new_bounds_to_old</span><span class="p">,</span>
                           <span class="n">old_constraint_to_new</span><span class="p">,</span> <span class="n">new_constraint_to_old</span><span class="p">,</span>
                           <span class="n">NonlinearConstraint</span><span class="p">,</span> <span class="n">LinearConstraint</span><span class="p">,</span> <span class="n">Bounds</span><span class="p">,</span>
                           <span class="n">PreparedConstraint</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">._differentiable_functions</span> <span class="kn">import</span> <span class="n">FD_METHODS</span>

<span class="n">MINIMIZE_METHODS</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;nelder-mead&#39;</span><span class="p">,</span> <span class="s1">&#39;powell&#39;</span><span class="p">,</span> <span class="s1">&#39;cg&#39;</span><span class="p">,</span> <span class="s1">&#39;bfgs&#39;</span><span class="p">,</span> <span class="s1">&#39;newton-cg&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;l-bfgs-b&#39;</span><span class="p">,</span> <span class="s1">&#39;tnc&#39;</span><span class="p">,</span> <span class="s1">&#39;cobyla&#39;</span><span class="p">,</span> <span class="s1">&#39;slsqp&#39;</span><span class="p">,</span> <span class="s1">&#39;trust-constr&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;dogleg&#39;</span><span class="p">,</span> <span class="s1">&#39;trust-ncg&#39;</span><span class="p">,</span> <span class="s1">&#39;trust-exact&#39;</span><span class="p">,</span> <span class="s1">&#39;trust-krylov&#39;</span><span class="p">]</span>

<span class="n">MINIMIZE_SCALAR_METHODS</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;brent&#39;</span><span class="p">,</span> <span class="s1">&#39;bounded&#39;</span><span class="p">,</span> <span class="s1">&#39;golden&#39;</span><span class="p">]</span>

<div class="viewcode-block" id="minimize">
<a class="viewcode-back" href="../../../_autosummary/pipeline.extern.tsys_contamination.minimize.html#pipeline.extern.tsys_contamination.minimize">[docs]</a>
<span class="k">def</span> <span class="nf">minimize</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(),</span> <span class="n">method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">jac</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">hess</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
             <span class="n">hessp</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">constraints</span><span class="o">=</span><span class="p">(),</span> <span class="n">tol</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
             <span class="n">callback</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Minimization of scalar function of one or more variables.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    fun : callable</span>
<span class="sd">        The objective function to be minimized.</span>

<span class="sd">            ``fun(x, *args) -&gt; float``</span>

<span class="sd">        where ``x`` is a 1-D array with shape (n,) and ``args``</span>
<span class="sd">        is a tuple of the fixed parameters needed to completely</span>
<span class="sd">        specify the function.</span>
<span class="sd">    x0 : ndarray, shape (n,)</span>
<span class="sd">        Initial guess. Array of real elements of size (n,),</span>
<span class="sd">        where ``n`` is the number of independent variables.</span>
<span class="sd">    args : tuple, optional</span>
<span class="sd">        Extra arguments passed to the objective function and its</span>
<span class="sd">        derivatives (`fun`, `jac` and `hess` functions).</span>
<span class="sd">    method : str or callable, optional</span>
<span class="sd">        Type of solver.  Should be one of</span>

<span class="sd">            - &#39;Nelder-Mead&#39; :ref:`(see here) &lt;optimize.minimize-neldermead&gt;`</span>
<span class="sd">            - &#39;Powell&#39;      :ref:`(see here) &lt;optimize.minimize-powell&gt;`</span>
<span class="sd">            - &#39;CG&#39;          :ref:`(see here) &lt;optimize.minimize-cg&gt;`</span>
<span class="sd">            - &#39;BFGS&#39;        :ref:`(see here) &lt;optimize.minimize-bfgs&gt;`</span>
<span class="sd">            - &#39;Newton-CG&#39;   :ref:`(see here) &lt;optimize.minimize-newtoncg&gt;`</span>
<span class="sd">            - &#39;L-BFGS-B&#39;    :ref:`(see here) &lt;optimize.minimize-lbfgsb&gt;`</span>
<span class="sd">            - &#39;TNC&#39;         :ref:`(see here) &lt;optimize.minimize-tnc&gt;`</span>
<span class="sd">            - &#39;COBYLA&#39;      :ref:`(see here) &lt;optimize.minimize-cobyla&gt;`</span>
<span class="sd">            - &#39;SLSQP&#39;       :ref:`(see here) &lt;optimize.minimize-slsqp&gt;`</span>
<span class="sd">            - &#39;trust-constr&#39;:ref:`(see here) &lt;optimize.minimize-trustconstr&gt;`</span>
<span class="sd">            - &#39;dogleg&#39;      :ref:`(see here) &lt;optimize.minimize-dogleg&gt;`</span>
<span class="sd">            - &#39;trust-ncg&#39;   :ref:`(see here) &lt;optimize.minimize-trustncg&gt;`</span>
<span class="sd">            - &#39;trust-exact&#39; :ref:`(see here) &lt;optimize.minimize-trustexact&gt;`</span>
<span class="sd">            - &#39;trust-krylov&#39; :ref:`(see here) &lt;optimize.minimize-trustkrylov&gt;`</span>
<span class="sd">            - custom - a callable object (added in version 0.14.0),</span>
<span class="sd">              see below for description.</span>

<span class="sd">        If not given, chosen to be one of ``BFGS``, ``L-BFGS-B``, ``SLSQP``,</span>
<span class="sd">        depending on whether or not the problem has constraints or bounds.</span>
<span class="sd">    jac : {callable,  &#39;2-point&#39;, &#39;3-point&#39;, &#39;cs&#39;, bool}, optional</span>
<span class="sd">        Method for computing the gradient vector. Only for CG, BFGS,</span>
<span class="sd">        Newton-CG, L-BFGS-B, TNC, SLSQP, dogleg, trust-ncg, trust-krylov,</span>
<span class="sd">        trust-exact and trust-constr.</span>
<span class="sd">        If it is a callable, it should be a function that returns the gradient</span>
<span class="sd">        vector:</span>

<span class="sd">            ``jac(x, *args) -&gt; array_like, shape (n,)``</span>

<span class="sd">        where ``x`` is an array with shape (n,) and ``args`` is a tuple with</span>
<span class="sd">        the fixed parameters. If `jac` is a Boolean and is True, `fun` is</span>
<span class="sd">        assumed to return a tuple ``(f, g)`` containing the objective</span>
<span class="sd">        function and the gradient.</span>
<span class="sd">        Methods &#39;Newton-CG&#39;, &#39;trust-ncg&#39;, &#39;dogleg&#39;, &#39;trust-exact&#39;, and</span>
<span class="sd">        &#39;trust-krylov&#39; require that either a callable be supplied, or that</span>
<span class="sd">        `fun` return the objective and gradient.</span>
<span class="sd">        If None or False, the gradient will be estimated using 2-point finite</span>
<span class="sd">        difference estimation with an absolute step size.</span>
<span class="sd">        Alternatively, the keywords  {&#39;2-point&#39;, &#39;3-point&#39;, &#39;cs&#39;} can be used</span>
<span class="sd">        to select a finite difference scheme for numerical estimation of the</span>
<span class="sd">        gradient with a relative step size. These finite difference schemes</span>
<span class="sd">        obey any specified `bounds`.</span>
<span class="sd">    hess : {callable, &#39;2-point&#39;, &#39;3-point&#39;, &#39;cs&#39;, HessianUpdateStrategy}, optional</span>
<span class="sd">        Method for computing the Hessian matrix. Only for Newton-CG, dogleg,</span>
<span class="sd">        trust-ncg, trust-krylov, trust-exact and trust-constr.</span>
<span class="sd">        If it is callable, it should return the Hessian matrix:</span>

<span class="sd">            ``hess(x, *args) -&gt; {LinearOperator, spmatrix, array}, (n, n)``</span>

<span class="sd">        where ``x`` is a (n,) ndarray and ``args`` is a tuple with the fixed</span>
<span class="sd">        parameters.</span>
<span class="sd">        The keywords {&#39;2-point&#39;, &#39;3-point&#39;, &#39;cs&#39;} can also be used to select</span>
<span class="sd">        a finite difference scheme for numerical estimation of the hessian.</span>
<span class="sd">        Alternatively, objects implementing the `HessianUpdateStrategy`</span>
<span class="sd">        interface can be used to approximate the Hessian. Available</span>
<span class="sd">        quasi-Newton methods implementing this interface are:</span>

<span class="sd">            - `BFGS`;</span>
<span class="sd">            - `SR1`.</span>

<span class="sd">        Not all of the options are available for each of the methods; for</span>
<span class="sd">        availability refer to the notes.</span>
<span class="sd">    hessp : callable, optional</span>
<span class="sd">        Hessian of objective function times an arbitrary vector p. Only for</span>
<span class="sd">        Newton-CG, trust-ncg, trust-krylov, trust-constr.</span>
<span class="sd">        Only one of `hessp` or `hess` needs to be given. If `hess` is</span>
<span class="sd">        provided, then `hessp` will be ignored. `hessp` must compute the</span>
<span class="sd">        Hessian times an arbitrary vector:</span>

<span class="sd">            ``hessp(x, p, *args) -&gt;  ndarray shape (n,)``</span>

<span class="sd">        where ``x`` is a (n,) ndarray, ``p`` is an arbitrary vector with</span>
<span class="sd">        dimension (n,) and ``args`` is a tuple with the fixed</span>
<span class="sd">        parameters.</span>
<span class="sd">    bounds : sequence or `Bounds`, optional</span>
<span class="sd">        Bounds on variables for Nelder-Mead, L-BFGS-B, TNC, SLSQP, Powell, and</span>
<span class="sd">        trust-constr methods. There are two ways to specify the bounds:</span>

<span class="sd">            1. Instance of `Bounds` class.</span>
<span class="sd">            2. Sequence of ``(min, max)`` pairs for each element in `x`. None</span>
<span class="sd">               is used to specify no bound.</span>

<span class="sd">    constraints : {Constraint, dict} or List of {Constraint, dict}, optional</span>
<span class="sd">        Constraints definition. Only for COBYLA, SLSQP and trust-constr.</span>

<span class="sd">        Constraints for &#39;trust-constr&#39; are defined as a single object or a</span>
<span class="sd">        list of objects specifying constraints to the optimization problem.</span>
<span class="sd">        Available constraints are:</span>

<span class="sd">            - `LinearConstraint`</span>
<span class="sd">            - `NonlinearConstraint`</span>

<span class="sd">        Constraints for COBYLA, SLSQP are defined as a list of dictionaries.</span>
<span class="sd">        Each dictionary with fields:</span>

<span class="sd">            type : str</span>
<span class="sd">                Constraint type: &#39;eq&#39; for equality, &#39;ineq&#39; for inequality.</span>
<span class="sd">            fun : callable</span>
<span class="sd">                The function defining the constraint.</span>
<span class="sd">            jac : callable, optional</span>
<span class="sd">                The Jacobian of `fun` (only for SLSQP).</span>
<span class="sd">            args : sequence, optional</span>
<span class="sd">                Extra arguments to be passed to the function and Jacobian.</span>

<span class="sd">        Equality constraint means that the constraint function result is to</span>
<span class="sd">        be zero whereas inequality means that it is to be non-negative.</span>
<span class="sd">        Note that COBYLA only supports inequality constraints.</span>
<span class="sd">    tol : float, optional</span>
<span class="sd">        Tolerance for termination. When `tol` is specified, the selected</span>
<span class="sd">        minimization algorithm sets some relevant solver-specific tolerance(s)</span>
<span class="sd">        equal to `tol`. For detailed control, use solver-specific</span>
<span class="sd">        options.</span>
<span class="sd">    options : dict, optional</span>
<span class="sd">        A dictionary of solver options. All methods accept the following</span>
<span class="sd">        generic options:</span>

<span class="sd">            maxiter : int</span>
<span class="sd">                Maximum number of iterations to perform. Depending on the</span>
<span class="sd">                method each iteration may use several function evaluations.</span>
<span class="sd">            disp : bool</span>
<span class="sd">                Set to True to print convergence messages.</span>

<span class="sd">        For method-specific options, see :func:`show_options()`.</span>
<span class="sd">    callback : callable, optional</span>
<span class="sd">        Called after each iteration. For &#39;trust-constr&#39; it is a callable with</span>
<span class="sd">        the signature:</span>

<span class="sd">            ``callback(xk, OptimizeResult state) -&gt; bool``</span>

<span class="sd">        where ``xk`` is the current parameter vector. and ``state``</span>
<span class="sd">        is an `OptimizeResult` object, with the same fields</span>
<span class="sd">        as the ones from the return. If callback returns True</span>
<span class="sd">        the algorithm execution is terminated.</span>
<span class="sd">        For all the other methods, the signature is:</span>

<span class="sd">            ``callback(xk)``</span>

<span class="sd">        where ``xk`` is the current parameter vector.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    res : OptimizeResult</span>
<span class="sd">        The optimization result represented as a ``OptimizeResult`` object.</span>
<span class="sd">        Important attributes are: ``x`` the solution array, ``success`` a</span>
<span class="sd">        Boolean flag indicating if the optimizer exited successfully and</span>
<span class="sd">        ``message`` which describes the cause of the termination. See</span>
<span class="sd">        `OptimizeResult` for a description of other attributes.</span>

<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    minimize_scalar : Interface to minimization algorithms for scalar</span>
<span class="sd">        univariate functions</span>
<span class="sd">    show_options : Additional options accepted by the solvers</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This section describes the available solvers that can be selected by the</span>
<span class="sd">    &#39;method&#39; parameter. The default method is *BFGS*.</span>

<span class="sd">    **Unconstrained minimization**</span>

<span class="sd">    Method :ref:`CG &lt;optimize.minimize-cg&gt;` uses a nonlinear conjugate</span>
<span class="sd">    gradient algorithm by Polak and Ribiere, a variant of the</span>
<span class="sd">    Fletcher-Reeves method described in [5]_ pp.120-122. Only the</span>
<span class="sd">    first derivatives are used.</span>

<span class="sd">    Method :ref:`BFGS &lt;optimize.minimize-bfgs&gt;` uses the quasi-Newton</span>
<span class="sd">    method of Broyden, Fletcher, Goldfarb, and Shanno (BFGS) [5]_</span>
<span class="sd">    pp. 136. It uses the first derivatives only. BFGS has proven good</span>
<span class="sd">    performance even for non-smooth optimizations. This method also</span>
<span class="sd">    returns an approximation of the Hessian inverse, stored as</span>
<span class="sd">    `hess_inv` in the OptimizeResult object.</span>

<span class="sd">    Method :ref:`Newton-CG &lt;optimize.minimize-newtoncg&gt;` uses a</span>
<span class="sd">    Newton-CG algorithm [5]_ pp. 168 (also known as the truncated</span>
<span class="sd">    Newton method). It uses a CG method to the compute the search</span>
<span class="sd">    direction. See also *TNC* method for a box-constrained</span>
<span class="sd">    minimization with a similar algorithm. Suitable for large-scale</span>
<span class="sd">    problems.</span>

<span class="sd">    Method :ref:`dogleg &lt;optimize.minimize-dogleg&gt;` uses the dog-leg</span>
<span class="sd">    trust-region algorithm [5]_ for unconstrained minimization. This</span>
<span class="sd">    algorithm requires the gradient and Hessian; furthermore the</span>
<span class="sd">    Hessian is required to be positive definite.</span>

<span class="sd">    Method :ref:`trust-ncg &lt;optimize.minimize-trustncg&gt;` uses the</span>
<span class="sd">    Newton conjugate gradient trust-region algorithm [5]_ for</span>
<span class="sd">    unconstrained minimization. This algorithm requires the gradient</span>
<span class="sd">    and either the Hessian or a function that computes the product of</span>
<span class="sd">    the Hessian with a given vector. Suitable for large-scale problems.</span>

<span class="sd">    Method :ref:`trust-krylov &lt;optimize.minimize-trustkrylov&gt;` uses</span>
<span class="sd">    the Newton GLTR trust-region algorithm [14]_, [15]_ for unconstrained</span>
<span class="sd">    minimization. This algorithm requires the gradient</span>
<span class="sd">    and either the Hessian or a function that computes the product of</span>
<span class="sd">    the Hessian with a given vector. Suitable for large-scale problems.</span>
<span class="sd">    On indefinite problems it requires usually less iterations than the</span>
<span class="sd">    `trust-ncg` method and is recommended for medium and large-scale problems.</span>

<span class="sd">    Method :ref:`trust-exact &lt;optimize.minimize-trustexact&gt;`</span>
<span class="sd">    is a trust-region method for unconstrained minimization in which</span>
<span class="sd">    quadratic subproblems are solved almost exactly [13]_. This</span>
<span class="sd">    algorithm requires the gradient and the Hessian (which is</span>
<span class="sd">    *not* required to be positive definite). It is, in many</span>
<span class="sd">    situations, the Newton method to converge in fewer iterations</span>
<span class="sd">    and the most recommended for small and medium-size problems.</span>

<span class="sd">    **Bound-Constrained minimization**</span>

<span class="sd">    Method :ref:`Nelder-Mead &lt;optimize.minimize-neldermead&gt;` uses the</span>
<span class="sd">    Simplex algorithm [1]_, [2]_. This algorithm is robust in many</span>
<span class="sd">    applications. However, if numerical computation of derivative can be</span>
<span class="sd">    trusted, other algorithms using the first and/or second derivatives</span>
<span class="sd">    information might be preferred for their better performance in</span>
<span class="sd">    general.</span>

<span class="sd">    Method :ref:`L-BFGS-B &lt;optimize.minimize-lbfgsb&gt;` uses the L-BFGS-B</span>
<span class="sd">    algorithm [6]_, [7]_ for bound constrained minimization.</span>

<span class="sd">    Method :ref:`Powell &lt;optimize.minimize-powell&gt;` is a modification</span>
<span class="sd">    of Powell&#39;s method [3]_, [4]_ which is a conjugate direction</span>
<span class="sd">    method. It performs sequential one-dimensional minimizations along</span>
<span class="sd">    each vector of the directions set (`direc` field in `options` and</span>
<span class="sd">    `info`), which is updated at each iteration of the main</span>
<span class="sd">    minimization loop. The function need not be differentiable, and no</span>
<span class="sd">    derivatives are taken. If bounds are not provided, then an</span>
<span class="sd">    unbounded line search will be used. If bounds are provided and</span>
<span class="sd">    the initial guess is within the bounds, then every function</span>
<span class="sd">    evaluation throughout the minimization procedure will be within</span>
<span class="sd">    the bounds. If bounds are provided, the initial guess is outside</span>
<span class="sd">    the bounds, and `direc` is full rank (default has full rank), then</span>
<span class="sd">    some function evaluations during the first iteration may be</span>
<span class="sd">    outside the bounds, but every function evaluation after the first</span>
<span class="sd">    iteration will be within the bounds. If `direc` is not full rank,</span>
<span class="sd">    then some parameters may not be optimized and the solution is not</span>
<span class="sd">    guaranteed to be within the bounds.</span>

<span class="sd">    Method :ref:`TNC &lt;optimize.minimize-tnc&gt;` uses a truncated Newton</span>
<span class="sd">    algorithm [5]_, [8]_ to minimize a function with variables subject</span>
<span class="sd">    to bounds. This algorithm uses gradient information; it is also</span>
<span class="sd">    called Newton Conjugate-Gradient. It differs from the *Newton-CG*</span>
<span class="sd">    method described above as it wraps a C implementation and allows</span>
<span class="sd">    each variable to be given upper and lower bounds.</span>

<span class="sd">    **Constrained Minimization**</span>

<span class="sd">    Method :ref:`COBYLA &lt;optimize.minimize-cobyla&gt;` uses the</span>
<span class="sd">    Constrained Optimization BY Linear Approximation (COBYLA) method</span>
<span class="sd">    [9]_, [10]_, [11]_. The algorithm is based on linear</span>
<span class="sd">    approximations to the objective function and each constraint. The</span>
<span class="sd">    method wraps a FORTRAN implementation of the algorithm. The</span>
<span class="sd">    constraints functions &#39;fun&#39; may return either a single number</span>
<span class="sd">    or an array or list of numbers.</span>

<span class="sd">    Method :ref:`SLSQP &lt;optimize.minimize-slsqp&gt;` uses Sequential</span>
<span class="sd">    Least SQuares Programming to minimize a function of several</span>
<span class="sd">    variables with any combination of bounds, equality and inequality</span>
<span class="sd">    constraints. The method wraps the SLSQP Optimization subroutine</span>
<span class="sd">    originally implemented by Dieter Kraft [12]_. Note that the</span>
<span class="sd">    wrapper handles infinite values in bounds by converting them into</span>
<span class="sd">    large floating values.</span>

<span class="sd">    Method :ref:`trust-constr &lt;optimize.minimize-trustconstr&gt;` is a</span>
<span class="sd">    trust-region algorithm for constrained optimization. It swiches</span>
<span class="sd">    between two implementations depending on the problem definition.</span>
<span class="sd">    It is the most versatile constrained minimization algorithm</span>
<span class="sd">    implemented in SciPy and the most appropriate for large-scale problems.</span>
<span class="sd">    For equality constrained problems it is an implementation of Byrd-Omojokun</span>
<span class="sd">    Trust-Region SQP method described in [17]_ and in [5]_, p. 549. When</span>
<span class="sd">    inequality constraints are imposed as well, it swiches to the trust-region</span>
<span class="sd">    interior point method described in [16]_. This interior point algorithm,</span>
<span class="sd">    in turn, solves inequality constraints by introducing slack variables</span>
<span class="sd">    and solving a sequence of equality-constrained barrier problems</span>
<span class="sd">    for progressively smaller values of the barrier parameter.</span>
<span class="sd">    The previously described equality constrained SQP method is</span>
<span class="sd">    used to solve the subproblems with increasing levels of accuracy</span>
<span class="sd">    as the iterate gets closer to a solution.</span>

<span class="sd">    **Finite-Difference Options**</span>

<span class="sd">    For Method :ref:`trust-constr &lt;optimize.minimize-trustconstr&gt;`</span>
<span class="sd">    the gradient and the Hessian may be approximated using</span>
<span class="sd">    three finite-difference schemes: {&#39;2-point&#39;, &#39;3-point&#39;, &#39;cs&#39;}.</span>
<span class="sd">    The scheme &#39;cs&#39; is, potentially, the most accurate but it</span>
<span class="sd">    requires the function to correctly handle complex inputs and to</span>
<span class="sd">    be differentiable in the complex plane. The scheme &#39;3-point&#39; is more</span>
<span class="sd">    accurate than &#39;2-point&#39; but requires twice as many operations. If the</span>
<span class="sd">    gradient is estimated via finite-differences the Hessian must be</span>
<span class="sd">    estimated using one of the quasi-Newton strategies.</span>

<span class="sd">    **Method specific options for the** `hess` **keyword**</span>

<span class="sd">    +--------------+------+----------+-------------------------+-----+</span>
<span class="sd">    | method/Hess  | None | callable | &#39;2-point/&#39;3-point&#39;/&#39;cs&#39; | HUS |</span>
<span class="sd">    +==============+======+==========+=========================+=====+</span>
<span class="sd">    | Newton-CG    | x    | (n, n)   | x                       | x   |</span>
<span class="sd">    |              |      | LO       |                         |     |</span>
<span class="sd">    +--------------+------+----------+-------------------------+-----+</span>
<span class="sd">    | dogleg       |      | (n, n)   |                         |     |</span>
<span class="sd">    +--------------+------+----------+-------------------------+-----+</span>
<span class="sd">    | trust-ncg    |      | (n, n)   | x                       | x   |</span>
<span class="sd">    +--------------+------+----------+-------------------------+-----+</span>
<span class="sd">    | trust-krylov |      | (n, n)   | x                       | x   |</span>
<span class="sd">    +--------------+------+----------+-------------------------+-----+</span>
<span class="sd">    | trust-exact  |      | (n, n)   |                         |     |</span>
<span class="sd">    +--------------+------+----------+-------------------------+-----+</span>
<span class="sd">    | trust-constr | x    | (n, n)   |  x                      | x   |</span>
<span class="sd">    |              |      | LO       |                         |     |</span>
<span class="sd">    |              |      | sp       |                         |     |</span>
<span class="sd">    +--------------+------+----------+-------------------------+-----+</span>

<span class="sd">    where LO=LinearOperator, sp=Sparse matrix, HUS=HessianUpdateStrategy</span>

<span class="sd">    **Custom minimizers**</span>

<span class="sd">    It may be useful to pass a custom minimization method, for example</span>
<span class="sd">    when using a frontend to this method such as `scipy.optimize.basinhopping`</span>
<span class="sd">    or a different library.  You can simply pass a callable as the ``method``</span>
<span class="sd">    parameter.</span>

<span class="sd">    The callable is called as ``method(fun, x0, args, **kwargs, **options)``</span>
<span class="sd">    where ``kwargs`` corresponds to any other parameters passed to `minimize`</span>
<span class="sd">    (such as `callback`, `hess`, etc.), except the `options` dict, which has</span>
<span class="sd">    its contents also passed as `method` parameters pair by pair.  Also, if</span>
<span class="sd">    `jac` has been passed as a bool type, `jac` and `fun` are mangled so that</span>
<span class="sd">    `fun` returns just the function values and `jac` is converted to a function</span>
<span class="sd">    returning the Jacobian.  The method shall return an `OptimizeResult`</span>
<span class="sd">    object.</span>

<span class="sd">    The provided `method` callable must be able to accept (and possibly ignore)</span>
<span class="sd">    arbitrary parameters; the set of parameters accepted by `minimize` may</span>
<span class="sd">    expand in future versions and then these parameters will be passed to</span>
<span class="sd">    the method.  You can find an example in the scipy.optimize tutorial.</span>

<span class="sd">    .. versionadded:: 0.11.0</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Nelder, J A, and R Mead. 1965. A Simplex Method for Function</span>
<span class="sd">        Minimization. The Computer Journal 7: 308-13.</span>
<span class="sd">    .. [2] Wright M H. 1996. Direct search methods: Once scorned, now</span>
<span class="sd">        respectable, in Numerical Analysis 1995: Proceedings of the 1995</span>
<span class="sd">        Dundee Biennial Conference in Numerical Analysis (Eds. D F</span>
<span class="sd">        Griffiths and G A Watson). Addison Wesley Longman, Harlow, UK.</span>
<span class="sd">        191-208.</span>
<span class="sd">    .. [3] Powell, M J D. 1964. An efficient method for finding the minimum of</span>
<span class="sd">       a function of several variables without calculating derivatives. The</span>
<span class="sd">       Computer Journal 7: 155-162.</span>
<span class="sd">    .. [4] Press W, S A Teukolsky, W T Vetterling and B P Flannery.</span>
<span class="sd">       Numerical Recipes (any edition), Cambridge University Press.</span>
<span class="sd">    .. [5] Nocedal, J, and S J Wright. 2006. Numerical Optimization.</span>
<span class="sd">       Springer New York.</span>
<span class="sd">    .. [6] Byrd, R H and P Lu and J. Nocedal. 1995. A Limited Memory</span>
<span class="sd">       Algorithm for Bound Constrained Optimization. SIAM Journal on</span>
<span class="sd">       Scientific and Statistical Computing 16 (5): 1190-1208.</span>
<span class="sd">    .. [7] Zhu, C and R H Byrd and J Nocedal. 1997. L-BFGS-B: Algorithm</span>
<span class="sd">       778: L-BFGS-B, FORTRAN routines for large scale bound constrained</span>
<span class="sd">       optimization. ACM Transactions on Mathematical Software 23 (4):</span>
<span class="sd">       550-560.</span>
<span class="sd">    .. [8] Nash, S G. Newton-Type Minimization Via the Lanczos Method.</span>
<span class="sd">       1984. SIAM Journal of Numerical Analysis 21: 770-778.</span>
<span class="sd">    .. [9] Powell, M J D. A direct search optimization method that models</span>
<span class="sd">       the objective and constraint functions by linear interpolation.</span>
<span class="sd">       1994. Advances in Optimization and Numerical Analysis, eds. S. Gomez</span>
<span class="sd">       and J-P Hennart, Kluwer Academic (Dordrecht), 51-67.</span>
<span class="sd">    .. [10] Powell M J D. Direct search algorithms for optimization</span>
<span class="sd">       calculations. 1998. Acta Numerica 7: 287-336.</span>
<span class="sd">    .. [11] Powell M J D. A view of algorithms for optimization without</span>
<span class="sd">       derivatives. 2007.Cambridge University Technical Report DAMTP</span>
<span class="sd">       2007/NA03</span>
<span class="sd">    .. [12] Kraft, D. A software package for sequential quadratic</span>
<span class="sd">       programming. 1988. Tech. Rep. DFVLR-FB 88-28, DLR German Aerospace</span>
<span class="sd">       Center -- Institute for Flight Mechanics, Koln, Germany.</span>
<span class="sd">    .. [13] Conn, A. R., Gould, N. I., and Toint, P. L.</span>
<span class="sd">       Trust region methods. 2000. Siam. pp. 169-200.</span>
<span class="sd">    .. [14] F. Lenders, C. Kirches, A. Potschka: &quot;trlib: A vector-free</span>
<span class="sd">       implementation of the GLTR method for iterative solution of</span>
<span class="sd">       the trust region problem&quot;, :arxiv:`1611.04718`</span>
<span class="sd">    .. [15] N. Gould, S. Lucidi, M. Roma, P. Toint: &quot;Solving the</span>
<span class="sd">       Trust-Region Subproblem using the Lanczos Method&quot;,</span>
<span class="sd">       SIAM J. Optim., 9(2), 504--525, (1999).</span>
<span class="sd">    .. [16] Byrd, Richard H., Mary E. Hribar, and Jorge Nocedal. 1999.</span>
<span class="sd">        An interior point algorithm for large-scale nonlinear  programming.</span>
<span class="sd">        SIAM Journal on Optimization 9.4: 877-900.</span>
<span class="sd">    .. [17] Lalee, Marucha, Jorge Nocedal, and Todd Plantega. 1998. On the</span>
<span class="sd">        implementation of an algorithm for large-scale equality constrained</span>
<span class="sd">        optimization. SIAM Journal on Optimization 8.3: 682-706.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Let us consider the problem of minimizing the Rosenbrock function. This</span>
<span class="sd">    function (and its respective derivatives) is implemented in `rosen`</span>
<span class="sd">    (resp. `rosen_der`, `rosen_hess`) in the `scipy.optimize`.</span>

<span class="sd">    &gt;&gt;&gt; from scipy.optimize import minimize, rosen, rosen_der</span>

<span class="sd">    A simple application of the *Nelder-Mead* method is:</span>

<span class="sd">    &gt;&gt;&gt; x0 = [1.3, 0.7, 0.8, 1.9, 1.2]</span>
<span class="sd">    &gt;&gt;&gt; res = minimize(rosen, x0, method=&#39;Nelder-Mead&#39;, tol=1e-6)</span>
<span class="sd">    &gt;&gt;&gt; res.x</span>
<span class="sd">    array([ 1.,  1.,  1.,  1.,  1.])</span>

<span class="sd">    Now using the *BFGS* algorithm, using the first derivative and a few</span>
<span class="sd">    options:</span>

<span class="sd">    &gt;&gt;&gt; res = minimize(rosen, x0, method=&#39;BFGS&#39;, jac=rosen_der,</span>
<span class="sd">    ...                options={&#39;gtol&#39;: 1e-6, &#39;disp&#39;: True})</span>
<span class="sd">    Optimization terminated successfully.</span>
<span class="sd">             Current function value: 0.000000</span>
<span class="sd">             Iterations: 26</span>
<span class="sd">             Function evaluations: 31</span>
<span class="sd">             Gradient evaluations: 31</span>
<span class="sd">    &gt;&gt;&gt; res.x</span>
<span class="sd">    array([ 1.,  1.,  1.,  1.,  1.])</span>
<span class="sd">    &gt;&gt;&gt; print(res.message)</span>
<span class="sd">    Optimization terminated successfully.</span>
<span class="sd">    &gt;&gt;&gt; res.hess_inv</span>
<span class="sd">    array([[ 0.00749589,  0.01255155,  0.02396251,  0.04750988,  0.09495377],  # may vary</span>
<span class="sd">           [ 0.01255155,  0.02510441,  0.04794055,  0.09502834,  0.18996269],</span>
<span class="sd">           [ 0.02396251,  0.04794055,  0.09631614,  0.19092151,  0.38165151],</span>
<span class="sd">           [ 0.04750988,  0.09502834,  0.19092151,  0.38341252,  0.7664427 ],</span>
<span class="sd">           [ 0.09495377,  0.18996269,  0.38165151,  0.7664427,   1.53713523]])</span>


<span class="sd">    Next, consider a minimization problem with several constraints (namely</span>
<span class="sd">    Example 16.4 from [5]_). The objective function is:</span>

<span class="sd">    &gt;&gt;&gt; fun = lambda x: (x[0] - 1)**2 + (x[1] - 2.5)**2</span>

<span class="sd">    There are three constraints defined as:</span>

<span class="sd">    &gt;&gt;&gt; cons = ({&#39;type&#39;: &#39;ineq&#39;, &#39;fun&#39;: lambda x:  x[0] - 2 * x[1] + 2},</span>
<span class="sd">    ...         {&#39;type&#39;: &#39;ineq&#39;, &#39;fun&#39;: lambda x: -x[0] - 2 * x[1] + 6},</span>
<span class="sd">    ...         {&#39;type&#39;: &#39;ineq&#39;, &#39;fun&#39;: lambda x: -x[0] + 2 * x[1] + 2})</span>

<span class="sd">    And variables must be positive, hence the following bounds:</span>

<span class="sd">    &gt;&gt;&gt; bnds = ((0, None), (0, None))</span>

<span class="sd">    The optimization problem is solved using the SLSQP method as:</span>

<span class="sd">    &gt;&gt;&gt; res = minimize(fun, (2, 0), method=&#39;SLSQP&#39;, bounds=bnds,</span>
<span class="sd">    ...                constraints=cons)</span>

<span class="sd">    It should converge to the theoretical solution (1.4 ,1.7).</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x0</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">x0</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">message</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;Use of `minimize` with `x0.ndim != 1` is deprecated. &#39;</span>
                   <span class="s1">&#39;Currently, singleton dimensions will be removed from &#39;</span>
                   <span class="s1">&#39;`x0`, but an error will be raised in SciPy 1.11.0.&#39;</span><span class="p">)</span>
        <span class="n">warn</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="ne">DeprecationWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">x0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">x0</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">x0</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">typecodes</span><span class="p">[</span><span class="s2">&quot;AllInteger&quot;</span><span class="p">]:</span>
        <span class="n">x0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">args</span><span class="p">,)</span>

    <span class="k">if</span> <span class="n">method</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Select automatically</span>
        <span class="k">if</span> <span class="n">constraints</span><span class="p">:</span>
            <span class="n">method</span> <span class="o">=</span> <span class="s1">&#39;SLSQP&#39;</span>
        <span class="k">elif</span> <span class="n">bounds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">method</span> <span class="o">=</span> <span class="s1">&#39;L-BFGS-B&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">method</span> <span class="o">=</span> <span class="s1">&#39;BFGS&#39;</span>

    <span class="k">if</span> <span class="nb">callable</span><span class="p">(</span><span class="n">method</span><span class="p">):</span>
        <span class="n">meth</span> <span class="o">=</span> <span class="s2">&quot;_custom&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">meth</span> <span class="o">=</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">options</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">options</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="c1"># check if optional parameters are supported by the selected method</span>
    <span class="c1"># - jac</span>
    <span class="k">if</span> <span class="n">meth</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;nelder-mead&#39;</span><span class="p">,</span> <span class="s1">&#39;powell&#39;</span><span class="p">,</span> <span class="s1">&#39;cobyla&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">bool</span><span class="p">(</span><span class="n">jac</span><span class="p">):</span>
        <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Method </span><span class="si">%s</span><span class="s1"> does not use gradient information (jac).&#39;</span> <span class="o">%</span> <span class="n">method</span><span class="p">,</span>
             <span class="ne">RuntimeWarning</span><span class="p">)</span>
    <span class="c1"># - hess</span>
    <span class="k">if</span> <span class="n">meth</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;newton-cg&#39;</span><span class="p">,</span> <span class="s1">&#39;dogleg&#39;</span><span class="p">,</span> <span class="s1">&#39;trust-ncg&#39;</span><span class="p">,</span> <span class="s1">&#39;trust-constr&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;trust-krylov&#39;</span><span class="p">,</span> <span class="s1">&#39;trust-exact&#39;</span><span class="p">,</span> <span class="s1">&#39;_custom&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">hess</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Method </span><span class="si">%s</span><span class="s1"> does not use Hessian information (hess).&#39;</span> <span class="o">%</span> <span class="n">method</span><span class="p">,</span>
             <span class="ne">RuntimeWarning</span><span class="p">)</span>
    <span class="c1"># - hessp</span>
    <span class="k">if</span> <span class="n">meth</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;newton-cg&#39;</span><span class="p">,</span> <span class="s1">&#39;dogleg&#39;</span><span class="p">,</span> <span class="s1">&#39;trust-ncg&#39;</span><span class="p">,</span> <span class="s1">&#39;trust-constr&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;trust-krylov&#39;</span><span class="p">,</span> <span class="s1">&#39;_custom&#39;</span><span class="p">)</span> \
       <span class="ow">and</span> <span class="n">hessp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Method </span><span class="si">%s</span><span class="s1"> does not use Hessian-vector product &#39;</span>
             <span class="s1">&#39;information (hessp).&#39;</span> <span class="o">%</span> <span class="n">method</span><span class="p">,</span> <span class="ne">RuntimeWarning</span><span class="p">)</span>
    <span class="c1"># - constraints or bounds</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">meth</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;cg&#39;</span><span class="p">,</span> <span class="s1">&#39;bfgs&#39;</span><span class="p">,</span> <span class="s1">&#39;newton-cg&#39;</span><span class="p">,</span> <span class="s1">&#39;dogleg&#39;</span><span class="p">,</span> <span class="s1">&#39;trust-ncg&#39;</span><span class="p">)</span>
            <span class="ow">and</span> <span class="p">(</span><span class="n">bounds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">constraints</span><span class="p">))):</span>
        <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Method </span><span class="si">%s</span><span class="s1"> cannot handle constraints nor bounds.&#39;</span> <span class="o">%</span> <span class="n">method</span><span class="p">,</span>
             <span class="ne">RuntimeWarning</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">meth</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;nelder-mead&#39;</span><span class="p">,</span> <span class="s1">&#39;l-bfgs-b&#39;</span><span class="p">,</span> <span class="s1">&#39;tnc&#39;</span><span class="p">,</span> <span class="s1">&#39;powell&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">constraints</span><span class="p">):</span>
        <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Method </span><span class="si">%s</span><span class="s1"> cannot handle constraints.&#39;</span> <span class="o">%</span> <span class="n">method</span><span class="p">,</span>
             <span class="ne">RuntimeWarning</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">meth</span> <span class="o">==</span> <span class="s1">&#39;cobyla&#39;</span> <span class="ow">and</span> <span class="n">bounds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Method </span><span class="si">%s</span><span class="s1"> cannot handle bounds.&#39;</span> <span class="o">%</span> <span class="n">method</span><span class="p">,</span>
             <span class="ne">RuntimeWarning</span><span class="p">)</span>
    <span class="c1"># - return_all</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">meth</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;l-bfgs-b&#39;</span><span class="p">,</span> <span class="s1">&#39;tnc&#39;</span><span class="p">,</span> <span class="s1">&#39;cobyla&#39;</span><span class="p">,</span> <span class="s1">&#39;slsqp&#39;</span><span class="p">)</span> <span class="ow">and</span>
            <span class="n">options</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;return_all&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)):</span>
        <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Method </span><span class="si">%s</span><span class="s1"> does not support the return_all option.&#39;</span> <span class="o">%</span> <span class="n">method</span><span class="p">,</span>
             <span class="ne">RuntimeWarning</span><span class="p">)</span>

    <span class="c1"># check gradient vector</span>
    <span class="k">if</span> <span class="nb">callable</span><span class="p">(</span><span class="n">jac</span><span class="p">):</span>
        <span class="k">pass</span>
    <span class="k">elif</span> <span class="n">jac</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
        <span class="c1"># fun returns func and grad</span>
        <span class="n">fun</span> <span class="o">=</span> <span class="n">MemoizeJac</span><span class="p">(</span><span class="n">fun</span><span class="p">)</span>
        <span class="n">jac</span> <span class="o">=</span> <span class="n">fun</span><span class="o">.</span><span class="n">derivative</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">jac</span> <span class="ow">in</span> <span class="n">FD_METHODS</span> <span class="ow">and</span>
          <span class="n">meth</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;trust-constr&#39;</span><span class="p">,</span> <span class="s1">&#39;bfgs&#39;</span><span class="p">,</span> <span class="s1">&#39;cg&#39;</span><span class="p">,</span> <span class="s1">&#39;l-bfgs-b&#39;</span><span class="p">,</span> <span class="s1">&#39;tnc&#39;</span><span class="p">,</span> <span class="s1">&#39;slsqp&#39;</span><span class="p">]):</span>
        <span class="c1"># finite differences with relative step</span>
        <span class="k">pass</span>
    <span class="k">elif</span> <span class="n">meth</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;trust-constr&#39;</span><span class="p">]:</span>
        <span class="c1"># default jac calculation for this method</span>
        <span class="n">jac</span> <span class="o">=</span> <span class="s1">&#39;2-point&#39;</span>
    <span class="k">elif</span> <span class="n">jac</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">bool</span><span class="p">(</span><span class="n">jac</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
        <span class="c1"># this will cause e.g. LBFGS to use forward difference, absolute step</span>
        <span class="n">jac</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># default if jac option is not understood</span>
        <span class="n">jac</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># set default tolerances</span>
    <span class="k">if</span> <span class="n">tol</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">options</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">options</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">meth</span> <span class="o">==</span> <span class="s1">&#39;nelder-mead&#39;</span><span class="p">:</span>
            <span class="n">options</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;xatol&#39;</span><span class="p">,</span> <span class="n">tol</span><span class="p">)</span>
            <span class="n">options</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;fatol&#39;</span><span class="p">,</span> <span class="n">tol</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">meth</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;newton-cg&#39;</span><span class="p">,</span> <span class="s1">&#39;powell&#39;</span><span class="p">,</span> <span class="s1">&#39;tnc&#39;</span><span class="p">):</span>
            <span class="n">options</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;xtol&#39;</span><span class="p">,</span> <span class="n">tol</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">meth</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;powell&#39;</span><span class="p">,</span> <span class="s1">&#39;l-bfgs-b&#39;</span><span class="p">,</span> <span class="s1">&#39;tnc&#39;</span><span class="p">,</span> <span class="s1">&#39;slsqp&#39;</span><span class="p">):</span>
            <span class="n">options</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;ftol&#39;</span><span class="p">,</span> <span class="n">tol</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">meth</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;bfgs&#39;</span><span class="p">,</span> <span class="s1">&#39;cg&#39;</span><span class="p">,</span> <span class="s1">&#39;l-bfgs-b&#39;</span><span class="p">,</span> <span class="s1">&#39;tnc&#39;</span><span class="p">,</span> <span class="s1">&#39;dogleg&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;trust-ncg&#39;</span><span class="p">,</span> <span class="s1">&#39;trust-exact&#39;</span><span class="p">,</span> <span class="s1">&#39;trust-krylov&#39;</span><span class="p">):</span>
            <span class="n">options</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;gtol&#39;</span><span class="p">,</span> <span class="n">tol</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">meth</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;cobyla&#39;</span><span class="p">,</span> <span class="s1">&#39;_custom&#39;</span><span class="p">):</span>
            <span class="n">options</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;tol&#39;</span><span class="p">,</span> <span class="n">tol</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">meth</span> <span class="o">==</span> <span class="s1">&#39;trust-constr&#39;</span><span class="p">:</span>
            <span class="n">options</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;xtol&#39;</span><span class="p">,</span> <span class="n">tol</span><span class="p">)</span>
            <span class="n">options</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;gtol&#39;</span><span class="p">,</span> <span class="n">tol</span><span class="p">)</span>
            <span class="n">options</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;barrier_tol&#39;</span><span class="p">,</span> <span class="n">tol</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">meth</span> <span class="o">==</span> <span class="s1">&#39;_custom&#39;</span><span class="p">:</span>
        <span class="c1"># custom method called before bounds and constraints are &#39;standardised&#39;</span>
        <span class="c1"># custom method should be able to accept whatever bounds/constraints</span>
        <span class="c1"># are provided to it.</span>
        <span class="k">return</span> <span class="n">method</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="n">args</span><span class="p">,</span> <span class="n">jac</span><span class="o">=</span><span class="n">jac</span><span class="p">,</span> <span class="n">hess</span><span class="o">=</span><span class="n">hess</span><span class="p">,</span> <span class="n">hessp</span><span class="o">=</span><span class="n">hessp</span><span class="p">,</span>
                      <span class="n">bounds</span><span class="o">=</span><span class="n">bounds</span><span class="p">,</span> <span class="n">constraints</span><span class="o">=</span><span class="n">constraints</span><span class="p">,</span>
                      <span class="n">callback</span><span class="o">=</span><span class="n">callback</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span>

    <span class="n">constraints</span> <span class="o">=</span> <span class="n">standardize_constraints</span><span class="p">(</span><span class="n">constraints</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">meth</span><span class="p">)</span>

    <span class="n">remove_vars</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">bounds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">meth</span> <span class="ow">in</span> <span class="p">{</span><span class="s2">&quot;tnc&quot;</span><span class="p">,</span> <span class="s2">&quot;slsqp&quot;</span><span class="p">,</span> <span class="s2">&quot;l-bfgs-b&quot;</span><span class="p">}:</span>
            <span class="c1"># These methods can&#39;t take the finite-difference derivatives they</span>
            <span class="c1"># need when a variable is fixed by the bounds. To avoid this issue,</span>
            <span class="c1"># remove fixed variables from the problem.</span>
            <span class="c1"># NOTE: if this list is expanded, then be sure to update the</span>
            <span class="c1"># accompanying tests and test_optimize.eb_data. Consider also if</span>
            <span class="c1"># default OptimizeResult will need updating.</span>

            <span class="c1"># convert to new-style bounds so we only have to consider one case</span>
            <span class="n">bounds</span> <span class="o">=</span> <span class="n">standardize_bounds</span><span class="p">(</span><span class="n">bounds</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="s1">&#39;new&#39;</span><span class="p">)</span>

            <span class="c1"># determine whether any variables are fixed</span>
            <span class="n">i_fixed</span> <span class="o">=</span> <span class="p">(</span><span class="n">bounds</span><span class="o">.</span><span class="n">lb</span> <span class="o">==</span> <span class="n">bounds</span><span class="o">.</span><span class="n">ub</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">i_fixed</span><span class="p">):</span>
                <span class="c1"># all the parameters are fixed, a minimizer is not able to do</span>
                <span class="c1"># anything</span>
                <span class="k">return</span> <span class="n">_optimize_result_for_equal_bounds</span><span class="p">(</span>
                    <span class="n">fun</span><span class="p">,</span> <span class="n">bounds</span><span class="p">,</span> <span class="n">meth</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="n">args</span><span class="p">,</span> <span class="n">constraints</span><span class="o">=</span><span class="n">constraints</span>
                <span class="p">)</span>

            <span class="c1"># determine whether finite differences are needed for any grad/jac</span>
            <span class="n">fd_needed</span> <span class="o">=</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">callable</span><span class="p">(</span><span class="n">jac</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">con</span> <span class="ow">in</span> <span class="n">constraints</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">callable</span><span class="p">(</span><span class="n">con</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;jac&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)):</span>
                    <span class="n">fd_needed</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="c1"># If finite differences are ever used, remove all fixed variables</span>
            <span class="c1"># Always remove fixed variables for TNC; see gh-14565</span>
            <span class="n">remove_vars</span> <span class="o">=</span> <span class="n">i_fixed</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="ow">and</span> <span class="p">(</span><span class="n">fd_needed</span> <span class="ow">or</span> <span class="n">meth</span> <span class="o">==</span> <span class="s2">&quot;tnc&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">remove_vars</span><span class="p">:</span>
                <span class="n">x_fixed</span> <span class="o">=</span> <span class="p">(</span><span class="n">bounds</span><span class="o">.</span><span class="n">lb</span><span class="p">)[</span><span class="n">i_fixed</span><span class="p">]</span>
                <span class="n">x0</span> <span class="o">=</span> <span class="n">x0</span><span class="p">[</span><span class="o">~</span><span class="n">i_fixed</span><span class="p">]</span>
                <span class="n">bounds</span> <span class="o">=</span> <span class="n">_remove_from_bounds</span><span class="p">(</span><span class="n">bounds</span><span class="p">,</span> <span class="n">i_fixed</span><span class="p">)</span>
                <span class="n">fun</span> <span class="o">=</span> <span class="n">_remove_from_func</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">i_fixed</span><span class="p">,</span> <span class="n">x_fixed</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">callable</span><span class="p">(</span><span class="n">callback</span><span class="p">):</span>
                    <span class="n">callback</span> <span class="o">=</span> <span class="n">_remove_from_func</span><span class="p">(</span><span class="n">callback</span><span class="p">,</span> <span class="n">i_fixed</span><span class="p">,</span> <span class="n">x_fixed</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">callable</span><span class="p">(</span><span class="n">jac</span><span class="p">):</span>
                    <span class="n">jac</span> <span class="o">=</span> <span class="n">_remove_from_func</span><span class="p">(</span><span class="n">jac</span><span class="p">,</span> <span class="n">i_fixed</span><span class="p">,</span> <span class="n">x_fixed</span><span class="p">,</span> <span class="n">remove</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

                <span class="c1"># make a copy of the constraints so the user&#39;s version doesn&#39;t</span>
                <span class="c1"># get changed. (Shallow copy is ok)</span>
                <span class="n">constraints</span> <span class="o">=</span> <span class="p">[</span><span class="n">con</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">for</span> <span class="n">con</span> <span class="ow">in</span> <span class="n">constraints</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">con</span> <span class="ow">in</span> <span class="n">constraints</span><span class="p">:</span>  <span class="c1"># yes, guaranteed to be a list</span>
                    <span class="n">con</span><span class="p">[</span><span class="s1">&#39;fun&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_remove_from_func</span><span class="p">(</span><span class="n">con</span><span class="p">[</span><span class="s1">&#39;fun&#39;</span><span class="p">],</span> <span class="n">i_fixed</span><span class="p">,</span>
                                                   <span class="n">x_fixed</span><span class="p">,</span> <span class="n">min_dim</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                                                   <span class="n">remove</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">callable</span><span class="p">(</span><span class="n">con</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;jac&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)):</span>
                        <span class="n">con</span><span class="p">[</span><span class="s1">&#39;jac&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_remove_from_func</span><span class="p">(</span><span class="n">con</span><span class="p">[</span><span class="s1">&#39;jac&#39;</span><span class="p">],</span> <span class="n">i_fixed</span><span class="p">,</span>
                                                       <span class="n">x_fixed</span><span class="p">,</span> <span class="n">min_dim</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                                                       <span class="n">remove</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">bounds</span> <span class="o">=</span> <span class="n">standardize_bounds</span><span class="p">(</span><span class="n">bounds</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">meth</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">meth</span> <span class="o">==</span> <span class="s1">&#39;nelder-mead&#39;</span><span class="p">:</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">_minimize_neldermead</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">callback</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="n">bounds</span><span class="p">,</span>
                                   <span class="o">**</span><span class="n">options</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">meth</span> <span class="o">==</span> <span class="s1">&#39;powell&#39;</span><span class="p">:</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">_minimize_powell</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">callback</span><span class="p">,</span> <span class="n">bounds</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">meth</span> <span class="o">==</span> <span class="s1">&#39;cg&#39;</span><span class="p">:</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">_minimize_cg</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">jac</span><span class="p">,</span> <span class="n">callback</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">meth</span> <span class="o">==</span> <span class="s1">&#39;bfgs&#39;</span><span class="p">:</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">_minimize_bfgs</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">jac</span><span class="p">,</span> <span class="n">callback</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">meth</span> <span class="o">==</span> <span class="s1">&#39;newton-cg&#39;</span><span class="p">:</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">_minimize_newtoncg</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">jac</span><span class="p">,</span> <span class="n">hess</span><span class="p">,</span> <span class="n">hessp</span><span class="p">,</span> <span class="n">callback</span><span class="p">,</span>
                                 <span class="o">**</span><span class="n">options</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">meth</span> <span class="o">==</span> <span class="s1">&#39;l-bfgs-b&#39;</span><span class="p">:</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">_minimize_lbfgsb</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">jac</span><span class="p">,</span> <span class="n">bounds</span><span class="p">,</span>
                               <span class="n">callback</span><span class="o">=</span><span class="n">callback</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">meth</span> <span class="o">==</span> <span class="s1">&#39;tnc&#39;</span><span class="p">:</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">_minimize_tnc</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">jac</span><span class="p">,</span> <span class="n">bounds</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="n">callback</span><span class="p">,</span>
                            <span class="o">**</span><span class="n">options</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">meth</span> <span class="o">==</span> <span class="s1">&#39;cobyla&#39;</span><span class="p">:</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">_minimize_cobyla</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">constraints</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="n">callback</span><span class="p">,</span>
                                <span class="o">**</span><span class="n">options</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">meth</span> <span class="o">==</span> <span class="s1">&#39;slsqp&#39;</span><span class="p">:</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">_minimize_slsqp</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">jac</span><span class="p">,</span> <span class="n">bounds</span><span class="p">,</span>
                              <span class="n">constraints</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="n">callback</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">meth</span> <span class="o">==</span> <span class="s1">&#39;trust-constr&#39;</span><span class="p">:</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">_minimize_trustregion_constr</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">jac</span><span class="p">,</span> <span class="n">hess</span><span class="p">,</span> <span class="n">hessp</span><span class="p">,</span>
                                           <span class="n">bounds</span><span class="p">,</span> <span class="n">constraints</span><span class="p">,</span>
                                           <span class="n">callback</span><span class="o">=</span><span class="n">callback</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">meth</span> <span class="o">==</span> <span class="s1">&#39;dogleg&#39;</span><span class="p">:</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">_minimize_dogleg</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">jac</span><span class="p">,</span> <span class="n">hess</span><span class="p">,</span>
                               <span class="n">callback</span><span class="o">=</span><span class="n">callback</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">meth</span> <span class="o">==</span> <span class="s1">&#39;trust-ncg&#39;</span><span class="p">:</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">_minimize_trust_ncg</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">jac</span><span class="p">,</span> <span class="n">hess</span><span class="p">,</span> <span class="n">hessp</span><span class="p">,</span>
                                  <span class="n">callback</span><span class="o">=</span><span class="n">callback</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">meth</span> <span class="o">==</span> <span class="s1">&#39;trust-krylov&#39;</span><span class="p">:</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">_minimize_trust_krylov</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">jac</span><span class="p">,</span> <span class="n">hess</span><span class="p">,</span> <span class="n">hessp</span><span class="p">,</span>
                                     <span class="n">callback</span><span class="o">=</span><span class="n">callback</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">meth</span> <span class="o">==</span> <span class="s1">&#39;trust-exact&#39;</span><span class="p">:</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">_minimize_trustregion_exact</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">jac</span><span class="p">,</span> <span class="n">hess</span><span class="p">,</span>
                                          <span class="n">callback</span><span class="o">=</span><span class="n">callback</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Unknown solver </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">method</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">remove_vars</span><span class="p">:</span>
        <span class="n">res</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">_add_to_array</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">i_fixed</span><span class="p">,</span> <span class="n">x_fixed</span><span class="p">)</span>
        <span class="n">res</span><span class="o">.</span><span class="n">jac</span> <span class="o">=</span> <span class="n">_add_to_array</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">jac</span><span class="p">,</span> <span class="n">i_fixed</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;hess_inv&quot;</span> <span class="ow">in</span> <span class="n">res</span><span class="p">:</span>
            <span class="n">res</span><span class="o">.</span><span class="n">hess_inv</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># unknown</span>

    <span class="k">return</span> <span class="n">res</span></div>



<span class="k">def</span> <span class="nf">minimize_scalar</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">bracket</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(),</span>
                    <span class="n">method</span><span class="o">=</span><span class="s1">&#39;brent&#39;</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Minimization of scalar function of one variable.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    fun : callable</span>
<span class="sd">        Objective function.</span>
<span class="sd">        Scalar function, must return a scalar.</span>
<span class="sd">    bracket : sequence, optional</span>
<span class="sd">        For methods &#39;brent&#39; and &#39;golden&#39;, `bracket` defines the bracketing</span>
<span class="sd">        interval and can either have three items ``(a, b, c)`` so that</span>
<span class="sd">        ``a &lt; b &lt; c`` and ``fun(b) &lt; fun(a), fun(c)`` or two items ``a`` and</span>
<span class="sd">        ``c`` which are assumed to be a starting interval for a downhill</span>
<span class="sd">        bracket search (see `bracket`); it doesn&#39;t always mean that the</span>
<span class="sd">        obtained solution will satisfy ``a &lt;= x &lt;= c``.</span>
<span class="sd">    bounds : sequence, optional</span>
<span class="sd">        For method &#39;bounded&#39;, `bounds` is mandatory and must have two items</span>
<span class="sd">        corresponding to the optimization bounds.</span>
<span class="sd">    args : tuple, optional</span>
<span class="sd">        Extra arguments passed to the objective function.</span>
<span class="sd">    method : str or callable, optional</span>
<span class="sd">        Type of solver.  Should be one of:</span>

<span class="sd">            - :ref:`Brent &lt;optimize.minimize_scalar-brent&gt;`</span>
<span class="sd">            - :ref:`Bounded &lt;optimize.minimize_scalar-bounded&gt;`</span>
<span class="sd">            - :ref:`Golden &lt;optimize.minimize_scalar-golden&gt;`</span>
<span class="sd">            - custom - a callable object (added in version 0.14.0), see below</span>

<span class="sd">        See the &#39;Notes&#39; section for details of each solver.</span>

<span class="sd">    tol : float, optional</span>
<span class="sd">        Tolerance for termination. For detailed control, use solver-specific</span>
<span class="sd">        options.</span>
<span class="sd">    options : dict, optional</span>
<span class="sd">        A dictionary of solver options.</span>

<span class="sd">            maxiter : int</span>
<span class="sd">                Maximum number of iterations to perform.</span>
<span class="sd">            disp : bool</span>
<span class="sd">                Set to True to print convergence messages.</span>

<span class="sd">        See :func:`show_options()` for solver-specific options.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    res : OptimizeResult</span>
<span class="sd">        The optimization result represented as a ``OptimizeResult`` object.</span>
<span class="sd">        Important attributes are: ``x`` the solution array, ``success`` a</span>
<span class="sd">        Boolean flag indicating if the optimizer exited successfully and</span>
<span class="sd">        ``message`` which describes the cause of the termination. See</span>
<span class="sd">        `OptimizeResult` for a description of other attributes.</span>

<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    minimize : Interface to minimization algorithms for scalar multivariate</span>
<span class="sd">        functions</span>
<span class="sd">    show_options : Additional options accepted by the solvers</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This section describes the available solvers that can be selected by the</span>
<span class="sd">    &#39;method&#39; parameter. The default method is *Brent*.</span>

<span class="sd">    Method :ref:`Brent &lt;optimize.minimize_scalar-brent&gt;` uses Brent&#39;s</span>
<span class="sd">    algorithm to find a local minimum.  The algorithm uses inverse</span>
<span class="sd">    parabolic interpolation when possible to speed up convergence of</span>
<span class="sd">    the golden section method.</span>

<span class="sd">    Method :ref:`Golden &lt;optimize.minimize_scalar-golden&gt;` uses the</span>
<span class="sd">    golden section search technique. It uses analog of the bisection</span>
<span class="sd">    method to decrease the bracketed interval. It is usually</span>
<span class="sd">    preferable to use the *Brent* method.</span>

<span class="sd">    Method :ref:`Bounded &lt;optimize.minimize_scalar-bounded&gt;` can</span>
<span class="sd">    perform bounded minimization. It uses the Brent method to find a</span>
<span class="sd">    local minimum in the interval x1 &lt; xopt &lt; x2.</span>

<span class="sd">    **Custom minimizers**</span>

<span class="sd">    It may be useful to pass a custom minimization method, for example</span>
<span class="sd">    when using some library frontend to minimize_scalar. You can simply</span>
<span class="sd">    pass a callable as the ``method`` parameter.</span>

<span class="sd">    The callable is called as ``method(fun, args, **kwargs, **options)``</span>
<span class="sd">    where ``kwargs`` corresponds to any other parameters passed to `minimize`</span>
<span class="sd">    (such as `bracket`, `tol`, etc.), except the `options` dict, which has</span>
<span class="sd">    its contents also passed as `method` parameters pair by pair.  The method</span>
<span class="sd">    shall return an `OptimizeResult` object.</span>

<span class="sd">    The provided `method` callable must be able to accept (and possibly ignore)</span>
<span class="sd">    arbitrary parameters; the set of parameters accepted by `minimize` may</span>
<span class="sd">    expand in future versions and then these parameters will be passed to</span>
<span class="sd">    the method. You can find an example in the scipy.optimize tutorial.</span>

<span class="sd">    .. versionadded:: 0.11.0</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Consider the problem of minimizing the following function.</span>

<span class="sd">    &gt;&gt;&gt; def f(x):</span>
<span class="sd">    ...     return (x - 2) * x * (x + 2)**2</span>

<span class="sd">    Using the *Brent* method, we find the local minimum as:</span>

<span class="sd">    &gt;&gt;&gt; from scipy.optimize import minimize_scalar</span>
<span class="sd">    &gt;&gt;&gt; res = minimize_scalar(f)</span>
<span class="sd">    &gt;&gt;&gt; res.x</span>
<span class="sd">    1.28077640403</span>

<span class="sd">    Using the *Bounded* method, we find a local minimum with specified</span>
<span class="sd">    bounds as:</span>

<span class="sd">    &gt;&gt;&gt; res = minimize_scalar(f, bounds=(-3, -1), method=&#39;bounded&#39;)</span>
<span class="sd">    &gt;&gt;&gt; res.x</span>
<span class="sd">    -2.0000002026</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">args</span><span class="p">,)</span>

    <span class="k">if</span> <span class="nb">callable</span><span class="p">(</span><span class="n">method</span><span class="p">):</span>
        <span class="n">meth</span> <span class="o">=</span> <span class="s2">&quot;_custom&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">meth</span> <span class="o">=</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">options</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">options</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">if</span> <span class="n">tol</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">options</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">options</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">meth</span> <span class="o">==</span> <span class="s1">&#39;bounded&#39;</span> <span class="ow">and</span> <span class="s1">&#39;xatol&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">options</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Method &#39;bounded&#39; does not support relative tolerance in x; &quot;</span>
                 <span class="s2">&quot;defaulting to absolute tolerance.&quot;</span><span class="p">,</span> <span class="ne">RuntimeWarning</span><span class="p">)</span>
            <span class="n">options</span><span class="p">[</span><span class="s1">&#39;xatol&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tol</span>
        <span class="k">elif</span> <span class="n">meth</span> <span class="o">==</span> <span class="s1">&#39;_custom&#39;</span><span class="p">:</span>
            <span class="n">options</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;tol&#39;</span><span class="p">,</span> <span class="n">tol</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">options</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;xtol&#39;</span><span class="p">,</span> <span class="n">tol</span><span class="p">)</span>

    <span class="c1"># replace boolean &quot;disp&quot; option, if specified, by an integer value.</span>
    <span class="n">disp</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;disp&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">disp</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="n">options</span><span class="p">[</span><span class="s1">&#39;disp&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="nb">int</span><span class="p">(</span><span class="n">disp</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">meth</span> <span class="o">==</span> <span class="s1">&#39;_custom&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">method</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="n">args</span><span class="p">,</span> <span class="n">bracket</span><span class="o">=</span><span class="n">bracket</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="n">bounds</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">meth</span> <span class="o">==</span> <span class="s1">&#39;brent&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_minimize_scalar_brent</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">bracket</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">meth</span> <span class="o">==</span> <span class="s1">&#39;bounded&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">bounds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The `bounds` parameter is mandatory for &#39;</span>
                             <span class="s1">&#39;method `bounded`.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_minimize_scalar_bounded</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">bounds</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">meth</span> <span class="o">==</span> <span class="s1">&#39;golden&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_minimize_scalar_golden</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">bracket</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Unknown solver </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">method</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_remove_from_bounds</span><span class="p">(</span><span class="n">bounds</span><span class="p">,</span> <span class="n">i_fixed</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Removes fixed variables from a `Bounds` instance&quot;&quot;&quot;</span>
    <span class="n">lb</span> <span class="o">=</span> <span class="n">bounds</span><span class="o">.</span><span class="n">lb</span><span class="p">[</span><span class="o">~</span><span class="n">i_fixed</span><span class="p">]</span>
    <span class="n">ub</span> <span class="o">=</span> <span class="n">bounds</span><span class="o">.</span><span class="n">ub</span><span class="p">[</span><span class="o">~</span><span class="n">i_fixed</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">Bounds</span><span class="p">(</span><span class="n">lb</span><span class="p">,</span> <span class="n">ub</span><span class="p">)</span>  <span class="c1"># don&#39;t mutate original Bounds object</span>


<span class="k">def</span> <span class="nf">_remove_from_func</span><span class="p">(</span><span class="n">fun_in</span><span class="p">,</span> <span class="n">i_fixed</span><span class="p">,</span> <span class="n">x_fixed</span><span class="p">,</span> <span class="n">min_dim</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">remove</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Wraps a function such that fixed variables need not be passed in&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">fun_out</span><span class="p">(</span><span class="n">x_in</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">x_out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">i_fixed</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">x_in</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">x_out</span><span class="p">[</span><span class="n">i_fixed</span><span class="p">]</span> <span class="o">=</span> <span class="n">x_fixed</span>
        <span class="n">x_out</span><span class="p">[</span><span class="o">~</span><span class="n">i_fixed</span><span class="p">]</span> <span class="o">=</span> <span class="n">x_in</span>
        <span class="n">y_out</span> <span class="o">=</span> <span class="n">fun_in</span><span class="p">(</span><span class="n">x_out</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">y_out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">y_out</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">min_dim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">y_out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">y_out</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">min_dim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">y_out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">y_out</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">remove</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">y_out</span> <span class="o">=</span> <span class="n">y_out</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="o">~</span><span class="n">i_fixed</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">remove</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">y_out</span> <span class="o">=</span> <span class="n">y_out</span><span class="p">[</span><span class="o">~</span><span class="n">i_fixed</span><span class="p">,</span> <span class="o">~</span><span class="n">i_fixed</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">y_out</span>
    <span class="k">return</span> <span class="n">fun_out</span>


<span class="k">def</span> <span class="nf">_add_to_array</span><span class="p">(</span><span class="n">x_in</span><span class="p">,</span> <span class="n">i_fixed</span><span class="p">,</span> <span class="n">x_fixed</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Adds fixed variables back to an array&quot;&quot;&quot;</span>
    <span class="n">i_free</span> <span class="o">=</span> <span class="o">~</span><span class="n">i_fixed</span>
    <span class="k">if</span> <span class="n">x_in</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">i_free</span> <span class="o">=</span> <span class="n">i_free</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">@</span> <span class="n">i_free</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>
    <span class="n">x_out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">i_free</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">x_in</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">x_out</span><span class="p">[</span><span class="o">~</span><span class="n">i_free</span><span class="p">]</span> <span class="o">=</span> <span class="n">x_fixed</span>
    <span class="n">x_out</span><span class="p">[</span><span class="n">i_free</span><span class="p">]</span> <span class="o">=</span> <span class="n">x_in</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">x_out</span>


<span class="k">def</span> <span class="nf">standardize_bounds</span><span class="p">(</span><span class="n">bounds</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">meth</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Converts bounds to the form required by the solver.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">meth</span> <span class="ow">in</span> <span class="p">{</span><span class="s1">&#39;trust-constr&#39;</span><span class="p">,</span> <span class="s1">&#39;powell&#39;</span><span class="p">,</span> <span class="s1">&#39;nelder-mead&#39;</span><span class="p">,</span> <span class="s1">&#39;new&#39;</span><span class="p">}:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bounds</span><span class="p">,</span> <span class="n">Bounds</span><span class="p">):</span>
            <span class="n">lb</span><span class="p">,</span> <span class="n">ub</span> <span class="o">=</span> <span class="n">old_bound_to_new</span><span class="p">(</span><span class="n">bounds</span><span class="p">)</span>
            <span class="n">bounds</span> <span class="o">=</span> <span class="n">Bounds</span><span class="p">(</span><span class="n">lb</span><span class="p">,</span> <span class="n">ub</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">meth</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;l-bfgs-b&#39;</span><span class="p">,</span> <span class="s1">&#39;tnc&#39;</span><span class="p">,</span> <span class="s1">&#39;slsqp&#39;</span><span class="p">,</span> <span class="s1">&#39;old&#39;</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bounds</span><span class="p">,</span> <span class="n">Bounds</span><span class="p">):</span>
            <span class="n">bounds</span> <span class="o">=</span> <span class="n">new_bounds_to_old</span><span class="p">(</span><span class="n">bounds</span><span class="o">.</span><span class="n">lb</span><span class="p">,</span> <span class="n">bounds</span><span class="o">.</span><span class="n">ub</span><span class="p">,</span> <span class="n">x0</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">bounds</span>


<span class="k">def</span> <span class="nf">standardize_constraints</span><span class="p">(</span><span class="n">constraints</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">meth</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Converts constraints to the form required by the solver.&quot;&quot;&quot;</span>
    <span class="n">all_constraint_types</span> <span class="o">=</span> <span class="p">(</span><span class="n">NonlinearConstraint</span><span class="p">,</span> <span class="n">LinearConstraint</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span>
    <span class="n">new_constraint_types</span> <span class="o">=</span> <span class="n">all_constraint_types</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">constraints</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">constraints</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">constraints</span><span class="p">,</span> <span class="n">all_constraint_types</span><span class="p">):</span>
        <span class="n">constraints</span> <span class="o">=</span> <span class="p">[</span><span class="n">constraints</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">constraints</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">constraints</span><span class="p">)</span>  <span class="c1"># ensure it&#39;s a mutable sequence</span>

    <span class="k">if</span> <span class="n">meth</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;trust-constr&#39;</span><span class="p">,</span> <span class="s1">&#39;new&#39;</span><span class="p">]:</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">con</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">constraints</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">con</span><span class="p">,</span> <span class="n">new_constraint_types</span><span class="p">):</span>
                <span class="n">constraints</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">old_constraint_to_new</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">con</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># iterate over copy, changing original</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">con</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">constraints</span><span class="p">)):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">con</span><span class="p">,</span> <span class="n">new_constraint_types</span><span class="p">):</span>
                <span class="n">old_constraints</span> <span class="o">=</span> <span class="n">new_constraint_to_old</span><span class="p">(</span><span class="n">con</span><span class="p">,</span> <span class="n">x0</span><span class="p">)</span>
                <span class="n">constraints</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">old_constraints</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">constraints</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">old_constraints</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>  <span class="c1"># appends 1 if present</span>

    <span class="k">return</span> <span class="n">constraints</span>


<span class="k">def</span> <span class="nf">_optimize_result_for_equal_bounds</span><span class="p">(</span>
        <span class="n">fun</span><span class="p">,</span> <span class="n">bounds</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(),</span> <span class="n">constraints</span><span class="o">=</span><span class="p">()</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Provides a default OptimizeResult for when a bounded minimization method</span>
<span class="sd">    has (lb == ub).all().</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    fun: callable</span>
<span class="sd">    bounds: Bounds</span>
<span class="sd">    method: str</span>
<span class="sd">    constraints: Constraint</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">success</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">message</span> <span class="o">=</span> <span class="s1">&#39;All independent variables were fixed by bounds.&#39;</span>

    <span class="c1"># bounds is new-style</span>
    <span class="n">x0</span> <span class="o">=</span> <span class="n">bounds</span><span class="o">.</span><span class="n">lb</span>

    <span class="k">if</span> <span class="n">constraints</span><span class="p">:</span>
        <span class="n">message</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;All independent variables were fixed by bounds at values&quot;</span>
                   <span class="s2">&quot; that satisfy the constraints.&quot;</span><span class="p">)</span>
        <span class="n">constraints</span> <span class="o">=</span> <span class="n">standardize_constraints</span><span class="p">(</span><span class="n">constraints</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="s1">&#39;new&#39;</span><span class="p">)</span>

    <span class="n">maxcv</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">constraints</span><span class="p">:</span>
        <span class="n">pc</span> <span class="o">=</span> <span class="n">PreparedConstraint</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">x0</span><span class="p">)</span>
        <span class="n">violation</span> <span class="o">=</span> <span class="n">pc</span><span class="o">.</span><span class="n">violation</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">violation</span><span class="p">):</span>
            <span class="n">maxcv</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">maxcv</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">violation</span><span class="p">))</span>
            <span class="n">success</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">message</span> <span class="o">=</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;All independent variables were fixed by bounds, but &quot;</span>
                       <span class="sa">f</span><span class="s2">&quot;the independent variables do not satisfy the &quot;</span>
                       <span class="sa">f</span><span class="s2">&quot;constraints exactly. (Maximum violation: </span><span class="si">{</span><span class="n">maxcv</span><span class="si">}</span><span class="s2">).&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">OptimizeResult</span><span class="p">(</span>
        <span class="n">x</span><span class="o">=</span><span class="n">x0</span><span class="p">,</span> <span class="n">fun</span><span class="o">=</span><span class="n">fun</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">),</span> <span class="n">success</span><span class="o">=</span><span class="n">success</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="n">message</span><span class="p">,</span> <span class="n">nfev</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">njev</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">nhev</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="p">)</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020–2024, Pipeline Dev. Team.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>