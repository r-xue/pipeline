

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>astropy.coordinates.baseframe &mdash; Pipeline unknown documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css?v=4ae1632d" />
      <link rel="stylesheet" type="text/css" href="../../../_static/custom_theme.css?v=678032d9" />

  
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=3f1b9271"></script>
      <script src="../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            Pipeline
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Releases etc.</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../releases.html">Past Releases</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../dependencies.html">Dependencies of <code class="docutils literal notranslate"><span class="pre">Pipeline</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../modular.html">Run the Pipeline in a Conda environment</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../apisummary.html">Pipeline Tasks (from autosummary)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../apisummary.html#full-list">Full List</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">TaskRef (create_docs.py)</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../_taskdocs/taskdocs.html">List of Heuristics Tasks (Pipeline 2023)</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Pipeline Heuristics</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../heuristics/field_parameter.html">Field parameter</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../heuristics/FlaggingTasks.html">Pipeline Flagging Tasks</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Developer Notes</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../develdocmd/ways_to_run_the_pipeline.html">Ways to run the Pipeline</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../develdocmd/comparing_pipeline_executions.html">Comparing pipeline executions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../develdocmd/building_the_pipeline.html">Building the pipeline</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../develdocmd/ALMA-Imaging-Workflow.html">ALMA interferometry imaging workflow</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../develdocmd/VLA-Imaging-Workflow.html">VLA interferometry imaging workflow</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../develdocmd/VLASS-SE-CONT-Imaging-Workflow.html">VLASS-SE-CONT imaging workflow</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../develdocmd/VLASS-SE-CUBE-Imaging-Workflow.html">VLASS-SE-CUBE imaging workflow</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../develdocmd/selfcal_workflow.html">VLASS Selfcal &amp; Restore workflows</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../develdocmd/pipeline_tests.html">Pipeline testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../develdocmd/DataType_Testing.html">DataType Testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../develdocmd/QA_scores.html">Pipeline Quality Assurance (QA) Score Class Design</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../develdocmd/DeveloperDocumentation.html">Pipeline developer documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../develdocmd/python3_conversion_notes.html">Python 3 conversion notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../develdocmd/recipes.html">Pipeline Recipes</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Pipeline Domain/Context (automodapi)</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../basics.html"><code class="docutils literal notranslate"><span class="pre">pipeline.domain</span></code> module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../basics.html#module-pipeline.infrastructure.launcher"><code class="docutils literal notranslate"><span class="pre">pipeline.infrastructure.launcher</span></code> module</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Pipeline Domain/Context (autosummary)</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../_autosummary/pipeline.domain.html">pipeline.domain</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../_autosummary/pipeline.infrastructure.launcher.html">pipeline.infrastructure.launcher</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Pipeline Task/Inputs/Results Classes</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../classes.html">Classes in <code class="docutils literal notranslate"><span class="pre">pipeline.h*.tasks</span></code> modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../classes.html#inheritance-diagrams">Inheritance Diagrams</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Examples Notes (from Jupyter Notebooks)</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/test1.html">test</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Example Notes (from .rst)</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/test2.html">Example 1</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">Pipeline</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">astropy.coordinates.baseframe</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for astropy.coordinates.baseframe</h1><div class="highlight"><pre>
<span></span><span class="c1"># Licensed under a 3-clause BSD style license - see LICENSE.rst</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Framework and base classes for coordinate frames/&quot;low-level&quot; coordinate</span>
<span class="sd">classes.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;BaseCoordinateFrame&quot;</span><span class="p">,</span>
    <span class="s2">&quot;frame_transform_graph&quot;</span><span class="p">,</span>
    <span class="s2">&quot;GenericFrame&quot;</span><span class="p">,</span>
    <span class="s2">&quot;RepresentationMapping&quot;</span><span class="p">,</span>
<span class="p">]</span>

<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">TYPE_CHECKING</span><span class="p">,</span> <span class="n">NamedTuple</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">astropy</span> <span class="kn">import</span> <span class="n">units</span> <span class="k">as</span> <span class="n">u</span>
<span class="kn">from</span> <span class="nn">astropy.utils</span> <span class="kn">import</span> <span class="n">ShapedLikeNDArray</span><span class="p">,</span> <span class="n">check_broadcast</span>
<span class="kn">from</span> <span class="nn">astropy.utils.decorators</span> <span class="kn">import</span> <span class="n">deprecated</span><span class="p">,</span> <span class="n">format_doc</span><span class="p">,</span> <span class="n">lazyproperty</span>
<span class="kn">from</span> <span class="nn">astropy.utils.exceptions</span> <span class="kn">import</span> <span class="n">AstropyWarning</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">representation</span> <span class="k">as</span> <span class="n">r</span>
<span class="kn">from</span> <span class="nn">.angles</span> <span class="kn">import</span> <span class="n">Angle</span><span class="p">,</span> <span class="n">position_angle</span>
<span class="kn">from</span> <span class="nn">.attributes</span> <span class="kn">import</span> <span class="n">Attribute</span>
<span class="kn">from</span> <span class="nn">.errors</span> <span class="kn">import</span> <span class="n">NonRotationTransformationError</span><span class="p">,</span> <span class="n">NonRotationTransformationWarning</span>
<span class="kn">from</span> <span class="nn">.transformations</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">DynamicMatrixTransform</span><span class="p">,</span>
    <span class="n">StaticMatrixTransform</span><span class="p">,</span>
    <span class="n">TransformGraph</span><span class="p">,</span>
<span class="p">)</span>

<span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Literal</span>

    <span class="kn">from</span> <span class="nn">astropy.coordinates</span> <span class="kn">import</span> <span class="n">Latitude</span><span class="p">,</span> <span class="n">Longitude</span><span class="p">,</span> <span class="n">SkyCoord</span>
    <span class="kn">from</span> <span class="nn">astropy.units</span> <span class="kn">import</span> <span class="n">Unit</span>

<span class="c1"># the graph used for all transformations between frames</span>
<span class="n">frame_transform_graph</span> <span class="o">=</span> <span class="n">TransformGraph</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">_get_repr_cls</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a valid representation class from ``value`` or raise exception.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">r</span><span class="o">.</span><span class="n">REPRESENTATION_CLASSES</span><span class="p">:</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">REPRESENTATION_CLASSES</span><span class="p">[</span><span class="n">value</span><span class="p">]</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">type</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">r</span><span class="o">.</span><span class="n">BaseRepresentation</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Representation is </span><span class="si">{</span><span class="n">value</span><span class="si">!r}</span><span class="s2"> but must be a BaseRepresentation class &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;or one of the string aliases </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">REPRESENTATION_CLASSES</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">value</span>


<span class="k">def</span> <span class="nf">_get_diff_cls</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a valid differential class from ``value`` or raise exception.</span>

<span class="sd">    As originally created, this is only used in the SkyCoord initializer, so if</span>
<span class="sd">    that is refactored, this function my no longer be necessary.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">r</span><span class="o">.</span><span class="n">DIFFERENTIAL_CLASSES</span><span class="p">:</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">DIFFERENTIAL_CLASSES</span><span class="p">[</span><span class="n">value</span><span class="p">]</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">type</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">r</span><span class="o">.</span><span class="n">BaseDifferential</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Differential is </span><span class="si">{</span><span class="n">value</span><span class="si">!r}</span><span class="s2"> but must be a BaseDifferential class &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;or one of the string aliases </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">DIFFERENTIAL_CLASSES</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">value</span>


<span class="k">def</span> <span class="nf">_get_repr_classes</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="o">**</span><span class="n">differentials</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Get valid representation and differential classes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    base : str or `~astropy.coordinates.BaseRepresentation` subclass</span>
<span class="sd">        class for the representation of the base coordinates.  If a string,</span>
<span class="sd">        it is looked up among the known representation classes.</span>
<span class="sd">    **differentials : dict of str or `~astropy.coordinates.BaseDifferentials`</span>
<span class="sd">        Keys are like for normal differentials, i.e., &#39;s&#39; for a first</span>
<span class="sd">        derivative in time, etc.  If an item is set to `None`, it will be</span>
<span class="sd">        guessed from the base class.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    repr_classes : dict of subclasses</span>
<span class="sd">        The base class is keyed by &#39;base&#39;; the others by the keys of</span>
<span class="sd">        ``diffferentials``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">base</span> <span class="o">=</span> <span class="n">_get_repr_cls</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>
    <span class="n">repr_classes</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;base&quot;</span><span class="p">:</span> <span class="n">base</span><span class="p">}</span>

    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">differential_type</span> <span class="ow">in</span> <span class="n">differentials</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">differential_type</span> <span class="o">==</span> <span class="s2">&quot;base&quot;</span><span class="p">:</span>
            <span class="c1"># We don&#39;t want to fail for this case.</span>
            <span class="n">differential_type</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">DIFFERENTIAL_CLASSES</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">get_name</span><span class="p">(),</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">differential_type</span> <span class="ow">in</span> <span class="n">r</span><span class="o">.</span><span class="n">DIFFERENTIAL_CLASSES</span><span class="p">:</span>
            <span class="n">differential_type</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">DIFFERENTIAL_CLASSES</span><span class="p">[</span><span class="n">differential_type</span><span class="p">]</span>

        <span class="k">elif</span> <span class="n">differential_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="p">(</span>
            <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">differential_type</span><span class="p">,</span> <span class="nb">type</span><span class="p">)</span>
            <span class="ow">or</span> <span class="ow">not</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">differential_type</span><span class="p">,</span> <span class="n">r</span><span class="o">.</span><span class="n">BaseDifferential</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Differential is </span><span class="si">{differential_type!r}</span><span class="s2"> but must be a BaseDifferential&quot;</span>
                <span class="sa">f</span><span class="s2">&quot; class or one of the string aliases </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">DIFFERENTIAL_CLASSES</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="n">repr_classes</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">differential_type</span>
    <span class="k">return</span> <span class="n">repr_classes</span>


<span class="k">class</span> <span class="nc">RepresentationMapping</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This :class:`~typing.NamedTuple` is used with the</span>
<span class="sd">    ``frame_specific_representation_info`` attribute to tell frames what</span>
<span class="sd">    attribute names (and default units) to use for a particular representation.</span>
<span class="sd">    ``reprname`` and ``framename`` should be strings, while ``defaultunit`` can</span>
<span class="sd">    be either an astropy unit, the string ``&#39;recommended&#39;`` (which is degrees</span>
<span class="sd">    for Angles, nothing otherwise), or None (to indicate that no unit mapping</span>
<span class="sd">    should be done).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">reprname</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">framename</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">defaultunit</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">Unit</span> <span class="o">=</span> <span class="s2">&quot;recommended&quot;</span>


<span class="n">base_doc</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="si">{__doc__}</span>
<span class="s2">    Parameters</span>
<span class="s2">    ----------</span>
<span class="s2">    data : `~astropy.coordinates.BaseRepresentation` subclass instance</span>
<span class="s2">        A representation object or ``None`` to have no data (or use the</span>
<span class="s2">        coordinate component arguments, see below).</span>
<span class="s2">    </span><span class="si">{components}</span>
<span class="s2">    representation_type : `~astropy.coordinates.BaseRepresentation` subclass, str, optional</span>
<span class="s2">        A representation class or string name of a representation class. This</span>
<span class="s2">        sets the expected input representation class, thereby changing the</span>
<span class="s2">        expected keyword arguments for the data passed in. For example, passing</span>
<span class="s2">        ``representation_type=&#39;cartesian&#39;`` will make the classes expect</span>
<span class="s2">        position data with cartesian names, i.e. ``x, y, z`` in most cases</span>
<span class="s2">        unless overridden via ``frame_specific_representation_info``. To see this</span>
<span class="s2">        frame&#39;s names, check out ``&lt;this frame&gt;().representation_info``.</span>
<span class="s2">    differential_type : `~astropy.coordinates.BaseDifferential` subclass, str, dict, optional</span>
<span class="s2">        A differential class or dictionary of differential classes (currently</span>
<span class="s2">        only a velocity differential with key &#39;s&#39; is supported). This sets the</span>
<span class="s2">        expected input differential class, thereby changing the expected keyword</span>
<span class="s2">        arguments of the data passed in. For example, passing</span>
<span class="s2">        ``differential_type=&#39;cartesian&#39;`` will make the classes expect velocity</span>
<span class="s2">        data with the argument names ``v_x, v_y, v_z`` unless overridden via</span>
<span class="s2">        ``frame_specific_representation_info``. To see this frame&#39;s names,</span>
<span class="s2">        check out ``&lt;this frame&gt;().representation_info``.</span>
<span class="s2">    copy : bool, optional</span>
<span class="s2">        If `True` (default), make copies of the input coordinate arrays.</span>
<span class="s2">        Can only be passed in as a keyword argument.</span>
<span class="s2">    </span><span class="si">{footer}</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="n">_components</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    *args, **kwargs</span>
<span class="s2">        Coordinate components, with names that depend on the subclass.</span>
<span class="s2">&quot;&quot;&quot;</span>


<span class="nd">@format_doc</span><span class="p">(</span><span class="n">base_doc</span><span class="p">,</span> <span class="n">components</span><span class="o">=</span><span class="n">_components</span><span class="p">,</span> <span class="n">footer</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">BaseCoordinateFrame</span><span class="p">(</span><span class="n">ShapedLikeNDArray</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The base class for coordinate frames.</span>

<span class="sd">    This class is intended to be subclassed to create instances of specific</span>
<span class="sd">    systems.  Subclasses can implement the following attributes:</span>

<span class="sd">    * `default_representation`</span>
<span class="sd">        A subclass of `~astropy.coordinates.BaseRepresentation` that will be</span>
<span class="sd">        treated as the default representation of this frame.  This is the</span>
<span class="sd">        representation assumed by default when the frame is created.</span>

<span class="sd">    * `default_differential`</span>
<span class="sd">        A subclass of `~astropy.coordinates.BaseDifferential` that will be</span>
<span class="sd">        treated as the default differential class of this frame.  This is the</span>
<span class="sd">        differential class assumed by default when the frame is created.</span>

<span class="sd">    * `~astropy.coordinates.Attribute` class attributes</span>
<span class="sd">       Frame attributes such as ``FK4.equinox`` or ``FK4.obstime`` are defined</span>
<span class="sd">       using a descriptor class.  See the narrative documentation or</span>
<span class="sd">       built-in classes code for details.</span>

<span class="sd">    * `frame_specific_representation_info`</span>
<span class="sd">        A dictionary mapping the name or class of a representation to a list of</span>
<span class="sd">        `~astropy.coordinates.RepresentationMapping` objects that tell what</span>
<span class="sd">        names and default units should be used on this frame for the components</span>
<span class="sd">        of that representation.</span>

<span class="sd">    Unless overridden via `frame_specific_representation_info`, velocity name</span>
<span class="sd">    defaults are:</span>

<span class="sd">      * ``pm_{lon}_cos{lat}``, ``pm_{lat}`` for `~astropy.coordinates.SphericalCosLatDifferential` velocity components</span>
<span class="sd">      * ``pm_{lon}``, ``pm_{lat}`` for `~astropy.coordinates.SphericalDifferential` velocity components</span>
<span class="sd">      * ``radial_velocity`` for any ``d_distance`` component</span>
<span class="sd">      * ``v_{x,y,z}`` for `~astropy.coordinates.CartesianDifferential` velocity components</span>

<span class="sd">    where ``{lon}`` and ``{lat}`` are the frame names of the angular components.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">default_representation</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">default_differential</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># Specifies special names and units for representation and differential</span>
    <span class="c1"># attributes.</span>
    <span class="n">frame_specific_representation_info</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="n">frame_attributes</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="c1"># Default empty frame_attributes dict</span>

    <span class="k">def</span> <span class="nf">__init_subclass__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># We first check for explicitly set values for these:</span>
        <span class="n">default_repr</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="s2">&quot;default_representation&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">default_diff</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="s2">&quot;default_differential&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">repr_info</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="s2">&quot;frame_specific_representation_info&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="c1"># Then, to make sure this works for subclasses-of-subclasses, we also</span>
        <span class="c1"># have to check for cases where the attribute names have already been</span>
        <span class="c1"># replaced by underscore-prefaced equivalents by the logic below:</span>
        <span class="k">if</span> <span class="n">default_repr</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">default_repr</span><span class="p">,</span> <span class="nb">property</span><span class="p">):</span>
            <span class="n">default_repr</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="s2">&quot;_default_representation&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">default_diff</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">default_diff</span><span class="p">,</span> <span class="nb">property</span><span class="p">):</span>
            <span class="n">default_diff</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="s2">&quot;_default_differential&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">repr_info</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">repr_info</span><span class="p">,</span> <span class="nb">property</span><span class="p">):</span>
            <span class="n">repr_info</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="s2">&quot;_frame_specific_representation_info&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="n">repr_info</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_infer_repr_info</span><span class="p">(</span><span class="n">repr_info</span><span class="p">)</span>

        <span class="c1"># Make read-only properties for the frame class attributes that should</span>
        <span class="c1"># be read-only to make them immutable after creation.</span>
        <span class="c1"># We copy attributes instead of linking to make sure there&#39;s no</span>
        <span class="c1"># accidental cross-talk between classes</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_create_readonly_property</span><span class="p">(</span>
            <span class="s2">&quot;default_representation&quot;</span><span class="p">,</span>
            <span class="n">default_repr</span><span class="p">,</span>
            <span class="s2">&quot;Default representation for position data&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_create_readonly_property</span><span class="p">(</span>
            <span class="s2">&quot;default_differential&quot;</span><span class="p">,</span>
            <span class="n">default_diff</span><span class="p">,</span>
            <span class="s2">&quot;Default representation for differential data (e.g., velocity)&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_create_readonly_property</span><span class="p">(</span>
            <span class="s2">&quot;frame_specific_representation_info&quot;</span><span class="p">,</span>
            <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">repr_info</span><span class="p">),</span>
            <span class="s2">&quot;Mapping for frame-specific component names&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Set the frame attributes. We first construct the attributes from</span>
        <span class="c1"># superclasses, going in reverse order to keep insertion order,</span>
        <span class="c1"># and then add any attributes from the frame now being defined</span>
        <span class="c1"># (if any old definitions are overridden, this keeps the order).</span>
        <span class="c1"># Note that we cannot simply start with the inherited frame_attributes</span>
        <span class="c1"># since we could be a mixin between multiple coordinate frames.</span>
        <span class="c1"># TODO: Should this be made to use readonly_prop_factory as well or</span>
        <span class="c1"># would it be inconvenient for getting the frame_attributes from</span>
        <span class="c1"># classes?</span>
        <span class="n">frame_attrs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">basecls</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__bases__</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">basecls</span><span class="p">,</span> <span class="n">BaseCoordinateFrame</span><span class="p">):</span>
                <span class="n">frame_attrs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">basecls</span><span class="o">.</span><span class="n">frame_attributes</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">Attribute</span><span class="p">):</span>
                <span class="n">frame_attrs</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>

        <span class="bp">cls</span><span class="o">.</span><span class="n">frame_attributes</span> <span class="o">=</span> <span class="n">frame_attrs</span>

        <span class="c1"># Deal with setting the name of the frame:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">):</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">BaseCoordinateFrame</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__bases__</span> <span class="ow">and</span> <span class="bp">cls</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="p">[</span>
            <span class="nb">getattr</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">base</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__bases__</span>
        <span class="p">]:</span>
            <span class="c1"># This may be a subclass of a subclass of BaseCoordinateFrame,</span>
            <span class="c1"># like ICRS(BaseRADecFrame). In this case, cls.name will have been</span>
            <span class="c1"># set by init_subclass</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>

        <span class="c1"># A cache that *must be unique to each frame class* - it is</span>
        <span class="c1"># insufficient to share them with superclasses, hence the need to put</span>
        <span class="c1"># them in the meta</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_frame_class_cache</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__init_subclass__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># call this once here to initialize defaults</span>
        <span class="c1"># (via FrameAttribute.__get__/convert_input)</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">get_frame_attr_defaults</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="n">args</span><span class="p">,</span>
        <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">representation_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">differential_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_attr_names_with_defaults</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_representation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_infer_representation</span><span class="p">(</span>
            <span class="n">representation_type</span><span class="p">,</span> <span class="n">differential_type</span>
        <span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_infer_data</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">copy</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>  <span class="c1"># possibly None.</span>

        <span class="n">shapes</span> <span class="o">=</span> <span class="p">[]</span> <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">[</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">]</span>

        <span class="c1"># Set frame attributes, if any.</span>
        <span class="c1"># Keep track of their shapes, but do not broadcast them yet.</span>
        <span class="n">values</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">fnm</span><span class="p">,</span> <span class="n">fdefault</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_frame_attr_defaults</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># Read-only frame attributes are defined as FrameAttribute</span>
            <span class="c1"># descriptors which are not settable, so set &#39;real&#39; attributes as</span>
            <span class="c1"># the name prefaced with an underscore.</span>

            <span class="k">if</span> <span class="n">fnm</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">fnm</span><span class="p">)</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="n">fnm</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
                <span class="c1"># Validate attribute by getting it.</span>
                <span class="n">values</span><span class="p">[</span><span class="n">fnm</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fnm</span><span class="p">)</span>
                <span class="n">shapes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="s2">&quot;shape&quot;</span><span class="p">,</span> <span class="p">()))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="n">fnm</span><span class="p">,</span> <span class="n">fdefault</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_attr_names_with_defaults</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fnm</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Coordinate frame </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> got unexpected &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;keywords: </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Determine the overall shape of the frame.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_shape</span> <span class="o">=</span> <span class="n">check_broadcast</span><span class="p">(</span><span class="o">*</span><span class="n">shapes</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;non-scalar data and/or attributes with inconsistent shapes: </span><span class="si">{</span><span class="n">shapes</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span> <span class="kn">from</span> <span class="nn">err</span>

        <span class="c1"># Broadcast the data if necessary and set it</span>
        <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shape</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># if broadcasting isn&#39;t strictly needed, avoid it</span>
                <span class="c1"># see https://github.com/astropy/astropy/issues/16219</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_shape</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">_apply</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_shape</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">data</span>
        <span class="c1"># Broadcast the attributes if necessary by getting them again</span>
        <span class="c1"># (we now know the shapes will be OK).</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">values</span><span class="p">:</span>
            <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>

        <span class="c1"># The logic of this block is not related to the previous one</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_data</span><span class="p">:</span>
            <span class="c1"># This makes the cache keys backwards-compatible, but also adds</span>
            <span class="c1"># support for having differentials attached to the frame data</span>
            <span class="c1"># representation object.</span>
            <span class="k">if</span> <span class="s2">&quot;s&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">differentials</span><span class="p">:</span>
                <span class="c1"># TODO: assumes a velocity unit differential</span>
                <span class="n">key</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">differentials</span><span class="p">[</span><span class="s2">&quot;s&quot;</span><span class="p">]</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                    <span class="kc">False</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

            <span class="c1"># Set up representation cache.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">[</span><span class="s2">&quot;representation&quot;</span><span class="p">][</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span>

    <span class="k">def</span> <span class="nf">_infer_representation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">representation_type</span><span class="p">,</span> <span class="n">differential_type</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">representation_type</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">differential_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;base&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">default_representation</span><span class="p">,</span> <span class="s2">&quot;s&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">default_differential</span><span class="p">}</span>

        <span class="k">if</span> <span class="n">representation_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">representation_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">default_representation</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">differential_type</span><span class="p">,</span> <span class="nb">type</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">issubclass</span><span class="p">(</span>
            <span class="n">differential_type</span><span class="p">,</span> <span class="n">r</span><span class="o">.</span><span class="n">BaseDifferential</span>
        <span class="p">):</span>
            <span class="c1"># TODO: assumes the differential class is for the velocity</span>
            <span class="c1"># differential</span>
            <span class="n">differential_type</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;s&quot;</span><span class="p">:</span> <span class="n">differential_type</span><span class="p">}</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">differential_type</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="c1"># TODO: assumes the differential class is for the velocity</span>
            <span class="c1"># differential</span>
            <span class="n">diff_cls</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">DIFFERENTIAL_CLASSES</span><span class="p">[</span><span class="n">differential_type</span><span class="p">]</span>
            <span class="n">differential_type</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;s&quot;</span><span class="p">:</span> <span class="n">diff_cls</span><span class="p">}</span>

        <span class="k">elif</span> <span class="n">differential_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">representation_type</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">default_representation</span><span class="p">:</span>
                <span class="n">differential_type</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;s&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">default_differential</span><span class="p">}</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">differential_type</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;s&quot;</span><span class="p">:</span> <span class="s2">&quot;base&quot;</span><span class="p">}</span>  <span class="c1"># see set_representation_cls()</span>

        <span class="k">return</span> <span class="n">_get_repr_classes</span><span class="p">(</span><span class="n">representation_type</span><span class="p">,</span> <span class="o">**</span><span class="n">differential_type</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_infer_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">copy</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># if not set below, this is a frame with no data</span>
        <span class="n">representation_data</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">differential_data</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">args</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>  <span class="c1"># need to be able to pop them</span>
        <span class="k">if</span> <span class="n">args</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">r</span><span class="o">.</span><span class="n">BaseRepresentation</span><span class="p">)</span> <span class="ow">or</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">representation_data</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># This can still be None</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;Cannot create a frame with both a representation object &quot;</span>
                    <span class="s2">&quot;and other positional arguments&quot;</span>
                <span class="p">)</span>

            <span class="k">if</span> <span class="n">representation_data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">diffs</span> <span class="o">=</span> <span class="n">representation_data</span><span class="o">.</span><span class="n">differentials</span>
                <span class="n">differential_data</span> <span class="o">=</span> <span class="n">diffs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;s&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">differential_data</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">diffs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span>
                    <span class="n">differential_data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">diffs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span>
                <span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;Multiple differentials are associated with the representation&quot;</span>
                        <span class="s2">&quot; object passed in to the frame initializer. Only a single&quot;</span>
                        <span class="sa">f</span><span class="s2">&quot; velocity differential is supported. Got: </span><span class="si">{</span><span class="n">diffs</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">representation_cls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_representation_cls</span><span class="p">()</span>
            <span class="c1"># Get any representation data passed in to the frame initializer</span>
            <span class="c1"># using keyword or positional arguments for the component names</span>
            <span class="n">repr_kwargs</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">nmkw</span><span class="p">,</span> <span class="n">nmrep</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">representation_component_names</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># first gather up positional args</span>
                    <span class="n">repr_kwargs</span><span class="p">[</span><span class="n">nmrep</span><span class="p">]</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">nmkw</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                    <span class="n">repr_kwargs</span><span class="p">[</span><span class="n">nmrep</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">nmkw</span><span class="p">)</span>

            <span class="c1"># special-case the Spherical-&gt;UnitSpherical if no `distance`</span>

            <span class="k">if</span> <span class="n">repr_kwargs</span><span class="p">:</span>
                <span class="c1"># TODO: determine how to get rid of the part before the &quot;try&quot; -</span>
                <span class="c1"># currently removing it has a performance regression for</span>
                <span class="c1"># unitspherical because of the try-related overhead.</span>
                <span class="c1"># Also frames have no way to indicate what the &quot;distance&quot; is</span>
                <span class="k">if</span> <span class="n">repr_kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;distance&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">del</span> <span class="n">repr_kwargs</span><span class="p">[</span><span class="s2">&quot;distance&quot;</span><span class="p">]</span>

                <span class="k">if</span> <span class="p">(</span>
                    <span class="nb">issubclass</span><span class="p">(</span><span class="n">representation_cls</span><span class="p">,</span> <span class="n">r</span><span class="o">.</span><span class="n">SphericalRepresentation</span><span class="p">)</span>
                    <span class="ow">and</span> <span class="s2">&quot;distance&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">repr_kwargs</span>
                <span class="p">):</span>
                    <span class="n">representation_cls</span> <span class="o">=</span> <span class="n">representation_cls</span><span class="o">.</span><span class="n">_unit_representation</span>

                <span class="k">try</span><span class="p">:</span>
                    <span class="n">representation_data</span> <span class="o">=</span> <span class="n">representation_cls</span><span class="p">(</span><span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="o">**</span><span class="n">repr_kwargs</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">TypeError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="c1"># this except clause is here to make the names of the</span>
                    <span class="c1"># attributes more human-readable.  Without this the names</span>
                    <span class="c1"># come from the representation instead of the frame&#39;s</span>
                    <span class="c1"># attribute names.</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">representation_data</span> <span class="o">=</span> <span class="n">representation_cls</span><span class="o">.</span><span class="n">_unit_representation</span><span class="p">(</span>
                            <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="o">**</span><span class="n">repr_kwargs</span>
                        <span class="p">)</span>
                    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                        <span class="n">msg</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
                        <span class="n">names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_representation_component_names</span><span class="p">()</span>
                        <span class="k">for</span> <span class="n">frame_name</span><span class="p">,</span> <span class="n">repr_name</span> <span class="ow">in</span> <span class="n">names</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                            <span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">repr_name</span><span class="p">,</span> <span class="n">frame_name</span><span class="p">)</span>
                        <span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;__init__()&quot;</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">()&quot;</span><span class="p">)</span>
                        <span class="n">e</span><span class="o">.</span><span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">msg</span><span class="p">,)</span>
                        <span class="k">raise</span> <span class="n">e</span>

            <span class="c1"># Now we handle the Differential data:</span>
            <span class="c1"># Get any differential data passed in to the frame initializer</span>
            <span class="c1"># using keyword or positional arguments for the component names</span>
            <span class="n">differential_cls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_representation_cls</span><span class="p">(</span><span class="s2">&quot;s&quot;</span><span class="p">)</span>
            <span class="n">diff_component_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_representation_component_names</span><span class="p">(</span><span class="s2">&quot;s&quot;</span><span class="p">)</span>
            <span class="n">diff_kwargs</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">nmkw</span><span class="p">,</span> <span class="n">nmrep</span> <span class="ow">in</span> <span class="n">diff_component_names</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># first gather up positional args</span>
                    <span class="n">diff_kwargs</span><span class="p">[</span><span class="n">nmrep</span><span class="p">]</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">nmkw</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                    <span class="n">diff_kwargs</span><span class="p">[</span><span class="n">nmrep</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">nmkw</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">diff_kwargs</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="nb">hasattr</span><span class="p">(</span><span class="n">differential_cls</span><span class="p">,</span> <span class="s2">&quot;_unit_differential&quot;</span><span class="p">)</span>
                    <span class="ow">and</span> <span class="s2">&quot;d_distance&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">diff_kwargs</span>
                <span class="p">):</span>
                    <span class="n">differential_cls</span> <span class="o">=</span> <span class="n">differential_cls</span><span class="o">.</span><span class="n">_unit_differential</span>

                <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">diff_kwargs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="s2">&quot;d_distance&quot;</span> <span class="ow">in</span> <span class="n">diff_kwargs</span><span class="p">:</span>
                    <span class="n">differential_cls</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">RadialDifferential</span>

                <span class="k">try</span><span class="p">:</span>
                    <span class="n">differential_data</span> <span class="o">=</span> <span class="n">differential_cls</span><span class="p">(</span><span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="o">**</span><span class="n">diff_kwargs</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">TypeError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="c1"># this except clause is here to make the names of the</span>
                    <span class="c1"># attributes more human-readable.  Without this the names</span>
                    <span class="c1"># come from the representation instead of the frame&#39;s</span>
                    <span class="c1"># attribute names.</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
                    <span class="n">names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_representation_component_names</span><span class="p">(</span><span class="s2">&quot;s&quot;</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">frame_name</span><span class="p">,</span> <span class="n">repr_name</span> <span class="ow">in</span> <span class="n">names</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                        <span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">repr_name</span><span class="p">,</span> <span class="n">frame_name</span><span class="p">)</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;__init__()&quot;</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">()&quot;</span><span class="p">)</span>
                    <span class="n">e</span><span class="o">.</span><span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">msg</span><span class="p">,)</span>
                    <span class="k">raise</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.__init__ had </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span><span class="si">}</span><span class="s2"> remaining &quot;</span>
                <span class="s2">&quot;unhandled arguments&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">representation_data</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">differential_data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot pass in differential component data &quot;</span>
                <span class="s2">&quot;without positional (representation) data.&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">differential_data</span><span class="p">:</span>
            <span class="c1"># Check that differential data provided has units compatible</span>
            <span class="c1"># with time-derivative of representation data.</span>
            <span class="c1"># NOTE: there is no dimensionless time while lengths can be</span>
            <span class="c1"># dimensionless (u.dimensionless_unscaled).</span>
            <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="n">representation_data</span><span class="o">.</span><span class="n">components</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">diff_comp</span> <span class="o">:=</span> <span class="sa">f</span><span class="s2">&quot;d_</span><span class="si">{</span><span class="n">comp</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="ow">in</span> <span class="n">differential_data</span><span class="o">.</span><span class="n">components</span><span class="p">:</span>
                    <span class="n">current_repr_unit</span> <span class="o">=</span> <span class="n">representation_data</span><span class="o">.</span><span class="n">_units</span><span class="p">[</span><span class="n">comp</span><span class="p">]</span>
                    <span class="n">current_diff_unit</span> <span class="o">=</span> <span class="n">differential_data</span><span class="o">.</span><span class="n">_units</span><span class="p">[</span><span class="n">diff_comp</span><span class="p">]</span>
                    <span class="n">expected_unit</span> <span class="o">=</span> <span class="n">current_repr_unit</span> <span class="o">/</span> <span class="n">u</span><span class="o">.</span><span class="n">s</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">current_diff_unit</span><span class="o">.</span><span class="n">is_equivalent</span><span class="p">(</span><span class="n">expected_unit</span><span class="p">):</span>
                        <span class="k">for</span> <span class="p">(</span>
                            <span class="n">key</span><span class="p">,</span>
                            <span class="n">val</span><span class="p">,</span>
                        <span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_representation_component_names</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                            <span class="k">if</span> <span class="n">val</span> <span class="o">==</span> <span class="n">comp</span><span class="p">:</span>
                                <span class="n">current_repr_name</span> <span class="o">=</span> <span class="n">key</span>
                                <span class="k">break</span>
                        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_representation_component_names</span><span class="p">(</span>
                            <span class="s2">&quot;s&quot;</span>
                        <span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                            <span class="k">if</span> <span class="n">val</span> <span class="o">==</span> <span class="n">diff_comp</span><span class="p">:</span>
                                <span class="n">current_diff_name</span> <span class="o">=</span> <span class="n">key</span>
                                <span class="k">break</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">current_repr_name</span><span class="si">}</span><span class="s1"> has unit &quot;</span><span class="si">{</span><span class="n">current_repr_unit</span><span class="si">}</span><span class="s1">&quot; with&#39;</span>
                            <span class="sa">f</span><span class="s1">&#39; physical type &quot;</span><span class="si">{</span><span class="n">current_repr_unit</span><span class="o">.</span><span class="n">physical_type</span><span class="si">}</span><span class="s1">&quot;, but&#39;</span>
                            <span class="sa">f</span><span class="s2">&quot; </span><span class="si">{</span><span class="n">current_diff_name</span><span class="si">}</span><span class="s2"> has incompatible unit&quot;</span>
                            <span class="sa">f</span><span class="s1">&#39; &quot;</span><span class="si">{</span><span class="n">current_diff_unit</span><span class="si">}</span><span class="s1">&quot; with physical type&#39;</span>
                            <span class="sa">f</span><span class="s1">&#39; &quot;</span><span class="si">{</span><span class="n">current_diff_unit</span><span class="o">.</span><span class="n">physical_type</span><span class="si">}</span><span class="s1">&quot; instead of the&#39;</span>
                            <span class="sa">f</span><span class="s1">&#39; expected &quot;</span><span class="si">{</span><span class="p">(</span><span class="n">expected_unit</span><span class="p">)</span><span class="o">.</span><span class="n">physical_type</span><span class="si">}</span><span class="s1">&quot;.&#39;</span>
                        <span class="p">)</span>

            <span class="n">representation_data</span> <span class="o">=</span> <span class="n">representation_data</span><span class="o">.</span><span class="n">with_differentials</span><span class="p">(</span>
                <span class="p">{</span><span class="s2">&quot;s&quot;</span><span class="p">:</span> <span class="n">differential_data</span><span class="p">}</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">representation_data</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_infer_repr_info</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">repr_info</span><span class="p">):</span>
        <span class="c1"># Unless overridden via `frame_specific_representation_info`, velocity</span>
        <span class="c1"># name defaults are (see also docstring for BaseCoordinateFrame):</span>
        <span class="c1">#   * ``pm_{lon}_cos{lat}``, ``pm_{lat}`` for</span>
        <span class="c1">#     `SphericalCosLatDifferential` proper motion components</span>
        <span class="c1">#   * ``pm_{lon}``, ``pm_{lat}`` for `SphericalDifferential` proper</span>
        <span class="c1">#     motion components</span>
        <span class="c1">#   * ``radial_velocity`` for any `d_distance` component</span>
        <span class="c1">#   * ``v_{x,y,z}`` for `CartesianDifferential` velocity components</span>
        <span class="c1"># where `{lon}` and `{lat}` are the frame names of the angular</span>
        <span class="c1"># components.</span>
        <span class="k">if</span> <span class="n">repr_info</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">repr_info</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># the tuple() call below is necessary because if it is not there,</span>
        <span class="c1"># the iteration proceeds in a difficult-to-predict manner in the</span>
        <span class="c1"># case that one of the class objects hash is such that it gets</span>
        <span class="c1"># revisited by the iteration.  The tuple() call prevents this by</span>
        <span class="c1"># making the items iterated over fixed regardless of how the dict</span>
        <span class="c1"># changes</span>
        <span class="k">for</span> <span class="n">cls_or_name</span> <span class="ow">in</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">repr_info</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cls_or_name</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="c1"># TODO: this provides a layer of backwards compatibility in</span>
                <span class="c1"># case the key is a string, but now we want explicit classes.</span>
                <span class="n">_cls</span> <span class="o">=</span> <span class="n">_get_repr_cls</span><span class="p">(</span><span class="n">cls_or_name</span><span class="p">)</span>
                <span class="n">repr_info</span><span class="p">[</span><span class="n">_cls</span><span class="p">]</span> <span class="o">=</span> <span class="n">repr_info</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">cls_or_name</span><span class="p">)</span>

        <span class="c1"># The default spherical names are &#39;lon&#39; and &#39;lat&#39;</span>
        <span class="n">repr_info</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span>
            <span class="n">r</span><span class="o">.</span><span class="n">SphericalRepresentation</span><span class="p">,</span>
            <span class="p">[</span><span class="n">RepresentationMapping</span><span class="p">(</span><span class="s2">&quot;lon&quot;</span><span class="p">,</span> <span class="s2">&quot;lon&quot;</span><span class="p">),</span> <span class="n">RepresentationMapping</span><span class="p">(</span><span class="s2">&quot;lat&quot;</span><span class="p">,</span> <span class="s2">&quot;lat&quot;</span><span class="p">)],</span>
        <span class="p">)</span>

        <span class="n">sph_component_map</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">m</span><span class="o">.</span><span class="n">reprname</span><span class="p">:</span> <span class="n">m</span><span class="o">.</span><span class="n">framename</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">repr_info</span><span class="p">[</span><span class="n">r</span><span class="o">.</span><span class="n">SphericalRepresentation</span><span class="p">]</span>
        <span class="p">}</span>

        <span class="n">repr_info</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span>
            <span class="n">r</span><span class="o">.</span><span class="n">SphericalCosLatDifferential</span><span class="p">,</span>
            <span class="p">[</span>
                <span class="n">RepresentationMapping</span><span class="p">(</span>
                    <span class="s2">&quot;d_lon_coslat&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;pm_</span><span class="si">{lon}</span><span class="s2">_cos</span><span class="si">{lat}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">**</span><span class="n">sph_component_map</span><span class="p">),</span>
                    <span class="n">u</span><span class="o">.</span><span class="n">mas</span> <span class="o">/</span> <span class="n">u</span><span class="o">.</span><span class="n">yr</span><span class="p">,</span>
                <span class="p">),</span>
                <span class="n">RepresentationMapping</span><span class="p">(</span>
                    <span class="s2">&quot;d_lat&quot;</span><span class="p">,</span> <span class="s2">&quot;pm_</span><span class="si">{lat}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">**</span><span class="n">sph_component_map</span><span class="p">),</span> <span class="n">u</span><span class="o">.</span><span class="n">mas</span> <span class="o">/</span> <span class="n">u</span><span class="o">.</span><span class="n">yr</span>
                <span class="p">),</span>
                <span class="n">RepresentationMapping</span><span class="p">(</span><span class="s2">&quot;d_distance&quot;</span><span class="p">,</span> <span class="s2">&quot;radial_velocity&quot;</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">km</span> <span class="o">/</span> <span class="n">u</span><span class="o">.</span><span class="n">s</span><span class="p">),</span>
            <span class="p">],</span>
        <span class="p">)</span>

        <span class="n">repr_info</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span>
            <span class="n">r</span><span class="o">.</span><span class="n">SphericalDifferential</span><span class="p">,</span>
            <span class="p">[</span>
                <span class="n">RepresentationMapping</span><span class="p">(</span>
                    <span class="s2">&quot;d_lon&quot;</span><span class="p">,</span> <span class="s2">&quot;pm_</span><span class="si">{lon}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">**</span><span class="n">sph_component_map</span><span class="p">),</span> <span class="n">u</span><span class="o">.</span><span class="n">mas</span> <span class="o">/</span> <span class="n">u</span><span class="o">.</span><span class="n">yr</span>
                <span class="p">),</span>
                <span class="n">RepresentationMapping</span><span class="p">(</span>
                    <span class="s2">&quot;d_lat&quot;</span><span class="p">,</span> <span class="s2">&quot;pm_</span><span class="si">{lat}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">**</span><span class="n">sph_component_map</span><span class="p">),</span> <span class="n">u</span><span class="o">.</span><span class="n">mas</span> <span class="o">/</span> <span class="n">u</span><span class="o">.</span><span class="n">yr</span>
                <span class="p">),</span>
                <span class="n">RepresentationMapping</span><span class="p">(</span><span class="s2">&quot;d_distance&quot;</span><span class="p">,</span> <span class="s2">&quot;radial_velocity&quot;</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">km</span> <span class="o">/</span> <span class="n">u</span><span class="o">.</span><span class="n">s</span><span class="p">),</span>
            <span class="p">],</span>
        <span class="p">)</span>
        <span class="n">repr_info</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span>
            <span class="n">r</span><span class="o">.</span><span class="n">RadialDifferential</span><span class="p">,</span>
            <span class="p">[</span><span class="n">RepresentationMapping</span><span class="p">(</span><span class="s2">&quot;d_distance&quot;</span><span class="p">,</span> <span class="s2">&quot;radial_velocity&quot;</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">km</span> <span class="o">/</span> <span class="n">u</span><span class="o">.</span><span class="n">s</span><span class="p">)],</span>
        <span class="p">)</span>
        <span class="n">repr_info</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span>
            <span class="n">r</span><span class="o">.</span><span class="n">CartesianDifferential</span><span class="p">,</span>
            <span class="p">[</span>
                <span class="n">RepresentationMapping</span><span class="p">(</span><span class="s2">&quot;d_x&quot;</span><span class="p">,</span> <span class="s2">&quot;v_x&quot;</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">km</span> <span class="o">/</span> <span class="n">u</span><span class="o">.</span><span class="n">s</span><span class="p">),</span>
                <span class="n">RepresentationMapping</span><span class="p">(</span><span class="s2">&quot;d_y&quot;</span><span class="p">,</span> <span class="s2">&quot;v_y&quot;</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">km</span> <span class="o">/</span> <span class="n">u</span><span class="o">.</span><span class="n">s</span><span class="p">),</span>
                <span class="n">RepresentationMapping</span><span class="p">(</span><span class="s2">&quot;d_z&quot;</span><span class="p">,</span> <span class="s2">&quot;v_z&quot;</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">km</span> <span class="o">/</span> <span class="n">u</span><span class="o">.</span><span class="n">s</span><span class="p">),</span>
            <span class="p">],</span>
        <span class="p">)</span>

        <span class="c1"># Unit* classes should follow the same naming conventions</span>
        <span class="c1"># TODO: this adds some unnecessary mappings for the Unit classes, so</span>
        <span class="c1"># this could be cleaned up, but in practice doesn&#39;t seem to have any</span>
        <span class="c1"># negative side effects</span>
        <span class="n">repr_info</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span>
            <span class="n">r</span><span class="o">.</span><span class="n">UnitSphericalRepresentation</span><span class="p">,</span> <span class="n">repr_info</span><span class="p">[</span><span class="n">r</span><span class="o">.</span><span class="n">SphericalRepresentation</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="n">repr_info</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span>
            <span class="n">r</span><span class="o">.</span><span class="n">UnitSphericalCosLatDifferential</span><span class="p">,</span> <span class="n">repr_info</span><span class="p">[</span><span class="n">r</span><span class="o">.</span><span class="n">SphericalCosLatDifferential</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="n">repr_info</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span>
            <span class="n">r</span><span class="o">.</span><span class="n">UnitSphericalDifferential</span><span class="p">,</span> <span class="n">repr_info</span><span class="p">[</span><span class="n">r</span><span class="o">.</span><span class="n">SphericalDifferential</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">repr_info</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_create_readonly_property</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">attr_name</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">private_attr</span> <span class="o">=</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="n">attr_name</span>

        <span class="k">def</span> <span class="nf">getter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">private_attr</span><span class="p">)</span>

        <span class="nb">setattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">private_attr</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">attr_name</span><span class="p">,</span> <span class="nb">property</span><span class="p">(</span><span class="n">getter</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="n">doc</span><span class="p">))</span>

    <span class="nd">@lazyproperty</span>
    <span class="k">def</span> <span class="nf">cache</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Cache for this frame, a dict.</span>

<span class="sd">        It stores anything that should be computed from the coordinate data (*not* from</span>
<span class="sd">        the frame attributes). This can be used in functions to store anything that</span>
<span class="sd">        might be expensive to compute but might be re-used by some other function.</span>
<span class="sd">        E.g.::</span>

<span class="sd">            if &#39;user_data&#39; in myframe.cache:</span>
<span class="sd">                data = myframe.cache[&#39;user_data&#39;]</span>
<span class="sd">            else:</span>
<span class="sd">                myframe.cache[&#39;user_data&#39;] = data = expensive_func(myframe.lat)</span>

<span class="sd">        If in-place modifications are made to the frame data, the cache should</span>
<span class="sd">        be cleared::</span>

<span class="sd">            myframe.cache.clear()</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">dict</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The coordinate data for this object.  If this frame has no data, an</span>
<span class="sd">        `ValueError` will be raised.  Use `has_data` to</span>
<span class="sd">        check if data is present on this frame object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;The frame object &quot;</span><span class="si">{</span><span class="bp">self</span><span class="si">!r}</span><span class="s1">&quot; does not have associated data&#39;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">has_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        True if this frame has `data`, False otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shape</span>

    <span class="c1"># We have to override the ShapedLikeNDArray definitions, since our shape</span>
    <span class="c1"># does not have to be that of the data.</span>
    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__bool__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_data</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">size</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">isscalar</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_data</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">isscalar</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">get_frame_attr_defaults</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a dict with the defaults for each frame attribute.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">name</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">default</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">frame_attributes</span><span class="p">}</span>

    <span class="nd">@deprecated</span><span class="p">(</span>
        <span class="s2">&quot;5.2&quot;</span><span class="p">,</span>
        <span class="n">alternative</span><span class="o">=</span><span class="s2">&quot;get_frame_attr_defaults&quot;</span><span class="p">,</span>
        <span class="n">message</span><span class="o">=</span><span class="p">(</span>
            <span class="s2">&quot;The </span><span class="si">{func}</span><span class="s2">() </span><span class="si">{obj_type}</span><span class="s2"> is deprecated and may be removed in a future&quot;</span>
            <span class="s2">&quot; version. Use </span><span class="si">{alternative}</span><span class="s2">() to obtain a dict of frame attribute names&quot;</span>
            <span class="s2">&quot; and default values.&quot;</span>
            <span class="s2">&quot; The fastest way to obtain the names is frame_attributes.keys()&quot;</span>
        <span class="p">),</span>
    <span class="p">)</span>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">get_frame_attr_names</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a dict with the defaults for each frame attribute.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">get_frame_attr_defaults</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">get_representation_cls</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s2">&quot;base&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The class used for part of this frame&#39;s data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        which : (&#39;base&#39;, &#39;s&#39;, `None`)</span>
<span class="sd">            The class of which part to return.  &#39;base&#39; means the class used to</span>
<span class="sd">            represent the coordinates; &#39;s&#39; the first derivative to time, i.e.,</span>
<span class="sd">            the class representing the proper motion and/or radial velocity.</span>
<span class="sd">            If `None`, return a dict with both.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        representation : `~astropy.coordinates.BaseRepresentation` or `~astropy.coordinates.BaseDifferential`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">which</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_representation</span><span class="p">[</span><span class="n">which</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_representation</span>

    <span class="k">def</span> <span class="nf">set_representation_cls</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="s2">&quot;base&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set representation and/or differential class for this frame&#39;s data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        base : str, `~astropy.coordinates.BaseRepresentation` subclass, optional</span>
<span class="sd">            The name or subclass to use to represent the coordinate data.</span>
<span class="sd">        s : `~astropy.coordinates.BaseDifferential` subclass, optional</span>
<span class="sd">            The differential subclass to use to represent any velocities,</span>
<span class="sd">            such as proper motion and radial velocity.  If equal to &#39;base&#39;,</span>
<span class="sd">            which is the default, it will be inferred from the representation.</span>
<span class="sd">            If `None`, the representation will drop any differentials.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">base</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">base</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_representation</span><span class="p">[</span><span class="s2">&quot;base&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_representation</span> <span class="o">=</span> <span class="n">_get_repr_classes</span><span class="p">(</span><span class="n">base</span><span class="o">=</span><span class="n">base</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">s</span><span class="p">)</span>

    <span class="n">representation_type</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span>
        <span class="n">fget</span><span class="o">=</span><span class="n">get_representation_cls</span><span class="p">,</span>
        <span class="n">fset</span><span class="o">=</span><span class="n">set_representation_cls</span><span class="p">,</span>
        <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;The representation class used for this frame&#39;s data.</span>

<span class="s2">        This will be a subclass from `~astropy.coordinates.BaseRepresentation`.</span>
<span class="s2">        Can also be *set* using the string name of the representation. If you</span>
<span class="s2">        wish to set an explicit differential class (rather than have it be</span>
<span class="s2">        inferred), use the ``set_representation_cls`` method.</span>
<span class="s2">        &quot;&quot;&quot;</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">differential_type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The differential used for this frame&#39;s data.</span>

<span class="sd">        This will be a subclass from `~astropy.coordinates.BaseDifferential`.</span>
<span class="sd">        For simultaneous setting of representation and differentials, see the</span>
<span class="sd">        ``set_representation_cls`` method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_representation_cls</span><span class="p">(</span><span class="s2">&quot;s&quot;</span><span class="p">)</span>

    <span class="nd">@differential_type</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">differential_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_representation_cls</span><span class="p">(</span><span class="n">s</span><span class="o">=</span><span class="n">value</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_get_representation_info</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="c1"># This exists as a class method only to support handling frame inputs</span>
        <span class="c1"># without units, which are deprecated and will be removed.  This can be</span>
        <span class="c1"># moved into the representation_info property at that time.</span>
        <span class="c1"># note that if so moved, the cache should be acceessed as</span>
        <span class="c1"># self.__class__._frame_class_cache</span>

        <span class="k">if</span> <span class="p">(</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">_frame_class_cache</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;last_reprdiff_hash&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="o">!=</span> <span class="n">r</span><span class="o">.</span><span class="n">get_reprdiff_cls_hash</span><span class="p">()</span>
        <span class="p">):</span>
            <span class="n">repr_attrs</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">repr_diff_cls</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">REPRESENTATION_CLASSES</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span>
                <span class="n">r</span><span class="o">.</span><span class="n">DIFFERENTIAL_CLASSES</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
            <span class="p">):</span>
                <span class="n">repr_attrs</span><span class="p">[</span><span class="n">repr_diff_cls</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;names&quot;</span><span class="p">:</span> <span class="p">[],</span> <span class="s2">&quot;units&quot;</span><span class="p">:</span> <span class="p">[]}</span>
                <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">c_cls</span> <span class="ow">in</span> <span class="n">repr_diff_cls</span><span class="o">.</span><span class="n">attr_classes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">repr_attrs</span><span class="p">[</span><span class="n">repr_diff_cls</span><span class="p">][</span><span class="s2">&quot;names&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
                    <span class="n">rec_unit</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">deg</span> <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">c_cls</span><span class="p">,</span> <span class="n">Angle</span><span class="p">)</span> <span class="k">else</span> <span class="kc">None</span>
                    <span class="n">repr_attrs</span><span class="p">[</span><span class="n">repr_diff_cls</span><span class="p">][</span><span class="s2">&quot;units&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rec_unit</span><span class="p">)</span>

            <span class="k">for</span> <span class="p">(</span>
                <span class="n">repr_diff_cls</span><span class="p">,</span>
                <span class="n">mappings</span><span class="p">,</span>
            <span class="p">)</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_frame_specific_representation_info</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="c1"># take the &#39;names&#39; and &#39;units&#39; tuples from repr_attrs,</span>
                <span class="c1"># and then use the RepresentationMapping objects</span>
                <span class="c1"># to update as needed for this frame.</span>
                <span class="n">nms</span> <span class="o">=</span> <span class="n">repr_attrs</span><span class="p">[</span><span class="n">repr_diff_cls</span><span class="p">][</span><span class="s2">&quot;names&quot;</span><span class="p">]</span>
                <span class="n">uns</span> <span class="o">=</span> <span class="n">repr_attrs</span><span class="p">[</span><span class="n">repr_diff_cls</span><span class="p">][</span><span class="s2">&quot;units&quot;</span><span class="p">]</span>
                <span class="n">comptomap</span> <span class="o">=</span> <span class="p">{</span><span class="n">m</span><span class="o">.</span><span class="n">reprname</span><span class="p">:</span> <span class="n">m</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">mappings</span><span class="p">}</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">repr_diff_cls</span><span class="o">.</span><span class="n">attr_classes</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                    <span class="k">if</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">comptomap</span><span class="p">:</span>
                        <span class="n">mapp</span> <span class="o">=</span> <span class="n">comptomap</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>
                        <span class="n">nms</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">mapp</span><span class="o">.</span><span class="n">framename</span>

                        <span class="c1"># need the isinstance because otherwise if it&#39;s a unit it</span>
                        <span class="c1"># will try to compare to the unit string representation</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span>
                            <span class="nb">isinstance</span><span class="p">(</span><span class="n">mapp</span><span class="o">.</span><span class="n">defaultunit</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
                            <span class="ow">and</span> <span class="n">mapp</span><span class="o">.</span><span class="n">defaultunit</span> <span class="o">==</span> <span class="s2">&quot;recommended&quot;</span>
                        <span class="p">):</span>
                            <span class="n">uns</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">mapp</span><span class="o">.</span><span class="n">defaultunit</span>
                            <span class="c1"># else we just leave it as recommended_units says above</span>

                <span class="c1"># Convert to tuples so that this can&#39;t mess with frame internals</span>
                <span class="n">repr_attrs</span><span class="p">[</span><span class="n">repr_diff_cls</span><span class="p">][</span><span class="s2">&quot;names&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">nms</span><span class="p">)</span>
                <span class="n">repr_attrs</span><span class="p">[</span><span class="n">repr_diff_cls</span><span class="p">][</span><span class="s2">&quot;units&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">uns</span><span class="p">)</span>

            <span class="bp">cls</span><span class="o">.</span><span class="n">_frame_class_cache</span><span class="p">[</span><span class="s2">&quot;representation_info&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">repr_attrs</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">_frame_class_cache</span><span class="p">[</span><span class="s2">&quot;last_reprdiff_hash&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">get_reprdiff_cls_hash</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_frame_class_cache</span><span class="p">[</span><span class="s2">&quot;representation_info&quot;</span><span class="p">]</span>

    <span class="nd">@lazyproperty</span>
    <span class="k">def</span> <span class="nf">representation_info</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A dictionary with the information of what attribute names for this frame</span>
<span class="sd">        apply to particular representations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_representation_info</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">get_representation_component_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s2">&quot;base&quot;</span><span class="p">):</span>
        <span class="n">out</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">repr_or_diff_cls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_representation_cls</span><span class="p">(</span><span class="n">which</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">repr_or_diff_cls</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">out</span>
        <span class="n">data_names</span> <span class="o">=</span> <span class="n">repr_or_diff_cls</span><span class="o">.</span><span class="n">attr_classes</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="n">repr_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">representation_info</span><span class="p">[</span><span class="n">repr_or_diff_cls</span><span class="p">][</span><span class="s2">&quot;names&quot;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">repr_name</span><span class="p">,</span> <span class="n">data_name</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">repr_names</span><span class="p">,</span> <span class="n">data_names</span><span class="p">):</span>
            <span class="n">out</span><span class="p">[</span><span class="n">repr_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_name</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span> <span class="nf">get_representation_component_units</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s2">&quot;base&quot;</span><span class="p">):</span>
        <span class="n">out</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">repr_or_diff_cls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_representation_cls</span><span class="p">(</span><span class="n">which</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">repr_or_diff_cls</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">out</span>
        <span class="n">repr_attrs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">representation_info</span><span class="p">[</span><span class="n">repr_or_diff_cls</span><span class="p">]</span>
        <span class="n">repr_names</span> <span class="o">=</span> <span class="n">repr_attrs</span><span class="p">[</span><span class="s2">&quot;names&quot;</span><span class="p">]</span>
        <span class="n">repr_units</span> <span class="o">=</span> <span class="n">repr_attrs</span><span class="p">[</span><span class="s2">&quot;units&quot;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">repr_name</span><span class="p">,</span> <span class="n">repr_unit</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">repr_names</span><span class="p">,</span> <span class="n">repr_units</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">repr_unit</span><span class="p">:</span>
                <span class="n">out</span><span class="p">[</span><span class="n">repr_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">repr_unit</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="n">representation_component_names</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">get_representation_component_names</span><span class="p">)</span>

    <span class="n">representation_component_units</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">get_representation_component_units</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_replicate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Base for replicating a frame, with possibly different attributes.</span>

<span class="sd">        Produces a new instance of the frame using the attributes of the old</span>
<span class="sd">        frame (unless overridden) and with the data given.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : `~astropy.coordinates.BaseRepresentation` or None</span>
<span class="sd">            Data to use in the new frame instance.  If `None`, it will be</span>
<span class="sd">            a data-less frame.</span>
<span class="sd">        copy : bool, optional</span>
<span class="sd">            Whether data and the attributes on the old frame should be copied</span>
<span class="sd">            (default), or passed on by reference.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Any attributes that should be overridden.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># This is to provide a slightly nicer error message if the user tries</span>
        <span class="c1"># to use frame_obj.representation instead of frame_obj.data to get the</span>
        <span class="c1"># underlying representation object [e.g., #2890]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">type</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;Class passed as data instead of a representation instance. If you&quot;</span>
                <span class="s2">&quot; called frame.representation, this returns the representation class.&quot;</span>
                <span class="s2">&quot; frame.data returns the instantiated object - you may want to  use&quot;</span>
                <span class="s2">&quot; this instead.&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">copy</span> <span class="ow">and</span> <span class="n">data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">frame_attributes</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">attr</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attr_names_with_defaults</span> <span class="ow">and</span> <span class="n">attr</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

                <span class="n">kwargs</span><span class="p">[</span><span class="n">attr</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">replicate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a replica of the frame, optionally with new frame attributes.</span>

<span class="sd">        The replica is a new frame object that has the same data as this frame</span>
<span class="sd">        object and with frame attributes overridden if they are provided as extra</span>
<span class="sd">        keyword arguments to this method. If ``copy`` is set to `True` then a</span>
<span class="sd">        copy of the internal arrays will be made.  Otherwise the replica will</span>
<span class="sd">        use a reference to the original arrays when possible to save memory. The</span>
<span class="sd">        internal arrays are normally not changeable by the user so in most cases</span>
<span class="sd">        it should not be necessary to set ``copy`` to `True`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        copy : bool, optional</span>
<span class="sd">            If True, the resulting object is a copy of the data.  When False,</span>
<span class="sd">            references are used where  possible. This rule also applies to the</span>
<span class="sd">            frame attributes.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Any additional keywords are treated as frame attributes to be set on the</span>
<span class="sd">            new frame object.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        frameobj : `~astropy.coordinates.BaseCoordinateFrame` subclass instance</span>
<span class="sd">            Replica of this object, but possibly with new frame attributes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replicate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">replicate_without_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a replica without data, optionally with new frame attributes.</span>

<span class="sd">        The replica is a new frame object without data but with the same frame</span>
<span class="sd">        attributes as this object, except where overridden by extra keyword</span>
<span class="sd">        arguments to this method.  The ``copy`` keyword determines if the frame</span>
<span class="sd">        attributes are truly copied vs being references (which saves memory for</span>
<span class="sd">        cases where frame attributes are large).</span>

<span class="sd">        This method is essentially the converse of `realize_frame`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        copy : bool, optional</span>
<span class="sd">            If True, the resulting object has copies of the frame attributes.</span>
<span class="sd">            When False, references are used where  possible.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Any additional keywords are treated as frame attributes to be set on the</span>
<span class="sd">            new frame object.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        frameobj : `~astropy.coordinates.BaseCoordinateFrame` subclass instance</span>
<span class="sd">            Replica of this object, but without data and possibly with new frame</span>
<span class="sd">            attributes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replicate</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">realize_frame</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates a new frame with new data from another frame (which may or</span>
<span class="sd">        may not have data). Roughly speaking, the converse of</span>
<span class="sd">        `replicate_without_data`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : `~astropy.coordinates.BaseRepresentation`</span>
<span class="sd">            The representation to use as the data for the new frame.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Any additional keywords are treated as frame attributes to be set on the</span>
<span class="sd">            new frame object. In particular, `representation_type` can be specified.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        frameobj : `~astropy.coordinates.BaseCoordinateFrame` subclass instance</span>
<span class="sd">            A new object in *this* frame, with the same frame attributes as</span>
<span class="sd">            this one, but with the ``data`` as the coordinate data.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replicate</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">represent_as</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="s2">&quot;base&quot;</span><span class="p">,</span> <span class="n">in_frame_units</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate and return a new representation of this frame&#39;s `data`</span>
<span class="sd">        as a Representation object.</span>

<span class="sd">        Note: In order to make an in-place change of the representation</span>
<span class="sd">        of a Frame or SkyCoord object, set the ``representation``</span>
<span class="sd">        attribute of that object to the desired new representation, or</span>
<span class="sd">        use the ``set_representation_cls`` method to also set the differential.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        base : subclass of BaseRepresentation or string</span>
<span class="sd">            The type of representation to generate.  Must be a *class*</span>
<span class="sd">            (not an instance), or the string name of the representation</span>
<span class="sd">            class.</span>
<span class="sd">        s : subclass of `~astropy.coordinates.BaseDifferential`, str, optional</span>
<span class="sd">            Class in which any velocities should be represented. Must be</span>
<span class="sd">            a *class* (not an instance), or the string name of the</span>
<span class="sd">            differential class.  If equal to &#39;base&#39; (default), inferred from</span>
<span class="sd">            the base class.  If `None`, all velocity information is dropped.</span>
<span class="sd">        in_frame_units : bool, keyword-only</span>
<span class="sd">            Force the representation units to match the specified units</span>
<span class="sd">            particular to this frame</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        newrep : BaseRepresentation-derived object</span>
<span class="sd">            A new representation object of this frame&#39;s `data`.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        AttributeError</span>
<span class="sd">            If this object had no `data`</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from astropy import units as u</span>
<span class="sd">        &gt;&gt;&gt; from astropy.coordinates import SkyCoord, CartesianRepresentation</span>
<span class="sd">        &gt;&gt;&gt; coord = SkyCoord(0*u.deg, 0*u.deg)</span>
<span class="sd">        &gt;&gt;&gt; coord.represent_as(CartesianRepresentation)  # doctest: +FLOAT_CMP</span>
<span class="sd">        &lt;CartesianRepresentation (x, y, z) [dimensionless]</span>
<span class="sd">                (1., 0., 0.)&gt;</span>

<span class="sd">        &gt;&gt;&gt; coord.representation_type = CartesianRepresentation</span>
<span class="sd">        &gt;&gt;&gt; coord  # doctest: +FLOAT_CMP</span>
<span class="sd">        &lt;SkyCoord (ICRS): (x, y, z) [dimensionless]</span>
<span class="sd">            (1., 0., 0.)&gt;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># For backwards compatibility (because in_frame_units used to be the</span>
        <span class="c1"># 2nd argument), we check to see if `new_differential` is a boolean. If</span>
        <span class="c1"># it is, we ignore the value of `new_differential` and warn about the</span>
        <span class="c1"># position change</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;The argument position for `in_frame_units` in `represent_as` has&quot;</span>
                <span class="s2">&quot; changed. Use as a keyword argument if needed.&quot;</span><span class="p">,</span>
                <span class="n">AstropyWarning</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">in_frame_units</span> <span class="o">=</span> <span class="n">s</span>
            <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;base&quot;</span>

        <span class="c1"># In the future, we may want to support more differentials, in which</span>
        <span class="c1"># case one probably needs to define **kwargs above and use it here.</span>
        <span class="c1"># But for now, we only care about the velocity.</span>
        <span class="n">repr_classes</span> <span class="o">=</span> <span class="n">_get_repr_classes</span><span class="p">(</span><span class="n">base</span><span class="o">=</span><span class="n">base</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">s</span><span class="p">)</span>
        <span class="n">representation_cls</span> <span class="o">=</span> <span class="n">repr_classes</span><span class="p">[</span><span class="s2">&quot;base&quot;</span><span class="p">]</span>
        <span class="c1"># We only keep velocity information</span>
        <span class="k">if</span> <span class="s2">&quot;s&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">differentials</span><span class="p">:</span>
            <span class="c1"># For the default &#39;base&#39; option in which _get_repr_classes has</span>
            <span class="c1"># given us a best guess based on the representation class, we only</span>
            <span class="c1"># use it if the class we had already is incompatible.</span>
            <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="s2">&quot;base&quot;</span> <span class="ow">and</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">differentials</span><span class="p">[</span><span class="s2">&quot;s&quot;</span><span class="p">]</span><span class="o">.</span><span class="vm">__class__</span>
                <span class="ow">in</span> <span class="n">representation_cls</span><span class="o">.</span><span class="n">_compatible_differentials</span>
            <span class="p">):</span>
                <span class="n">differential_cls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">differentials</span><span class="p">[</span><span class="s2">&quot;s&quot;</span><span class="p">]</span><span class="o">.</span><span class="vm">__class__</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">differential_cls</span> <span class="o">=</span> <span class="n">repr_classes</span><span class="p">[</span><span class="s2">&quot;s&quot;</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">s</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">s</span> <span class="o">==</span> <span class="s2">&quot;base&quot;</span><span class="p">:</span>
            <span class="n">differential_cls</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;Frame data has no associated differentials (i.e. the frame has no&quot;</span>
                <span class="s2">&quot; velocity data) - represent_as() only accepts a new representation.&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">differential_cls</span><span class="p">:</span>
            <span class="n">cache_key</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">representation_cls</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                <span class="n">differential_cls</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                <span class="n">in_frame_units</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cache_key</span> <span class="o">=</span> <span class="p">(</span><span class="n">representation_cls</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">in_frame_units</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">cached_repr</span> <span class="o">:=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">[</span><span class="s2">&quot;representation&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">cache_key</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">cached_repr</span>

        <span class="k">if</span> <span class="n">differential_cls</span><span class="p">:</span>
            <span class="c1"># Sanity check to ensure we do not just drop radial</span>
            <span class="c1"># velocity.  TODO: should Representation.represent_as</span>
            <span class="c1"># allow this transformation in the first place?</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">r</span><span class="o">.</span><span class="n">UnitSphericalRepresentation</span><span class="p">)</span>
                <span class="ow">and</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">representation_cls</span><span class="p">,</span> <span class="n">r</span><span class="o">.</span><span class="n">CartesianRepresentation</span><span class="p">)</span>
                <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">differentials</span><span class="p">[</span><span class="s2">&quot;s&quot;</span><span class="p">],</span>
                    <span class="p">(</span>
                        <span class="n">r</span><span class="o">.</span><span class="n">UnitSphericalDifferential</span><span class="p">,</span>
                        <span class="n">r</span><span class="o">.</span><span class="n">UnitSphericalCosLatDifferential</span><span class="p">,</span>
                        <span class="n">r</span><span class="o">.</span><span class="n">RadialDifferential</span><span class="p">,</span>
                    <span class="p">),</span>
                <span class="p">)</span>
            <span class="p">):</span>
                <span class="k">raise</span> <span class="n">u</span><span class="o">.</span><span class="n">UnitConversionError</span><span class="p">(</span>
                    <span class="s2">&quot;need a distance to retrieve a cartesian representation &quot;</span>
                    <span class="s2">&quot;when both radial velocity and proper motion are present, &quot;</span>
                    <span class="s2">&quot;since otherwise the units cannot match.&quot;</span>
                <span class="p">)</span>

            <span class="c1"># TODO NOTE: only supports a single differential</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">represent_as</span><span class="p">(</span><span class="n">representation_cls</span><span class="p">,</span> <span class="n">differential_cls</span><span class="p">)</span>
            <span class="n">diff</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">differentials</span><span class="p">[</span><span class="s2">&quot;s&quot;</span><span class="p">]</span>  <span class="c1"># TODO: assumes velocity</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">represent_as</span><span class="p">(</span><span class="n">representation_cls</span><span class="p">)</span>

        <span class="c1"># If the new representation is known to this frame and has a defined</span>
        <span class="c1"># set of names and units, then use that.</span>
        <span class="k">if</span> <span class="n">in_frame_units</span> <span class="ow">and</span> <span class="p">(</span>
            <span class="n">new_attrs</span> <span class="o">:=</span> <span class="bp">self</span><span class="o">.</span><span class="n">representation_info</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">representation_cls</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="n">datakwargs</span> <span class="o">=</span> <span class="p">{</span><span class="n">comp</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">comp</span><span class="p">)</span> <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">components</span><span class="p">}</span>
            <span class="k">for</span> <span class="n">comp</span><span class="p">,</span> <span class="n">new_attr_unit</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">components</span><span class="p">,</span> <span class="n">new_attrs</span><span class="p">[</span><span class="s2">&quot;units&quot;</span><span class="p">]):</span>
                <span class="k">if</span> <span class="n">new_attr_unit</span><span class="p">:</span>
                    <span class="n">datakwargs</span><span class="p">[</span><span class="n">comp</span><span class="p">]</span> <span class="o">=</span> <span class="n">datakwargs</span><span class="p">[</span><span class="n">comp</span><span class="p">]</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">new_attr_unit</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">datakwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">differential_cls</span><span class="p">:</span>
            <span class="c1"># the original differential</span>
            <span class="n">data_diff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">differentials</span><span class="p">[</span><span class="s2">&quot;s&quot;</span><span class="p">]</span>

            <span class="c1"># If the new differential is known to this frame and has a</span>
            <span class="c1"># defined set of names and units, then use that.</span>
            <span class="k">if</span> <span class="n">in_frame_units</span> <span class="ow">and</span> <span class="p">(</span>
                <span class="n">new_attrs</span> <span class="o">:=</span> <span class="bp">self</span><span class="o">.</span><span class="n">representation_info</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">differential_cls</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="n">diffkwargs</span> <span class="o">=</span> <span class="p">{</span><span class="n">comp</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">diff</span><span class="p">,</span> <span class="n">comp</span><span class="p">)</span> <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="n">diff</span><span class="o">.</span><span class="n">components</span><span class="p">}</span>
                <span class="k">for</span> <span class="n">comp</span><span class="p">,</span> <span class="n">new_attr_unit</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">diff</span><span class="o">.</span><span class="n">components</span><span class="p">,</span> <span class="n">new_attrs</span><span class="p">[</span><span class="s2">&quot;units&quot;</span><span class="p">]):</span>
                    <span class="c1"># Some special-casing to treat a situation where the</span>
                    <span class="c1"># input data has a UnitSphericalDifferential or a</span>
                    <span class="c1"># RadialDifferential. It is re-represented to the</span>
                    <span class="c1"># frame&#39;s differential class (which might be, e.g., a</span>
                    <span class="c1"># dimensional Differential), so we don&#39;t want to try to</span>
                    <span class="c1"># convert the empty component units</span>
                    <span class="k">if</span> <span class="p">(</span>
                        <span class="nb">isinstance</span><span class="p">(</span>
                            <span class="n">data_diff</span><span class="p">,</span>
                            <span class="p">(</span>
                                <span class="n">r</span><span class="o">.</span><span class="n">UnitSphericalDifferential</span><span class="p">,</span>
                                <span class="n">r</span><span class="o">.</span><span class="n">UnitSphericalCosLatDifferential</span><span class="p">,</span>
                                <span class="n">r</span><span class="o">.</span><span class="n">RadialDifferential</span><span class="p">,</span>
                            <span class="p">),</span>
                        <span class="p">)</span>
                        <span class="ow">and</span> <span class="n">comp</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data_diff</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">attr_classes</span>
                    <span class="p">):</span>
                        <span class="k">continue</span>

                    <span class="c1"># Try to convert to requested units. Since that might</span>
                    <span class="c1"># not be possible (e.g., for a coordinate with proper</span>
                    <span class="c1"># motion but without distance, one cannot convert to a</span>
                    <span class="c1"># cartesian differential in km/s), we allow the unit</span>
                    <span class="c1"># conversion to fail.  See gh-7028 for discussion.</span>
                    <span class="k">if</span> <span class="n">new_attr_unit</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">diff</span><span class="p">,</span> <span class="n">comp</span><span class="p">):</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">diffkwargs</span><span class="p">[</span><span class="n">comp</span><span class="p">]</span> <span class="o">=</span> <span class="n">diffkwargs</span><span class="p">[</span><span class="n">comp</span><span class="p">]</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">new_attr_unit</span><span class="p">)</span>
                        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                            <span class="k">pass</span>

                <span class="n">diff</span> <span class="o">=</span> <span class="n">diff</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">diffkwargs</span><span class="p">)</span>

                <span class="c1"># Here we have to bypass using with_differentials() because</span>
                <span class="c1"># it has a validation check. But because</span>
                <span class="c1"># .representation_type and .differential_type don&#39;t point to</span>
                <span class="c1"># the original classes, if the input differential is a</span>
                <span class="c1"># RadialDifferential, it usually gets turned into a</span>
                <span class="c1"># SphericalCosLatDifferential (or whatever the default is)</span>
                <span class="c1"># with strange units for the d_lon and d_lat attributes.</span>
                <span class="c1"># This then causes the dictionary key check to fail (i.e.</span>
                <span class="c1"># comparison against `diff._get_deriv_key()`)</span>
                <span class="n">data</span><span class="o">.</span><span class="n">_differentials</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;s&quot;</span><span class="p">:</span> <span class="n">diff</span><span class="p">})</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">[</span><span class="s2">&quot;representation&quot;</span><span class="p">][</span><span class="n">cache_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span>
        <span class="k">return</span> <span class="n">data</span>

    <span class="k">def</span> <span class="nf">transform_to</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_frame</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transform this object&#39;s coordinate data to a new frame.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        new_frame : coordinate-like</span>
<span class="sd">            The frame to transform this coordinate frame into.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        transframe : coordinate-like</span>
<span class="sd">            A new object with the coordinate data represented in the</span>
<span class="sd">            ``newframe`` system.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If there is no possible transformation route.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.errors</span> <span class="kn">import</span> <span class="n">ConvertError</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot transform a frame with no data&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span>
            <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="s2">&quot;differentials&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;obstime&quot;</span><span class="p">)</span>
            <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">new_frame</span><span class="p">,</span> <span class="s2">&quot;obstime&quot;</span><span class="p">)</span>
            <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obstime</span> <span class="o">!=</span> <span class="n">new_frame</span><span class="o">.</span><span class="n">obstime</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s2">&quot;You cannot transform a frame that has velocities to another frame at a&quot;</span>
                <span class="s2">&quot; different obstime. If you think this should (or should not) be&quot;</span>
                <span class="s2">&quot; possible, please comment at&quot;</span>
                <span class="s2">&quot; https://github.com/astropy/astropy/issues/6280&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">new_frame</span><span class="p">,</span> <span class="s2">&quot;_sky_coord_frame&quot;</span><span class="p">):</span>
            <span class="c1"># Input new_frame is not a frame instance or class and is most</span>
            <span class="c1"># likely a SkyCoord object.</span>
            <span class="n">new_frame</span> <span class="o">=</span> <span class="n">new_frame</span><span class="o">.</span><span class="n">_sky_coord_frame</span>

        <span class="n">trans</span> <span class="o">=</span> <span class="n">frame_transform_graph</span><span class="o">.</span><span class="n">get_transform</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">new_frame</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">trans</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">new_frame</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">:</span>
                <span class="c1"># no special transform needed, but should update frame info</span>
                <span class="k">return</span> <span class="n">new_frame</span><span class="o">.</span><span class="n">realize_frame</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Cannot transform from </span><span class="si">{0}</span><span class="s2"> to </span><span class="si">{1}</span><span class="s2">&quot;</span>
            <span class="k">raise</span> <span class="n">ConvertError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">new_frame</span><span class="o">.</span><span class="vm">__class__</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">trans</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_frame</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">is_transformable_to</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_frame</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determines if this coordinate frame can be transformed to another</span>
<span class="sd">        given frame.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        new_frame : `~astropy.coordinates.BaseCoordinateFrame` subclass or instance</span>
<span class="sd">            The proposed frame to transform into.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        transformable : bool or str</span>
<span class="sd">            `True` if this can be transformed to ``new_frame``, `False` if</span>
<span class="sd">            not, or the string &#39;same&#39; if ``new_frame`` is the same system as</span>
<span class="sd">            this object but no transformation is defined.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        A return value of &#39;same&#39; means the transformation will work, but it will</span>
<span class="sd">        just give back a copy of this object.  The intended usage is::</span>

<span class="sd">            if coord.is_transformable_to(some_unknown_frame):</span>
<span class="sd">                coord2 = coord.transform_to(some_unknown_frame)</span>

<span class="sd">        This will work even if ``some_unknown_frame``  turns out to be the same</span>
<span class="sd">        frame class as ``coord``.  This is intended for cases where the frame</span>
<span class="sd">        is the same regardless of the frame attributes (e.g. ICRS), but be</span>
<span class="sd">        aware that it *might* also indicate that someone forgot to define the</span>
<span class="sd">        transformation between two objects of the same frame class but with</span>
<span class="sd">        different attributes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_frame_cls</span> <span class="o">=</span> <span class="n">new_frame</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">new_frame</span><span class="p">,</span> <span class="nb">type</span><span class="p">)</span> <span class="k">else</span> <span class="nb">type</span><span class="p">(</span><span class="n">new_frame</span><span class="p">)</span>
        <span class="n">trans</span> <span class="o">=</span> <span class="n">frame_transform_graph</span><span class="o">.</span><span class="n">get_transform</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">new_frame_cls</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">trans</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">new_frame_cls</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">:</span>
                <span class="k">return</span> <span class="s2">&quot;same&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">is_frame_attr_default</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attrnm</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine whether or not a frame attribute has its value because it&#39;s</span>
<span class="sd">        the default value, or because this frame was created with that value</span>
<span class="sd">        explicitly requested.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        attrnm : str</span>
<span class="sd">            The name of the attribute to check.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        isdefault : bool</span>
<span class="sd">            True if the attribute ``attrnm`` has its value by default, False if</span>
<span class="sd">            it was specified at creation of this frame.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">attrnm</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attr_names_with_defaults</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_frameattr_equiv</span><span class="p">(</span><span class="n">left_fattr</span><span class="p">,</span> <span class="n">right_fattr</span><span class="p">):</span>  <span class="c1"># noqa: PLR0911</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine if two frame attributes are equivalent.  Implemented as a</span>
<span class="sd">        staticmethod mainly as a convenient location, although conceivable it</span>
<span class="sd">        might be desirable for subclasses to override this behavior.</span>

<span class="sd">        Primary purpose is to check for equality of representations.</span>
<span class="sd">        Secondary purpose is to check for equality of coordinate attributes,</span>
<span class="sd">        which first checks whether they themselves are in equivalent frames</span>
<span class="sd">        before checking for equality in the normal fashion.  This is because</span>
<span class="sd">        checking for equality with non-equivalent frames raises an error.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">left_fattr</span> <span class="ow">is</span> <span class="n">right_fattr</span><span class="p">:</span>
            <span class="c1"># shortcut if it&#39;s exactly the same object</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">left_fattr</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">right_fattr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># shortcut if one attribute is unspecified and the other isn&#39;t</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="n">left_is_repr</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">left_fattr</span><span class="p">,</span> <span class="n">r</span><span class="o">.</span><span class="n">BaseRepresentationOrDifferential</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">left_is_repr</span> <span class="o">^</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">right_fattr</span><span class="p">,</span> <span class="n">r</span><span class="o">.</span><span class="n">BaseRepresentationOrDifferential</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">left_is_repr</span><span class="p">:</span>
            <span class="c1"># both are representations.</span>
            <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">left_fattr</span><span class="p">,</span> <span class="s2">&quot;differentials&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">getattr</span><span class="p">(</span>
                <span class="n">right_fattr</span><span class="p">,</span> <span class="s2">&quot;differentials&quot;</span><span class="p">,</span> <span class="kc">False</span>
            <span class="p">):</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;Two representation frame attributes were checked for equivalence&quot;</span>
                    <span class="s2">&quot; when at least one of them has differentials.  This yields False&quot;</span>
                    <span class="s2">&quot; even if the underlying representations are equivalent (although&quot;</span>
                    <span class="s2">&quot; this may change in future versions of Astropy)&quot;</span><span class="p">,</span>
                    <span class="n">AstropyWarning</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span>
                <span class="n">left_fattr</span> <span class="o">==</span> <span class="n">right_fattr</span>
                <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">left_fattr</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">type</span><span class="p">(</span><span class="n">right_fattr</span><span class="p">)</span>
                <span class="k">else</span> <span class="n">left_fattr</span><span class="o">.</span><span class="n">to_cartesian</span><span class="p">()</span> <span class="o">==</span> <span class="n">right_fattr</span><span class="o">.</span><span class="n">to_cartesian</span><span class="p">()</span>
            <span class="p">)</span>

        <span class="n">left_is_coord</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">left_fattr</span><span class="p">,</span> <span class="n">BaseCoordinateFrame</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">left_is_coord</span> <span class="o">^</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">right_fattr</span><span class="p">,</span> <span class="n">BaseCoordinateFrame</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">left_is_coord</span><span class="p">:</span>
            <span class="c1"># both are coordinates</span>
            <span class="k">return</span> <span class="n">left_fattr</span><span class="o">.</span><span class="n">is_equivalent_frame</span><span class="p">(</span><span class="n">right_fattr</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span>
                <span class="n">left_fattr</span> <span class="o">==</span> <span class="n">right_fattr</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">left_fattr</span> <span class="o">==</span> <span class="n">right_fattr</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">is_equivalent_frame</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks if this object is the same frame as the ``other`` object.</span>

<span class="sd">        To be the same frame, two objects must be the same frame class and have</span>
<span class="sd">        the same frame attributes.  Note that it does *not* matter what, if any,</span>
<span class="sd">        data either object has.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : :class:`~astropy.coordinates.BaseCoordinateFrame`</span>
<span class="sd">            the other frame to check</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        isequiv : bool</span>
<span class="sd">            True if the frames are the same, False if not.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        TypeError</span>
<span class="sd">            If ``other`` isn&#39;t a `~astropy.coordinates.BaseCoordinateFrame` or subclass.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="vm">__class__</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">frame_attr_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">frame_attributes</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_frameattr_equiv</span><span class="p">(</span>
                    <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">frame_attr_name</span><span class="p">),</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">frame_attr_name</span><span class="p">)</span>
                <span class="p">):</span>
                    <span class="k">return</span> <span class="kc">False</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">BaseCoordinateFrame</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;Tried to do is_equivalent_frame on something that isn&#39;t a frame&quot;</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">frameattrs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_frame_attrs_repr</span><span class="p">()</span>
        <span class="n">data_repr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_repr</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">frameattrs</span><span class="p">:</span>
            <span class="n">frameattrs</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot; (</span><span class="si">{</span><span class="n">frameattrs</span><span class="si">}</span><span class="s2">)&quot;</span>

        <span class="k">if</span> <span class="n">data_repr</span><span class="p">:</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;&lt;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> Coordinate</span><span class="si">{</span><span class="n">frameattrs</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">data_repr</span><span class="si">}</span><span class="s2">&gt;&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;&lt;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> Frame</span><span class="si">{</span><span class="n">frameattrs</span><span class="si">}</span><span class="s2">&gt;&quot;</span>

    <span class="k">def</span> <span class="nf">_data_repr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a string representation of the coordinate data.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_data</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">representation_type</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">representation_type</span><span class="p">,</span> <span class="s2">&quot;_unit_representation&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">representation_type</span><span class="o">.</span><span class="n">_unit_representation</span>
            <span class="p">):</span>
                <span class="n">rep_cls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="vm">__class__</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">rep_cls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">representation_type</span>

            <span class="k">if</span> <span class="s2">&quot;s&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">differentials</span><span class="p">:</span>
                <span class="n">dif_cls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_representation_cls</span><span class="p">(</span><span class="s2">&quot;s&quot;</span><span class="p">)</span>
                <span class="n">dif_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">differentials</span><span class="p">[</span><span class="s2">&quot;s&quot;</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span>
                    <span class="n">dif_data</span><span class="p">,</span>
                    <span class="p">(</span>
                        <span class="n">r</span><span class="o">.</span><span class="n">UnitSphericalDifferential</span><span class="p">,</span>
                        <span class="n">r</span><span class="o">.</span><span class="n">UnitSphericalCosLatDifferential</span><span class="p">,</span>
                        <span class="n">r</span><span class="o">.</span><span class="n">RadialDifferential</span><span class="p">,</span>
                    <span class="p">),</span>
                <span class="p">):</span>
                    <span class="n">dif_cls</span> <span class="o">=</span> <span class="n">dif_data</span><span class="o">.</span><span class="vm">__class__</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">dif_cls</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">represent_as</span><span class="p">(</span><span class="n">rep_cls</span><span class="p">,</span> <span class="n">dif_cls</span><span class="p">,</span> <span class="n">in_frame_units</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="n">data_repr</span> <span class="o">=</span> <span class="nb">repr</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="c1"># Generate the list of component names out of the repr string</span>
            <span class="n">part1</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">remainder</span> <span class="o">=</span> <span class="n">data_repr</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="s2">&quot;(&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">remainder</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
                <span class="n">comp_str</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">part2</span> <span class="o">=</span> <span class="n">remainder</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="s2">&quot;)&quot;</span><span class="p">)</span>
                <span class="n">comp_names</span> <span class="o">=</span> <span class="n">comp_str</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="p">)</span>
                <span class="c1"># Swap in frame-specific component names</span>
                <span class="n">invnames</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="n">nmrepr</span><span class="p">:</span> <span class="n">nmpref</span>
                    <span class="k">for</span> <span class="n">nmpref</span><span class="p">,</span> <span class="n">nmrepr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">representation_component_names</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="p">}</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">comp_names</span><span class="p">):</span>
                    <span class="n">comp_names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">invnames</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
                <span class="c1"># Reassemble the repr string</span>
                <span class="n">data_repr</span> <span class="o">=</span> <span class="n">part1</span> <span class="o">+</span> <span class="s2">&quot;(&quot;</span> <span class="o">+</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">comp_names</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span> <span class="o">+</span> <span class="n">part2</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>
            <span class="n">data_repr</span> <span class="o">=</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">data_repr</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;&lt;&quot;</span> <span class="o">+</span> <span class="n">data</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">):</span>
            <span class="c1"># remove both the leading &quot;&lt;&quot; and the space after the name, as well</span>
            <span class="c1"># as the trailing &quot;&gt;&quot;</span>
            <span class="n">data_repr</span> <span class="o">=</span> <span class="n">data_repr</span><span class="p">[(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data_repr</span> <span class="o">=</span> <span class="s2">&quot;Data:</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="n">data_repr</span>

        <span class="k">if</span> <span class="s2">&quot;s&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">differentials</span><span class="p">:</span>
            <span class="n">data_repr_spl</span> <span class="o">=</span> <span class="n">data_repr</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="s2">&quot;has differentials&quot;</span> <span class="ow">in</span> <span class="n">data_repr_spl</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">diffrepr</span> <span class="o">=</span> <span class="nb">repr</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">differentials</span><span class="p">[</span><span class="s2">&quot;s&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">diffrepr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;&lt;&quot;</span><span class="p">):</span>
                    <span class="n">diffrepr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span> <span class="o">+</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">diffrepr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">:])</span>
                <span class="k">for</span> <span class="n">frm_nm</span><span class="p">,</span> <span class="n">rep_nm</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_representation_component_names</span><span class="p">(</span>
                    <span class="s2">&quot;s&quot;</span>
                <span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">diffrepr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">diffrepr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">rep_nm</span><span class="p">,</span> <span class="n">frm_nm</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">diffrepr</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;&gt;&quot;</span><span class="p">):</span>
                    <span class="n">diffrepr</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">diffrepr</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">data_repr_spl</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">diffrepr</span><span class="p">)</span>

            <span class="n">data_repr</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">data_repr_spl</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">data_repr</span>

    <span class="k">def</span> <span class="nf">_frame_attrs_repr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a string representation of the frame&#39;s attributes, if any.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">attr_strs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">attribute_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">frame_attributes</span><span class="p">:</span>
            <span class="n">attr</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attribute_name</span><span class="p">)</span>
            <span class="c1"># Check to see if this object has a way of representing itself</span>
            <span class="c1"># specific to being an attribute of a frame. (Note, this is not the</span>
            <span class="c1"># Attribute class, it&#39;s the actual object).</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="s2">&quot;_astropy_repr_in_frame&quot;</span><span class="p">):</span>
                <span class="n">attrstr</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">_astropy_repr_in_frame</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">attrstr</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">attr</span><span class="p">)</span>
            <span class="n">attr_strs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">attribute_name</span><span class="si">}</span><span class="s2">=</span><span class="si">{</span><span class="n">attrstr</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">attr_strs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a new instance, applying a method to the underlying data.</span>

<span class="sd">        In typical usage, the method is any of the shape-changing methods for</span>
<span class="sd">        `~numpy.ndarray` (``reshape``, ``swapaxes``, etc.), as well as those</span>
<span class="sd">        picking particular elements (``__getitem__``, ``take``, etc.), which</span>
<span class="sd">        are all defined in `~astropy.utils.shapes.ShapedLikeNDArray`. It will be</span>
<span class="sd">        applied to the underlying arrays in the representation (e.g., ``x``,</span>
<span class="sd">        ``y``, and ``z`` for `~astropy.coordinates.CartesianRepresentation`),</span>
<span class="sd">        as well as to any frame attributes that have a shape, with the results</span>
<span class="sd">        used to create a new instance.</span>

<span class="sd">        Internally, it is also used to apply functions to the above parts</span>
<span class="sd">        (in particular, `~numpy.broadcast_to`).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        method : str or callable</span>
<span class="sd">            If str, it is the name of a method that is applied to the internal</span>
<span class="sd">            ``components``. If callable, the function is applied.</span>
<span class="sd">        *args : tuple</span>
<span class="sd">            Any positional arguments for ``method``.</span>
<span class="sd">        **kwargs : dict</span>
<span class="sd">            Any keyword arguments for ``method``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">apply_method</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">ShapedLikeNDArray</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">value</span><span class="o">.</span><span class="n">_apply</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">callable</span><span class="p">(</span><span class="n">method</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">method</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">method</span><span class="p">)(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">new</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_representation&quot;</span><span class="p">):</span>
            <span class="n">new</span><span class="o">.</span><span class="n">_representation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_representation</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">new</span><span class="o">.</span><span class="n">_attr_names_with_defaults</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attr_names_with_defaults</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="n">new_shape</span> <span class="o">=</span> <span class="p">()</span>
        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">frame_attributes</span><span class="p">:</span>
            <span class="n">_attr</span> <span class="o">=</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="n">attr</span>
            <span class="k">if</span> <span class="n">attr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attr_names_with_defaults</span><span class="p">:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="n">_attr</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_attr</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_attr</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="s2">&quot;shape&quot;</span><span class="p">,</span> <span class="p">()):</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="n">apply_method</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                    <span class="n">new_shape</span> <span class="o">=</span> <span class="n">new_shape</span> <span class="ow">or</span> <span class="n">value</span><span class="o">.</span><span class="n">shape</span>
                <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;copy&quot;</span> <span class="ow">or</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;flatten&quot;</span><span class="p">:</span>
                    <span class="c1"># flatten should copy also for a single element array, but</span>
                    <span class="c1"># we cannot use it directly for array scalars, since it</span>
                    <span class="c1"># always returns a one-dimensional array. So, just copy.</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

                <span class="nb">setattr</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="n">_attr</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_data</span><span class="p">:</span>
            <span class="n">new</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">apply_method</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
            <span class="n">new_shape</span> <span class="o">=</span> <span class="n">new_shape</span> <span class="ow">or</span> <span class="n">new</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">new</span><span class="o">.</span><span class="n">_shape</span> <span class="o">=</span> <span class="n">new_shape</span>

        <span class="k">return</span> <span class="n">new</span>

    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">value</span><span class="o">.</span><span class="vm">__class__</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;can only set from object of same class: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> vs.&quot;</span>
                <span class="sa">f</span><span class="s2">&quot; </span><span class="si">{</span><span class="n">value</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_equivalent_frame</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;can only set frame item from an equivalent frame&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">value</span><span class="o">.</span><span class="n">_data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;can only set frame with value that has data&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;cannot set frame which has no data&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">():</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;scalar &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&#39; frame object &quot;</span>
                <span class="s2">&quot;does not support item assignment&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;can only set frame if it has data&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="vm">__class__</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">value</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="vm">__class__</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;can only set from object of same class: &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> vs. </span><span class="si">{</span><span class="n">value</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">_differentials</span><span class="p">:</span>
            <span class="c1"># Can this ever occur? (Same class but different differential keys).</span>
            <span class="c1"># This exception is not tested since it is not clear how to generate it.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">_differentials</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="o">!=</span> <span class="n">value</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">_differentials</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;setitem value must have same differentials&quot;</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">self_diff</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">_differentials</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">self_diff</span><span class="o">.</span><span class="vm">__class__</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">value</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">_differentials</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="vm">__class__</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                        <span class="s2">&quot;can only set from object of same class: &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">self_diff</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> vs. &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">value</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">_differentials</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>

        <span class="c1"># Set representation data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">item</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">_data</span>

        <span class="c1"># Frame attributes required to be identical by is_equivalent_frame,</span>
        <span class="c1"># no need to set them here.</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__dir__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Override the builtin `dir` behavior to include representation</span>
<span class="sd">        names.</span>

<span class="sd">        TODO: dynamic representation transforms (i.e. include cylindrical et al.).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span>
            <span class="nb">set</span><span class="p">(</span><span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__dir__</span><span class="p">())</span>
            <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">representation_component_names</span><span class="p">)</span>
            <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_representation_component_names</span><span class="p">(</span><span class="s2">&quot;s&quot;</span><span class="p">))</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Allow access to attributes on the representation and differential as</span>
<span class="sd">        found via ``self.get_representation_component_names``.</span>

<span class="sd">        TODO: We should handle dynamic representation transforms here (e.g.,</span>
<span class="sd">        `.cylindrical`) instead of defining properties as below.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># attr == &#39;_representation&#39; is likely from the hasattr() test in the</span>
        <span class="c1"># representation property which is used for</span>
        <span class="c1"># self.representation_component_names.</span>
        <span class="c1">#</span>
        <span class="c1"># Prevent infinite recursion here.</span>
        <span class="k">if</span> <span class="n">attr</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="n">attr</span><span class="p">)</span>  <span class="c1"># Raise AttributeError.</span>

        <span class="n">repr_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">representation_component_names</span>
        <span class="k">if</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">repr_names</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># this raises the &quot;no data&quot; error by design - doing it this way means we</span>
                <span class="c1"># don&#39;t have to replicate the error message here.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data</span>  <span class="c1"># noqa: B018</span>

            <span class="n">rep</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">represent_as</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">representation_type</span><span class="p">,</span> <span class="n">in_frame_units</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">val</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">rep</span><span class="p">,</span> <span class="n">repr_names</span><span class="p">[</span><span class="n">attr</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">val</span>

        <span class="n">diff_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_representation_component_names</span><span class="p">(</span><span class="s2">&quot;s&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">diff_names</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data</span>  <span class="c1"># noqa: B018  # see above.</span>
            <span class="c1"># TODO: this doesn&#39;t work for the case when there is only</span>
            <span class="c1"># unitspherical information. The differential_type gets set to the</span>
            <span class="c1"># default_differential, which expects full information, so the</span>
            <span class="c1"># units don&#39;t work out</span>
            <span class="n">rep</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">represent_as</span><span class="p">(</span>
                <span class="n">in_frame_units</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">get_representation_cls</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">val</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">rep</span><span class="o">.</span><span class="n">differentials</span><span class="p">[</span><span class="s2">&quot;s&quot;</span><span class="p">],</span> <span class="n">diff_names</span><span class="p">[</span><span class="n">attr</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">val</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="n">attr</span><span class="p">)</span>  <span class="c1"># Raise AttributeError.</span>

    <span class="k">def</span> <span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="c1"># Don&#39;t slow down access of private attributes!</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">attr</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;representation_info&quot;</span><span class="p">):</span>
                <span class="n">repr_attr_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">representation_attr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">representation_info</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                    <span class="n">repr_attr_names</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">representation_attr</span><span class="p">[</span><span class="s2">&quot;names&quot;</span><span class="p">])</span>

                <span class="k">if</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">repr_attr_names</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cannot set any frame attribute </span><span class="si">{</span><span class="n">attr</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Equality operator for frame.</span>

<span class="sd">        This implements strict equality and requires that the frames are</span>
<span class="sd">        equivalent and that the representation data are exactly equal.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">BaseCoordinateFrame</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>

        <span class="n">is_equiv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_equivalent_frame</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">value</span><span class="o">.</span><span class="n">_data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># For Frame with no data, == compare is same as is_equivalent_frame()</span>
            <span class="k">return</span> <span class="n">is_equiv</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_equiv</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;cannot compare: objects must have equivalent frames: &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">replicate_without_data</span><span class="p">()</span><span class="si">}</span><span class="s2"> vs. </span><span class="si">{</span><span class="n">value</span><span class="o">.</span><span class="n">replicate_without_data</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">_data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;cannot compare: one frame has data and the other does not&quot;</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">==</span> <span class="n">value</span><span class="o">.</span><span class="n">_data</span>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="bp">self</span> <span class="o">==</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_prepare_unit_sphere_coords</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">other</span><span class="p">:</span> <span class="n">BaseCoordinateFrame</span> <span class="o">|</span> <span class="n">SkyCoord</span><span class="p">,</span>
        <span class="n">origin_mismatch</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;ignore&quot;</span><span class="p">,</span> <span class="s2">&quot;warn&quot;</span><span class="p">,</span> <span class="s2">&quot;error&quot;</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Longitude</span><span class="p">,</span> <span class="n">Latitude</span><span class="p">,</span> <span class="n">Longitude</span><span class="p">,</span> <span class="n">Latitude</span><span class="p">]:</span>
        <span class="n">other_frame</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s2">&quot;frame&quot;</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span>
            <span class="n">origin_mismatch</span> <span class="o">==</span> <span class="s2">&quot;ignore&quot;</span>
            <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_equivalent_frame</span><span class="p">(</span><span class="n">other_frame</span><span class="p">)</span>
            <span class="ow">or</span> <span class="nb">all</span><span class="p">(</span>
                <span class="nb">isinstance</span><span class="p">(</span><span class="n">comp</span><span class="p">,</span> <span class="p">(</span><span class="n">StaticMatrixTransform</span><span class="p">,</span> <span class="n">DynamicMatrixTransform</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="n">frame_transform_graph</span><span class="o">.</span><span class="n">get_transform</span><span class="p">(</span>
                    <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="nb">type</span><span class="p">(</span><span class="n">other_frame</span><span class="p">)</span>
                <span class="p">)</span><span class="o">.</span><span class="n">transforms</span>
            <span class="p">)</span>
        <span class="p">):</span>
            <span class="k">if</span> <span class="n">origin_mismatch</span> <span class="o">==</span> <span class="s2">&quot;warn&quot;</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">NonRotationTransformationWarning</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_frame</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">origin_mismatch</span> <span class="o">==</span> <span class="s2">&quot;error&quot;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">NonRotationTransformationError</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_frame</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">origin_mismatch</span><span class="si">=}</span><span class="s2"> is invalid. Allowed values are &#39;ignore&#39;, &quot;</span>
                    <span class="s2">&quot;&#39;warn&#39; or &#39;error&#39;.&quot;</span>
                <span class="p">)</span>
        <span class="n">self_sph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">represent_as</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">UnitSphericalRepresentation</span><span class="p">)</span>
        <span class="n">other_sph</span> <span class="o">=</span> <span class="n">other_frame</span><span class="o">.</span><span class="n">transform_to</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">represent_as</span><span class="p">(</span>
            <span class="n">r</span><span class="o">.</span><span class="n">UnitSphericalRepresentation</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">self_sph</span><span class="o">.</span><span class="n">lon</span><span class="p">,</span> <span class="n">self_sph</span><span class="o">.</span><span class="n">lat</span><span class="p">,</span> <span class="n">other_sph</span><span class="o">.</span><span class="n">lon</span><span class="p">,</span> <span class="n">other_sph</span><span class="o">.</span><span class="n">lat</span>

    <span class="k">def</span> <span class="nf">position_angle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">BaseCoordinateFrame</span> <span class="o">|</span> <span class="n">SkyCoord</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Angle</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute the on-sky position angle to another coordinate.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : `~astropy.coordinates.BaseCoordinateFrame` or `~astropy.coordinates.SkyCoord`</span>
<span class="sd">            The other coordinate to compute the position angle to.  It is</span>
<span class="sd">            treated as the &quot;head&quot; of the vector of the position angle.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        `~astropy.coordinates.Angle`</span>
<span class="sd">            The (positive) position angle of the vector pointing from ``self``</span>
<span class="sd">            to ``other``, measured East from North.  If either ``self`` or</span>
<span class="sd">            ``other`` contain arrays, this will be an array following the</span>
<span class="sd">            appropriate `numpy` broadcasting rules.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from astropy import units as u</span>
<span class="sd">        &gt;&gt;&gt; from astropy.coordinates import ICRS, SkyCoord</span>
<span class="sd">        &gt;&gt;&gt; c1 = SkyCoord(0*u.deg, 0*u.deg)</span>
<span class="sd">        &gt;&gt;&gt; c2 = ICRS(1*u.deg, 0*u.deg)</span>
<span class="sd">        &gt;&gt;&gt; c1.position_angle(c2).degree</span>
<span class="sd">        90.0</span>
<span class="sd">        &gt;&gt;&gt; c2.position_angle(c1).degree</span>
<span class="sd">        270.0</span>
<span class="sd">        &gt;&gt;&gt; c3 = SkyCoord(1*u.deg, 1*u.deg)</span>
<span class="sd">        &gt;&gt;&gt; c1.position_angle(c3).degree  # doctest: +FLOAT_CMP</span>
<span class="sd">        44.995636455344844</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">position_angle</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_prepare_unit_sphere_coords</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s2">&quot;ignore&quot;</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">separation</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">other</span><span class="p">:</span> <span class="n">BaseCoordinateFrame</span> <span class="o">|</span> <span class="n">SkyCoord</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">origin_mismatch</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;ignore&quot;</span><span class="p">,</span> <span class="s2">&quot;warn&quot;</span><span class="p">,</span> <span class="s2">&quot;error&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;warn&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Angle</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes on-sky separation between this coordinate and another.</span>

<span class="sd">        For more on how to use this (and related) functionality, see the</span>
<span class="sd">        examples in :ref:`astropy-coordinates-separations-matching`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : `~astropy.coordinates.BaseCoordinateFrame` or `~astropy.coordinates.SkyCoord`</span>
<span class="sd">            The coordinate to get the separation to.</span>
<span class="sd">        origin_mismatch : {&quot;warn&quot;, &quot;ignore&quot;, &quot;error&quot;}, keyword-only</span>
<span class="sd">            If the ``other`` coordinates are in a different frame then they</span>
<span class="sd">            will have to be transformed, and if the transformation is not a</span>
<span class="sd">            pure rotation then ``self.separation(other)`` can be</span>
<span class="sd">            different from ``other.separation(self)``. With</span>
<span class="sd">            ``origin_mismatch=&quot;warn&quot;`` (default) the transformation is</span>
<span class="sd">            always performed, but a warning is emitted if it is not a</span>
<span class="sd">            pure rotation. If ``origin_mismatch=&quot;ignore&quot;`` then the</span>
<span class="sd">            required transformation is always performed without warnings.</span>
<span class="sd">            If ``origin_mismatch=&quot;error&quot;`` then only transformations</span>
<span class="sd">            that are pure rotations are allowed.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        sep : `~astropy.coordinates.Angle`</span>
<span class="sd">            The on-sky separation between this and the ``other`` coordinate.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The separation is calculated using the Vincenty formula, which</span>
<span class="sd">        is stable at all locations, including poles and antipodes [1]_.</span>

<span class="sd">        .. [1] https://en.wikipedia.org/wiki/Great-circle_distance</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.angles</span> <span class="kn">import</span> <span class="n">Angle</span><span class="p">,</span> <span class="n">angular_separation</span>

        <span class="k">return</span> <span class="n">Angle</span><span class="p">(</span>
            <span class="n">angular_separation</span><span class="p">(</span>
                <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_prepare_unit_sphere_coords</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">origin_mismatch</span><span class="p">)</span>
            <span class="p">),</span>
            <span class="n">unit</span><span class="o">=</span><span class="n">u</span><span class="o">.</span><span class="n">degree</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">separation_3d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes three dimensional separation between this coordinate</span>
<span class="sd">        and another.</span>

<span class="sd">        For more on how to use this (and related) functionality, see the</span>
<span class="sd">        examples in :ref:`astropy-coordinates-separations-matching`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : `~astropy.coordinates.BaseCoordinateFrame` or `~astropy.coordinates.SkyCoord`</span>
<span class="sd">            The coordinate system to get the distance to.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        sep : `~astropy.coordinates.Distance`</span>
<span class="sd">            The real-space distance between these two coordinates.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If this or the other coordinate do not have distances.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.distances</span> <span class="kn">import</span> <span class="n">Distance</span>

        <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">r</span><span class="o">.</span><span class="n">UnitSphericalRepresentation</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;This object does not have a distance; cannot compute 3d separation.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># do this first just in case the conversion somehow creates a distance</span>
        <span class="n">other_in_self_system</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s2">&quot;frame&quot;</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span><span class="o">.</span><span class="n">transform_to</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">other_in_self_system</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">r</span><span class="o">.</span><span class="n">UnitSphericalRepresentation</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The other object does not have a distance; &quot;</span>
                <span class="s2">&quot;cannot compute 3d separation.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># drop the differentials to ensure they don&#39;t do anything odd in the</span>
        <span class="c1"># subtraction</span>
        <span class="n">self_car</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">without_differentials</span><span class="p">()</span><span class="o">.</span><span class="n">represent_as</span><span class="p">(</span>
            <span class="n">r</span><span class="o">.</span><span class="n">CartesianRepresentation</span>
        <span class="p">)</span>
        <span class="n">other_car</span> <span class="o">=</span> <span class="n">other_in_self_system</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">without_differentials</span><span class="p">()</span><span class="o">.</span><span class="n">represent_as</span><span class="p">(</span>
            <span class="n">r</span><span class="o">.</span><span class="n">CartesianRepresentation</span>
        <span class="p">)</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="p">(</span><span class="n">self_car</span> <span class="o">-</span> <span class="n">other_car</span><span class="p">)</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">dist</span><span class="o">.</span><span class="n">unit</span> <span class="o">==</span> <span class="n">u</span><span class="o">.</span><span class="n">one</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">dist</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Distance</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">cartesian</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Shorthand for a cartesian representation of the coordinates in this</span>
<span class="sd">        object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: if representations are updated to use a full transform graph,</span>
        <span class="c1">#       the representation aliases should not be hard-coded like this</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">represent_as</span><span class="p">(</span><span class="s2">&quot;cartesian&quot;</span><span class="p">,</span> <span class="n">in_frame_units</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">cylindrical</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Shorthand for a cylindrical representation of the coordinates in this</span>
<span class="sd">        object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: if representations are updated to use a full transform graph,</span>
        <span class="c1">#       the representation aliases should not be hard-coded like this</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">represent_as</span><span class="p">(</span><span class="s2">&quot;cylindrical&quot;</span><span class="p">,</span> <span class="n">in_frame_units</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">spherical</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Shorthand for a spherical representation of the coordinates in this</span>
<span class="sd">        object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: if representations are updated to use a full transform graph,</span>
        <span class="c1">#       the representation aliases should not be hard-coded like this</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">represent_as</span><span class="p">(</span><span class="s2">&quot;spherical&quot;</span><span class="p">,</span> <span class="n">in_frame_units</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">sphericalcoslat</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Shorthand for a spherical representation of the positional data and a</span>
<span class="sd">        `~astropy.coordinates.SphericalCosLatDifferential` for the velocity</span>
<span class="sd">        data in this object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: if representations are updated to use a full transform graph,</span>
        <span class="c1">#       the representation aliases should not be hard-coded like this</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">represent_as</span><span class="p">(</span><span class="s2">&quot;spherical&quot;</span><span class="p">,</span> <span class="s2">&quot;sphericalcoslat&quot;</span><span class="p">,</span> <span class="n">in_frame_units</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">velocity</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Shorthand for retrieving the Cartesian space-motion as a</span>
<span class="sd">        `~astropy.coordinates.CartesianDifferential` object.</span>

<span class="sd">        This is equivalent to calling ``self.cartesian.differentials[&#39;s&#39;]``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;s&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">differentials</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Frame has no associated velocity (Differential) data information.&quot;</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cartesian</span><span class="o">.</span><span class="n">differentials</span><span class="p">[</span><span class="s2">&quot;s&quot;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">proper_motion</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Shorthand for the two-dimensional proper motion as a</span>
<span class="sd">        `~astropy.units.Quantity` object with angular velocity units. In the</span>
<span class="sd">        returned `~astropy.units.Quantity`, ``axis=0`` is the longitude/latitude</span>
<span class="sd">        dimension so that ``.proper_motion[0]`` is the longitudinal proper</span>
<span class="sd">        motion and ``.proper_motion[1]`` is latitudinal. The longitudinal proper</span>
<span class="sd">        motion already includes the cos(latitude) term.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;s&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">differentials</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Frame has no associated velocity (Differential) data information.&quot;</span>
            <span class="p">)</span>

        <span class="n">sph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">represent_as</span><span class="p">(</span><span class="s2">&quot;spherical&quot;</span><span class="p">,</span> <span class="s2">&quot;sphericalcoslat&quot;</span><span class="p">,</span> <span class="n">in_frame_units</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">pm_lon</span> <span class="o">=</span> <span class="n">sph</span><span class="o">.</span><span class="n">differentials</span><span class="p">[</span><span class="s2">&quot;s&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">d_lon_coslat</span>
        <span class="n">pm_lat</span> <span class="o">=</span> <span class="n">sph</span><span class="o">.</span><span class="n">differentials</span><span class="p">[</span><span class="s2">&quot;s&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">d_lat</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">pm_lon</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">pm_lat</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">pm_lon</span><span class="o">.</span><span class="n">unit</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="n">pm_lon</span><span class="o">.</span><span class="n">unit</span>
        <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">radial_velocity</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Shorthand for the radial or line-of-sight velocity as a</span>
<span class="sd">        `~astropy.units.Quantity` object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;s&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">differentials</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Frame has no associated velocity (Differential) data information.&quot;</span>
            <span class="p">)</span>

        <span class="n">sph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">represent_as</span><span class="p">(</span><span class="s2">&quot;spherical&quot;</span><span class="p">,</span> <span class="n">in_frame_units</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sph</span><span class="o">.</span><span class="n">differentials</span><span class="p">[</span><span class="s2">&quot;s&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">d_distance</span>


<span class="k">class</span> <span class="nc">GenericFrame</span><span class="p">(</span><span class="n">BaseCoordinateFrame</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A frame object that can&#39;t store data but can hold any arbitrary frame</span>
<span class="sd">    attributes. Mostly useful as a utility for the high-level class to store</span>
<span class="sd">    intermediate frame attributes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    frame_attrs : dict</span>
<span class="sd">        A dictionary of attributes to be used as the frame attributes for this</span>
<span class="sd">        frame.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">name</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># it&#39;s not a &quot;real&quot; frame so it doesn&#39;t have a name</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">frame_attrs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">frame_attributes</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">default</span> <span class="ow">in</span> <span class="n">frame_attrs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">frame_attributes</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">Attribute</span><span class="p">(</span><span class="n">default</span><span class="p">)</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="n">name</span><span class="p">,</span> <span class="n">default</span><span class="p">)</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">if</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="n">name</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;no </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">frame_attributes</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;can&#39;t set frame attribute &#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 20202024, Pipeline Dev. Team.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>