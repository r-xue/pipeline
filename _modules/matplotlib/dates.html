

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>matplotlib.dates &mdash; Pipeline unknown documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css?v=4ae1632d" />
      <link rel="stylesheet" type="text/css" href="../../_static/custom_theme.css?v=678032d9" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=3f1b9271"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            Pipeline
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Releases etc.</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../releases.html">Past Releases</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dependencies.html">Dependencies of <code class="docutils literal notranslate"><span class="pre">Pipeline</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modular.html">Run the Pipeline in a Conda environment</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../apisummary.html">Pipeline Tasks (from autosummary)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../apisummary.html#full-list">Full List</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">TaskRef (create_docs.py)</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../_taskdocs/taskdocs.html">List of Heuristics Tasks (Pipeline 2023)</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Pipeline Heuristics</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../heuristics/field_parameter.html">Field parameter</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../heuristics/FlaggingTasks.html">Pipeline Flagging Tasks</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Developer Notes</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../develdocmd/ways_to_run_the_pipeline.html">Ways to run the Pipeline</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../develdocmd/comparing_pipeline_executions.html">Comparing pipeline executions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../develdocmd/building_the_pipeline.html">Building the pipeline</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../develdocmd/ALMA-Imaging-Workflow.html">ALMA interferometry imaging workflow</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../develdocmd/VLA-Imaging-Workflow.html">VLA interferometry imaging workflow</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../develdocmd/VLASS-SE-CONT-Imaging-Workflow.html">VLASS-SE-CONT imaging workflow</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../develdocmd/VLASS-SE-CUBE-Imaging-Workflow.html">VLASS-SE-CUBE imaging workflow</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../develdocmd/selfcal_workflow.html">VLASS Selfcal &amp; Restore workflows</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../develdocmd/pipeline_tests.html">Pipeline testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../develdocmd/DataType_Testing.html">DataType Testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../develdocmd/QA_scores.html">Pipeline Quality Assurance (QA) Score Class Design</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../develdocmd/DeveloperDocumentation.html">Pipeline developer documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../develdocmd/python3_conversion_notes.html">Python 3 conversion notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../develdocmd/recipes.html">Pipeline Recipes</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Pipeline Domain/Context (automodapi)</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../basics.html"><code class="docutils literal notranslate"><span class="pre">pipeline.domain</span></code> module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../basics.html#module-pipeline.infrastructure.launcher"><code class="docutils literal notranslate"><span class="pre">pipeline.infrastructure.launcher</span></code> module</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Pipeline Domain/Context (autosummary)</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../_autosummary/pipeline.domain.html">pipeline.domain</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../_autosummary/pipeline.infrastructure.launcher.html">pipeline.infrastructure.launcher</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Pipeline Task/Inputs/Results Classes</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../classes.html">Classes in <code class="docutils literal notranslate"><span class="pre">pipeline.h*.tasks</span></code> modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../classes.html#inheritance-diagrams">Inheritance Diagrams</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Examples Notes (from Jupyter Notebooks)</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../examples/test1.html">test</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Example Notes (from .rst)</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../examples/test2.html">Example 1</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Pipeline</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">matplotlib.dates</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for matplotlib.dates</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Matplotlib provides sophisticated date plotting capabilities, standing on the</span>
<span class="sd">shoulders of python :mod:`datetime` and the add-on module dateutil_.</span>

<span class="sd">By default, Matplotlib uses the units machinery described in</span>
<span class="sd">`~matplotlib.units` to convert `datetime.datetime`, and `numpy.datetime64`</span>
<span class="sd">objects when plotted on an x- or y-axis. The user does not</span>
<span class="sd">need to do anything for dates to be formatted, but dates often have strict</span>
<span class="sd">formatting needs, so this module provides many axis locators and formatters.</span>
<span class="sd">A basic example using `numpy.datetime64` is::</span>

<span class="sd">    import numpy as np</span>

<span class="sd">    times = np.arange(np.datetime64(&#39;2001-01-02&#39;),</span>
<span class="sd">                      np.datetime64(&#39;2002-02-03&#39;), np.timedelta64(75, &#39;m&#39;))</span>
<span class="sd">    y = np.random.randn(len(times))</span>

<span class="sd">    fig, ax = plt.subplots()</span>
<span class="sd">    ax.plot(times, y)</span>

<span class="sd">.. seealso::</span>

<span class="sd">    - :doc:`/gallery/text_labels_and_annotations/date`</span>
<span class="sd">    - :doc:`/gallery/ticks/date_concise_formatter`</span>
<span class="sd">    - :doc:`/gallery/ticks/date_demo_convert`</span>

<span class="sd">.. _date-format:</span>

<span class="sd">Matplotlib date format</span>
<span class="sd">----------------------</span>

<span class="sd">Matplotlib represents dates using floating point numbers specifying the number</span>
<span class="sd">of days since a default epoch of 1970-01-01 UTC; for example,</span>
<span class="sd">1970-01-01, 06:00 is the floating point number 0.25. The formatters and</span>
<span class="sd">locators require the use of `datetime.datetime` objects, so only dates between</span>
<span class="sd">year 0001 and 9999 can be represented.  Microsecond precision</span>
<span class="sd">is achievable for (approximately) 70 years on either side of the epoch, and</span>
<span class="sd">20 microseconds for the rest of the allowable range of dates (year 0001 to</span>
<span class="sd">9999). The epoch can be changed at import time via `.dates.set_epoch` or</span>
<span class="sd">:rc:`dates.epoch` to other dates if necessary; see</span>
<span class="sd">:doc:`/gallery/ticks/date_precision_and_epochs` for a discussion.</span>

<span class="sd">.. note::</span>

<span class="sd">   Before Matplotlib 3.3, the epoch was 0000-12-31 which lost modern</span>
<span class="sd">   microsecond precision and also made the default axis limit of 0 an invalid</span>
<span class="sd">   datetime.  In 3.3 the epoch was changed as above.  To convert old</span>
<span class="sd">   ordinal floats to the new epoch, users can do::</span>

<span class="sd">     new_ordinal = old_ordinal + mdates.date2num(np.datetime64(&#39;0000-12-31&#39;))</span>


<span class="sd">There are a number of helper functions to convert between :mod:`datetime`</span>
<span class="sd">objects and Matplotlib dates:</span>

<span class="sd">.. currentmodule:: matplotlib.dates</span>

<span class="sd">.. autosummary::</span>
<span class="sd">   :nosignatures:</span>

<span class="sd">   datestr2num</span>
<span class="sd">   date2num</span>
<span class="sd">   num2date</span>
<span class="sd">   num2timedelta</span>
<span class="sd">   drange</span>
<span class="sd">   set_epoch</span>
<span class="sd">   get_epoch</span>

<span class="sd">.. note::</span>

<span class="sd">   Like Python&#39;s `datetime.datetime`, Matplotlib uses the Gregorian calendar</span>
<span class="sd">   for all conversions between dates and floating point numbers. This practice</span>
<span class="sd">   is not universal, and calendar differences can cause confusing</span>
<span class="sd">   differences between what Python and Matplotlib give as the number of days</span>
<span class="sd">   since 0001-01-01 and what other software and databases yield.  For</span>
<span class="sd">   example, the US Naval Observatory uses a calendar that switches</span>
<span class="sd">   from Julian to Gregorian in October, 1582.  Hence, using their</span>
<span class="sd">   calculator, the number of days between 0001-01-01 and 2006-04-01 is</span>
<span class="sd">   732403, whereas using the Gregorian calendar via the datetime</span>
<span class="sd">   module we find::</span>

<span class="sd">     In [1]: date(2006, 4, 1).toordinal() - date(1, 1, 1).toordinal()</span>
<span class="sd">     Out[1]: 732401</span>

<span class="sd">All the Matplotlib date converters, tickers and formatters are timezone aware.</span>
<span class="sd">If no explicit timezone is provided, :rc:`timezone` is assumed, provided as a</span>
<span class="sd">string.  If you want to use a different timezone, pass the *tz* keyword</span>
<span class="sd">argument of `num2date` to any date tickers or locators you create.  This can</span>
<span class="sd">be either a `datetime.tzinfo` instance or a string with the timezone name that</span>
<span class="sd">can be parsed by `~dateutil.tz.gettz`.</span>

<span class="sd">A wide range of specific and general purpose date tick locators and</span>
<span class="sd">formatters are provided in this module.  See</span>
<span class="sd">:mod:`matplotlib.ticker` for general information on tick locators</span>
<span class="sd">and formatters.  These are described below.</span>

<span class="sd">The dateutil_ module provides additional code to handle date ticking, making it</span>
<span class="sd">easy to place ticks on any kinds of dates.  See examples below.</span>

<span class="sd">.. _dateutil: https://dateutil.readthedocs.io</span>

<span class="sd">Date tickers</span>
<span class="sd">------------</span>

<span class="sd">Most of the date tickers can locate single or multiple values.  For example::</span>

<span class="sd">    # import constants for the days of the week</span>
<span class="sd">    from matplotlib.dates import MO, TU, WE, TH, FR, SA, SU</span>

<span class="sd">    # tick on mondays every week</span>
<span class="sd">    loc = WeekdayLocator(byweekday=MO, tz=tz)</span>

<span class="sd">    # tick on mondays and saturdays</span>
<span class="sd">    loc = WeekdayLocator(byweekday=(MO, SA))</span>

<span class="sd">In addition, most of the constructors take an interval argument::</span>

<span class="sd">    # tick on mondays every second week</span>
<span class="sd">    loc = WeekdayLocator(byweekday=MO, interval=2)</span>

<span class="sd">The rrule locator allows completely general date ticking::</span>

<span class="sd">    # tick every 5th easter</span>
<span class="sd">    rule = rrulewrapper(YEARLY, byeaster=1, interval=5)</span>
<span class="sd">    loc = RRuleLocator(rule)</span>

<span class="sd">The available date tickers are:</span>

<span class="sd">* `MicrosecondLocator`: Locate microseconds.</span>

<span class="sd">* `SecondLocator`: Locate seconds.</span>

<span class="sd">* `MinuteLocator`: Locate minutes.</span>

<span class="sd">* `HourLocator`: Locate hours.</span>

<span class="sd">* `DayLocator`: Locate specified days of the month.</span>

<span class="sd">* `WeekdayLocator`: Locate days of the week, e.g., MO, TU.</span>

<span class="sd">* `MonthLocator`: Locate months, e.g., 7 for July.</span>

<span class="sd">* `YearLocator`: Locate years that are multiples of base.</span>

<span class="sd">* `RRuleLocator`: Locate using a `rrulewrapper`.</span>
<span class="sd">  `rrulewrapper` is a simple wrapper around dateutil_&#39;s `dateutil.rrule`</span>
<span class="sd">  which allow almost arbitrary date tick specifications.</span>
<span class="sd">  See :doc:`rrule example &lt;/gallery/ticks/date_demo_rrule&gt;`.</span>

<span class="sd">* `AutoDateLocator`: On autoscale, this class picks the best `DateLocator`</span>
<span class="sd">  (e.g., `RRuleLocator`) to set the view limits and the tick locations.  If</span>
<span class="sd">  called with ``interval_multiples=True`` it will make ticks line up with</span>
<span class="sd">  sensible multiples of the tick intervals.  E.g. if the interval is 4 hours,</span>
<span class="sd">  it will pick hours 0, 4, 8, etc as ticks.  This behaviour is not guaranteed</span>
<span class="sd">  by default.</span>

<span class="sd">Date formatters</span>
<span class="sd">---------------</span>

<span class="sd">The available date formatters are:</span>

<span class="sd">* `AutoDateFormatter`: attempts to figure out the best format to use.  This is</span>
<span class="sd">  most useful when used with the `AutoDateLocator`.</span>

<span class="sd">* `ConciseDateFormatter`: also attempts to figure out the best format to use,</span>
<span class="sd">  and to make the format as compact as possible while still having complete</span>
<span class="sd">  date information.  This is most useful when used with the `AutoDateLocator`.</span>

<span class="sd">* `DateFormatter`: use `~datetime.datetime.strftime` format strings.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">datetime</span>
<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">re</span>

<span class="kn">from</span> <span class="nn">dateutil.rrule</span> <span class="kn">import</span> <span class="p">(</span><span class="n">rrule</span><span class="p">,</span> <span class="n">MO</span><span class="p">,</span> <span class="n">TU</span><span class="p">,</span> <span class="n">WE</span><span class="p">,</span> <span class="n">TH</span><span class="p">,</span> <span class="n">FR</span><span class="p">,</span> <span class="n">SA</span><span class="p">,</span> <span class="n">SU</span><span class="p">,</span> <span class="n">YEARLY</span><span class="p">,</span>
                            <span class="n">MONTHLY</span><span class="p">,</span> <span class="n">WEEKLY</span><span class="p">,</span> <span class="n">DAILY</span><span class="p">,</span> <span class="n">HOURLY</span><span class="p">,</span> <span class="n">MINUTELY</span><span class="p">,</span>
                            <span class="n">SECONDLY</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">dateutil.relativedelta</span> <span class="kn">import</span> <span class="n">relativedelta</span>
<span class="kn">import</span> <span class="nn">dateutil.parser</span>
<span class="kn">import</span> <span class="nn">dateutil.tz</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">import</span> <span class="nn">matplotlib</span> <span class="k">as</span> <span class="nn">mpl</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">_api</span><span class="p">,</span> <span class="n">cbook</span><span class="p">,</span> <span class="n">ticker</span><span class="p">,</span> <span class="n">units</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;datestr2num&#39;</span><span class="p">,</span> <span class="s1">&#39;date2num&#39;</span><span class="p">,</span> <span class="s1">&#39;num2date&#39;</span><span class="p">,</span> <span class="s1">&#39;num2timedelta&#39;</span><span class="p">,</span> <span class="s1">&#39;drange&#39;</span><span class="p">,</span>
           <span class="s1">&#39;epoch2num&#39;</span><span class="p">,</span> <span class="s1">&#39;num2epoch&#39;</span><span class="p">,</span> <span class="s1">&#39;set_epoch&#39;</span><span class="p">,</span> <span class="s1">&#39;get_epoch&#39;</span><span class="p">,</span> <span class="s1">&#39;DateFormatter&#39;</span><span class="p">,</span>
           <span class="s1">&#39;ConciseDateFormatter&#39;</span><span class="p">,</span> <span class="s1">&#39;AutoDateFormatter&#39;</span><span class="p">,</span>
           <span class="s1">&#39;DateLocator&#39;</span><span class="p">,</span> <span class="s1">&#39;RRuleLocator&#39;</span><span class="p">,</span> <span class="s1">&#39;AutoDateLocator&#39;</span><span class="p">,</span> <span class="s1">&#39;YearLocator&#39;</span><span class="p">,</span>
           <span class="s1">&#39;MonthLocator&#39;</span><span class="p">,</span> <span class="s1">&#39;WeekdayLocator&#39;</span><span class="p">,</span>
           <span class="s1">&#39;DayLocator&#39;</span><span class="p">,</span> <span class="s1">&#39;HourLocator&#39;</span><span class="p">,</span> <span class="s1">&#39;MinuteLocator&#39;</span><span class="p">,</span>
           <span class="s1">&#39;SecondLocator&#39;</span><span class="p">,</span> <span class="s1">&#39;MicrosecondLocator&#39;</span><span class="p">,</span>
           <span class="s1">&#39;rrule&#39;</span><span class="p">,</span> <span class="s1">&#39;MO&#39;</span><span class="p">,</span> <span class="s1">&#39;TU&#39;</span><span class="p">,</span> <span class="s1">&#39;WE&#39;</span><span class="p">,</span> <span class="s1">&#39;TH&#39;</span><span class="p">,</span> <span class="s1">&#39;FR&#39;</span><span class="p">,</span> <span class="s1">&#39;SA&#39;</span><span class="p">,</span> <span class="s1">&#39;SU&#39;</span><span class="p">,</span>
           <span class="s1">&#39;YEARLY&#39;</span><span class="p">,</span> <span class="s1">&#39;MONTHLY&#39;</span><span class="p">,</span> <span class="s1">&#39;WEEKLY&#39;</span><span class="p">,</span> <span class="s1">&#39;DAILY&#39;</span><span class="p">,</span>
           <span class="s1">&#39;HOURLY&#39;</span><span class="p">,</span> <span class="s1">&#39;MINUTELY&#39;</span><span class="p">,</span> <span class="s1">&#39;SECONDLY&#39;</span><span class="p">,</span> <span class="s1">&#39;MICROSECONDLY&#39;</span><span class="p">,</span> <span class="s1">&#39;relativedelta&#39;</span><span class="p">,</span>
           <span class="s1">&#39;DateConverter&#39;</span><span class="p">,</span> <span class="s1">&#39;ConciseDateConverter&#39;</span><span class="p">,</span> <span class="s1">&#39;rrulewrapper&#39;</span><span class="p">)</span>


<span class="n">_log</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>
<span class="n">UTC</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">timezone</span><span class="o">.</span><span class="n">utc</span>


<span class="k">def</span> <span class="nf">_get_tzinfo</span><span class="p">(</span><span class="n">tz</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate tzinfo from a string or return tzinfo. If None,</span>
<span class="sd">    retrieve the preferred timezone from the rcParams dictionary.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">tz</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">tz</span> <span class="o">=</span> <span class="n">mpl</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;timezone&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">tz</span> <span class="o">==</span> <span class="s1">&#39;UTC&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">UTC</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tz</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">tzinfo</span> <span class="o">=</span> <span class="n">dateutil</span><span class="o">.</span><span class="n">tz</span><span class="o">.</span><span class="n">gettz</span><span class="p">(</span><span class="n">tz</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">tzinfo</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">tz</span><span class="si">}</span><span class="s2"> is not a valid timezone as parsed by&quot;</span>
                             <span class="s2">&quot; dateutil.tz.gettz.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tzinfo</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tz</span><span class="p">,</span> <span class="n">datetime</span><span class="o">.</span><span class="n">tzinfo</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">tz</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;tz must be string or tzinfo subclass.&quot;</span><span class="p">)</span>


<span class="c1"># Time-related constants.</span>
<span class="n">EPOCH_OFFSET</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">(</span><span class="mi">1970</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">toordinal</span><span class="p">())</span>
<span class="c1"># EPOCH_OFFSET is not used by matplotlib</span>
<span class="n">JULIAN_OFFSET</span> <span class="o">=</span> <span class="mf">1721424.5</span>  <span class="c1"># Julian date at 0000-12-31</span>
<span class="c1"># note that the Julian day epoch is achievable w/</span>
<span class="c1"># np.datetime64(&#39;-4713-11-24T12:00:00&#39;); datetime64 is proleptic</span>
<span class="c1"># Gregorian and BC has a one-year offset.  So</span>
<span class="c1"># np.datetime64(&#39;0000-12-31&#39;) - np.datetime64(&#39;-4713-11-24T12:00&#39;) = 1721424.5</span>
<span class="c1"># Ref: https://en.wikipedia.org/wiki/Julian_day</span>
<span class="n">MICROSECONDLY</span> <span class="o">=</span> <span class="n">SECONDLY</span> <span class="o">+</span> <span class="mi">1</span>
<span class="n">HOURS_PER_DAY</span> <span class="o">=</span> <span class="mf">24.</span>
<span class="n">MIN_PER_HOUR</span> <span class="o">=</span> <span class="mf">60.</span>
<span class="n">SEC_PER_MIN</span> <span class="o">=</span> <span class="mf">60.</span>
<span class="n">MONTHS_PER_YEAR</span> <span class="o">=</span> <span class="mf">12.</span>

<span class="n">DAYS_PER_WEEK</span> <span class="o">=</span> <span class="mf">7.</span>
<span class="n">DAYS_PER_MONTH</span> <span class="o">=</span> <span class="mf">30.</span>
<span class="n">DAYS_PER_YEAR</span> <span class="o">=</span> <span class="mf">365.0</span>

<span class="n">MINUTES_PER_DAY</span> <span class="o">=</span> <span class="n">MIN_PER_HOUR</span> <span class="o">*</span> <span class="n">HOURS_PER_DAY</span>

<span class="n">SEC_PER_HOUR</span> <span class="o">=</span> <span class="n">SEC_PER_MIN</span> <span class="o">*</span> <span class="n">MIN_PER_HOUR</span>
<span class="n">SEC_PER_DAY</span> <span class="o">=</span> <span class="n">SEC_PER_HOUR</span> <span class="o">*</span> <span class="n">HOURS_PER_DAY</span>
<span class="n">SEC_PER_WEEK</span> <span class="o">=</span> <span class="n">SEC_PER_DAY</span> <span class="o">*</span> <span class="n">DAYS_PER_WEEK</span>

<span class="n">MUSECONDS_PER_DAY</span> <span class="o">=</span> <span class="mf">1e6</span> <span class="o">*</span> <span class="n">SEC_PER_DAY</span>

<span class="n">MONDAY</span><span class="p">,</span> <span class="n">TUESDAY</span><span class="p">,</span> <span class="n">WEDNESDAY</span><span class="p">,</span> <span class="n">THURSDAY</span><span class="p">,</span> <span class="n">FRIDAY</span><span class="p">,</span> <span class="n">SATURDAY</span><span class="p">,</span> <span class="n">SUNDAY</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">MO</span><span class="p">,</span> <span class="n">TU</span><span class="p">,</span> <span class="n">WE</span><span class="p">,</span> <span class="n">TH</span><span class="p">,</span> <span class="n">FR</span><span class="p">,</span> <span class="n">SA</span><span class="p">,</span> <span class="n">SU</span><span class="p">)</span>
<span class="n">WEEKDAYS</span> <span class="o">=</span> <span class="p">(</span><span class="n">MONDAY</span><span class="p">,</span> <span class="n">TUESDAY</span><span class="p">,</span> <span class="n">WEDNESDAY</span><span class="p">,</span> <span class="n">THURSDAY</span><span class="p">,</span> <span class="n">FRIDAY</span><span class="p">,</span> <span class="n">SATURDAY</span><span class="p">,</span> <span class="n">SUNDAY</span><span class="p">)</span>

<span class="c1"># default epoch: passed to np.datetime64...</span>
<span class="n">_epoch</span> <span class="o">=</span> <span class="kc">None</span>


<span class="k">def</span> <span class="nf">_reset_epoch_test_example</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Reset the Matplotlib date epoch so it can be set again.</span>

<span class="sd">    Only for use in tests and examples.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">global</span> <span class="n">_epoch</span>
    <span class="n">_epoch</span> <span class="o">=</span> <span class="kc">None</span>


<span class="k">def</span> <span class="nf">set_epoch</span><span class="p">(</span><span class="n">epoch</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Set the epoch (origin for dates) for datetime calculations.</span>

<span class="sd">    The default epoch is :rc:`dates.epoch` (by default 1970-01-01T00:00).</span>

<span class="sd">    If microsecond accuracy is desired, the date being plotted needs to be</span>
<span class="sd">    within approximately 70 years of the epoch. Matplotlib internally</span>
<span class="sd">    represents dates as days since the epoch, so floating point dynamic</span>
<span class="sd">    range needs to be within a factor of 2^52.</span>

<span class="sd">    `~.dates.set_epoch` must be called before any dates are converted</span>
<span class="sd">    (i.e. near the import section) or a RuntimeError will be raised.</span>

<span class="sd">    See also :doc:`/gallery/ticks/date_precision_and_epochs`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    epoch : str</span>
<span class="sd">        valid UTC date parsable by `numpy.datetime64` (do not include</span>
<span class="sd">        timezone).</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">global</span> <span class="n">_epoch</span>
    <span class="k">if</span> <span class="n">_epoch</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;set_epoch must be called before dates plotted.&#39;</span><span class="p">)</span>
    <span class="n">_epoch</span> <span class="o">=</span> <span class="n">epoch</span>


<span class="k">def</span> <span class="nf">get_epoch</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the epoch used by `.dates`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    epoch : str</span>
<span class="sd">        String for the epoch (parsable by `numpy.datetime64`).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">global</span> <span class="n">_epoch</span>

    <span class="k">if</span> <span class="n">_epoch</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">_epoch</span> <span class="o">=</span> <span class="n">mpl</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;date.epoch&#39;</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">_epoch</span>


<span class="k">def</span> <span class="nf">_dt64_to_ordinalf</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert `numpy.datetime64` or an ndarray of those types to Gregorian</span>
<span class="sd">    date as UTC float relative to the epoch (see `.get_epoch`).  Roundoff</span>
<span class="sd">    is float64 precision.  Practically: microseconds for dates between</span>
<span class="sd">    290301 BC, 294241 AD, milliseconds for larger dates</span>
<span class="sd">    (see `numpy.datetime64`).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># the &quot;extra&quot; ensures that we at least allow the dynamic range out to</span>
    <span class="c1"># seconds.  That should get out to +/-2e11 years.</span>
    <span class="n">dseconds</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[s]&#39;</span><span class="p">)</span>
    <span class="n">extra</span> <span class="o">=</span> <span class="p">(</span><span class="n">d</span> <span class="o">-</span> <span class="n">dseconds</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;timedelta64[ns]&#39;</span><span class="p">)</span>
    <span class="n">t0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="n">get_epoch</span><span class="p">(),</span> <span class="s1">&#39;s&#39;</span><span class="p">)</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="p">(</span><span class="n">dseconds</span> <span class="o">-</span> <span class="n">t0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="n">dt</span> <span class="o">+=</span> <span class="n">extra</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span> <span class="o">/</span> <span class="mf">1.0e9</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">dt</span> <span class="o">/</span> <span class="n">SEC_PER_DAY</span>

    <span class="n">NaT_int</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="s1">&#39;NaT&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
    <span class="n">d_int</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
    <span class="n">dt</span><span class="p">[</span><span class="n">d_int</span> <span class="o">==</span> <span class="n">NaT_int</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="k">return</span> <span class="n">dt</span>


<span class="k">def</span> <span class="nf">_from_ordinalf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">tz</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert Gregorian float of the date, preserving hours, minutes,</span>
<span class="sd">    seconds and microseconds.  Return value is a `.datetime`.</span>

<span class="sd">    The input date *x* is a float in ordinal days at UTC, and the output will</span>
<span class="sd">    be the specified `.datetime` object corresponding to that time in</span>
<span class="sd">    timezone *tz*, or if *tz* is ``None``, in the timezone specified in</span>
<span class="sd">    :rc:`timezone`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">tz</span> <span class="o">=</span> <span class="n">_get_tzinfo</span><span class="p">(</span><span class="n">tz</span><span class="p">)</span>

    <span class="n">dt</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="n">get_epoch</span><span class="p">())</span> <span class="o">+</span>
          <span class="n">np</span><span class="o">.</span><span class="n">timedelta64</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">MUSECONDS_PER_DAY</span><span class="p">)),</span> <span class="s1">&#39;us&#39;</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">dt</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="s1">&#39;0001-01-01&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">dt</span> <span class="o">&gt;=</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="s1">&#39;10000-01-01&#39;</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Date ordinal </span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s1"> converts to </span><span class="si">{</span><span class="n">dt</span><span class="si">}</span><span class="s1"> (using &#39;</span>
                         <span class="sa">f</span><span class="s1">&#39;epoch </span><span class="si">{</span><span class="n">get_epoch</span><span class="p">()</span><span class="si">}</span><span class="s1">), but Matplotlib dates must be &#39;</span>
                          <span class="s1">&#39;between year 0001 and 9999.&#39;</span><span class="p">)</span>
    <span class="c1"># convert from datetime64 to datetime:</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

    <span class="c1"># datetime64 is always UTC:</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">tzinfo</span><span class="o">=</span><span class="n">dateutil</span><span class="o">.</span><span class="n">tz</span><span class="o">.</span><span class="n">gettz</span><span class="p">(</span><span class="s1">&#39;UTC&#39;</span><span class="p">))</span>
    <span class="c1"># but maybe we are working in a different timezone so move.</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">astimezone</span><span class="p">(</span><span class="n">tz</span><span class="p">)</span>
    <span class="c1"># fix round off errors</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">70</span> <span class="o">*</span> <span class="mi">365</span><span class="p">:</span>
        <span class="c1"># if x is big, round off to nearest twenty microseconds.</span>
        <span class="c1"># This avoids floating point roundoff error</span>
        <span class="n">ms</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">dt</span><span class="o">.</span><span class="n">microsecond</span> <span class="o">/</span> <span class="mi">20</span><span class="p">)</span> <span class="o">*</span> <span class="mi">20</span>
        <span class="k">if</span> <span class="n">ms</span> <span class="o">==</span> <span class="mi">1000000</span><span class="p">:</span>
            <span class="n">dt</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">microsecond</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">datetime</span><span class="o">.</span><span class="n">timedelta</span><span class="p">(</span><span class="n">seconds</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dt</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">microsecond</span><span class="o">=</span><span class="n">ms</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">dt</span>


<span class="c1"># a version of _from_ordinalf that can operate on numpy arrays</span>
<span class="n">_from_ordinalf_np_vectorized</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="n">_from_ordinalf</span><span class="p">,</span> <span class="n">otypes</span><span class="o">=</span><span class="s2">&quot;O&quot;</span><span class="p">)</span>


<span class="c1"># a version of dateutil.parser.parse that can operate on numpy arrays</span>
<span class="n">_dateutil_parser_parse_np_vectorized</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="n">dateutil</span><span class="o">.</span><span class="n">parser</span><span class="o">.</span><span class="n">parse</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">datestr2num</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert a date string to a datenum using `dateutil.parser.parse`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    d : str or sequence of str</span>
<span class="sd">        The dates to convert.</span>

<span class="sd">    default : datetime.datetime, optional</span>
<span class="sd">        The default date to use when fields are missing in *d*.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">dateutil</span><span class="o">.</span><span class="n">parser</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="n">default</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">date2num</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">default</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="p">[</span><span class="n">date2num</span><span class="p">(</span><span class="n">dateutil</span><span class="o">.</span><span class="n">parser</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="n">default</span><span class="p">))</span>
                 <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">d</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">d</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">d</span>
        <span class="k">return</span> <span class="n">date2num</span><span class="p">(</span><span class="n">_dateutil_parser_parse_np_vectorized</span><span class="p">(</span><span class="n">d</span><span class="p">))</span>


<div class="viewcode-block" id="date2num">
<a class="viewcode-back" href="../../_autosummary/pipeline.hsd.tasks.common.display.date2num.html#pipeline.hsd.tasks.common.display.date2num">[docs]</a>
<span class="k">def</span> <span class="nf">date2num</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert datetime objects to Matplotlib dates.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    d : `datetime.datetime` or `numpy.datetime64` or sequences of these</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float or sequence of floats</span>
<span class="sd">        Number of days since the epoch.  See `.get_epoch` for the</span>
<span class="sd">        epoch, which can be changed by :rc:`date.epoch` or `.set_epoch`.  If</span>
<span class="sd">        the epoch is &quot;1970-01-01T00:00:00&quot; (default) then noon Jan 1 1970</span>
<span class="sd">        (&quot;1970-01-01T12:00:00&quot;) returns 0.5.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The Gregorian calendar is assumed; this is not universal practice.</span>
<span class="sd">    For details see the module docstring.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Unpack in case of e.g. Pandas or xarray object</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">cbook</span><span class="o">.</span><span class="n">_unpack_to_numpy</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>

    <span class="c1"># make an iterable, but save state to unpack later:</span>
    <span class="n">iterable</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">iterable</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">iterable</span><span class="p">:</span>
        <span class="n">d</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span><span class="p">]</span>

    <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
    <span class="c1"># convert to datetime64 arrays, if not already:</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">):</span>
        <span class="c1"># datetime arrays</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">d</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
            <span class="c1"># deals with an empty array...</span>
            <span class="k">return</span> <span class="n">d</span>
        <span class="n">tzi</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;tzinfo&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">tzi</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># make datetime naive:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="p">[</span><span class="n">dt</span><span class="o">.</span><span class="n">astimezone</span><span class="p">(</span><span class="n">UTC</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">tzinfo</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">dt</span> <span class="ow">in</span> <span class="n">d</span><span class="p">]</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[us]&#39;</span><span class="p">)</span>

    <span class="n">d</span> <span class="o">=</span> <span class="n">_dt64_to_ordinalf</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">d</span> <span class="k">if</span> <span class="n">iterable</span> <span class="k">else</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>



<span class="k">def</span> <span class="nf">julian2num</span><span class="p">(</span><span class="n">j</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert a Julian date (or sequence) to a Matplotlib date (or sequence).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    j : float or sequence of floats</span>
<span class="sd">        Julian dates (days relative to 4713 BC Jan 1, 12:00:00 Julian</span>
<span class="sd">        calendar or 4714 BC Nov 24, 12:00:00, proleptic Gregorian calendar).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float or sequence of floats</span>
<span class="sd">        Matplotlib dates (days relative to `.get_epoch`).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="n">get_epoch</span><span class="p">(),</span> <span class="s1">&#39;h&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span> <span class="o">/</span> <span class="mf">24.</span>
    <span class="n">ep0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="s1">&#39;0000-12-31T00:00:00&#39;</span><span class="p">,</span> <span class="s1">&#39;h&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span> <span class="o">/</span> <span class="mf">24.</span>
    <span class="c1"># Julian offset defined above is relative to 0000-12-31, but we need</span>
    <span class="c1"># relative to our current epoch:</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">JULIAN_OFFSET</span> <span class="o">-</span> <span class="n">ep0</span> <span class="o">+</span> <span class="n">ep</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>  <span class="c1"># Handles both scalar &amp; nonscalar j.</span>


<span class="k">def</span> <span class="nf">num2julian</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert a Matplotlib date (or sequence) to a Julian date (or sequence).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : float or sequence of floats</span>
<span class="sd">        Matplotlib dates (days relative to `.get_epoch`).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float or sequence of floats</span>
<span class="sd">        Julian dates (days relative to 4713 BC Jan 1, 12:00:00).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="n">get_epoch</span><span class="p">(),</span> <span class="s1">&#39;h&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span> <span class="o">/</span> <span class="mf">24.</span>
    <span class="n">ep0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="s1">&#39;0000-12-31T00:00:00&#39;</span><span class="p">,</span> <span class="s1">&#39;h&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span> <span class="o">/</span> <span class="mf">24.</span>
    <span class="c1"># Julian offset defined above is relative to 0000-12-31, but we need</span>
    <span class="c1"># relative to our current epoch:</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">JULIAN_OFFSET</span> <span class="o">-</span> <span class="n">ep0</span> <span class="o">+</span> <span class="n">ep</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>  <span class="c1"># Handles both scalar &amp; nonscalar j.</span>


<span class="k">def</span> <span class="nf">num2date</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">tz</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert Matplotlib dates to `~datetime.datetime` objects.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : float or sequence of floats</span>
<span class="sd">        Number of days (fraction part represents hours, minutes, seconds)</span>
<span class="sd">        since the epoch.  See `.get_epoch` for the</span>
<span class="sd">        epoch, which can be changed by :rc:`date.epoch` or `.set_epoch`.</span>
<span class="sd">    tz : str or `~datetime.tzinfo`, default: :rc:`timezone`</span>
<span class="sd">        Timezone of *x*. If a string, *tz* is passed to `dateutil.tz`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    `~datetime.datetime` or sequence of `~datetime.datetime`</span>
<span class="sd">        Dates are returned in timezone *tz*.</span>

<span class="sd">        If *x* is a sequence, a sequence of `~datetime.datetime` objects will</span>
<span class="sd">        be returned.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The Gregorian calendar is assumed; this is not universal practice.</span>
<span class="sd">    For details, see the module docstring.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">tz</span> <span class="o">=</span> <span class="n">_get_tzinfo</span><span class="p">(</span><span class="n">tz</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_from_ordinalf_np_vectorized</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">tz</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>


<span class="n">_ordinalf_to_timedelta_np_vectorized</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span>
    <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">datetime</span><span class="o">.</span><span class="n">timedelta</span><span class="p">(</span><span class="n">days</span><span class="o">=</span><span class="n">x</span><span class="p">),</span> <span class="n">otypes</span><span class="o">=</span><span class="s2">&quot;O&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">num2timedelta</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert number of days to a `~datetime.timedelta` object.</span>

<span class="sd">    If *x* is a sequence, a sequence of `~datetime.timedelta` objects will</span>
<span class="sd">    be returned.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : float, sequence of floats</span>
<span class="sd">        Number of days. The fraction part represents hours, minutes, seconds.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    `datetime.timedelta` or list[`datetime.timedelta`]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_ordinalf_to_timedelta_np_vectorized</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">drange</span><span class="p">(</span><span class="n">dstart</span><span class="p">,</span> <span class="n">dend</span><span class="p">,</span> <span class="n">delta</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a sequence of equally spaced Matplotlib dates.</span>

<span class="sd">    The dates start at *dstart* and reach up to, but not including *dend*.</span>
<span class="sd">    They are spaced by *delta*.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dstart, dend : `~datetime.datetime`</span>
<span class="sd">        The date limits.</span>
<span class="sd">    delta : `datetime.timedelta`</span>
<span class="sd">        Spacing of the dates.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    `numpy.array`</span>
<span class="sd">        A list floats representing Matplotlib dates.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">f1</span> <span class="o">=</span> <span class="n">date2num</span><span class="p">(</span><span class="n">dstart</span><span class="p">)</span>
    <span class="n">f2</span> <span class="o">=</span> <span class="n">date2num</span><span class="p">(</span><span class="n">dend</span><span class="p">)</span>
    <span class="n">step</span> <span class="o">=</span> <span class="n">delta</span><span class="o">.</span><span class="n">total_seconds</span><span class="p">()</span> <span class="o">/</span> <span class="n">SEC_PER_DAY</span>

    <span class="c1"># calculate the difference between dend and dstart in times of delta</span>
    <span class="n">num</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">((</span><span class="n">f2</span> <span class="o">-</span> <span class="n">f1</span><span class="p">)</span> <span class="o">/</span> <span class="n">step</span><span class="p">))</span>

    <span class="c1"># calculate end of the interval which will be generated</span>
    <span class="n">dinterval_end</span> <span class="o">=</span> <span class="n">dstart</span> <span class="o">+</span> <span class="n">num</span> <span class="o">*</span> <span class="n">delta</span>

    <span class="c1"># ensure, that an half open interval will be generated [dstart, dend)</span>
    <span class="k">if</span> <span class="n">dinterval_end</span> <span class="o">&gt;=</span> <span class="n">dend</span><span class="p">:</span>
        <span class="c1"># if the endpoint is greater than or equal to dend,</span>
        <span class="c1"># just subtract one delta</span>
        <span class="n">dinterval_end</span> <span class="o">-=</span> <span class="n">delta</span>
        <span class="n">num</span> <span class="o">-=</span> <span class="mi">1</span>

    <span class="n">f2</span> <span class="o">=</span> <span class="n">date2num</span><span class="p">(</span><span class="n">dinterval_end</span><span class="p">)</span>  <span class="c1"># new float-endpoint</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">,</span> <span class="n">num</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_wrap_in_tex</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
    <span class="n">p</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;([a-zA-Z]+)&#39;</span>
    <span class="n">ret_text</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="sa">r</span><span class="s1">&#39;}$\1$</span><span class="se">\\</span><span class="s1">mathdefault{&#39;</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>

    <span class="c1"># Braces ensure symbols are not spaced like binary operators.</span>
    <span class="n">ret_text</span> <span class="o">=</span> <span class="n">ret_text</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="s1">&#39;{-}&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;:&#39;</span><span class="p">,</span> <span class="s1">&#39;</span><span class="si">{:}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="c1"># To not concatenate space between numbers.</span>
    <span class="n">ret_text</span> <span class="o">=</span> <span class="n">ret_text</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="sa">r</span><span class="s1">&#39;\;&#39;</span><span class="p">)</span>
    <span class="n">ret_text</span> <span class="o">=</span> <span class="s1">&#39;$</span><span class="se">\\</span><span class="s1">mathdefault{&#39;</span> <span class="o">+</span> <span class="n">ret_text</span> <span class="o">+</span> <span class="s1">&#39;}$&#39;</span>
    <span class="n">ret_text</span> <span class="o">=</span> <span class="n">ret_text</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;$</span><span class="se">\\</span><span class="s1">mathdefault</span><span class="si">{}</span><span class="s1">$&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ret_text</span>


<span class="c1">## date tickers and formatters ###</span>


<div class="viewcode-block" id="DateFormatter">
<a class="viewcode-back" href="../../_autosummary/pipeline.hsd.tasks.common.display.DateFormatter.html#pipeline.hsd.tasks.common.display.DateFormatter">[docs]</a>
<span class="k">class</span> <span class="nc">DateFormatter</span><span class="p">(</span><span class="n">ticker</span><span class="o">.</span><span class="n">Formatter</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Format a tick (in days since the epoch) with a</span>
<span class="sd">    `~datetime.datetime.strftime` format string.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">tz</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">usetex</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fmt : str</span>
<span class="sd">            `~datetime.datetime.strftime` format string</span>
<span class="sd">        tz : str or `~datetime.tzinfo`, default: :rc:`timezone`</span>
<span class="sd">            Ticks timezone. If a string, *tz* is passed to `dateutil.tz`.</span>
<span class="sd">        usetex : bool, default: :rc:`text.usetex`</span>
<span class="sd">            To enable/disable the use of TeX&#39;s math mode for rendering the</span>
<span class="sd">            results of the formatter.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tz</span> <span class="o">=</span> <span class="n">_get_tzinfo</span><span class="p">(</span><span class="n">tz</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fmt</span> <span class="o">=</span> <span class="n">fmt</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_usetex</span> <span class="o">=</span> <span class="p">(</span><span class="n">usetex</span> <span class="k">if</span> <span class="n">usetex</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span>
                        <span class="n">mpl</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;text.usetex&#39;</span><span class="p">])</span>

<div class="viewcode-block" id="DateFormatter.__call__">
<a class="viewcode-back" href="../../_autosummary/pipeline.hsd.tasks.common.display.DateFormatter.html#pipeline.hsd.tasks.common.display.DateFormatter.__call__">[docs]</a>
    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">num2date</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tz</span><span class="p">)</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fmt</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_wrap_in_tex</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_usetex</span> <span class="k">else</span> <span class="n">result</span></div>


    <span class="k">def</span> <span class="nf">set_tzinfo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tz</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tz</span> <span class="o">=</span> <span class="n">_get_tzinfo</span><span class="p">(</span><span class="n">tz</span><span class="p">)</span></div>



<span class="k">class</span> <span class="nc">ConciseDateFormatter</span><span class="p">(</span><span class="n">ticker</span><span class="o">.</span><span class="n">Formatter</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A `.Formatter` which attempts to figure out the best format to use for the</span>
<span class="sd">    date, and to make it as compact as possible, but still be complete. This is</span>
<span class="sd">    most useful when used with the `AutoDateLocator`::</span>

<span class="sd">    &gt;&gt;&gt; locator = AutoDateLocator()</span>
<span class="sd">    &gt;&gt;&gt; formatter = ConciseDateFormatter(locator)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    locator : `.ticker.Locator`</span>
<span class="sd">        Locator that this axis is using.</span>

<span class="sd">    tz : str or `~datetime.tzinfo`, default: :rc:`timezone`</span>
<span class="sd">        Ticks timezone, passed to `.dates.num2date`.</span>

<span class="sd">    formats : list of 6 strings, optional</span>
<span class="sd">        Format strings for 6 levels of tick labelling: mostly years,</span>
<span class="sd">        months, days, hours, minutes, and seconds.  Strings use</span>
<span class="sd">        the same format codes as `~datetime.datetime.strftime`.  Default is</span>
<span class="sd">        ``[&#39;%Y&#39;, &#39;%b&#39;, &#39;%d&#39;, &#39;%H:%M&#39;, &#39;%H:%M&#39;, &#39;%S.%f&#39;]``</span>

<span class="sd">    zero_formats : list of 6 strings, optional</span>
<span class="sd">        Format strings for tick labels that are &quot;zeros&quot; for a given tick</span>
<span class="sd">        level.  For instance, if most ticks are months, ticks around 1 Jan 2005</span>
<span class="sd">        will be labeled &quot;Dec&quot;, &quot;2005&quot;, &quot;Feb&quot;.  The default is</span>
<span class="sd">        ``[&#39;&#39;, &#39;%Y&#39;, &#39;%b&#39;, &#39;%b-%d&#39;, &#39;%H:%M&#39;, &#39;%H:%M&#39;]``</span>

<span class="sd">    offset_formats : list of 6 strings, optional</span>
<span class="sd">        Format strings for the 6 levels that is applied to the &quot;offset&quot;</span>
<span class="sd">        string found on the right side of an x-axis, or top of a y-axis.</span>
<span class="sd">        Combined with the tick labels this should completely specify the</span>
<span class="sd">        date.  The default is::</span>

<span class="sd">            [&#39;&#39;, &#39;%Y&#39;, &#39;%Y-%b&#39;, &#39;%Y-%b-%d&#39;, &#39;%Y-%b-%d&#39;, &#39;%Y-%b-%d %H:%M&#39;]</span>

<span class="sd">    show_offset : bool, default: True</span>
<span class="sd">        Whether to show the offset or not.</span>

<span class="sd">    usetex : bool, default: :rc:`text.usetex`</span>
<span class="sd">        To enable/disable the use of TeX&#39;s math mode for rendering the results</span>
<span class="sd">        of the formatter.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    See :doc:`/gallery/ticks/date_concise_formatter`</span>

<span class="sd">    .. plot::</span>

<span class="sd">        import datetime</span>
<span class="sd">        import matplotlib.dates as mdates</span>

<span class="sd">        base = datetime.datetime(2005, 2, 1)</span>
<span class="sd">        dates = np.array([base + datetime.timedelta(hours=(2 * i))</span>
<span class="sd">                          for i in range(732)])</span>
<span class="sd">        N = len(dates)</span>
<span class="sd">        np.random.seed(19680801)</span>
<span class="sd">        y = np.cumsum(np.random.randn(N))</span>

<span class="sd">        fig, ax = plt.subplots(constrained_layout=True)</span>
<span class="sd">        locator = mdates.AutoDateLocator()</span>
<span class="sd">        formatter = mdates.ConciseDateFormatter(locator)</span>
<span class="sd">        ax.xaxis.set_major_locator(locator)</span>
<span class="sd">        ax.xaxis.set_major_formatter(formatter)</span>

<span class="sd">        ax.plot(dates, y)</span>
<span class="sd">        ax.set_title(&#39;Concise Date Formatter&#39;)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">locator</span><span class="p">,</span> <span class="n">tz</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">formats</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">offset_formats</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">zero_formats</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">show_offset</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">usetex</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Autoformat the date labels.  The default format is used to form an</span>
<span class="sd">        initial string, and then redundant elements are removed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_locator</span> <span class="o">=</span> <span class="n">locator</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tz</span> <span class="o">=</span> <span class="n">tz</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">defaultfmt</span> <span class="o">=</span> <span class="s1">&#39;%Y&#39;</span>
        <span class="c1"># there are 6 levels with each level getting a specific format</span>
        <span class="c1"># 0: mostly years,  1: months,  2: days,</span>
        <span class="c1"># 3: hours, 4: minutes, 5: seconds</span>
        <span class="k">if</span> <span class="n">formats</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">formats</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">6</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;formats argument must be a list of &#39;</span>
                                 <span class="s1">&#39;6 format strings (or None)&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">formats</span> <span class="o">=</span> <span class="n">formats</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">formats</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;%Y&#39;</span><span class="p">,</span>  <span class="c1"># ticks are mostly years</span>
                            <span class="s1">&#39;%b&#39;</span><span class="p">,</span>          <span class="c1"># ticks are mostly months</span>
                            <span class="s1">&#39;</span><span class="si">%d</span><span class="s1">&#39;</span><span class="p">,</span>          <span class="c1"># ticks are mostly days</span>
                            <span class="s1">&#39;%H:%M&#39;</span><span class="p">,</span>       <span class="c1"># hrs</span>
                            <span class="s1">&#39;%H:%M&#39;</span><span class="p">,</span>       <span class="c1"># min</span>
                            <span class="s1">&#39;%S.</span><span class="si">%f</span><span class="s1">&#39;</span><span class="p">,</span>       <span class="c1"># secs</span>
                            <span class="p">]</span>
        <span class="c1"># fmt for zeros ticks at this level.  These are</span>
        <span class="c1"># ticks that should be labeled w/ info the level above.</span>
        <span class="c1"># like 1 Jan can just be labelled &quot;Jan&quot;.  02:02:00 can</span>
        <span class="c1"># just be labeled 02:02.</span>
        <span class="k">if</span> <span class="n">zero_formats</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">zero_formats</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">6</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;zero_formats argument must be a list of &#39;</span>
                                 <span class="s1">&#39;6 format strings (or None)&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">zero_formats</span> <span class="o">=</span> <span class="n">zero_formats</span>
        <span class="k">elif</span> <span class="n">formats</span><span class="p">:</span>
            <span class="c1"># use the users formats for the zero tick formats</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">zero_formats</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">formats</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># make the defaults a bit nicer:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">zero_formats</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">formats</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">zero_formats</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;%b-</span><span class="si">%d</span><span class="s1">&#39;</span>

        <span class="k">if</span> <span class="n">offset_formats</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">offset_formats</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">6</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;offset_formats argument must be a list of &#39;</span>
                                 <span class="s1">&#39;6 format strings (or None)&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">offset_formats</span> <span class="o">=</span> <span class="n">offset_formats</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">offset_formats</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;&#39;</span><span class="p">,</span>
                                   <span class="s1">&#39;%Y&#39;</span><span class="p">,</span>
                                   <span class="s1">&#39;%Y-%b&#39;</span><span class="p">,</span>
                                   <span class="s1">&#39;%Y-%b-</span><span class="si">%d</span><span class="s1">&#39;</span><span class="p">,</span>
                                   <span class="s1">&#39;%Y-%b-</span><span class="si">%d</span><span class="s1">&#39;</span><span class="p">,</span>
                                   <span class="s1">&#39;%Y-%b-</span><span class="si">%d</span><span class="s1"> %H:%M&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">offset_string</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">show_offset</span> <span class="o">=</span> <span class="n">show_offset</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_usetex</span> <span class="o">=</span> <span class="p">(</span><span class="n">usetex</span> <span class="k">if</span> <span class="n">usetex</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span>
                        <span class="n">mpl</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;text.usetex&#39;</span><span class="p">])</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">formatter</span> <span class="o">=</span> <span class="n">DateFormatter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">defaultfmt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tz</span><span class="p">,</span>
                                  <span class="n">usetex</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_usetex</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">formatter</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="n">pos</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">format_ticks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="n">tickdatetime</span> <span class="o">=</span> <span class="p">[</span><span class="n">num2date</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">tz</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_tz</span><span class="p">)</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">values</span><span class="p">]</span>
        <span class="n">tickdate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">tdt</span><span class="o">.</span><span class="n">timetuple</span><span class="p">()[:</span><span class="mi">6</span><span class="p">]</span> <span class="k">for</span> <span class="n">tdt</span> <span class="ow">in</span> <span class="n">tickdatetime</span><span class="p">])</span>

        <span class="c1"># basic algorithm:</span>
        <span class="c1"># 1) only display a part of the date if it changes over the ticks.</span>
        <span class="c1"># 2) don&#39;t display the smaller part of the date if:</span>
        <span class="c1">#    it is always the same or if it is the start of the</span>
        <span class="c1">#    year, month, day etc.</span>
        <span class="c1"># fmt for most ticks at this level</span>
        <span class="n">fmts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">formats</span>
        <span class="c1"># format beginnings of days, months, years, etc.</span>
        <span class="n">zerofmts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">zero_formats</span>
        <span class="c1"># offset fmt are for the offset in the upper left of the</span>
        <span class="c1"># or lower right of the axis.</span>
        <span class="n">offsetfmts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">offset_formats</span>
        <span class="n">show_offset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">show_offset</span>

        <span class="c1"># determine the level we will label at:</span>
        <span class="c1"># mostly 0: years,  1: months,  2: days,</span>
        <span class="c1"># 3: hours, 4: minutes, 5: seconds, 6: microseconds</span>
        <span class="k">for</span> <span class="n">level</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">unique</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">tickdate</span><span class="p">[:,</span> <span class="n">level</span><span class="p">])</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># if 1 is included in unique, the year is shown in ticks</span>
                <span class="k">if</span> <span class="n">level</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">unique</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="n">show_offset</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">break</span>
            <span class="k">elif</span> <span class="n">level</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># all tickdate are the same, so only micros might be different</span>
                <span class="c1"># set to the most precise (6: microseconds doesn&#39;t exist...)</span>
                <span class="n">level</span> <span class="o">=</span> <span class="mi">5</span>

        <span class="c1"># level is the basic level we will label at.</span>
        <span class="c1"># now loop through and decide the actual ticklabels</span>
        <span class="n">zerovals</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">tickdate</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">nn</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tickdate</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">level</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">tickdate</span><span class="p">[</span><span class="n">nn</span><span class="p">][</span><span class="n">level</span><span class="p">]</span> <span class="o">==</span> <span class="n">zerovals</span><span class="p">[</span><span class="n">level</span><span class="p">]:</span>
                    <span class="n">fmt</span> <span class="o">=</span> <span class="n">zerofmts</span><span class="p">[</span><span class="n">level</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">fmt</span> <span class="o">=</span> <span class="n">fmts</span><span class="p">[</span><span class="n">level</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># special handling for seconds + microseconds</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">tickdatetime</span><span class="p">[</span><span class="n">nn</span><span class="p">]</span><span class="o">.</span><span class="n">second</span> <span class="o">==</span> <span class="n">tickdatetime</span><span class="p">[</span><span class="n">nn</span><span class="p">]</span><span class="o">.</span><span class="n">microsecond</span>
                        <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                    <span class="n">fmt</span> <span class="o">=</span> <span class="n">zerofmts</span><span class="p">[</span><span class="n">level</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">fmt</span> <span class="o">=</span> <span class="n">fmts</span><span class="p">[</span><span class="n">level</span><span class="p">]</span>
            <span class="n">labels</span><span class="p">[</span><span class="n">nn</span><span class="p">]</span> <span class="o">=</span> <span class="n">tickdatetime</span><span class="p">[</span><span class="n">nn</span><span class="p">]</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="n">fmt</span><span class="p">)</span>

        <span class="c1"># special handling of seconds and microseconds:</span>
        <span class="c1"># strip extra zeros and decimal if possible.</span>
        <span class="c1"># this is complicated by two factors.  1) we have some level-4 strings</span>
        <span class="c1"># here (i.e. 03:00, &#39;0.50000&#39;, &#39;1.000&#39;) 2) we would like to have the</span>
        <span class="c1"># same number of decimals for each string (i.e. 0.5 and 1.0).</span>
        <span class="k">if</span> <span class="n">level</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span>
            <span class="n">trailing_zeros</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span>
                <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="p">))</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">labels</span> <span class="k">if</span> <span class="s1">&#39;.&#39;</span> <span class="ow">in</span> <span class="n">s</span><span class="p">),</span>
                <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">trailing_zeros</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">nn</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">labels</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="s1">&#39;.&#39;</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">[</span><span class="n">nn</span><span class="p">]:</span>
                        <span class="n">labels</span><span class="p">[</span><span class="n">nn</span><span class="p">]</span> <span class="o">=</span> <span class="n">labels</span><span class="p">[</span><span class="n">nn</span><span class="p">][:</span><span class="o">-</span><span class="n">trailing_zeros</span><span class="p">]</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">show_offset</span><span class="p">:</span>
            <span class="c1"># set the offset string:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">offset_string</span> <span class="o">=</span> <span class="n">tickdatetime</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="n">offsetfmts</span><span class="p">[</span><span class="n">level</span><span class="p">])</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_usetex</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">offset_string</span> <span class="o">=</span> <span class="n">_wrap_in_tex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">offset_string</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">offset_string</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_usetex</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">_wrap_in_tex</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">labels</span>

    <span class="k">def</span> <span class="nf">get_offset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">offset_string</span>

    <span class="k">def</span> <span class="nf">format_data_short</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">num2date</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">tz</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_tz</span><span class="p">)</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s1">&#39;%Y-%m-</span><span class="si">%d</span><span class="s1"> %H:%M:%S&#39;</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">AutoDateFormatter</span><span class="p">(</span><span class="n">ticker</span><span class="o">.</span><span class="n">Formatter</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A `.Formatter` which attempts to figure out the best format to use.  This</span>
<span class="sd">    is most useful when used with the `AutoDateLocator`.</span>

<span class="sd">    `.AutoDateFormatter` has a ``.scale`` dictionary that maps tick scales (the</span>
<span class="sd">    interval in days between one major tick) to format strings; this dictionary</span>
<span class="sd">    defaults to ::</span>

<span class="sd">        self.scaled = {</span>
<span class="sd">            DAYS_PER_YEAR: rcParams[&#39;date.autoformatter.year&#39;],</span>
<span class="sd">            DAYS_PER_MONTH: rcParams[&#39;date.autoformatter.month&#39;],</span>
<span class="sd">            1: rcParams[&#39;date.autoformatter.day&#39;],</span>
<span class="sd">            1 / HOURS_PER_DAY: rcParams[&#39;date.autoformatter.hour&#39;],</span>
<span class="sd">            1 / MINUTES_PER_DAY: rcParams[&#39;date.autoformatter.minute&#39;],</span>
<span class="sd">            1 / SEC_PER_DAY: rcParams[&#39;date.autoformatter.second&#39;],</span>
<span class="sd">            1 / MUSECONDS_PER_DAY: rcParams[&#39;date.autoformatter.microsecond&#39;],</span>
<span class="sd">        }</span>

<span class="sd">    The formatter uses the format string corresponding to the lowest key in</span>
<span class="sd">    the dictionary that is greater or equal to the current scale.  Dictionary</span>
<span class="sd">    entries can be customized::</span>

<span class="sd">        locator = AutoDateLocator()</span>
<span class="sd">        formatter = AutoDateFormatter(locator)</span>
<span class="sd">        formatter.scaled[1/(24*60)] = &#39;%M:%S&#39; # only show min and sec</span>

<span class="sd">    Custom callables can also be used instead of format strings.  The following</span>
<span class="sd">    example shows how to use a custom format function to strip trailing zeros</span>
<span class="sd">    from decimal seconds and adds the date to the first ticklabel::</span>

<span class="sd">        def my_format_function(x, pos=None):</span>
<span class="sd">            x = matplotlib.dates.num2date(x)</span>
<span class="sd">            if pos == 0:</span>
<span class="sd">                fmt = &#39;%D %H:%M:%S.%f&#39;</span>
<span class="sd">            else:</span>
<span class="sd">                fmt = &#39;%H:%M:%S.%f&#39;</span>
<span class="sd">            label = x.strftime(fmt)</span>
<span class="sd">            label = label.rstrip(&quot;0&quot;)</span>
<span class="sd">            label = label.rstrip(&quot;.&quot;)</span>
<span class="sd">            return label</span>

<span class="sd">        formatter.scaled[1/(24*60)] = my_format_function</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># This can be improved by providing some user-level direction on</span>
    <span class="c1"># how to choose the best format (precedence, etc.).</span>

    <span class="c1"># Perhaps a &#39;struct&#39; that has a field for each time-type where a</span>
    <span class="c1"># zero would indicate &quot;don&#39;t show&quot; and a number would indicate</span>
    <span class="c1"># &quot;show&quot; with some sort of priority.  Same priorities could mean</span>
    <span class="c1"># show all with the same priority.</span>

    <span class="c1"># Or more simply, perhaps just a format string for each</span>
    <span class="c1"># possibility...</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">locator</span><span class="p">,</span> <span class="n">tz</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">defaultfmt</span><span class="o">=</span><span class="s1">&#39;%Y-%m-</span><span class="si">%d</span><span class="s1">&#39;</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span>
                 <span class="n">usetex</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Autoformat the date labels.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        locator : `.ticker.Locator`</span>
<span class="sd">            Locator that this axis is using.</span>

<span class="sd">        tz : str or `~datetime.tzinfo`, default: :rc:`timezone`</span>
<span class="sd">            Ticks timezone. If a string, *tz* is passed to `dateutil.tz`.</span>

<span class="sd">        defaultfmt : str</span>
<span class="sd">            The default format to use if none of the values in ``self.scaled``</span>
<span class="sd">            are greater than the unit returned by ``locator._get_unit()``.</span>

<span class="sd">        usetex : bool, default: :rc:`text.usetex`</span>
<span class="sd">            To enable/disable the use of TeX&#39;s math mode for rendering the</span>
<span class="sd">            results of the formatter. If any entries in ``self.scaled`` are set</span>
<span class="sd">            as functions, then it is up to the customized function to enable or</span>
<span class="sd">            disable TeX&#39;s math mode itself.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_locator</span> <span class="o">=</span> <span class="n">locator</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tz</span> <span class="o">=</span> <span class="n">tz</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">defaultfmt</span> <span class="o">=</span> <span class="n">defaultfmt</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_formatter</span> <span class="o">=</span> <span class="n">DateFormatter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">defaultfmt</span><span class="p">,</span> <span class="n">tz</span><span class="p">)</span>
        <span class="n">rcParams</span> <span class="o">=</span> <span class="n">mpl</span><span class="o">.</span><span class="n">rcParams</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_usetex</span> <span class="o">=</span> <span class="p">(</span><span class="n">usetex</span> <span class="k">if</span> <span class="n">usetex</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span>
                        <span class="n">mpl</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;text.usetex&#39;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scaled</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">DAYS_PER_YEAR</span><span class="p">:</span> <span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;date.autoformatter.year&#39;</span><span class="p">],</span>
            <span class="n">DAYS_PER_MONTH</span><span class="p">:</span> <span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;date.autoformatter.month&#39;</span><span class="p">],</span>
            <span class="mi">1</span><span class="p">:</span> <span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;date.autoformatter.day&#39;</span><span class="p">],</span>
            <span class="mi">1</span> <span class="o">/</span> <span class="n">HOURS_PER_DAY</span><span class="p">:</span> <span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;date.autoformatter.hour&#39;</span><span class="p">],</span>
            <span class="mi">1</span> <span class="o">/</span> <span class="n">MINUTES_PER_DAY</span><span class="p">:</span> <span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;date.autoformatter.minute&#39;</span><span class="p">],</span>
            <span class="mi">1</span> <span class="o">/</span> <span class="n">SEC_PER_DAY</span><span class="p">:</span> <span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;date.autoformatter.second&#39;</span><span class="p">],</span>
            <span class="mi">1</span> <span class="o">/</span> <span class="n">MUSECONDS_PER_DAY</span><span class="p">:</span> <span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;date.autoformatter.microsecond&#39;</span><span class="p">]</span>
        <span class="p">}</span>

    <span class="k">def</span> <span class="nf">_set_locator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">locator</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_locator</span> <span class="o">=</span> <span class="n">locator</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">locator_unit_scale</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_locator</span><span class="o">.</span><span class="n">_get_unit</span><span class="p">())</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">locator_unit_scale</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="c1"># Pick the first scale which is greater than the locator unit.</span>
        <span class="n">fmt</span> <span class="o">=</span> <span class="nb">next</span><span class="p">((</span><span class="n">fmt</span> <span class="k">for</span> <span class="n">scale</span><span class="p">,</span> <span class="n">fmt</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scaled</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
                    <span class="k">if</span> <span class="n">scale</span> <span class="o">&gt;=</span> <span class="n">locator_unit_scale</span><span class="p">),</span>
                   <span class="bp">self</span><span class="o">.</span><span class="n">defaultfmt</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fmt</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_formatter</span> <span class="o">=</span> <span class="n">DateFormatter</span><span class="p">(</span><span class="n">fmt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tz</span><span class="p">,</span> <span class="n">usetex</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_usetex</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_formatter</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">callable</span><span class="p">(</span><span class="n">fmt</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">fmt</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Unexpected type passed to </span><span class="si">{0!r}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">result</span>


<span class="k">class</span> <span class="nc">rrulewrapper</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A simple wrapper around a `dateutil.rrule` allowing flexible</span>
<span class="sd">    date tick specifications.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="n">tzinfo</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        freq : {YEARLY, MONTHLY, WEEKLY, DAILY, HOURLY, MINUTELY, SECONDLY}</span>
<span class="sd">            Tick frequency. These constants are defined in `dateutil.rrule`,</span>
<span class="sd">            but they are accessible from `matplotlib.dates` as well.</span>
<span class="sd">        tzinfo : `datetime.tzinfo`, optional</span>
<span class="sd">            Time zone information. The default is None.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional keyword arguments are passed to the `dateutil.rrule`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;freq&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">freq</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_base_tzinfo</span> <span class="o">=</span> <span class="n">tzinfo</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_update_rrule</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set parameters for an existing wrapper.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_construct</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_update_rrule</span><span class="p">(</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_construct</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_update_rrule</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">tzinfo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_base_tzinfo</span>

        <span class="c1"># rrule does not play nicely with timezones - especially pytz time</span>
        <span class="c1"># zones, it&#39;s best to use naive zones and attach timezones once the</span>
        <span class="c1"># datetimes are returned</span>
        <span class="k">if</span> <span class="s1">&#39;dtstart&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">dtstart</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;dtstart&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">dtstart</span><span class="o">.</span><span class="n">tzinfo</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">tzinfo</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">tzinfo</span> <span class="o">=</span> <span class="n">dtstart</span><span class="o">.</span><span class="n">tzinfo</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">dtstart</span> <span class="o">=</span> <span class="n">dtstart</span><span class="o">.</span><span class="n">astimezone</span><span class="p">(</span><span class="n">tzinfo</span><span class="p">)</span>

                <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;dtstart&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dtstart</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">tzinfo</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="s1">&#39;until&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">until</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;until&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">until</span><span class="o">.</span><span class="n">tzinfo</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">tzinfo</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">until</span> <span class="o">=</span> <span class="n">until</span><span class="o">.</span><span class="n">astimezone</span><span class="p">(</span><span class="n">tzinfo</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;until cannot be aware if dtstart &#39;</span>
                                     <span class="s1">&#39;is naive and tzinfo is None&#39;</span><span class="p">)</span>

                <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;until&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">until</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">tzinfo</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_construct</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tzinfo</span> <span class="o">=</span> <span class="n">tzinfo</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_rrule</span> <span class="o">=</span> <span class="n">rrule</span><span class="p">(</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_construct</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_attach_tzinfo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">tzinfo</span><span class="p">):</span>
        <span class="c1"># pytz zones are attached by &quot;localizing&quot; the datetime</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">tzinfo</span><span class="p">,</span> <span class="s1">&#39;localize&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">tzinfo</span><span class="o">.</span><span class="n">localize</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">is_dst</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">dt</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">tzinfo</span><span class="o">=</span><span class="n">tzinfo</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_aware_return_wrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">returns_list</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Decorator function that allows rrule methods to handle tzinfo.&quot;&quot;&quot;</span>
        <span class="c1"># This is only necessary if we&#39;re actually attaching a tzinfo</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tzinfo</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">f</span>

        <span class="c1"># All datetime arguments must be naive. If they are not naive, they are</span>
        <span class="c1"># converted to the _tzinfo zone before dropping the zone.</span>
        <span class="k">def</span> <span class="nf">normalize_arg</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">)</span> <span class="ow">and</span> <span class="n">arg</span><span class="o">.</span><span class="n">tzinfo</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">arg</span><span class="o">.</span><span class="n">tzinfo</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tzinfo</span><span class="p">:</span>
                    <span class="n">arg</span> <span class="o">=</span> <span class="n">arg</span><span class="o">.</span><span class="n">astimezone</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tzinfo</span><span class="p">)</span>

                <span class="k">return</span> <span class="n">arg</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">tzinfo</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">arg</span>

        <span class="k">def</span> <span class="nf">normalize_args</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">):</span>
            <span class="n">args</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">normalize_arg</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">)</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="n">kw</span><span class="p">:</span> <span class="n">normalize_arg</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="k">for</span> <span class="n">kw</span><span class="p">,</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

            <span class="k">return</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span>

        <span class="c1"># There are two kinds of functions we care about - ones that return</span>
        <span class="c1"># dates and ones that return lists of dates.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">returns_list</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">inner_func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
                <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="n">normalize_args</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
                <span class="n">dt</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attach_tzinfo</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tzinfo</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">inner_func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
                <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="n">normalize_args</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
                <span class="n">dts</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_attach_tzinfo</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tzinfo</span><span class="p">)</span> <span class="k">for</span> <span class="n">dt</span> <span class="ow">in</span> <span class="n">dts</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">functools</span><span class="o">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)(</span><span class="n">inner_func</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>

        <span class="n">f</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_rrule</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">{</span><span class="s1">&#39;after&#39;</span><span class="p">,</span> <span class="s1">&#39;before&#39;</span><span class="p">}:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_aware_return_wrapper</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">{</span><span class="s1">&#39;xafter&#39;</span><span class="p">,</span> <span class="s1">&#39;xbefore&#39;</span><span class="p">,</span> <span class="s1">&#39;between&#39;</span><span class="p">}:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_aware_return_wrapper</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">returns_list</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">f</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">DateLocator</span><span class="p">(</span><span class="n">ticker</span><span class="o">.</span><span class="n">Locator</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Determines the tick locations when plotting dates.</span>

<span class="sd">    This class is subclassed by other Locators and</span>
<span class="sd">    is not meant to be used on its own.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">hms0d</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;byhour&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;byminute&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;bysecond&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">}</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tz</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        tz : str or `~datetime.tzinfo`, default: :rc:`timezone`</span>
<span class="sd">            Ticks timezone. If a string, *tz* is passed to `dateutil.tz`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tz</span> <span class="o">=</span> <span class="n">_get_tzinfo</span><span class="p">(</span><span class="n">tz</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">set_tzinfo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tz</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set timezone info.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        tz : str or `~datetime.tzinfo`, default: :rc:`timezone`</span>
<span class="sd">            Ticks timezone. If a string, *tz* is passed to `dateutil.tz`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tz</span> <span class="o">=</span> <span class="n">_get_tzinfo</span><span class="p">(</span><span class="n">tz</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">datalim_to_dt</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert axis data interval to datetime objects.&quot;&quot;&quot;</span>
        <span class="n">dmin</span><span class="p">,</span> <span class="n">dmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="o">.</span><span class="n">get_data_interval</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">dmin</span> <span class="o">&gt;</span> <span class="n">dmax</span><span class="p">:</span>
            <span class="n">dmin</span><span class="p">,</span> <span class="n">dmax</span> <span class="o">=</span> <span class="n">dmax</span><span class="p">,</span> <span class="n">dmin</span>

        <span class="k">return</span> <span class="n">num2date</span><span class="p">(</span><span class="n">dmin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tz</span><span class="p">),</span> <span class="n">num2date</span><span class="p">(</span><span class="n">dmax</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tz</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">viewlim_to_dt</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert the view interval to datetime objects.&quot;&quot;&quot;</span>
        <span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="o">.</span><span class="n">get_view_interval</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">vmin</span> <span class="o">&gt;</span> <span class="n">vmax</span><span class="p">:</span>
            <span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span> <span class="o">=</span> <span class="n">vmax</span><span class="p">,</span> <span class="n">vmin</span>
        <span class="k">return</span> <span class="n">num2date</span><span class="p">(</span><span class="n">vmin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tz</span><span class="p">),</span> <span class="n">num2date</span><span class="p">(</span><span class="n">vmax</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tz</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_unit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return how many days a unit of the locator is; used for</span>
<span class="sd">        intelligent autoscaling.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">_get_interval</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the number of units for each tick.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">nonsingular</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given the proposed upper and lower extent, adjust the range</span>
<span class="sd">        if it is too close to being singular (i.e. a range of ~0).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">vmin</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">vmax</span><span class="p">):</span>
            <span class="c1"># Except if there is no data, then use 1970 as default.</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">date2num</span><span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">date</span><span class="p">(</span><span class="mi">1970</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span>
                    <span class="n">date2num</span><span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">date</span><span class="p">(</span><span class="mi">1970</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)))</span>
        <span class="k">if</span> <span class="n">vmax</span> <span class="o">&lt;</span> <span class="n">vmin</span><span class="p">:</span>
            <span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span> <span class="o">=</span> <span class="n">vmax</span><span class="p">,</span> <span class="n">vmin</span>
        <span class="n">unit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_unit</span><span class="p">()</span>
        <span class="n">interval</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_interval</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">vmax</span> <span class="o">-</span> <span class="n">vmin</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-6</span><span class="p">:</span>
            <span class="n">vmin</span> <span class="o">-=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">unit</span> <span class="o">*</span> <span class="n">interval</span>
            <span class="n">vmax</span> <span class="o">+=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">unit</span> <span class="o">*</span> <span class="n">interval</span>
        <span class="k">return</span> <span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span>


<span class="k">class</span> <span class="nc">RRuleLocator</span><span class="p">(</span><span class="n">DateLocator</span><span class="p">):</span>
    <span class="c1"># use the dateutil rrule instance</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">tz</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">tz</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rule</span> <span class="o">=</span> <span class="n">o</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># if no data have been set, this will tank with a ValueError</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">dmin</span><span class="p">,</span> <span class="n">dmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">viewlim_to_dt</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tick_values</span><span class="p">(</span><span class="n">dmin</span><span class="p">,</span> <span class="n">dmax</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">tick_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="p">):</span>
        <span class="n">start</span><span class="p">,</span> <span class="n">stop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_rrule</span><span class="p">(</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="p">)</span>
        <span class="n">dates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rule</span><span class="o">.</span><span class="n">between</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dates</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">date2num</span><span class="p">([</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="p">])</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">raise_if_exceeds</span><span class="p">(</span><span class="n">date2num</span><span class="p">(</span><span class="n">dates</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_create_rrule</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="p">):</span>
        <span class="c1"># set appropriate rrule dtstart and until and return</span>
        <span class="c1"># start and end</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="n">relativedelta</span><span class="p">(</span><span class="n">vmax</span><span class="p">,</span> <span class="n">vmin</span><span class="p">)</span>

        <span class="c1"># We need to cap at the endpoints of valid datetime</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">vmin</span> <span class="o">-</span> <span class="n">delta</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="ne">OverflowError</span><span class="p">):</span>
            <span class="c1"># cap</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
                                      <span class="n">tzinfo</span><span class="o">=</span><span class="n">datetime</span><span class="o">.</span><span class="n">timezone</span><span class="o">.</span><span class="n">utc</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">stop</span> <span class="o">=</span> <span class="n">vmax</span> <span class="o">+</span> <span class="n">delta</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="ne">OverflowError</span><span class="p">):</span>
            <span class="c1"># cap</span>
            <span class="n">stop</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">(</span><span class="mi">9999</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="mi">59</span><span class="p">,</span> <span class="mi">59</span><span class="p">,</span>
                                     <span class="n">tzinfo</span><span class="o">=</span><span class="n">datetime</span><span class="o">.</span><span class="n">timezone</span><span class="o">.</span><span class="n">utc</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">rule</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">dtstart</span><span class="o">=</span><span class="n">start</span><span class="p">,</span> <span class="n">until</span><span class="o">=</span><span class="n">stop</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span>

    <span class="k">def</span> <span class="nf">_get_unit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># docstring inherited</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rule</span><span class="o">.</span><span class="n">_rrule</span><span class="o">.</span><span class="n">_freq</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_unit_generic</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">get_unit_generic</span><span class="p">(</span><span class="n">freq</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">freq</span> <span class="o">==</span> <span class="n">YEARLY</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">DAYS_PER_YEAR</span>
        <span class="k">elif</span> <span class="n">freq</span> <span class="o">==</span> <span class="n">MONTHLY</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">DAYS_PER_MONTH</span>
        <span class="k">elif</span> <span class="n">freq</span> <span class="o">==</span> <span class="n">WEEKLY</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">DAYS_PER_WEEK</span>
        <span class="k">elif</span> <span class="n">freq</span> <span class="o">==</span> <span class="n">DAILY</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">1.0</span>
        <span class="k">elif</span> <span class="n">freq</span> <span class="o">==</span> <span class="n">HOURLY</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">HOURS_PER_DAY</span>
        <span class="k">elif</span> <span class="n">freq</span> <span class="o">==</span> <span class="n">MINUTELY</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">MINUTES_PER_DAY</span>
        <span class="k">elif</span> <span class="n">freq</span> <span class="o">==</span> <span class="n">SECONDLY</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">SEC_PER_DAY</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># error</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>  <span class="c1"># or should this just return &#39;1&#39;?</span>

    <span class="k">def</span> <span class="nf">_get_interval</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rule</span><span class="o">.</span><span class="n">_rrule</span><span class="o">.</span><span class="n">_interval</span>


<span class="k">class</span> <span class="nc">AutoDateLocator</span><span class="p">(</span><span class="n">DateLocator</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    On autoscale, this class picks the best `DateLocator` to set the view</span>
<span class="sd">    limits and the tick locations.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    intervald : dict</span>

<span class="sd">        Mapping of tick frequencies to multiples allowed for that ticking.</span>
<span class="sd">        The default is ::</span>

<span class="sd">            self.intervald = {</span>
<span class="sd">                YEARLY  : [1, 2, 4, 5, 10, 20, 40, 50, 100, 200, 400, 500,</span>
<span class="sd">                           1000, 2000, 4000, 5000, 10000],</span>
<span class="sd">                MONTHLY : [1, 2, 3, 4, 6],</span>
<span class="sd">                DAILY   : [1, 2, 3, 7, 14, 21],</span>
<span class="sd">                HOURLY  : [1, 2, 3, 4, 6, 12],</span>
<span class="sd">                MINUTELY: [1, 5, 10, 15, 30],</span>
<span class="sd">                SECONDLY: [1, 5, 10, 15, 30],</span>
<span class="sd">                MICROSECONDLY: [1, 2, 5, 10, 20, 50, 100, 200, 500,</span>
<span class="sd">                                1000, 2000, 5000, 10000, 20000, 50000,</span>
<span class="sd">                                100000, 200000, 500000, 1000000],</span>
<span class="sd">            }</span>

<span class="sd">        where the keys are defined in `dateutil.rrule`.</span>

<span class="sd">        The interval is used to specify multiples that are appropriate for</span>
<span class="sd">        the frequency of ticking. For instance, every 7 days is sensible</span>
<span class="sd">        for daily ticks, but for minutes/seconds, 15 or 30 make sense.</span>

<span class="sd">        When customizing, you should only modify the values for the existing</span>
<span class="sd">        keys. You should not add or delete entries.</span>

<span class="sd">        Example for forcing ticks every 3 hours::</span>

<span class="sd">            locator = AutoDateLocator()</span>
<span class="sd">            locator.intervald[HOURLY] = [3]  # only show every 3 hours</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tz</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">minticks</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">maxticks</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">interval_multiples</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        tz : str or `~datetime.tzinfo`, default: :rc:`timezone`</span>
<span class="sd">            Ticks timezone. If a string, *tz* is passed to `dateutil.tz`.</span>
<span class="sd">        minticks : int</span>
<span class="sd">            The minimum number of ticks desired; controls whether ticks occur</span>
<span class="sd">            yearly, monthly, etc.</span>
<span class="sd">        maxticks : int</span>
<span class="sd">            The maximum number of ticks desired; controls the interval between</span>
<span class="sd">            ticks (ticking every other, every 3, etc.).  For fine-grained</span>
<span class="sd">            control, this can be a dictionary mapping individual rrule</span>
<span class="sd">            frequency constants (YEARLY, MONTHLY, etc.) to their own maximum</span>
<span class="sd">            number of ticks.  This can be used to keep the number of ticks</span>
<span class="sd">            appropriate to the format chosen in `AutoDateFormatter`. Any</span>
<span class="sd">            frequency not specified in this dictionary is given a default</span>
<span class="sd">            value.</span>
<span class="sd">        interval_multiples : bool, default: True</span>
<span class="sd">            Whether ticks should be chosen to be multiple of the interval,</span>
<span class="sd">            locking them to &#39;nicer&#39; locations.  For example, this will force</span>
<span class="sd">            the ticks to be at hours 0, 6, 12, 18 when hourly ticking is done</span>
<span class="sd">            at 6 hour intervals.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">tz</span><span class="o">=</span><span class="n">tz</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_freq</span> <span class="o">=</span> <span class="n">YEARLY</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_freqs</span> <span class="o">=</span> <span class="p">[</span><span class="n">YEARLY</span><span class="p">,</span> <span class="n">MONTHLY</span><span class="p">,</span> <span class="n">DAILY</span><span class="p">,</span> <span class="n">HOURLY</span><span class="p">,</span> <span class="n">MINUTELY</span><span class="p">,</span>
                       <span class="n">SECONDLY</span><span class="p">,</span> <span class="n">MICROSECONDLY</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">minticks</span> <span class="o">=</span> <span class="n">minticks</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">maxticks</span> <span class="o">=</span> <span class="p">{</span><span class="n">YEARLY</span><span class="p">:</span> <span class="mi">11</span><span class="p">,</span> <span class="n">MONTHLY</span><span class="p">:</span> <span class="mi">12</span><span class="p">,</span> <span class="n">DAILY</span><span class="p">:</span> <span class="mi">11</span><span class="p">,</span> <span class="n">HOURLY</span><span class="p">:</span> <span class="mi">12</span><span class="p">,</span>
                         <span class="n">MINUTELY</span><span class="p">:</span> <span class="mi">11</span><span class="p">,</span> <span class="n">SECONDLY</span><span class="p">:</span> <span class="mi">11</span><span class="p">,</span> <span class="n">MICROSECONDLY</span><span class="p">:</span> <span class="mi">8</span><span class="p">}</span>
        <span class="k">if</span> <span class="n">maxticks</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">maxticks</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">maxticks</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="c1"># Assume we were given an integer. Use this as the maximum</span>
                <span class="c1"># number of ticks for every frequency and create a</span>
                <span class="c1"># dictionary for this</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">maxticks</span> <span class="o">=</span> <span class="nb">dict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_freqs</span><span class="p">,</span> <span class="n">maxticks</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interval_multiples</span> <span class="o">=</span> <span class="n">interval_multiples</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">intervald</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">YEARLY</span><span class="p">:</span>   <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="mi">400</span><span class="p">,</span> <span class="mi">500</span><span class="p">,</span>
                       <span class="mi">1000</span><span class="p">,</span> <span class="mi">2000</span><span class="p">,</span> <span class="mi">4000</span><span class="p">,</span> <span class="mi">5000</span><span class="p">,</span> <span class="mi">10000</span><span class="p">],</span>
            <span class="n">MONTHLY</span><span class="p">:</span>  <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span>
            <span class="n">DAILY</span><span class="p">:</span>    <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">21</span><span class="p">],</span>
            <span class="n">HOURLY</span><span class="p">:</span>   <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">12</span><span class="p">],</span>
            <span class="n">MINUTELY</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">30</span><span class="p">],</span>
            <span class="n">SECONDLY</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">30</span><span class="p">],</span>
            <span class="n">MICROSECONDLY</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="mi">500</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="mi">2000</span><span class="p">,</span>
                            <span class="mi">5000</span><span class="p">,</span> <span class="mi">10000</span><span class="p">,</span> <span class="mi">20000</span><span class="p">,</span> <span class="mi">50000</span><span class="p">,</span> <span class="mi">100000</span><span class="p">,</span> <span class="mi">200000</span><span class="p">,</span> <span class="mi">500000</span><span class="p">,</span>
                            <span class="mi">1000000</span><span class="p">],</span>
                            <span class="p">}</span>
        <span class="k">if</span> <span class="n">interval_multiples</span><span class="p">:</span>
            <span class="c1"># Swap &quot;3&quot; for &quot;4&quot; in the DAILY list; If we use 3 we get bad</span>
            <span class="c1"># tick loc for months w/ 31 days: 1, 4, ..., 28, 31, 1</span>
            <span class="c1"># If we use 4 then we get: 1, 5, ... 25, 29, 1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">intervald</span><span class="p">[</span><span class="n">DAILY</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">14</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_byranges</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">13</span><span class="p">),</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">32</span><span class="p">),</span>
                          <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">24</span><span class="p">),</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">60</span><span class="p">),</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">60</span><span class="p">),</span> <span class="kc">None</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># docstring inherited</span>
        <span class="n">dmin</span><span class="p">,</span> <span class="n">dmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">viewlim_to_dt</span><span class="p">()</span>
        <span class="n">locator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_locator</span><span class="p">(</span><span class="n">dmin</span><span class="p">,</span> <span class="n">dmax</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">locator</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">tick_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_locator</span><span class="p">(</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="p">)</span><span class="o">.</span><span class="n">tick_values</span><span class="p">(</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">nonsingular</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="p">):</span>
        <span class="c1"># whatever is thrown at us, we can scale the unit.</span>
        <span class="c1"># But default nonsingular date plots at an ~4 year period.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">vmin</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">vmax</span><span class="p">):</span>
            <span class="c1"># Except if there is no data, then use 1970 as default.</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">date2num</span><span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">date</span><span class="p">(</span><span class="mi">1970</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span>
                    <span class="n">date2num</span><span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">date</span><span class="p">(</span><span class="mi">1970</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)))</span>
        <span class="k">if</span> <span class="n">vmax</span> <span class="o">&lt;</span> <span class="n">vmin</span><span class="p">:</span>
            <span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span> <span class="o">=</span> <span class="n">vmax</span><span class="p">,</span> <span class="n">vmin</span>
        <span class="k">if</span> <span class="n">vmin</span> <span class="o">==</span> <span class="n">vmax</span><span class="p">:</span>
            <span class="n">vmin</span> <span class="o">=</span> <span class="n">vmin</span> <span class="o">-</span> <span class="n">DAYS_PER_YEAR</span> <span class="o">*</span> <span class="mi">2</span>
            <span class="n">vmax</span> <span class="o">=</span> <span class="n">vmax</span> <span class="o">+</span> <span class="n">DAYS_PER_YEAR</span> <span class="o">*</span> <span class="mi">2</span>
        <span class="k">return</span> <span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span>

    <span class="k">def</span> <span class="nf">_get_unit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_freq</span> <span class="ow">in</span> <span class="p">[</span><span class="n">MICROSECONDLY</span><span class="p">]:</span>
            <span class="k">return</span> <span class="mf">1.</span> <span class="o">/</span> <span class="n">MUSECONDS_PER_DAY</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">RRuleLocator</span><span class="o">.</span><span class="n">get_unit_generic</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_freq</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_locator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dmin</span><span class="p">,</span> <span class="n">dmax</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Pick the best locator based on a distance.&quot;&quot;&quot;</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="n">relativedelta</span><span class="p">(</span><span class="n">dmax</span><span class="p">,</span> <span class="n">dmin</span><span class="p">)</span>
        <span class="n">tdelta</span> <span class="o">=</span> <span class="n">dmax</span> <span class="o">-</span> <span class="n">dmin</span>

        <span class="c1"># take absolute difference</span>
        <span class="k">if</span> <span class="n">dmin</span> <span class="o">&gt;</span> <span class="n">dmax</span><span class="p">:</span>
            <span class="n">delta</span> <span class="o">=</span> <span class="o">-</span><span class="n">delta</span>
            <span class="n">tdelta</span> <span class="o">=</span> <span class="o">-</span><span class="n">tdelta</span>
        <span class="c1"># The following uses a mix of calls to relativedelta and timedelta</span>
        <span class="c1"># methods because there is incomplete overlap in the functionality of</span>
        <span class="c1"># these similar functions, and it&#39;s best to avoid doing our own math</span>
        <span class="c1"># whenever possible.</span>
        <span class="n">numYears</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">delta</span><span class="o">.</span><span class="n">years</span><span class="p">)</span>
        <span class="n">numMonths</span> <span class="o">=</span> <span class="n">numYears</span> <span class="o">*</span> <span class="n">MONTHS_PER_YEAR</span> <span class="o">+</span> <span class="n">delta</span><span class="o">.</span><span class="n">months</span>
        <span class="n">numDays</span> <span class="o">=</span> <span class="n">tdelta</span><span class="o">.</span><span class="n">days</span>  <span class="c1"># Avoids estimates of days/month, days/year.</span>
        <span class="n">numHours</span> <span class="o">=</span> <span class="n">numDays</span> <span class="o">*</span> <span class="n">HOURS_PER_DAY</span> <span class="o">+</span> <span class="n">delta</span><span class="o">.</span><span class="n">hours</span>
        <span class="n">numMinutes</span> <span class="o">=</span> <span class="n">numHours</span> <span class="o">*</span> <span class="n">MIN_PER_HOUR</span> <span class="o">+</span> <span class="n">delta</span><span class="o">.</span><span class="n">minutes</span>
        <span class="n">numSeconds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">tdelta</span><span class="o">.</span><span class="n">total_seconds</span><span class="p">())</span>
        <span class="n">numMicroseconds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">tdelta</span><span class="o">.</span><span class="n">total_seconds</span><span class="p">()</span> <span class="o">*</span> <span class="mf">1e6</span><span class="p">)</span>

        <span class="n">nums</span> <span class="o">=</span> <span class="p">[</span><span class="n">numYears</span><span class="p">,</span> <span class="n">numMonths</span><span class="p">,</span> <span class="n">numDays</span><span class="p">,</span> <span class="n">numHours</span><span class="p">,</span> <span class="n">numMinutes</span><span class="p">,</span>
                <span class="n">numSeconds</span><span class="p">,</span> <span class="n">numMicroseconds</span><span class="p">]</span>

        <span class="n">use_rrule_locator</span> <span class="o">=</span> <span class="p">[</span><span class="kc">True</span><span class="p">]</span> <span class="o">*</span> <span class="mi">6</span> <span class="o">+</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span>

        <span class="c1"># Default setting of bymonth, etc. to pass to rrule</span>
        <span class="c1"># [unused (for year), bymonth, bymonthday, byhour, byminute,</span>
        <span class="c1">#  bysecond, unused (for microseconds)]</span>
        <span class="n">byranges</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>

        <span class="c1"># Loop over all the frequencies and try to find one that gives at</span>
        <span class="c1"># least a minticks tick positions.  Once this is found, look for</span>
        <span class="c1"># an interval from an list specific to that frequency that gives no</span>
        <span class="c1"># more than maxticks tick positions. Also, set up some ranges</span>
        <span class="c1"># (bymonth, etc.) as appropriate to be passed to rrulewrapper.</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">freq</span><span class="p">,</span> <span class="n">num</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_freqs</span><span class="p">,</span> <span class="n">nums</span><span class="p">)):</span>
            <span class="c1"># If this particular frequency doesn&#39;t give enough ticks, continue</span>
            <span class="k">if</span> <span class="n">num</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">minticks</span><span class="p">:</span>
                <span class="c1"># Since we&#39;re not using this particular frequency, set</span>
                <span class="c1"># the corresponding by_ to None so the rrule can act as</span>
                <span class="c1"># appropriate</span>
                <span class="n">byranges</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">continue</span>

            <span class="c1"># Find the first available interval that doesn&#39;t give too many</span>
            <span class="c1"># ticks</span>
            <span class="k">for</span> <span class="n">interval</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">intervald</span><span class="p">[</span><span class="n">freq</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">num</span> <span class="o">&lt;=</span> <span class="n">interval</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">maxticks</span><span class="p">[</span><span class="n">freq</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">interval_multiples</span> <span class="ow">and</span> <span class="n">freq</span> <span class="o">==</span> <span class="n">DAILY</span><span class="p">):</span>
                    <span class="n">_api</span><span class="o">.</span><span class="n">warn_external</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;AutoDateLocator was unable to pick an appropriate &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;interval for this date range. It may be necessary &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;to add an interval value to the AutoDateLocator&#39;s &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;intervald dictionary. Defaulting to </span><span class="si">{</span><span class="n">interval</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>

            <span class="c1"># Set some parameters as appropriate</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_freq</span> <span class="o">=</span> <span class="n">freq</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_byranges</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">interval_multiples</span><span class="p">:</span>
                <span class="n">byranges</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_byranges</span><span class="p">[</span><span class="n">i</span><span class="p">][::</span><span class="n">interval</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">(</span><span class="n">DAILY</span><span class="p">,</span> <span class="n">WEEKLY</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">interval</span> <span class="o">==</span> <span class="mi">14</span><span class="p">:</span>
                        <span class="c1"># just make first and 15th.  Avoids 30th.</span>
                        <span class="n">byranges</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">15</span><span class="p">]</span>
                    <span class="k">elif</span> <span class="n">interval</span> <span class="o">==</span> <span class="mi">7</span><span class="p">:</span>
                        <span class="n">byranges</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">22</span><span class="p">]</span>

                <span class="n">interval</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">byranges</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_byranges</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">interval</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">freq</span> <span class="o">==</span> <span class="n">YEARLY</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">interval_multiples</span><span class="p">:</span>
            <span class="n">locator</span> <span class="o">=</span> <span class="n">YearLocator</span><span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="n">tz</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tz</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">use_rrule_locator</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">bymonth</span><span class="p">,</span> <span class="n">bymonthday</span><span class="p">,</span> <span class="n">byhour</span><span class="p">,</span> <span class="n">byminute</span><span class="p">,</span> <span class="n">bysecond</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">byranges</span>
            <span class="n">rrule</span> <span class="o">=</span> <span class="n">rrulewrapper</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_freq</span><span class="p">,</span> <span class="n">interval</span><span class="o">=</span><span class="n">interval</span><span class="p">,</span>
                                 <span class="n">dtstart</span><span class="o">=</span><span class="n">dmin</span><span class="p">,</span> <span class="n">until</span><span class="o">=</span><span class="n">dmax</span><span class="p">,</span>
                                 <span class="n">bymonth</span><span class="o">=</span><span class="n">bymonth</span><span class="p">,</span> <span class="n">bymonthday</span><span class="o">=</span><span class="n">bymonthday</span><span class="p">,</span>
                                 <span class="n">byhour</span><span class="o">=</span><span class="n">byhour</span><span class="p">,</span> <span class="n">byminute</span><span class="o">=</span><span class="n">byminute</span><span class="p">,</span>
                                 <span class="n">bysecond</span><span class="o">=</span><span class="n">bysecond</span><span class="p">)</span>

            <span class="n">locator</span> <span class="o">=</span> <span class="n">RRuleLocator</span><span class="p">(</span><span class="n">rrule</span><span class="p">,</span> <span class="n">tz</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tz</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">locator</span> <span class="o">=</span> <span class="n">MicrosecondLocator</span><span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="n">tz</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tz</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">date2num</span><span class="p">(</span><span class="n">dmin</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">70</span> <span class="o">*</span> <span class="mi">365</span> <span class="ow">and</span> <span class="n">interval</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">:</span>
                <span class="n">_api</span><span class="o">.</span><span class="n">warn_external</span><span class="p">(</span>
                    <span class="s1">&#39;Plotting microsecond time intervals for dates far from &#39;</span>
                    <span class="sa">f</span><span class="s1">&#39;the epoch (time origin: </span><span class="si">{</span><span class="n">get_epoch</span><span class="p">()</span><span class="si">}</span><span class="s1">) is not well-&#39;</span>
                    <span class="s1">&#39;supported. See matplotlib.dates.set_epoch to change the &#39;</span>
                    <span class="s1">&#39;epoch.&#39;</span><span class="p">)</span>

        <span class="n">locator</span><span class="o">.</span><span class="n">set_axis</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">locator</span>


<span class="k">class</span> <span class="nc">YearLocator</span><span class="p">(</span><span class="n">RRuleLocator</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Make ticks on a given day of each year that is a multiple of base.</span>

<span class="sd">    Examples::</span>

<span class="sd">      # Tick every year on Jan 1st</span>
<span class="sd">      locator = YearLocator()</span>

<span class="sd">      # Tick every 5 years on July 4th</span>
<span class="sd">      locator = YearLocator(5, month=7, day=4)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">month</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">day</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">tz</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        base : int, default: 1</span>
<span class="sd">            Mark ticks every *base* years.</span>
<span class="sd">        month : int, default: 1</span>
<span class="sd">            The month on which to place the ticks, starting from 1. Default is</span>
<span class="sd">            January.</span>
<span class="sd">        day : int, default: 1</span>
<span class="sd">            The day on which to place the ticks.</span>
<span class="sd">        tz : str or `~datetime.tzinfo`, default: :rc:`timezone`</span>
<span class="sd">            Ticks timezone. If a string, *tz* is passed to `dateutil.tz`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rule</span> <span class="o">=</span> <span class="n">rrulewrapper</span><span class="p">(</span><span class="n">YEARLY</span><span class="p">,</span> <span class="n">interval</span><span class="o">=</span><span class="n">base</span><span class="p">,</span> <span class="n">bymonth</span><span class="o">=</span><span class="n">month</span><span class="p">,</span>
                            <span class="n">bymonthday</span><span class="o">=</span><span class="n">day</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">hms0d</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">rule</span><span class="p">,</span> <span class="n">tz</span><span class="o">=</span><span class="n">tz</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base</span> <span class="o">=</span> <span class="n">ticker</span><span class="o">.</span><span class="n">_Edge_integer</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_create_rrule</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="p">):</span>
        <span class="c1"># &#39;start&#39; needs to be a multiple of the interval to create ticks on</span>
        <span class="c1"># interval multiples when the tick frequency is YEARLY</span>
        <span class="n">ymin</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">le</span><span class="p">(</span><span class="n">vmin</span><span class="o">.</span><span class="n">year</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">step</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">ymax</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">ge</span><span class="p">(</span><span class="n">vmax</span><span class="o">.</span><span class="n">year</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">step</span><span class="p">,</span> <span class="mi">9999</span><span class="p">)</span>

        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rule</span><span class="o">.</span><span class="n">_construct</span>
        <span class="n">replace</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;year&#39;</span><span class="p">:</span> <span class="n">ymin</span><span class="p">,</span>
                   <span class="s1">&#39;month&#39;</span><span class="p">:</span> <span class="n">c</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;bymonth&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
                   <span class="s1">&#39;day&#39;</span><span class="p">:</span> <span class="n">c</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;bymonthday&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
                   <span class="s1">&#39;hour&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;minute&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;second&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">}</span>

        <span class="n">start</span> <span class="o">=</span> <span class="n">vmin</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="o">**</span><span class="n">replace</span><span class="p">)</span>
        <span class="n">stop</span> <span class="o">=</span> <span class="n">start</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">year</span><span class="o">=</span><span class="n">ymax</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rule</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">dtstart</span><span class="o">=</span><span class="n">start</span><span class="p">,</span> <span class="n">until</span><span class="o">=</span><span class="n">stop</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span>


<span class="k">class</span> <span class="nc">MonthLocator</span><span class="p">(</span><span class="n">RRuleLocator</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Make ticks on occurrences of each month, e.g., 1, 3, 12.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bymonth</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bymonthday</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">interval</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">tz</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        bymonth : int or list of int, default: all months</span>
<span class="sd">            Ticks will be placed on every month in *bymonth*. Default is</span>
<span class="sd">            ``range(1, 13)``, i.e. every month.</span>
<span class="sd">        bymonthday : int, default: 1</span>
<span class="sd">            The day on which to place the ticks.</span>
<span class="sd">        interval : int, default: 1</span>
<span class="sd">            The interval between each iteration. For example, if</span>
<span class="sd">            ``interval=2``, mark every second occurrence.</span>
<span class="sd">        tz : str or `~datetime.tzinfo`, default: :rc:`timezone`</span>
<span class="sd">            Ticks timezone. If a string, *tz* is passed to `dateutil.tz`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">bymonth</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">bymonth</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">13</span><span class="p">)</span>

        <span class="n">rule</span> <span class="o">=</span> <span class="n">rrulewrapper</span><span class="p">(</span><span class="n">MONTHLY</span><span class="p">,</span> <span class="n">bymonth</span><span class="o">=</span><span class="n">bymonth</span><span class="p">,</span> <span class="n">bymonthday</span><span class="o">=</span><span class="n">bymonthday</span><span class="p">,</span>
                            <span class="n">interval</span><span class="o">=</span><span class="n">interval</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">hms0d</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">rule</span><span class="p">,</span> <span class="n">tz</span><span class="o">=</span><span class="n">tz</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">WeekdayLocator</span><span class="p">(</span><span class="n">RRuleLocator</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Make ticks on occurrences of each weekday.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">byweekday</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">interval</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">tz</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        byweekday : int or list of int, default: all days</span>
<span class="sd">            Ticks will be placed on every weekday in *byweekday*. Default is</span>
<span class="sd">            every day.</span>

<span class="sd">            Elements of *byweekday* must be one of MO, TU, WE, TH, FR, SA,</span>
<span class="sd">            SU, the constants from :mod:`dateutil.rrule`, which have been</span>
<span class="sd">            imported into the :mod:`matplotlib.dates` namespace.</span>
<span class="sd">        interval : int, default: 1</span>
<span class="sd">            The interval between each iteration. For example, if</span>
<span class="sd">            ``interval=2``, mark every second occurrence.</span>
<span class="sd">        tz : str or `~datetime.tzinfo`, default: :rc:`timezone`</span>
<span class="sd">            Ticks timezone. If a string, *tz* is passed to `dateutil.tz`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rule</span> <span class="o">=</span> <span class="n">rrulewrapper</span><span class="p">(</span><span class="n">DAILY</span><span class="p">,</span> <span class="n">byweekday</span><span class="o">=</span><span class="n">byweekday</span><span class="p">,</span>
                            <span class="n">interval</span><span class="o">=</span><span class="n">interval</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">hms0d</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">rule</span><span class="p">,</span> <span class="n">tz</span><span class="o">=</span><span class="n">tz</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">DayLocator</span><span class="p">(</span><span class="n">RRuleLocator</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Make ticks on occurrences of each day of the month.  For example,</span>
<span class="sd">    1, 15, 30.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bymonthday</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">interval</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">tz</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        bymonthday : int or list of int, default: all days</span>
<span class="sd">            Ticks will be placed on every day in *bymonthday*. Default is</span>
<span class="sd">            ``bymonthday=range(1, 32)``, i.e., every day of the month.</span>
<span class="sd">        interval : int, default: 1</span>
<span class="sd">            The interval between each iteration. For example, if</span>
<span class="sd">            ``interval=2``, mark every second occurrence.</span>
<span class="sd">        tz : str or `~datetime.tzinfo`, default: :rc:`timezone`</span>
<span class="sd">            Ticks timezone. If a string, *tz* is passed to `dateutil.tz`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">interval</span> <span class="o">!=</span> <span class="nb">int</span><span class="p">(</span><span class="n">interval</span><span class="p">)</span> <span class="ow">or</span> <span class="n">interval</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;interval must be an integer greater than 0&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">bymonthday</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">bymonthday</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>

        <span class="n">rule</span> <span class="o">=</span> <span class="n">rrulewrapper</span><span class="p">(</span><span class="n">DAILY</span><span class="p">,</span> <span class="n">bymonthday</span><span class="o">=</span><span class="n">bymonthday</span><span class="p">,</span>
                            <span class="n">interval</span><span class="o">=</span><span class="n">interval</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">hms0d</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">rule</span><span class="p">,</span> <span class="n">tz</span><span class="o">=</span><span class="n">tz</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">HourLocator</span><span class="p">(</span><span class="n">RRuleLocator</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Make ticks on occurrences of each hour.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">byhour</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">interval</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">tz</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        byhour : int or list of int, default: all hours</span>
<span class="sd">            Ticks will be placed on every hour in *byhour*. Default is</span>
<span class="sd">            ``byhour=range(24)``, i.e., every hour.</span>
<span class="sd">        interval : int, default: 1</span>
<span class="sd">            The interval between each iteration. For example, if</span>
<span class="sd">            ``interval=2``, mark every second occurrence.</span>
<span class="sd">        tz : str or `~datetime.tzinfo`, default: :rc:`timezone`</span>
<span class="sd">            Ticks timezone. If a string, *tz* is passed to `dateutil.tz`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">byhour</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">byhour</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span>

        <span class="n">rule</span> <span class="o">=</span> <span class="n">rrulewrapper</span><span class="p">(</span><span class="n">HOURLY</span><span class="p">,</span> <span class="n">byhour</span><span class="o">=</span><span class="n">byhour</span><span class="p">,</span> <span class="n">interval</span><span class="o">=</span><span class="n">interval</span><span class="p">,</span>
                            <span class="n">byminute</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">bysecond</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">rule</span><span class="p">,</span> <span class="n">tz</span><span class="o">=</span><span class="n">tz</span><span class="p">)</span>


<div class="viewcode-block" id="MinuteLocator">
<a class="viewcode-back" href="../../_autosummary/pipeline.hsd.tasks.common.display.MinuteLocator.html#pipeline.hsd.tasks.common.display.MinuteLocator">[docs]</a>
<span class="k">class</span> <span class="nc">MinuteLocator</span><span class="p">(</span><span class="n">RRuleLocator</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Make ticks on occurrences of each minute.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">byminute</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">interval</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">tz</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        byminute : int or list of int, default: all minutes</span>
<span class="sd">            Ticks will be placed on every minutes in *byminutes*. Default is</span>
<span class="sd">            ``byminute=range(60)``, i.e., every minute.</span>
<span class="sd">        interval : int, default: 1</span>
<span class="sd">            The interval between each iteration. For example, if</span>
<span class="sd">            ``interval=2``, mark every second occurrence.</span>
<span class="sd">        tz : str or `~datetime.tzinfo`, default: :rc:`timezone`</span>
<span class="sd">            Ticks timezone. If a string, *tz* is passed to `dateutil.tz`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">byminute</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">byminute</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">60</span><span class="p">)</span>

        <span class="n">rule</span> <span class="o">=</span> <span class="n">rrulewrapper</span><span class="p">(</span><span class="n">MINUTELY</span><span class="p">,</span> <span class="n">byminute</span><span class="o">=</span><span class="n">byminute</span><span class="p">,</span> <span class="n">interval</span><span class="o">=</span><span class="n">interval</span><span class="p">,</span>
                            <span class="n">bysecond</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">rule</span><span class="p">,</span> <span class="n">tz</span><span class="o">=</span><span class="n">tz</span><span class="p">)</span></div>



<span class="k">class</span> <span class="nc">SecondLocator</span><span class="p">(</span><span class="n">RRuleLocator</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Make ticks on occurrences of each second.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bysecond</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">interval</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">tz</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        bysecond : int or list of int, default: all seconds</span>
<span class="sd">            Ticks will be placed on every second in *bysecond*. Default is</span>
<span class="sd">            ``bysecond = range(60)``, i.e., every second.</span>
<span class="sd">        interval : int, default: 1</span>
<span class="sd">            The interval between each iteration. For example, if</span>
<span class="sd">            ``interval=2``, mark every second occurrence.</span>
<span class="sd">        tz : str or `~datetime.tzinfo`, default: :rc:`timezone`</span>
<span class="sd">            Ticks timezone. If a string, *tz* is passed to `dateutil.tz`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">bysecond</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">bysecond</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">60</span><span class="p">)</span>

        <span class="n">rule</span> <span class="o">=</span> <span class="n">rrulewrapper</span><span class="p">(</span><span class="n">SECONDLY</span><span class="p">,</span> <span class="n">bysecond</span><span class="o">=</span><span class="n">bysecond</span><span class="p">,</span> <span class="n">interval</span><span class="o">=</span><span class="n">interval</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">rule</span><span class="p">,</span> <span class="n">tz</span><span class="o">=</span><span class="n">tz</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">MicrosecondLocator</span><span class="p">(</span><span class="n">DateLocator</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Make ticks on regular intervals of one or more microsecond(s).</span>

<span class="sd">    .. note::</span>

<span class="sd">        By default, Matplotlib uses a floating point representation of time in</span>
<span class="sd">        days since the epoch, so plotting data with</span>
<span class="sd">        microsecond time resolution does not work well for</span>
<span class="sd">        dates that are far (about 70 years) from the epoch (check with</span>
<span class="sd">        `~.dates.get_epoch`).</span>

<span class="sd">        If you want sub-microsecond resolution time plots, it is strongly</span>
<span class="sd">        recommended to use floating point seconds, not datetime-like</span>
<span class="sd">        time representation.</span>

<span class="sd">        If you really must use datetime.datetime() or similar and still</span>
<span class="sd">        need microsecond precision, change the time origin via</span>
<span class="sd">        `.dates.set_epoch` to something closer to the dates being plotted.</span>
<span class="sd">        See :doc:`/gallery/ticks/date_precision_and_epochs`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">interval</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">tz</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        interval : int, default: 1</span>
<span class="sd">            The interval between each iteration. For example, if</span>
<span class="sd">            ``interval=2``, mark every second occurrence.</span>
<span class="sd">        tz : str or `~datetime.tzinfo`, default: :rc:`timezone`</span>
<span class="sd">            Ticks timezone. If a string, *tz* is passed to `dateutil.tz`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">tz</span><span class="o">=</span><span class="n">tz</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_interval</span> <span class="o">=</span> <span class="n">interval</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_wrapped_locator</span> <span class="o">=</span> <span class="n">ticker</span><span class="o">.</span><span class="n">MultipleLocator</span><span class="p">(</span><span class="n">interval</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">set_axis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_wrapped_locator</span><span class="o">.</span><span class="n">set_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">set_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

    <span class="nd">@_api</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span><span class="s2">&quot;3.5&quot;</span><span class="p">,</span> <span class="n">alternative</span><span class="o">=</span><span class="s2">&quot;`.Axis.set_view_interval`&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">set_view_interval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_wrapped_locator</span><span class="o">.</span><span class="n">set_view_interval</span><span class="p">(</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">set_view_interval</span><span class="p">(</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="p">)</span>

    <span class="nd">@_api</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span><span class="s2">&quot;3.5&quot;</span><span class="p">,</span> <span class="n">alternative</span><span class="o">=</span><span class="s2">&quot;`.Axis.set_data_interval`&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">set_data_interval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_wrapped_locator</span><span class="o">.</span><span class="n">set_data_interval</span><span class="p">(</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">set_data_interval</span><span class="p">(</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># if no data have been set, this will tank with a ValueError</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">dmin</span><span class="p">,</span> <span class="n">dmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">viewlim_to_dt</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tick_values</span><span class="p">(</span><span class="n">dmin</span><span class="p">,</span> <span class="n">dmax</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">tick_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="p">):</span>
        <span class="n">nmin</span><span class="p">,</span> <span class="n">nmax</span> <span class="o">=</span> <span class="n">date2num</span><span class="p">((</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="p">))</span>
        <span class="n">t0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">nmin</span><span class="p">)</span>
        <span class="n">nmax</span> <span class="o">=</span> <span class="n">nmax</span> <span class="o">-</span> <span class="n">t0</span>
        <span class="n">nmin</span> <span class="o">=</span> <span class="n">nmin</span> <span class="o">-</span> <span class="n">t0</span>
        <span class="n">nmin</span> <span class="o">*=</span> <span class="n">MUSECONDS_PER_DAY</span>
        <span class="n">nmax</span> <span class="o">*=</span> <span class="n">MUSECONDS_PER_DAY</span>

        <span class="n">ticks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrapped_locator</span><span class="o">.</span><span class="n">tick_values</span><span class="p">(</span><span class="n">nmin</span><span class="p">,</span> <span class="n">nmax</span><span class="p">)</span>

        <span class="n">ticks</span> <span class="o">=</span> <span class="n">ticks</span> <span class="o">/</span> <span class="n">MUSECONDS_PER_DAY</span> <span class="o">+</span> <span class="n">t0</span>
        <span class="k">return</span> <span class="n">ticks</span>

    <span class="k">def</span> <span class="nf">_get_unit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># docstring inherited</span>
        <span class="k">return</span> <span class="mf">1.</span> <span class="o">/</span> <span class="n">MUSECONDS_PER_DAY</span>

    <span class="k">def</span> <span class="nf">_get_interval</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># docstring inherited</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interval</span>


<span class="nd">@_api</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span>
    <span class="s2">&quot;3.5&quot;</span><span class="p">,</span>
    <span class="n">alternative</span><span class="o">=</span><span class="s2">&quot;``[date2num(datetime.utcfromtimestamp(t)) for t in e]`` or &quot;</span>
                <span class="s2">&quot;numpy.datetime64 types&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">epoch2num</span><span class="p">(</span><span class="n">e</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert UNIX time to days since Matplotlib epoch.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    e : list of floats</span>
<span class="sd">        Time in seconds since 1970-01-01.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    `numpy.array`</span>
<span class="sd">        Time in days since Matplotlib epoch (see `~.dates.get_epoch()`).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">dt</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="s1">&#39;1970-01-01T00:00:00&#39;</span><span class="p">,</span> <span class="s1">&#39;s&#39;</span><span class="p">)</span> <span class="o">-</span>
          <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="n">get_epoch</span><span class="p">(),</span> <span class="s1">&#39;s&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">dt</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">e</span><span class="p">))</span> <span class="o">/</span> <span class="n">SEC_PER_DAY</span>


<span class="nd">@_api</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span><span class="s2">&quot;3.5&quot;</span><span class="p">,</span> <span class="n">alternative</span><span class="o">=</span><span class="s2">&quot;`num2date(e).timestamp()&lt;.num2date&gt;`&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">num2epoch</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert days since Matplotlib epoch to UNIX time.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    d : list of floats</span>
<span class="sd">        Time in days since Matplotlib epoch (see `~.dates.get_epoch()`).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    `numpy.array`</span>
<span class="sd">        Time in seconds since 1970-01-01.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="s1">&#39;1970-01-01T00:00:00&#39;</span><span class="p">,</span> <span class="s1">&#39;s&#39;</span><span class="p">)</span> <span class="o">-</span>
          <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="n">get_epoch</span><span class="p">(),</span> <span class="s1">&#39;s&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">*</span> <span class="n">SEC_PER_DAY</span> <span class="o">-</span> <span class="n">dt</span>


<span class="nd">@_api</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span><span class="s2">&quot;3.6&quot;</span><span class="p">,</span> <span class="n">alternative</span><span class="o">=</span><span class="s2">&quot;`AutoDateLocator` and `AutoDateFormatter`&quot;</span>
                 <span class="s2">&quot; or vendor the code&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">date_ticker_factory</span><span class="p">(</span><span class="n">span</span><span class="p">,</span> <span class="n">tz</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">numticks</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a date locator with *numticks* (approx) and a date formatter</span>
<span class="sd">    for *span* in days.  Return value is (locator, formatter).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">span</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">span</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">HOURS_PER_DAY</span>

    <span class="n">mins</span> <span class="o">=</span> <span class="n">span</span> <span class="o">*</span> <span class="n">MINUTES_PER_DAY</span>
    <span class="n">hrs</span> <span class="o">=</span> <span class="n">span</span> <span class="o">*</span> <span class="n">HOURS_PER_DAY</span>
    <span class="n">days</span> <span class="o">=</span> <span class="n">span</span>
    <span class="n">wks</span> <span class="o">=</span> <span class="n">span</span> <span class="o">/</span> <span class="n">DAYS_PER_WEEK</span>
    <span class="n">months</span> <span class="o">=</span> <span class="n">span</span> <span class="o">/</span> <span class="n">DAYS_PER_MONTH</span>      <span class="c1"># Approx</span>
    <span class="n">years</span> <span class="o">=</span> <span class="n">span</span> <span class="o">/</span> <span class="n">DAYS_PER_YEAR</span>        <span class="c1"># Approx</span>

    <span class="k">if</span> <span class="n">years</span> <span class="o">&gt;</span> <span class="n">numticks</span><span class="p">:</span>
        <span class="n">locator</span> <span class="o">=</span> <span class="n">YearLocator</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">years</span> <span class="o">/</span> <span class="n">numticks</span><span class="p">),</span> <span class="n">tz</span><span class="o">=</span><span class="n">tz</span><span class="p">)</span>  <span class="c1"># define</span>
        <span class="n">fmt</span> <span class="o">=</span> <span class="s1">&#39;%Y&#39;</span>
    <span class="k">elif</span> <span class="n">months</span> <span class="o">&gt;</span> <span class="n">numticks</span><span class="p">:</span>
        <span class="n">locator</span> <span class="o">=</span> <span class="n">MonthLocator</span><span class="p">(</span><span class="n">tz</span><span class="o">=</span><span class="n">tz</span><span class="p">)</span>
        <span class="n">fmt</span> <span class="o">=</span> <span class="s1">&#39;%b %Y&#39;</span>
    <span class="k">elif</span> <span class="n">wks</span> <span class="o">&gt;</span> <span class="n">numticks</span><span class="p">:</span>
        <span class="n">locator</span> <span class="o">=</span> <span class="n">WeekdayLocator</span><span class="p">(</span><span class="n">tz</span><span class="o">=</span><span class="n">tz</span><span class="p">)</span>
        <span class="n">fmt</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%a</span><span class="s1">, %b </span><span class="si">%d</span><span class="s1">&#39;</span>
    <span class="k">elif</span> <span class="n">days</span> <span class="o">&gt;</span> <span class="n">numticks</span><span class="p">:</span>
        <span class="n">locator</span> <span class="o">=</span> <span class="n">DayLocator</span><span class="p">(</span><span class="n">interval</span><span class="o">=</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">days</span> <span class="o">/</span> <span class="n">numticks</span><span class="p">),</span> <span class="n">tz</span><span class="o">=</span><span class="n">tz</span><span class="p">)</span>
        <span class="n">fmt</span> <span class="o">=</span> <span class="s1">&#39;%b </span><span class="si">%d</span><span class="s1">&#39;</span>
    <span class="k">elif</span> <span class="n">hrs</span> <span class="o">&gt;</span> <span class="n">numticks</span><span class="p">:</span>
        <span class="n">locator</span> <span class="o">=</span> <span class="n">HourLocator</span><span class="p">(</span><span class="n">interval</span><span class="o">=</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">hrs</span> <span class="o">/</span> <span class="n">numticks</span><span class="p">),</span> <span class="n">tz</span><span class="o">=</span><span class="n">tz</span><span class="p">)</span>
        <span class="n">fmt</span> <span class="o">=</span> <span class="s1">&#39;%H:%M</span><span class="se">\n</span><span class="s1">%b </span><span class="si">%d</span><span class="s1">&#39;</span>
    <span class="k">elif</span> <span class="n">mins</span> <span class="o">&gt;</span> <span class="n">numticks</span><span class="p">:</span>
        <span class="n">locator</span> <span class="o">=</span> <span class="n">MinuteLocator</span><span class="p">(</span><span class="n">interval</span><span class="o">=</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">mins</span> <span class="o">/</span> <span class="n">numticks</span><span class="p">),</span> <span class="n">tz</span><span class="o">=</span><span class="n">tz</span><span class="p">)</span>
        <span class="n">fmt</span> <span class="o">=</span> <span class="s1">&#39;%H:%M:%S&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">locator</span> <span class="o">=</span> <span class="n">MinuteLocator</span><span class="p">(</span><span class="n">tz</span><span class="o">=</span><span class="n">tz</span><span class="p">)</span>
        <span class="n">fmt</span> <span class="o">=</span> <span class="s1">&#39;%H:%M:%S&#39;</span>

    <span class="n">formatter</span> <span class="o">=</span> <span class="n">DateFormatter</span><span class="p">(</span><span class="n">fmt</span><span class="p">,</span> <span class="n">tz</span><span class="o">=</span><span class="n">tz</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">locator</span><span class="p">,</span> <span class="n">formatter</span>


<span class="k">class</span> <span class="nc">DateConverter</span><span class="p">(</span><span class="n">units</span><span class="o">.</span><span class="n">ConversionInterface</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Converter for `datetime.date` and `datetime.datetime` data, or for</span>
<span class="sd">    date/time data represented as it would be converted by `date2num`.</span>

<span class="sd">    The &#39;unit&#39; tag for such data is None or a tzinfo instance.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">interval_multiples</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_interval_multiples</span> <span class="o">=</span> <span class="n">interval_multiples</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">axisinfo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unit</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the `~matplotlib.units.AxisInfo` for *unit*.</span>

<span class="sd">        *unit* is a tzinfo instance or None.</span>
<span class="sd">        The *axis* argument is required but not used.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tz</span> <span class="o">=</span> <span class="n">unit</span>

        <span class="n">majloc</span> <span class="o">=</span> <span class="n">AutoDateLocator</span><span class="p">(</span><span class="n">tz</span><span class="o">=</span><span class="n">tz</span><span class="p">,</span>
                                 <span class="n">interval_multiples</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_interval_multiples</span><span class="p">)</span>
        <span class="n">majfmt</span> <span class="o">=</span> <span class="n">AutoDateFormatter</span><span class="p">(</span><span class="n">majloc</span><span class="p">,</span> <span class="n">tz</span><span class="o">=</span><span class="n">tz</span><span class="p">)</span>
        <span class="n">datemin</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">date</span><span class="p">(</span><span class="mi">1970</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">datemax</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">date</span><span class="p">(</span><span class="mi">1970</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">units</span><span class="o">.</span><span class="n">AxisInfo</span><span class="p">(</span><span class="n">majloc</span><span class="o">=</span><span class="n">majloc</span><span class="p">,</span> <span class="n">majfmt</span><span class="o">=</span><span class="n">majfmt</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span>
                              <span class="n">default_limits</span><span class="o">=</span><span class="p">(</span><span class="n">datemin</span><span class="p">,</span> <span class="n">datemax</span><span class="p">))</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">convert</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">unit</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        If *value* is not already a number or sequence of numbers, convert it</span>
<span class="sd">        with `date2num`.</span>

<span class="sd">        The *unit* and *axis* arguments are not used.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">date2num</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">default_units</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the tzinfo instance of *x* or of its first element, or None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">cbook</span><span class="o">.</span><span class="n">_safe_first_finite</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">StopIteration</span><span class="p">):</span>
            <span class="k">pass</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">tzinfo</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">return</span> <span class="kc">None</span>


<span class="k">class</span> <span class="nc">ConciseDateConverter</span><span class="p">(</span><span class="n">DateConverter</span><span class="p">):</span>
    <span class="c1"># docstring inherited</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">formats</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">zero_formats</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">offset_formats</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">show_offset</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">interval_multiples</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_formats</span> <span class="o">=</span> <span class="n">formats</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_zero_formats</span> <span class="o">=</span> <span class="n">zero_formats</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_offset_formats</span> <span class="o">=</span> <span class="n">offset_formats</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_show_offset</span> <span class="o">=</span> <span class="n">show_offset</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_interval_multiples</span> <span class="o">=</span> <span class="n">interval_multiples</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">axisinfo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unit</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
        <span class="c1"># docstring inherited</span>
        <span class="n">tz</span> <span class="o">=</span> <span class="n">unit</span>
        <span class="n">majloc</span> <span class="o">=</span> <span class="n">AutoDateLocator</span><span class="p">(</span><span class="n">tz</span><span class="o">=</span><span class="n">tz</span><span class="p">,</span>
                                 <span class="n">interval_multiples</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_interval_multiples</span><span class="p">)</span>
        <span class="n">majfmt</span> <span class="o">=</span> <span class="n">ConciseDateFormatter</span><span class="p">(</span><span class="n">majloc</span><span class="p">,</span> <span class="n">tz</span><span class="o">=</span><span class="n">tz</span><span class="p">,</span> <span class="n">formats</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_formats</span><span class="p">,</span>
                                      <span class="n">zero_formats</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_zero_formats</span><span class="p">,</span>
                                      <span class="n">offset_formats</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_offset_formats</span><span class="p">,</span>
                                      <span class="n">show_offset</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_show_offset</span><span class="p">)</span>
        <span class="n">datemin</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">date</span><span class="p">(</span><span class="mi">1970</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">datemax</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">date</span><span class="p">(</span><span class="mi">1970</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">units</span><span class="o">.</span><span class="n">AxisInfo</span><span class="p">(</span><span class="n">majloc</span><span class="o">=</span><span class="n">majloc</span><span class="p">,</span> <span class="n">majfmt</span><span class="o">=</span><span class="n">majfmt</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span>
                              <span class="n">default_limits</span><span class="o">=</span><span class="p">(</span><span class="n">datemin</span><span class="p">,</span> <span class="n">datemax</span><span class="p">))</span>


<span class="k">class</span> <span class="nc">_SwitchableDateConverter</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Helper converter-like object that generates and dispatches to</span>
<span class="sd">    temporary ConciseDateConverter or DateConverter instances based on</span>
<span class="sd">    :rc:`date.converter` and :rc:`date.interval_multiples`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_get_converter</span><span class="p">():</span>
        <span class="n">converter_cls</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;concise&quot;</span><span class="p">:</span> <span class="n">ConciseDateConverter</span><span class="p">,</span> <span class="s2">&quot;auto&quot;</span><span class="p">:</span> <span class="n">DateConverter</span><span class="p">}[</span>
                <span class="n">mpl</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s2">&quot;date.converter&quot;</span><span class="p">]]</span>
        <span class="n">interval_multiples</span> <span class="o">=</span> <span class="n">mpl</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s2">&quot;date.interval_multiples&quot;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">converter_cls</span><span class="p">(</span><span class="n">interval_multiples</span><span class="o">=</span><span class="n">interval_multiples</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">axisinfo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_converter</span><span class="p">()</span><span class="o">.</span><span class="n">axisinfo</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">default_units</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_converter</span><span class="p">()</span><span class="o">.</span><span class="n">default_units</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">convert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_converter</span><span class="p">()</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<span class="n">units</span><span class="o">.</span><span class="n">registry</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">]</span> <span class="o">=</span> \
    <span class="n">units</span><span class="o">.</span><span class="n">registry</span><span class="p">[</span><span class="n">datetime</span><span class="o">.</span><span class="n">date</span><span class="p">]</span> <span class="o">=</span> \
    <span class="n">units</span><span class="o">.</span><span class="n">registry</span><span class="p">[</span><span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">]</span> <span class="o">=</span> \
    <span class="n">_SwitchableDateConverter</span><span class="p">()</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020–2024, Pipeline Dev. Team.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>