'''
The qaadapter module holds classes that regroup the results list, ordered by
stage number, into a structure ordered by task type. This regrouping is used
by the QA sections of the weblog.
'''
import collections
import json
import os

import pipeline.infrastructure as infrastructure
import pipeline.infrastructure.renderer.logger as logger
import pipeline.hif.tasks.bandpass as bandpass
import pipeline.hif.tasks.gaincal as gaincal
#import pipeline.hifa.tasks.wvrgcal as wvrgcal
import pipeline.hifa.tasks.wvrgcalflag as wvrgcalflag

LOG = infrastructure.get_logger(__name__)



class QASection(object):    
    """
    QASection is the base class for a QA weblog section. It should not be 
    instantiated directly.    
    """
    # text shown in weblog describing this QA summary section 
    description = 'Generic QA Section'
    
    # filename pointing to the more detailed T2-3-X sections for this QA
    # grouping
    url = ''

    # a dictionary holding the mapping of results class to description. This
    # should be overridden by the subclass
    result_descriptions = {}

    def __init__(self, results):
        """
        Construct a new QASection, allocating Results to the appropriate task
        type based on the mapping help in result_descriptions.
    
        :param results: the results
        :type results: a list of :class:`~pipeline.infrastructure.api.Result`
        """
        # Within each QA section, results must be gathered together by type,
        # eg. all bandpass tasks under a 'Bandpass' heading). This is 
        # accomplished with the results_by_type dictionary, keyed by results
        # class and with the matching results objects as values, eg.
        # results_by_type[BandpassResults] = [bpresult1, bpresult2]
        self.results_by_type = collections.defaultdict(list)

        # the keys of the results_descriptions dictionary holds the results
        # classes we should include in this section
        results_classes = self.result_descriptions.keys()
         
        # collect each results node matching a recognised class for this
        # section, adding it to the list held as the dictionary value
        in_section = [r for r in results if r.__class__ in results_classes]
        for result in in_section:
            self.results_by_type[result.__class__].append(result)
            
        
class CalibrationQASection(QASection):
    """
    CalibrationQASection collects together those results generated by
    calibration tasks.
    """
    
    description = 'Calibration'
    url = 't2-3-1m.html'
 
    LOG.todo('Re-enable QA output in CalibrationQASection')
    result_descriptions = {
#        bandpass.common.BandpassResults         : 'Bandpass',
#        gaincal.common.GaincalResults           : 'Gain',
        wvrgcalflag.resultobjects.WvrgcalflagResult : 'WVR Calibration'
    }
    
    def __init__(self, results):
        super(CalibrationQASection, self).__init__(results)

        
class LineFindingQASection(QASection):
    """
    LineFindingQASection collects together those results generated by
    line-finding tasks.
    """
    description = 'Line finding'
    url = 't2-3-2m.html'
    
    def __init__(self, results):
        super(LineFindingQASection, self).__init__(results)


class FlaggingQASection(QASection):
    """
    FlaggingQASection collects together those results generated by flagging
    tasks.
    """
    description = 'Flagging'
    url = 't2-3-3m.html'

    result_descriptions = {
        wvrgcalflag.resultobjects.WvrgcalflagResult : 'WVR Flagging',
    }

    def __init__(self, results):
        super(FlaggingQASection, self).__init__(results)


class ImagingQASection(QASection):
    """
    ImagingQASection collects together those results generated by imaging
    tasks.
    """
    description = 'Imaging'
    url = 't2-3-4m.html'
    
    def __init__(self, results):
        super(ImagingQASection, self).__init__(results)

        
class ResultsToQAAdapter(object):
    """
    ResultsToQAAdapter is a wrapper providing a QA perspective of a results
    list. It converts the results list, ordered by stage number, into a set of
    sections (QASections) grouped by QA type.
    """
    
    # holds the QASections into which we should push the results 
    section_classes = [CalibrationQASection,
                       LineFindingQASection,
                       FlaggingQASection,
                       ImagingQASection     ]
    
    def __init__(self, results):
        """
        Construct a new ResultsToQAAdapter, allocating Results to the
        appropriate QA sections.  
    
        :param results: the results
        :type results: a list of :class:`~pipeline.infrastructure.api.Result`
        """
        self.sections = collections.defaultdict(list)

        for cls in self.section_classes:
            self.sections[cls] = cls(results)


def get_url(result):
    """
    Get the URL of the QA section appropriate to the given result.

    :param result: the task result
    :type result: :class:`~pipeline.infrastructure.api.Result`
    :rtype: the filename of the appropriate QA section
    """
    result_cls = result.__class__

    for section_cls in ResultsToQAAdapter.section_classes:
        if result_cls in section_cls.result_descriptions.keys():
            return section_cls.url
    return None


QAScore = collections.namedtuple('Score', 'phase amplitude total')
PhaseScore = collections.namedtuple('PhaseScore', 'delay rms flag total')
AmplitudeScore = collections.namedtuple('AmplitudeScore', 'rms total sn flag')                                     
FlaggedFeed = collections.namedtuple('FlaggedFeed', 'antenna polarization')


class QABaseAdapter(object):
    def __init__(self, context, result):
        if not getattr(result, 'qa', None):
            return

        self._context = context
        self._result = result
        self._qa = result.qa

        vis = self._result.inputs['vis']
        self._ms = self._context.observing_run.get_ms(vis)
        self._write_json(context, result)

    def _write_json(self, context, result):
        json_file = os.path.join(context.report_dir, 
                                 'stage%s' % result.stage_number, 
                                 'qa.json')
        
        LOG.trace('Writing QA data to %s' % json_file)
        with open(json_file, 'w') as fp:
            json.dump(self.scores, fp)

 
class QAFlaggingAdapter(QABaseAdapter):
    Axes = collections.namedtuple('Axes', "x y")
    
    def __init__(self, context, result):
        super(QAFlaggingAdapter, self).__init__(context, result)
        self.scores = {}
        
        self.unscored_plots = self._get_unscored_plots()

    def _get_unscored_plots(self):
        # initially the dictionary values are the names of the x axis, which
        # will be replaced by the Plot objects
        unscored_plots = {
            'ANTENNA_PLOT'  : 'Antenna ID',
            'BASELINE_PLOT' : 'Baseline Length', 
            'FIELD_PLOT'    : 'Field ID',
            'SCAN_PLOT'     : 'Scan ID',
            'SPW_PLOT'      : 'Spectral Window ID',
        }

        for key, x_axis in unscored_plots.values():
            filename = self._qa['QAPLOTS'][key]
            plot = logger.Plot(filename,
                               x_axis=x_axis,
                               y_axis='Fraction of Flagged Data')
            unscored_plots[key] = plot

        return unscored_plots

        
    def _get_plots(self, y_axis):
        # bail out early if no QA analysis has been performed.
        if 'QAPLOTS' not in self._qa:
            return []

        y_axis = 'amp' if y_axis == 'amp' else 'phase'
        plot_key = 'AMPLITUDE_PLOT' if y_axis == 'amp' else 'PHASE_PLOT'

        plots = []
        for spw_id, spw_plots in self._qa['QAPLOTS'][plot_key].items():
            spw = self._ms.get_spectral_window(spw_id)
            dd = self._ms.get_data_description(spw=spw)

            # Some windows, such as ALMA window averages, do not have a data
            # description              
            if dd is None:
                continue
            
            for k, filename in spw_plots.items():
                # QA dictionary keys are peculiar, in that their index is a
                # function of both antenna and feed.
                ant_id = int(k) / dd.num_polarizations
                feed_id = int(k) % dd.num_polarizations
                
                polarization = dd.polarizations[feed_id]
                antenna = self._ms.get_antenna(ant_id)[0]

                # while we have the spw index and qa feed idx at hand,
                # populate the scores for this plot
                score = self._get_score(spw_id, k, y_axis)
                self.scores[os.path.basename(filename)] = score
                
                plot = logger.Plot(filename,
                                   x_axis='freq',
                                   y_axis=y_axis,
                                   field=self._result.inputs['field'],
                                   qa_score=score,
                                   parameters={'ant' : antenna.identifier,
                                               'spw' : spw.id,
                                               'pol' : polarization})
                plots.append(plot)

        return plots

    

    
 
class QABandpassAdapter(object):
    TableEntry = collections.namedtuple('TableEntry', 
                                        'vis spw antenna polarizations')

    def __init__(self, context, result):
        self._context = context
        self._result = result
        self._qa = result.qa

        if not result.qa:
            return

        vis = self._result.inputs['vis']
        self._ms = self._context.observing_run.get_ms(vis)

        self.scores = {}
        self.amplitude_plots = self._get_plots('amp')
        self.phase_plots = self._get_plots('phase')

        self.flagged_feeds = self._get_flagged_feeds() 

        self._write_json(context, result)


    def _write_json(self, context, result):
        json_file = os.path.join(context.report_dir, 
                                 'stage%s' % result.stage_number, 
                                 'qa.json')
        
        LOG.trace('Writing QA data to %s' % json_file)
        with open(json_file, 'w') as fp:
            json.dump(self.scores, fp)

    def _get_flagged_feeds(self):
        flagged = collections.defaultdict(list)
        
        # completely flagged antennas are present in the QA plot dictionaries
        # but missing from the QA score dictionaries
        for spw_id, qa_plots in self._qa['QAPLOTS']['PHASE_PLOT'].items():
            if spw_id not in self._qa['QASCORES']['PHASE_SCORE_RMS']:
                continue
            
            all_ids = qa_plots.keys()
            unflagged_ids = self._qa['QASCORES']['PHASE_SCORE_RMS'][spw_id].keys()
            flagged_ids = [i for i in all_ids if i not in unflagged_ids]

            for qa_id in flagged_ids:
                spw = self._ms.get_spectral_window(spw_id)
                dd = self._ms.get_data_description(spw=spw)
                
                ant_id = int(qa_id) / dd.num_polarizations
                feed_id = int(qa_id) % dd.num_polarizations

                polarization = dd.polarizations[feed_id]
                antenna = self._ms.get_antenna(ant_id)[0]

                flagged[antenna].append(polarization)

        return flagged

    def _get_score(self, spw, key, y_axis):
        if y_axis == 'phase':
            return self._get_phase_score(spw, key)
        else:
            return self._get_amplitude_score(spw, key)

    def _get_phase_score(self, spw, key):        
        f = lambda k : self._qa['QASCORES'][k][spw].get(key, None) 
        return {
            'total' : f('PHASE_SCORE_TOTAL'),
            'rms'   : f('PHASE_SCORE_RMS'),
            'flag'  : f('PHASE_SCORE_FLAG'),
            'delay' : f('PHASE_SCORE_DELAY')
        }

    def _get_amplitude_score(self, spw, key):
        f = lambda k : self._qa['QASCORES'][k][spw].get(key, None) 
        return {
            'total' : f('AMPLITUDE_SCORE_TOTAL'),
            'rms'   : f('AMPLITUDE_SCORE_RMS'),
            'flag'  : f('AMPLITUDE_SCORE_FLAG'),
            'sn'    : f('AMPLITUDE_SCORE_SN')
        }

    def _get_plots(self, y_axis):
        # bail out early if no QA analysis has been performed.
        if 'QAPLOTS' not in self._qa:
            return []

        y_axis = 'amp' if y_axis == 'amp' else 'phase'
        plot_key = 'AMPLITUDE_PLOT' if y_axis == 'amp' else 'PHASE_PLOT'

        plots = []
        for spw_id, spw_plots in self._qa['QAPLOTS'][plot_key].items():
            spw = self._ms.get_spectral_window(spw_id)
            dd = self._ms.get_data_description(spw=spw)

            # Some windows, such as ALMA window averages, do not have a data
            # description              
            if dd is None:
                continue
            
            for k, filename in spw_plots.items():
                # QA dictionary keys are peculiar, in that their index is a
                # function of both antenna and feed.
                ant_id = int(k) / dd.num_polarizations
                feed_id = int(k) % dd.num_polarizations
                
                polarization = dd.polarizations[feed_id]
                antenna = self._ms.get_antenna(ant_id)[0]

                # while we have the spw index and qa feed idx at hand,
                # populate the scores for this plot
                score = self._get_score(spw_id, k, y_axis)
                self.scores[os.path.basename(filename)] = score
                
                plot = logger.Plot(filename,
                                   x_axis='freq',
                                   y_axis=y_axis,
                                   field=self._result.inputs['field'],
                                   qa_score=score,
                                   parameters={'ant' : antenna.identifier,
                                               'spw' : spw.id,
                                               'pol' : polarization})
                plots.append(plot)

        return plots
