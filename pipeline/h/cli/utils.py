import inspect
from functools import wraps
from typing import Callable, Any

import pipeline.infrastructure as infrastructure
import pipeline.infrastructure.api as api
import pipeline.infrastructure.argmapper as argmapper
import pipeline.infrastructure.vdp as vdp
from pipeline.infrastructure import exceptions, task_registry, utils

from .. import heuristics
from . import cli

LOG = infrastructure.get_logger(__name__)


def cli_wrapper(func: Callable) -> Callable:
    """Handles CLI argument parsing and execution for a pipeline task.

    This decorator streamlines pipeline CLI tasks by automating common boilerplate
    code. It inspects the wrapped function's signature to correctly map all
    arguments, retrieves the pipeline context, and manages task execution.

    It also includes a compatibility fix to handle and remove the deprecated
    `pipelinemode` argument, which may be present in scripts generated by
    older pipeline versions. If the target function is not a registered
    pipeline task (e.g. ``h_init``), it is executed as a regular Python function.

    Args:
        func: The Pipeline task function to wrap.

    Returns:
        The decorated function that returns task results.

    Note:
        The decorated function should focus on its docstring and parameter
        definitions. This wrapper handles the execution logic and the implementation of
        PIPE-2385 merges docstrings from the task's input class, ensuring the final CLI
        function is fully documented.
    """

    @wraps(func)
    def wrapper(*args: Any, **kwargs: Any) -> Any:
        # Compatibility for old scripts: remove the "pipelinemode" argument if present.
        # This argument was used in pipeline versions before PIPE-1686, and commonly
        # exists in archived casa_pipescript.py/casa_pipestorescript.py scripts generated
        # by old pipeline versions before PIPE-1686.
        if 'pipelinemode' in kwargs:
            LOG.attention(
                'The task argument "pipelinemode" is deprecated and will be ignored.'
            )
            kwargs.pop('pipelinemode')

        task_name = func.__name__

        try:
            # Determine if the function is a standard, class-based pipeline task.
            task_registry.get_pipeline_class_for_task(task_name)
        except KeyError:
            # A KeyError indicates it's not a registered pipeline task,
            # so execute it as a normal Python callable.
            LOG.debug('%r is not a pipeline task, executing as a standard function.', task_name)
            return func(*args, **kwargs)

        # Bind the provided arguments to the function's signature to create a complete
        # mapping of all parameter names to their values.
        signature = inspect.signature(func)
        bound_arguments = signature.bind(*args, **kwargs)
        bound_arguments.apply_defaults()
        all_inputs = dict(bound_arguments.arguments)

        context = get_context()
        results = execute_task(context, task_name, all_inputs)

        return results

    return wrapper


def get_context():
    """Retrieve the current pipeline context."""
    if cli.PIPELINE_NAME not in cli.stack:
        raise exceptions.PipelineException(
            'Pipeline has not been initialized. Please call h_init() or h_resume() first.'
        )
    return cli.stack[cli.PIPELINE_NAME].context


def get_output_dir():
    context = get_context()
    return context.output_dir


def get_ms(vis):
    context = get_context()
    return context.observing_run.get_ms(name=vis)


def get_heuristic(arg):
    if issubclass(arg, api.Heuristic):
        return arg()

    if callable(arg):
        return arg

    # TODO LOOK IN HEURISTICS MODULE

    # If the argument is a non-empty string, try to get the class with the
    # given name, or if that class doesn't exist, wrap the input in an
    # EchoHeuristic
    if isinstance(arg, str) and arg:
        packages = arg.split('.')
        module = '.'.join(packages[:-1])
        # if arg was a raw string with no dots, module is empty
        if not module:
            return heuristics.EchoHeuristic(arg)

        try:
            m = __import__(module)
        except ImportError:
            return heuristics.EchoHeuristic(arg)
        for package in packages[1:]:
            m = getattr(m, package, heuristics.EchoHeuristic(arg))
        return m()

    return heuristics.EchoHeuristic(arg)


def execute_task(context, casa_task, casa_args):
    # get the pipeline task inputs
    task_inputs = _get_task_inputs(casa_task, context, casa_args)

    # Execute the class, collecting the results
    results = _execute_task(casa_task, task_inputs)

    # write the command invoked (eg. hif_setjy) to the result so that the
    # weblog can print help from the XML task definition rather than the
    # python class
    results.taskname = casa_task

    # accept the results if desired
    _merge_results(context, results)

    tracebacks = utils.get_tracebacks(results)
    if len(tracebacks) > 0:
        previous_tracebacks_as_string = "{}".format("\n".join([tb for tb in tracebacks]))
        raise exceptions.PipelineException(previous_tracebacks_as_string)

    return results


def _get_task_inputs(casa_task, context, casa_args):
    # convert the CASA arguments to pipeline arguments, renaming and
    # converting as necessary.
    pipeline_task_class = task_registry.get_pipeline_class_for_task(casa_task)
    task_args = argmapper.convert_args(pipeline_task_class, casa_args)
    inputs = vdp.InputsContainer(pipeline_task_class, context, **task_args)

    return inputs


def _execute_task(casa_task, task_inputs):
    # Given the class and CASA name of the stage and the list
    # of stage arguments, compute and return the results.

    # Find the task and run it
    pipeline_task_cls = task_registry.get_pipeline_class_for_task(casa_task)
    task = pipeline_task_cls(task_inputs)

    # Reporting stuff goes here

    # Error checking ?
    return task.execute()


def _merge_results(context, results):
    try:
        results.accept(context)
    except Exception:
        LOG.critical('Warning: Check merge to context for {}'.format(results.__class__.__name__))
        raise
