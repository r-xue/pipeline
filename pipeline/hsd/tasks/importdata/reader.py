"""This module is implemented classes for importdata to read MeasurementSet."""

import collections
import glob
import itertools
import os
import shutil
import string
from typing import Any, Dict, List, Tuple, Union

import numpy
from pipeline.hsd.heuristics.rasterscan import RasterScanHeuristicsResult
import pipeline.infrastructure as infrastructure
import pipeline.infrastructure.logging as logging
import pipeline.infrastructure.utils as utils
from pipeline.domain.datatable import DataTableColumnMaskList as ColMaskList
from pipeline.domain.datatable import DataTableImpl as DataTable
from pipeline.domain.datatable import OnlineFlagIndex
from pipeline.domain.measurementset import MeasurementSet
from pipeline.hsd.tasks.common import TableSelector, mjd_to_datestring
from pipeline.infrastructure import casa_tools
from pipeline.infrastructure.launcher import Context

from ..common import direction_utils as dirutil
from ..common import rasterutil
from ..common.utils import mjd_to_datetime

LOG = infrastructure.get_logger(__name__)


def get_value_in_deg(quantity: Dict[str, Any]) -> numpy.ndarray:
    """Convert a casa quantity into a value in the unit of degree.

    Args:
        quantity: value for convert
    Returns:
        numpy.ndarray: converted value
    """
    qa = casa_tools.quanta
    return qa.getvalue(qa.convert(quantity, 'deg'))


def mjdsec2str(t: float) -> str:
    """Convert datetime to string.

    Args:
        t: MJD second to convert
    Returns:
        str: formatted datetime
    """
    date_time = mjd_to_datetime(t / 86400)
    attributes = ('year', 'month', 'day', 'hour', 'minute', 'second', 'microsecond')
    return '{}/{}/{}/{}:{}:{}.{:0>6d}'.format(*[getattr(date_time, name) for name in attributes])


def get_state_id(ms: MeasurementSet, spw: str, intent: str) -> numpy.ndarray:
    """Get state ID from MeasurementSet.

    Args:
        ms: MeasurementSet
        spw: spectral window
        intent: Pipeline intent
    Returns:
        array: state IDs
    """
    states = (s for s in ms.states if intent in s.intents)
    obs_modes = set()
    for s in states:
        modes = set(s.get_obs_mode_for_intent(intent))
        obs_modes.update(modes)
    state_ids = set()
    with casa_tools.MSReader(ms.name) as msreader:
        for obs_mode in obs_modes:
            msreader.msselect({'spw': spw, 'scanintent': obs_mode}, onlyparse=True)
            indices = msreader.msselectedindices()
            state_ids.update(indices['stateid'])
            # Need to reset explicitly after CASA 5.3. See CAS-11088 for detail.
            msreader.selectinit(reset=True)
    return numpy.fromiter(state_ids, dtype=numpy.int32)


def merge_timerange(timerange_list: List[List]) -> List[List]:
    """Merge time ranges.

    Args:
        timerange_list: list of timerange
    Returns:
        List: merged time ranges
    """
    timegap_list = numpy.asarray([l1[0] - l0[1] for l0, l1 in zip(timerange_list, timerange_list[1:])])
    LOG.info(f'timegap_list is {timegap_list}')

    # regard timegap <= 0.1msec as continuous
    gap_index = [-1] + numpy.where(timegap_list > 1e-4)[0].tolist() + [len(timegap_list)]

    timerange_merged = [[timerange_list[i + 1][0], timerange_list[j][1]] for i, j in zip(gap_index, gap_index[1:])]
    LOG.info(f'timerange_merged is {timerange_merged}')

    return timerange_merged


def initialize_template(flagtemplate: str):
    """Initialise flag template.

    Args:
        flagtemplate: path of flag template
    """
    # remove existing template file
    if os.path.exists(flagtemplate):
        os.remove(flagtemplate)

    # initialize template file with header
    with open(flagtemplate, 'w') as f:
        f.write('# This template file is auto-generated by hsd_importdata to flag MS rows based on pointing data \n')


def merge_flagcmd(commands: List[Tuple[str]]) -> List[Tuple[str]]:
    """Primitive merge of flag command.

    Merge flag commands that have exactly same timerange but different antennas/spws.

    Args:
        commands: List of (spw, antenna, timerange) string tuples.
    Returns:
        List: Merged list of (spw, antenna, timerange) string tuples.
    """
    LOG.debug('INPUT: %s', commands)
    # merge command using utils.dict_merge
    # result will be
    #   {timerangeX: {antennaX: {spwX: 0, spwY: 0,...},
    #                {antennaY: {spwX: 0, spwY: 0, ...},
    #    timerangeY: ...}
    tmp = {}
    for cmd in map(lambda x: {x[2]: {x[1]: {x[0]: 0}}}, commands):
        tmp = utils.dict_merge(tmp, cmd)

    # construct return value
    merged = []
    for timerange, atmp in tmp.items():
        # mtmp dict
        # {spwX: [antennaX, antennaY, ...],
        #  spwY: [antennaX, antennaY, ...]}
        mtmp = {}
        for antenna, stmp in atmp.items():
            for spw in stmp.keys():
                mtmp.setdefault(spw, [])
                mtmp[spw].append(antenna)

        # mtmp2 dict
        # {antstr1: [spwX, spwY, ...],
        #  antstr2: [spwX, spwY, ...]}
        # where antstrN is string of comma-separated
        # list of antenna ids.
        mtmp2 = {}
        for k, v in mtmp.items():
            key = ','.join(v)
            mtmp2.setdefault(key, [])
            mtmp2[key].append(k)

        # construct merged command
        # [(spwstr1, antstr1, timerange),
        #  (spwstr2, antstr2, timerange),
        #  ...]
        for k, v in mtmp2.items():
            merged_spw = ','.join(v)
            merged_antenna = k
            merged.append((merged_spw, merged_antenna, timerange))
    LOG.debug('OUTPUT: %s', merged)
    return merged


def write_flagcmd(flagtemplate: str, cmd_list: List[Tuple[str, str, str]], reason: str=''):
    """Write command list to flagtemplate file.

    Args:
        flagtemplate: filename of flagtemplate
        cmd_list: list of (spw, antenna, timerange) string tuples.
        reason: reason string
    """
    sanitized = reason.replace(' ', '_')
    template = string.Template(f"mode='manual' spw='$spw' antenna='$antenna&&&' timerange='$timerange' reason='SDPL:{sanitized}'\n")

    with open(flagtemplate, 'a') as f:
        for spw, antenna, timerange in cmd_list:
            f.write(template.safe_substitute(spw=spw, antenna=antenna, timerange=timerange))


def set_nominal_direction(ant: numpy.ndarray, srctype: numpy.ndarray, az: numpy.ndarray, el: numpy.ndarray, ra: numpy.ndarray, dec: numpy.ndarray,
                          shift_ra: numpy.ndarray, shift_dec: numpy.ndarray, offset_ra: numpy.ndarray, offset_dec: numpy.ndarray):
    """Replace NaNs in input arrays with nominal directions.

    Args:
        ant: antenna id
        srctype: source type ids (0=target, 1=other types)
        az: pointing direction:AZ
        el: pointing direction:EL
        ra: pointing direction:RA
        dec: pointing direction:DEC
        shift_ra: pointing direction:Shift RA
        shift_dec: pointing direction:Shift DEC
        offset_ra: pointing direction:Offset RA
        offset_dec: pointing direction:Offset DEC
    """
    # check if there are NaN's
    isvalid = numpy.logical_not(numpy.isnan(az))
    if numpy.all(isvalid):
        # no NaN's so exit this loop
        LOG.debug('no NaN')
        return

    for _a, _s in itertools.product(set(ant), set(srctype)):
        # select data
        LOG.debug(f'ant {_a} src {_s}')
        sel = numpy.logical_and(ant == _a, srctype == _s)
        if numpy.all(numpy.logical_not(sel)):
            # no data for this selection
            LOG.debug('no data')
            continue

        # separate NaN's
        mask = numpy.logical_and(isvalid, sel)
        if numpy.all(mask[sel]):
            # no NaN's for this selection
            LOG.debug('no NaN for this selection')
            continue

        nanmask = numpy.logical_and(numpy.logical_not(isvalid), sel)
        _az = numpy.median(az[mask])
        LOG.debug('nominal az {}'.format(_az))
        _el = numpy.median(el[mask])
        LOG.debug('nominal el {}'.format(_el))
        _ra = numpy.median(ra[mask])
        LOG.debug('nominal ra {}'.format(_ra))
        _dec = numpy.median(dec[mask])
        LOG.debug('nominal dec {}'.format(_dec))
        _shift_ra = numpy.median(shift_ra[mask])
        LOG.debug('nominal shift_ra {}'.format(_shift_ra))
        _shift_dec = numpy.median(shift_dec[mask])
        LOG.debug('nominal shift_dec {}'.format(_shift_dec))
        _offset_ra = numpy.median(offset_ra[mask])
        LOG.debug('nominal offset_ra {}'.format(_offset_ra))
        _offset_dec = numpy.median(offset_dec[mask])
        LOG.debug('nominal offset_dec {}'.format(_offset_dec))
        az[nanmask] = _az
        el[nanmask] = _el
        ra[nanmask] = _ra
        dec[nanmask] = _dec
        shift_ra[nanmask] = _shift_ra
        shift_dec[nanmask] = _shift_dec
        offset_ra[nanmask] = _offset_ra
        offset_dec[nanmask] = _offset_dec


class MetaDataReader(object):
    """MetaData reading class."""

    def __init__(self, context: Context, ms: MeasurementSet, table_name: str):
        """Initialize this class.

        Args:
            context: pipeline context
            mses: list of measurementset domain objects
            table_name: name of DataTable
        """
        self.context = context
        self.ms = ms
        self.table_name = table_name
        # existing table should be the one generated by the previous run
        # so it must be overwritten
        if os.path.exists(self.table_name):
            shutil.rmtree(self.table_name)
        self.datatable = DataTable(name=self.table_name, readonly=False)
        self.vAnt = 0
        self.appended_row = 0

        # invalid_pointing_data is dictionary (collections.defaultdict)
        # it stores an information of the data that caused
        # msmd.pointingdirection to fail due to the lack of
        # pointing data in POINTING table
        # key: antenna id
        # value: list of DataTable rows for invalid data
        self.invalid_pointing_data = collections.defaultdict(list)

        # remove flag template for pointing
        ms_prefix = os.path.splitext(self.ms.basename)[0]
        self.flagtemplate = os.path.join(self.context.output_dir, f'{ms_prefix}.flagpointing.txt')
        initialize_template(self.flagtemplate)

    @property
    def name(self) -> str:
        """Property:name.

        Returns:
            str: ms.name
        """
        return self.ms.name

    def get_datatable(self) -> DataTable:
        """Return datatable.

        Returns:
            DataTable: self.datatable
        """
        return self.datatable

    def detect_target_spw(self) -> List[int]:
        """Return a list of science spectral window IDs.

        Returns:
            List: spectral window IDs
        """
        if not hasattr(self, 'name'):
            return []

        ms = self.ms
        spws = ms.get_spectral_windows(science_windows_only=True)
        return [x.id for x in spws]

    def detect_target_data_desc(self) -> numpy.ndarray:
        """Return a list of data description IDs associated with science spectral windows.

        Returns:
            array: data description ids
        """
        science_windows = self.detect_target_spw()
        ms = self.ms

        def _g():
            for spwid in science_windows:
                dd = ms.get_data_description(spw=spwid)
                assert dd is not None
                yield dd.id

        dds = numpy.fromiter(_g(), dtype=numpy.int32)
        return dds

    def register_invalid_pointing_data(self, antenna_id: int, row: int):
        """Register invalid pointing data.

        Args:
            antenna_id: antenna id
            row: DataTable row
        """
        self.invalid_pointing_data[antenna_id].append(row)

    def generate_flagcmd(self, rasterscan_heuristics_result: RasterScanHeuristicsResult):
        """
        Generate flag commands based on pointings of observation and save them in the flag template file.

        Args:
            rasterscan_heuristics_result (RasterScanHeuristicsResult): Result object of RasterScanHeuristics
        """
        # PIPE-646
        # per-antenna row list for the data without pointing data
        # key: antenna id
        # value: list of rows to be flagged
        try:
            flagdict1, _ = self.generate_flagdict_for_invalid_pointing_data()
        except Exception:
            flagdict1 = {}

        # PIPE-647
        # per-spw, per-antenna row list for uniform image rms
        # key: (spw id, antenna id) tuple
        # value: list of rows to be flagged
        try:
            flagdict2 = self.generate_flagdict_for_uniform_rms(rasterscan_heuristics_result)
        except Exception:
            flagdict2 = {}

        # do nothing if no rows to be flagged
        nflag1 = sum(map(len, flagdict1.values()))
        nflag2 = sum(map(len, flagdict2.values()))
        if nflag1 + nflag2 == 0:
            return

        # for debugging
        if LOG.isEnabledFor(logging.DEBUG):
            for aid, dt_rows in flagdict1.items():
                with open(f'toflag1_ant{aid}.txt', 'w') as f:
                    f.write('\n'.join(map(lambda x: str(self.datatable.getcell('ROW', x)), dt_rows)))
                    f.write('\n')

            for (sid, aid), dt_rows in flagdict2.items():
                with open(f'toflag2_spw_{sid}_ant{aid}.txt', 'w') as f:
                    f.write('\n'.join(map(lambda x: str(self.datatable.getcell('ROW', x)), dt_rows)))
                    f.write('\n')

        # generate flag command
        self._generate_flagcmd(self.flagtemplate, flagdict1, reason='missing pointing data')
        self._generate_flagcmd(self.flagtemplate, flagdict2, reason='uniform image rms')

    def generate_flagdict_for_invalid_pointing_data(self) -> Tuple[collections.defaultdict, List[str]]:
        """Return row IDs of DataTable with invalid pointing information and a list of message.

        Returns:
            Tuple: contains dictionary of invalid pointing data and a list of message
        """

        msglist = []
        if len(self.invalid_pointing_data) > 0:
            msg = 'There are rows without corresponding POINTING data. Affected rows are identified and will be flagged in hsd_flagdata stage. Affected antennas are: {} in {}'.format(' '.join([self.ms.antennas[k].name for k in self.invalid_pointing_data]), self.ms.basename)
            msglist.append(msg)
        return self.invalid_pointing_data, msglist

    def generate_flagdict_for_uniform_rms(self, rasterscan_heuristics_result: RasterScanHeuristicsResult) -> Dict[Tuple[int, int], numpy.ndarray]:
        """Return row IDs of DataTable to flag.

        Args:
            rasterscan_heuristics_result (RasterScanHeuristicsResult): Result object of RasterScanHeuristics

        Returns:
            Dict: contains list of row IDs of datatable
        """
        # keys for dictionary are (spw_id, antenna_id) tuples
        flagdict = rasterutil.flag_raster_map(self.datatable, self.ms, rasterscan_heuristics_result)

        return flagdict

    def _generate_flagcmd(self, flagtemplate: str, flag_dict: Dict[Union[Tuple[str, int], int], List[int]], reason: str=''):
        """Generate and store flag commands in the flag template file.

        Args:
            flagtemplate: filename of flagtemplate
            flag_dict: dictionary of flags
            reason: reason string
        """
        datatable = self.datatable
        cmdlist = []
        for key, rowlist in flag_dict.items():
            if isinstance(key, tuple):
                spw_id, antenna_id = key
            else:
                spw_id = '*'
                antenna_id = key
            time_list, sort_index = numpy.unique(
                [datatable.getcell('TIME', row) for row in rowlist],
                return_index=True)

            # day -> sec
            time_list *= 86400.0

            interval_list = [datatable.getcell('EXPOSURE', row) for row in numpy.asarray(rowlist)[sort_index]]

            LOG.info(f'antenna {antenna_id} spw {spw_id}: time_list is {time_list}')

            if len(time_list) == 0:
                continue

            timerange_list = [[t - i / 2, t + i / 2] for t, i in zip(time_list, interval_list)]
            LOG.info(f'antenna {antenna_id} spw {spw_id}: timerange_list is {timerange_list}')

            timerange_merged = merge_timerange(timerange_list)

            for t in timerange_merged:
                # timerange is [start, end] list of MJD [sec]
                timerange_str = '~'.join(map(mjdsec2str, t))
                cmdlist.append((str(spw_id), str(antenna_id), timerange_str))

        cmd_merged = merge_flagcmd(cmdlist)
        write_flagcmd(flagtemplate, cmd_merged, reason)

    def execute(self) -> Dict[str, Dict[str, Union[str, Dict]]]:
        """Read MeasurementSet and fill DataTable.

        Returns:
            Dict: dictionary of ephemeris sources
        """

        # name of the MS
        name = self.name
        spwids = self.detect_target_spw()
        nchan_map = dict([(spwid, self.ms.get_spectral_window(spwid).num_channels) for spwid in spwids])
        ddids = self.detect_target_data_desc()

        # Rad2Deg = 180. / 3.141592653

        # FILENAME keyword stores name of the MS
        LOG.info('name=%s' % name)
        self.datatable.putkeyword('FILENAME', name)

        # 2018/04/18 TN
        # CAS-10874 single dish pipeline should use ICRS instead of J2000
        # For consistency throuout the single dish pipeline, direction
        # reference frame is stored in the DataTable
        outref = self._get_outref()
        # register direction reference to datatable
        self.datatable.direction_ref = outref
        azelref = self._get_azelref()
        # LOG.info('outref="{0}" azelref="{1}"'.format(outref, azelref))

        ms = self.ms
        assert ms is not None
        spwsel = ','.join(map(str, spwids))
        target = 'TARGET'
        reference = 'REFERENCE'
        assert target in ms.intents
        # assert reference in ms.intents
        target_states = get_state_id(ms, spwsel, target)
        reference_states = get_state_id(ms, spwsel, reference)
#         target_states = (s for s in ms.states if target in s.intents)
#         reference_states = (s for s in ms.states if reference in s.intents)
#         target_obs_modes = set()
#         for s in target_states:
#             modes = set(s.get_obs_mode_for_intent(target))
#             target_obs_modes.update(modes)
#             modes = set(s.get_obs_mode_for_intent(reference))
#             obs_modes.update(modes)
#         state_ids = set()
#         with casa_tools.MSReader(name) as msreader:
#             for obs_mode in obs_modes:
#                 msreader.msselect({'spw': spwsel, 'scanintent': obs_mode}, onlyparse=True)
#                 indices = msreader.msselectedindices()
#                 state_ids.update(indices['stateid'])
#         state_ids = numpy.fromiter(state_ids, dtype=numpy.int32)
        state_ids = numpy.concatenate([target_states, reference_states])
        target_state_ids = numpy.concatenate([target_states])

        # get antenna position list
        mpositions = [a.position for a in ms.antennas]

        # get names of ephemeris sources (excludes 'COMET')
        me = casa_tools.measures
        direction_codes = me.listcodes(me.direction())
        ephemeris_list = direction_codes['extra']
        known_ephemeris_list = numpy.delete(ephemeris_list, numpy.where(ephemeris_list == 'COMET'))
        # set org_directions
        ephemsrc_list = []   # list of ephemsrc names (unique appearance)
        ephemsrc_names = {}  # ephemsrc name for each field_id
        ephem_tables = {}    # epheris table name for each field_id if applicasble
        # ephem_tables to be "" for known_ephemeris_list and non-ephemeris sources

        with casa_tools.TableReader(os.path.join(name, 'FIELD')) as tb:
            field_ids = list(range(tb.nrows()))
            for field_id in list(set(field_ids)):
                fields = ms.get_fields(field_id=field_id)
                if len(fields) == 0:
                    continue

                source_name = (fields[0].source.name)  # removed upper() 2019.5.14
                if 'EPHEMERIS_ID' in tb.colnames():
                    ephemeris_ids = tb.getcol('EPHEMERIS_ID')
                else:
                    ephemeris_ids = []

                # check if known_ephemeris_sources
                if source_name.upper() in known_ephemeris_list and not fields[0].source.is_eph_obj:
                    fields[0].source.is_known_eph_obj = True
                else:
                    fields[0].source.is_known_eph_obj = False

                # ephemeris source with ephemeris table
                if fields[0].source.is_eph_obj:
                    ephemsrc_names.update({field_id: source_name})
                    if source_name.upper not in ephemsrc_list:
                        # found a new ephemeris source
                        ephemsrc_list.append(source_name)

                    # pick ephemeris table name
                    ephem_table_files = glob.glob(ms.name + '/FIELD/EPHEM' + str(ephemeris_ids[field_id]) + '_*.tab')
                    if len(ephem_table_files) > 1:
                        raise RuntimeError("multiple ephemeris tables found for field_id={}".format(field_id))

                    if len(ephem_table_files) == 1:
                        ephem_table_file = ephem_table_files[0]
                        # double check the source name in ephem_table_file
                        with casa_tools.TableReader(ephem_table_file) as tb2:
                            keywords = tb2.getkeywords()
                            if keywords['NAME'] != source_name:
                                raise RuntimeError(
                                    "source name in ephemeris table {0} was {1}, inconsistent with {2}".format(ephem_table_file,
                                                                                                               keywords['NAME'],
                                                                                                               source_name))
                        ephem_tables.update({field_id: ephem_table_file})
                        LOG.info("FIELD_ID={} ({}) with ephemeris table {}".format(field_id, source_name, ephem_table_file))

                # known ephemeris source without ephemeirs table (not applicable for ALMA)
                elif fields[0].source.is_known_eph_obj:
                    ephemsrc_names.update({field_id: source_name})
                    ephem_tables.update({field_id: ''})
                    LOG.info("FIELD_ID={} ({}) as KNOWN EPHEMERIS SOURCE".format(field_id, source_name))

                # non-ephemeris source
                else:
                    ephemsrc_names.update({field_id: ''})
                    ephem_tables.update({field_id: ''})
                    LOG.info("FIELD_ID={} ({}) as NORMAL SOURCE".format(field_id, source_name))

        with TableSelector(name, 'ANTENNA1 == ANTENNA2 && FEED1 == FEED2 && DATA_DESC_ID IN %s && STATE_ID IN %s' % (list(ddids),
                                                                                                                     list(target_state_ids))) as tb:
            # find the first onsrc for each ephemeris source and pack org_directions
            org_directions = {}
            nrow = tb.nrows()
            for irow in range(nrow):
                field_id = tb.getcell('FIELD_ID', irow)
                if field_id not in ephemsrc_names:
                    raise RuntimeError("ephemsrc_name for field_id={0} does not exist".format(field_id))
                if ephemsrc_names[field_id] != "":
                    source_name = ephemsrc_names[field_id]
                    if source_name not in org_directions:
                        mjd_in_sec = tb.getcell('TIME', irow)
                        antenna_id = tb.getcell('ANTENNA1', irow)
                        time_meas = tb.getcolkeyword('TIME', 'MEASINFO')
                        time_frame = time_meas['Ref']
                        me = casa_tools.measures
                        qa = casa_tools.quanta
                        mepoch = me.epoch(rf=time_frame, v0=qa.quantity(mjd_in_sec, 's'))
                        antennas = self.ms.get_antenna(antenna_id)
                        assert len(antennas) == 1
                        antenna_domain = antennas[0]
                        mposition = antenna_domain.position
                        fields = ms.get_fields(field_id=field_id)
                        is_known_eph_obj = fields[0].source.is_known_eph_obj
                        org_direction = self.get_reference_direction(source_name, ephem_tables[field_id], is_known_eph_obj, mepoch, mposition, outref)
                        org_directions.update({source_name: org_direction})

        with casa_tools.TableReader(os.path.join(name, 'FIELD')) as tb:
            field_ids = list(range(tb.nrows()))
            for field_id in list(set(field_ids)):
                fields = ms.get_fields(field_id=field_id)
                if len(fields) == 0:
                    org_direction = None
                    continue

                source_name = fields[0].source.name
                if source_name in org_directions:
                    fields[0].source.org_direction = org_directions[source_name]
                    LOG.info("registering org_direction[{}] (field_id={} of {}) as {}".format(source_name, field_id, name,
                             org_directions[source_name]))
                else:
                    org_direction = None

        with TableSelector(name, 'ANTENNA1 == ANTENNA2 && FEED1 == FEED2 && DATA_DESC_ID IN %s && STATE_ID IN %s' % (list(ddids),
                                                                                                                     list(state_ids))) as tb:
            nrow = tb.nrows()
            rows = tb.rownumbers()
            Texpt = tb.getcol('INTERVAL')
            Tmjd = tb.getcol('TIME')
            time_meas = tb.getcolkeyword('TIME', 'MEASINFO')
            time_frame = time_meas['Ref']
            Tscan = tb.getcol('SCAN_NUMBER')
            TDD = tb.getcol('DATA_DESC_ID')
            ddspwmap = numpy.vectorize(lambda x: ms.get_data_description(id=x).spw.id, otypes=[numpy.int32])
            ddnpolmap = numpy.vectorize(lambda x: ms.get_data_description(id=x).num_polarizations, otypes=[numpy.int32])
            Tif = ddspwmap(TDD)
            Tpol = ddnpolmap(TDD)
            Tant = tb.getcol('ANTENNA1')
            Tbeam = tb.getcol('FEED1')
            Tsrctype = numpy.fromiter((0 if i in target_states else 1 for i in tb.getcol('STATE_ID')), dtype=numpy.int32)
            Tflagrow = tb.getcol('FLAG_ROW')
            Tflag = numpy.fromiter((numpy.all(tb.getcell('FLAG', i) == True) for i in range(nrow)), dtype=bool)
            Tflagrow = numpy.logical_or(Tflagrow, Tflag)
            field_ids = tb.getcol('FIELD_ID')
            getsourcename = numpy.vectorize(lambda x: ms.get_fields(x)[0].source.name, otypes=['str'])
            Tsrc = getsourcename(field_ids)
            NchanArray = numpy.fromiter((nchan_map[n] for n in Tif), dtype=int)

        ID = len(self.datatable)
        LOG.info('ID=%s' % ID)
        # ROWs = []
        # IDs = []

        self.datatable.addrows(nrow)
        # column based storing
        self.datatable.putcol('ROW', rows, startrow=ID)
        self.datatable.putcol('SCAN', Tscan, startrow=ID)
        self.datatable.putcol('IF', Tif, startrow=ID)
        self.datatable.putcol('NPOL', Tpol, startrow=ID)
        self.datatable.putcol('BEAM', Tbeam, startrow=ID)
        self.datatable.putcol('TIME', Tmjd / 86400.0, startrow=ID)
        self.datatable.putcol('ELAPSED', Tmjd - Tmjd[0], startrow=ID)
        self.datatable.putcol('EXPOSURE', Texpt, startrow=ID)
        self.datatable.putcol('FIELD_ID', field_ids, startrow=ID)
        Tra = numpy.zeros(nrow, dtype=numpy.float64)
        Tdec = numpy.zeros(nrow, dtype=numpy.float64)
        Tshift_ra = numpy.zeros(nrow, dtype=numpy.float64)
        Tshift_dec = numpy.zeros(nrow, dtype=numpy.float64)
        Tofs_ra = numpy.zeros(nrow, dtype=numpy.float64)
        Tofs_dec = numpy.zeros(nrow, dtype=numpy.float64)
        Taz = numpy.zeros(nrow, dtype=numpy.float64)
        Tel = numpy.zeros(nrow, dtype=numpy.float64)
        index = numpy.lexsort((Tant, Tmjd))
        LOG.info('Start reading direction (convert if necessary). It may take a while.')
        with casa_tools.MSMDReader(name) as msmd:
            nprogress = 5000
            iprogress = 0
            last_mjd = None
            last_antenna = None
            last_result = None
            ref_direction = None

            for irow in index:
                iprogress += 1
                if iprogress >= nprogress and iprogress % nprogress == 0:
                    print('{}/{}'.format(iprogress, nrow))
                row = rows[irow]
                mjd_in_sec = Tmjd[irow]
                antenna_id = Tant[irow]
                if mjd_in_sec == last_mjd and antenna_id == last_antenna:
                    Taz[irow] = last_result[0]
                    Tel[irow] = last_result[1]
                    Tra[irow] = last_result[2]
                    Tdec[irow] = last_result[3]
                    Tshift_ra[irow] = last_result[4]
                    Tshift_dec[irow] = last_result[5]
                    Tofs_ra[irow] = last_result[6]
                    Tofs_dec[irow] = last_result[7]
                    continue

                me = casa_tools.measures
                qa = casa_tools.quanta
                mepoch = me.epoch(rf=time_frame, v0=qa.quantity(mjd_in_sec, 's'))
                # now mposition is prepared in mpositions
                # antennas = self.ms.get_antenna(antenna_id)
                # assert len(antennas) == 1
                # antenna_domain = antennas[0]
                # mposition = antenna_domain.position
                mposition = mpositions[antenna_id]
                # CASR-494
                try:
                    pointing_directions = msmd.pointingdirection(row, interpolate=True)
                except RuntimeError as e:
                    if 'SSMIndex::getIndex - access to non-existing row' in str(e):
                        LOG.info('{}: Missing pointing data for row {} (antenna {} time {})'.format(ms.basename, rows[irow], Tant[irow], Tmjd[irow]))

                        # register DataTable row to self.invalid_pointing_data
                        dt_row = ID + irow
                        self.register_invalid_pointing_data(antenna_id, dt_row)

                        NAN = numpy.nan
                        Taz[irow] = NAN
                        Tel[irow] = NAN
                        Tra[irow] = NAN
                        Tdec[irow] = NAN
                        Tshift_ra[irow] = NAN
                        Tshift_dec[irow] = NAN
                        Tofs_ra[irow] = NAN
                        Tofs_dec[irow] = NAN
                        Tflagrow[irow] = True
                        continue
                    else:
                        LOG.warning(e)
                        raise e

                pointing_direction = pointing_directions['antenna1']['pointingdirection']  # antenna2 should be the same
                lon = pointing_direction['m0']
                lat = pointing_direction['m1']
                ref = pointing_direction['refer']

                # 2018/04/18 TN
                # CAS-10874 single dish pipeline should use ICRS instead of J2000
                if ref in [azelref]:
                    if irow == 0:
                        LOG.info('Require direction conversion from {0} to {1}'.format(ref, outref))

                    Taz[irow] = get_value_in_deg(lon)
                    Tel[irow] = get_value_in_deg(lat)

                    # conversion to J2000
                    ra, dec = dirutil.direction_convert(pointing_direction, mepoch, mposition, outframe=outref)
                    Tra[irow] = get_value_in_deg(ra)
                    Tdec[irow] = get_value_in_deg(dec)
                elif ref in [outref]:
                    if irow == 0:
                        LOG.info('Require direction conversion from {0} to {1}'.format(ref, azelref))

                    Tra[irow] = get_value_in_deg(lon)
                    Tdec[irow] = get_value_in_deg(lat)

                    # conversion to AZELGEO
                    az, el = dirutil.direction_convert(pointing_direction, mepoch, mposition, outframe=azelref)
                    Taz[irow] = get_value_in_deg(az)
                    Tel[irow] = get_value_in_deg(el)
                else:
                    if irow == 0:
                        LOG.info('Require direction conversion from {0} to {1} as well as to {2}'.format(ref, outref,
                                                                                                         azelref))

                    # conversion to J2000
                    ra, dec = dirutil.direction_convert(pointing_direction, mepoch, mposition, outframe=outref)
                    Tra[irow] = get_value_in_deg(ra)
                    Tdec[irow] = get_value_in_deg(dec)

                    # conversion to AZELGEO
                    az, el = dirutil.direction_convert(pointing_direction, mepoch, mposition, outframe=azelref)
                    Taz[irow] = get_value_in_deg(az)
                    Tel[irow] = get_value_in_deg(el)

                # Calculate shift_ra/dec and pack them into Tshift_ra/dec
                field_id = field_ids[irow]
                if field_id not in ephemsrc_names:
                    raise RuntimeError("ephemsrc_name for field_id={0} does not exist".format(field_id))
                if ephemsrc_names[field_id] == "":
                    Tshift_ra[irow] = Tra[irow]
                    Tshift_dec[irow] = Tdec[irow]
                    Tofs_ra[irow] = Tra[irow]
                    Tofs_dec[irow] = Tdec[irow]
                else:
                    source_name = ephemsrc_names[field_id]
                    if source_name not in org_directions:
                        raise RuntimeError("Ephemeris source {0} does not exist in org_directions".format(source_name))
                    org_direction = org_directions[source_name]
                    fields = ms.get_fields(field_id=field_id)
                    is_known_eph_obj = fields[0].source.is_known_eph_obj
                    ref_direction = self.get_reference_direction(source_name, ephem_tables[field_id], is_known_eph_obj, mepoch, mposition, outref)
                    direction2 = me.measure(pointing_direction, outref)

                    shift_direction = dirutil.direction_shift(direction2, ref_direction, org_direction)
                    shift_ra, shift_dec = dirutil.direction_convert(shift_direction, mepoch, mposition, outframe=outref)
                    Tshift_ra[irow] = get_value_in_deg(shift_ra)
                    Tshift_dec[irow] = get_value_in_deg(shift_dec)

                    ofs_direction = dirutil.direction_offset(direction2, ref_direction)
                    ofs_ra, ofs_dec = dirutil.direction_convert(ofs_direction, mepoch, mposition, outframe=outref)
                    Tofs_ra[irow] = get_value_in_deg(ofs_ra)
                    Tofs_dec[irow] = get_value_in_deg(ofs_dec)

                last_mjd = mjd_in_sec
                last_antenna = antenna_id
                last_result = (Taz[irow], Tel[irow], Tra[irow], Tdec[irow], Tshift_ra[irow], Tshift_dec[irow], Tofs_ra[irow], Tofs_dec[irow])

        # PIPE-646 replace NaN's with nominal value
        set_nominal_direction(Tant, Tsrctype, Taz, Tel, Tra, Tdec, Tshift_ra, Tshift_dec, Tofs_ra, Tofs_dec)

        assert numpy.all(numpy.isfinite(Taz))
        assert numpy.all(numpy.isfinite(Tel))
        assert numpy.all(numpy.isfinite(Tra))
        assert numpy.all(numpy.isfinite(Tdec))
        assert numpy.all(numpy.isfinite(Tshift_ra))
        assert numpy.all(numpy.isfinite(Tshift_dec))
        assert numpy.all(numpy.isfinite(Tofs_ra))
        assert numpy.all(numpy.isfinite(Tofs_dec))

        LOG.info('Done reading direction (convert if necessary).')

        # save org_directions if exists
        if 'org_direction' in locals():
            self.datatable.putkeyword('ORG_DIRECTION', org_direction)

        self.datatable.putcol('RA', Tra, startrow=ID)
        self.datatable.putcol('DEC', Tdec, startrow=ID)
        self.datatable.putcol('SHIFT_RA', Tshift_ra, startrow=ID)
        self.datatable.putcol('SHIFT_DEC', Tshift_dec, startrow=ID)
        self.datatable.putcol('OFS_RA', Tofs_ra, startrow=ID)
        self.datatable.putcol('OFS_DEC', Tofs_dec, startrow=ID)
        self.datatable.putcol('AZ', Taz, startrow=ID)
        self.datatable.putcol('EL', Tel, startrow=ID)
        self.datatable.putcol('NCHAN', NchanArray, startrow=ID)
        self.datatable.putcol('TARGET', Tsrc, startrow=ID)
        intArr = numpy.zeros(nrow, dtype=int)
        self.datatable.putcol('NMASK', intArr, startrow=ID)
        intArr[:] = -1
        self.datatable.putcol('NOCHANGE', intArr, startrow=ID)
        self.datatable.putcol('POSGRP', intArr, startrow=ID)
        self.datatable.putcol('ANTENNA', Tant, startrow=ID)
        self.datatable.putcol('SRCTYPE', Tsrctype, startrow=ID)

        # row base storing
        masklist = ColMaskList.NoMask

        # Tsys will be overwritten in applycal stage
        tsys_template = numpy.ones(4, dtype=numpy.float32)

        flag_summary_template = numpy.ones(4, dtype=numpy.int32)
        stats_template = numpy.zeros((4, 7), dtype=numpy.int32) - 1
        flags_template = numpy.ones((4, 7), dtype=numpy.int32)
        pflags_template = numpy.ones((4, 4), dtype=numpy.int32)
        for x in range(nrow):
            # FLAGROW is mapped into OnlineFlag (PermanentFlag[3])
            # NOTE: data is valid if Tflagrow is 0
            #       data is valid if pflags[3] is 1
            pflags_template[:, OnlineFlagIndex] = 1 if Tflagrow[x] == 0 else 0
            sDate = mjd_to_datestring(Tmjd[x] / 86400.0, unit='day')
            self.datatable.putcell('DATE', ID, sDate)
            self.datatable.putcell('MASKLIST', ID, masklist)

            # polarization dependent arrays
            npol = self.datatable.getcell('NPOL', ID)
            self.datatable.putcell('STATISTICS', ID, stats_template[:npol])
            self.datatable.putcell('FLAG', ID, flags_template[:npol])
            self.datatable.putcell('FLAG_PERMANENT', ID, pflags_template[:npol])
            self.datatable.putcell('FLAG_SUMMARY', ID, flag_summary_template[:npol])
            self.datatable.putcell('TSYS', ID, tsys_template[:npol])
            ID += 1

        num_antenna = len(self.ms.antennas)
        self.vAnt += num_antenna
        self.appended_row = nrow

        return org_directions

    def _get_outref(self) -> str:
        """Get direction reference for target.

        Returns:
            str: direction reference
        """
        outref = None

        dirrefs = []

        if self.ms.representative_target[0] is not None:
            # if ms has representative target, take reference from that
            LOG.info(
                'Use direction reference for representative target "{0}".'.format(self.ms.representative_target[0]))
            representative_source_name = self.ms.representative_target[0]
            dirrefs.extend(
                numpy.unique([f.mdirection['refer'] for f in self.ms.fields
                             if f.source.name == representative_source_name])
            )

        if len(dirrefs) == 0:
            # if representative target is not given, or is not observed,
            # take reference from one of the targets
            dirrefs.extend(
                numpy.unique([f.mdirection['refer'] for f in self.ms.fields if 'TARGET' in f.intents])
            )

            if len(dirrefs) == 0:
                # no target field exists, something wrong
                raise RuntimeError('No TARGET field exists.')

        if len(dirrefs) == 1:
            outref = dirrefs[0]
        else:
            # direction reference is not unique, search desired ref
            if 'ICRS' in dirrefs:
                outref = 'ICRS'
            elif 'J2000' in dirrefs:
                outref = 'J2000'
            else:
                # use first one
                outref = dirrefs[0]
        if outref is None:
            raise RuntimeError('Failed to get direction reference for TARGET.')

        return outref

    @staticmethod
    def _get_azelref() -> str:
        """Return reference type of AZEL coordinate.

        Returns:
            str: fix string 'AZELGEO'
        """
        return 'AZELGEO'

    def get_reference_direction(self, source_name: str, ephem_table: str, is_known_eph_obj: bool, mepoch: Dict[str, Union[Dict[str, Any], Any]],
                                mposition: Dict[str, Union[Dict[str, Any], Any]], outframe: str) -> Dict[str, Union[str, Dict]]:
        """Get reference direction of a ephemeris object by specified a position and epoch timestamp.

        Args:
            source_name: source name (ex:'Venus')
            ephem_table: ephemeris table name
            is_known_eph_obj: known ephemeris flag
            mepoc: dict of timestamp
            mposition: dict of position
            outframe: direction reference (ex:'ICRS')
        Returns:
            Dict: reference direction of ephemeris object
        Raises:
            RuntimeError: raise when is_known_eph_obj is False
        """
        me = casa_tools.measures

        if ephem_table != "":
            me.framecomet(ephem_table)
            me.doframe(mepoch)
            me.doframe(mposition)
            obj_azel = me.measure(me.direction('COMET'), 'AZELGEO')
            ref = me.measure(obj_azel, outframe)
        else:
            # if source_name.upper() in known_ephemeris_list:
            if is_known_eph_obj:
                me.doframe(mepoch)
                me.doframe(mposition)
                obj_azel = me.measure(me.direction(source_name.upper()), 'AZELGEO')
                ref = me.measure(obj_azel, outframe)
            else:
                raise RuntimeError("{0} is not registered in known_ephemeris_list".format(source_name))

        return ref
