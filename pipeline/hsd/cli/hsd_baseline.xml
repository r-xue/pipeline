<casaxml xmlns="http://casa.nrao.edu/schema/psetTypes.html" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://casa.nrao.edu/schema/casa.xsd file:///opt/casa/code/xmlcasa/xml/casa.xsd">

<task category="pipeline" name="hsd_baseline" type="function">
<shortdescription>Detect and validate spectral lines, subtract baseline by masking detected lines</shortdescription>
<description>The hsd_baseline task subtracts baseline from calibrated spectra.
             By default, the task tries to find spectral line feature using
             line detection and validation algorithms. Then, the task puts a
             mask on detected lines and perform baseline subtraction.
             The user is able to turn off automatic line masking by setting
             linewindow parameter, which specifies pre-defined line window.

             Fitting order is automatically determined by default. It can be
             disabled by specifying fitorder as non-negative value. In this
             case, the value specified by fitorder will be used.

             ***WARNING***
             Currently, hsd_baseline overwrites the result obtained by the
             previous run. Due to this behavior, users need to be careful
             about an order of the task execution when they run hsd_baseline
             multiple times with different data selection. Suppose there are
             two spectral windows (0 and 1) and hsd_baseline is executed
             separately for each spw as below,

             hsd_baseline(pipelinemode=&quot;interactive&quot;, spw=&quot;0&quot;)
             hsd_baseline(pipelinemode=&quot;interactive&quot;, spw=&quot;1&quot;)
             hsd_blflag(pipelinemode=&quot;automatic&quot;)
             hsd_imaging(pipelinemode=&quot;automatic&quot;)

             Since the second run of hsd_baseline overwrites the result for
             spw 0 with the data before baseline subtraction, this will not
             produce correct result for spw 0. Proper sequence for this use
             case is to process each spw to the imaging stage separately,
             which looks like as follows:

             hsd_baseline(pipelinemode=&quot;interactive&quot;, spw=&quot;0&quot;)
             hsd_blflag(pipelinemode=&quot;interactive&quot;, spw=&quot;0&quot;)
             hsd_imaging(pipelinemode=&quot;interactive&quot;, spw=&quot;0&quot;))
             hsd_baseline(pipelinemode=&quot;interactive&quot;, spw=&quot;1&quot;)
             hsd_blflag(pipelinemode=&quot;interactive&quot;, spw=&quot;1&quot;)
             hsd_imaging(pipelinemode=&quot;interactive&quot;, spw=&quot;1&quot;)

             Output:
              results -- If pipeline mode is 'getinputs' then None is returned.
                         Otherwise the results object for the pipeline task is
                         returned.
</description>
<input>
    <param name="fitfunc" type="string">
        <shortdescription>Fitting function for baseline subtraction</shortdescription>
        <description>fitting function for baseline subtraction. You can only
                     choose cubic spline ('spline' or 'cspline')
        </description>
	<value>cspline</value>
	<allowed kind="enum">
	    <value>cspline</value>
	    <value>spline</value>

	    <value>CSPLINE</value>
	    <value>SPLINE</value>

	</allowed>
    </param>

    <param name="fitorder" type="int">
        <shortdescription>Fitting order for baseline subtraction</shortdescription>
        <description>Fitting order for polynomial. For cubic spline, it is used
                     to determine how much the spectrum is segmented into.
                     Default (-1) is to determine the order automatically.
        </description>
	<value>-1</value>
    </param>

    <param name="switchpoly" type="bool">
        <shortdescription>Switch to polynomial fit when large mask exists at edge</shortdescription>
        <description>If True, switch to 1st or 2nd order polynomial fit when
                     large mask exists at edge regardless of whatever fitfunc
                     or fitorder are specified. Condition for switching is as
                     follows:
                         if nmask &gt; nchan/2      =&gt; 1st order polynomial
                         else if nmask &gt; nchan/4 =&gt; 2nd order polynomial
                         else                    =&gt; use fitfunc and fitorder
                     where nmask is a number of channels for mask at edge while
                     nchan is a number of channels of entire spectral window.
        </description>
	<value>True</value>
    </param>

    <param name="linewindow" type="any">
        <shortdescription>Pre-defined line window</shortdescription>
        <description>Pre-defined line window. If this is set, specified line
                     windows are used as a line mask for baseline subtraction
                      instead to determine masks based on line detection and
                      validation stage. Several types of format are acceptable.
                      One is channel-based window,
                          [min_chan, max_chan]
                      where min_chan and max_chan should be an integer. For
                      multiple  windows, nested list is also acceptable,
                          [[min_chan0, max_chan0], [min_chan1, max_chan1], ...]
                      Another way is frequency-based window,
                          [min_freq, max_freq]
                      where min_freq and max_freq should be either a float or
                      a string. If float value is given, it is interpreted as
                      a frequency in Hz. String should be a quantity consisting
                      of &quot;value&quot; and &quot;unit&quot;,
                      e.g., '100GHz'. Multiple windows are also supported.
                          [[min_freq0, max_freq0], [min_freq1, max_freq1], ...]
                      Note that the specified frequencies are assumed to be
                      the value in LSRK frame. Note also that there is a
                      limitation when multiple MSes are processed.
                      If native frequency frame of the data is not LSRK
                      (e.g. TOPO), frequencies need to be converted to that
                      frame. As a result, corresponding channel range may vary
                      between MSes. However, current implementation is not
                      able to handle such case. Frequencies are converted to
                      desired frame using representative MS (time, position,
                      direction).

                      In the above cases, specified line windows are applied
                      to all science spws. In case when line windows vary with
                      spw, line windows can be specified by a dictionary whose
                      key is spw id while value is line window.
                      For example, the following dictionary gives different
                      line windows to spws 17 and 19. Other spws, if available,
                      will have an empty line window.
                          {17: [[100, 200], [1200, 1400]], 19: ['112115MHz', '112116MHz']}
                      Furthermore, linewindow accepts MS selection string.
                      The following string gives [[100,200],[1200,1400]] for
                      spw 17 while [1000,1500] for spw 21.
                          &quot;17:100~200;1200~1400,21:1000~1500&quot;
                      The string also accepts frequency with units. Note,
                      however, that frequency reference frame in this case is
                      not fixed to LSRK. Instead, the frame will be taken from
                      the MS (typically TOPO for ALMA).
                      Thus, the following two frequency-based line windows
                      result different channel selections.
                          {19: ['112115MHz', '112116MHz']} # frequency frame is LSRK
                          &quot;19:11215MHz~11216MHz&quot; # frequency frame is taken from the data
                                                           # (TOPO for ALMA)

                     None is allowed as a value of dictionary input to indicate that
                     no line detection/validation is required even if manually specified
                     line window does not exist. When None is given as a value and if
                     linewindowmode is 'replace', line detection/validation is not performed
                     for the corresponding spw. For example, suppose the following parameters
                     are given for the data with four science spws, 17, 19, 21, and 23.
                         linewindow={17: [112.1e9, 112.2e9], 19: [113.1e9, 113.15e9], 21: None}
                         linewindowmode='replace'
                     The task will use given line window for 17 and 19 while the task performs
                     line deteciton/validation for spw 23 because no line window is set.
                     On the other hand, line detection/validation is skipped for spw 21 due to
                     the effect of None.


   example: [100,200] (channel), [115e9, 115.1e9] (frequency in Hz)
            ['115GHz', '115.1GHz'], see above for more examples
        </description>
        <any type="variant"/>
	    <value type="string"/>
    </param>

    <param name="linewindowmode" subparam="true" type="string">
        <shortdescription>Merge or replace given manual line window with line detection/validation result</shortdescription>
        <description>Merge or replace given manual line window with line
                     detection/validation result. If 'replace' is given, line
                     detection and validation will not be performed.
                     On the other hand, when 'merge' is specified, line
                     detection/validation will be performed and manually
                     specified line windows are added to the result.

                     Note that this has no effect when linewindow for target
                     spw is an empty list. In that case, line detection/validation
                     will be performed regardless of the value of linewindowmode.
                     In case if no linewindow nor line detection/validation
                     are necessary, you should set linewindowmode to 'replace'
                     and specify None as a value of the linewindow dictionary
                     for the spw to apply. See parameter description of linewindow
                     for detail.

        </description>
        <value>replace</value>
        <allowed kind="enum">
            <value>replace</value>
            <value>merge</value>
        </allowed>
    </param>

    <param name="edge" type="intVec">
        <shortdescription>Edge channels to be dropped</shortdescription>
        <description>Number of edge channels to be dropped from baseline
                     subtraction. The value must be a list with length of 2,
                     whose values specify left and right edge channels,
                     respectively.

                     example: [10,10]
        </description>
        <value/>
    </param>

    <param name="broadline" type="bool">
        <shortdescription>Try to detect broad component of the line</shortdescription>
        <description>Try to detect broad component of spectral line if True.
        </description>
	<value>True</value>
    </param>

    <param name="clusteringalgorithm" type="string">
	<shortdescription>Algorithm for line validation clustering algorithm</shortdescription>
        <description>Selection of the algorithm used in the clustering
                     analysis to check the validity of detected line features.
                    'kmean' algorithm and hierarchical clustering algorithm
                    'hierarchy', and their combination ('both') are so far
                    implemented.
        </description>
	<value>hierarchy</value>
	<allowed kind="enum">
	    <value>hierarchy</value>
	    <value>kmean</value>
        <value>both</value>
	</allowed>
    </param>

    <param name="deviationmask" type="bool">
        <shortdescription>Apply deviation mask in addition to detected line masks</shortdescription>
        <description>Apply deviation mask in addition to masks determined by
                     the automatic line detection.
        </description>
	<value>True</value>
    </param>

    <param name="pipelinemode" type="string">
	<shortdescription>The pipeline operating mode</shortdescription>
        <description>The pipeline operating mode. In 'automatic' mode the
                     pipeline determines the values of all context defined
                     pipeline inputs  automatically.  In 'interactive' mode
                     the user can set the pipeline context defined parameters
                     manually.  In 'getinputs' mode the user can check the
                     settings of all pipeline parameters without running the
                     task.
        </description>
	<value>automatic</value>
	<allowed kind="enum">
	    <value>automatic</value>
	    <value>interactive</value>
	    <value>getinputs</value>
	</allowed>
    </param>

    <param name="infiles" subparam="true" type="stringVec">
        <shortdescription>List of input files to be calibrated (default all)</shortdescription>
        <description>List of data files. These must be a name of
                     MeasurementSets that are registered to context via
                     hsd_importdata task.

                     example: vis=['X227.ms', 'X228.ms']
        </description>
        <value/>
    </param>

	<param name="field" subparam="true" type="string">
		<shortdescription>select data by field</shortdescription>
		<description>Data selection by field.
                             example: '1' (select by FIELD_ID)
                                      'M100*' (select by field name)
                                      '' (all fields)
                </description>
	<value/>
	</param>

	<param name="antenna" subparam="true" type="string">
		<shortdescription>select data by antenna</shortdescription>
                <description>Data selection by antenna.
                             example: '1' (select by ANTENNA_ID)
                                      'PM03' (select by antenna name)
                                      '' (all antennas)
                </description>
		<value/>
	</param>

    <param name="spw" subparam="true" type="any">
            <shortdescription>select data by spw ids, e.g. \'3,5,7\' (\'\'=all)</shortdescription>
            <description>Data selection by spw.
                         example: '3,4' (generate caltable for spw 3 and 4)
                                  ['0','2'] (spw 0 for first data, 2 for second)
                                  '' (all spws)
            </description>
            <type>string</type><type>stringVec</type>
            <value type="string"/>
    </param>

    <param name="pol" subparam="true" type="any">
            <shortdescription>select data by polarizations, e.g. \'0~1\' (\'\'=all)</shortdescription>
            <description>Data selection by polarizations.
                         example: '0' (generate caltable for pol 0)
                                  ['0~1','0'] (pol 0 and 1 for first data, only 0 for second)
                                  '' (all polarizations)
            </description>
            <type>string</type><type>stringVec</type>
            <value type="string"/>
    </param>

    <param name="dryrun" subparam="true" type="bool">
	<shortdescription>Run the task (False) or display task command (True)</shortdescription>
        <description>Run the commands (True) or generate the commands to be
                     run but do not execute (False).
        </description>
	<value>False</value>
    </param>

    <param name="acceptresults" subparam="true" type="bool">
	<shortdescription>Add the results into the pipeline context</shortdescription>
        <description>Add the results of the task to the pipeline context (True)
                     or reject them (False).
        </description>
	<value>True</value>
    </param>

    <param name="parallel" subparam="true" type="string">
        <shortdescription>Execute using CASA HPC functionality, if available.</shortdescription>
        <description>Execute using CASA HPC functionality, if available.</description>
            <value>automatic</value>
            <allowed kind="enum">
                <value>automatic</value>
                <value>true</value>
                <value>false</value>
            </allowed>
    </param>

    <constraints>
    <when param="linewindow">
        <notequals type="string" value="">
            <default param="linewindowmode"><value type="string">replace</value></default>
        </notequals>
    </when>
	<when param="pipelinemode">
	    <equals type="string" value="automatic">
	    </equals>
	    <equals type="string" value="interactive">
                <default param="infiles"><value type="stringVec"/></default>
                <default param="field"><value type="string"/></default>
                <default param="antenna"><value type="string"/></default>
                <default param="spw"><value type="string"/></default>
                <default param="pol"><value type="string"/></default>
                <default param="parallel"><value type="string">automatic</value></default>
		<default param="dryrun"><value type="bool">False</value></default>
		<default param="acceptresults"><value type="bool">True</value></default>
	    </equals>
	    <equals type="string" value="getinputs">
                <default param="infiles"><value type="stringVec"/></default>
                <default param="field"><value type="string"/></default>
                <default param="antenna"><value type="string"/></default>
                <default param="spw"><value type="string"/></default>
                <default param="pol"><value type="string"/></default>
	    </equals>
	</when>
    </constraints>

</input>


<returns>any</returns>


<example/>
</task>
</casaxml>
