import collections
import os

import pipeline.infrastructure.logging as logging
import pipeline.infrastructure.pipelineqa as pqa
import pipeline.infrastructure.utils as utils
from pipeline.h.tasks.tsysflag.qa import TsysflagQAHandler
from pipeline.h.tasks.tsysflag.resultobjects import TsysflagResults
from .tsysflagcontamination import TsysFlagContamination

LOG = logging.get_logger(__name__)


class TsysflagContaminationQAHandler(pqa.QAPlugin):
    """
    QA handler for an uncontained TsysflagResult generated by TsysflagContamination.
    """

    result_cls = TsysflagResults
    child_cls = None
    generating_task = TsysFlagContamination

    def handle(self, context, result):
        # we must instantiate rather than extend TsysflagQAHandler as plugin
        # registration only works on classes that directly extend QAPlugin
        delegate = TsysflagQAHandler()
        delegate.handle(context, result)

        # add any QA scores generated during task execution, such as the
        # preflight checks on data. Here we use the qascores_from_task
        # property added on-the-fly by hifa_tsysflagcontamination, which is
        # not an 'official' TsysflagResults property.
        result.qa.pool.extend(result.qascores_from_task)

        # now add any QA scores originating from the heuristic itself,
        # denoting data that requires further inspection
        vis = os.path.basename(result.inputs["vis"])
        origin = pqa.QAOrigin(
            metric_name="pipeline.extern.tsys_contamination",
            metric_score="N/A",
            metric_units="",
        )
        for shortmsg, longmsg in getattr(result, "extern_warnings", []):
            extern_score = pqa.QAScore(
                score=0.6,  # as requested in PIPE-2009
                longmsg=f"{longmsg} Check the Tsys plots.",
                shortmsg=shortmsg,
                applies_to=pqa.TargetDataSelection(vis={vis}),
                origin=origin,
            )
            result.qa.pool.append(extern_score)

        # The heuristic cannot operate on some kinds of data (multispec, DSB,
        # etc.). Skipping the task in these cases should not result in a QA
        # -0.1 failure.
        if result.qascores_from_task:
            result.qa.pool = [
                score
                for score in result.qa.pool
                if score.longmsg != "Task ended prematurely"
            ]


class TsysflagContaminationListQAHandler(pqa.QAPlugin):
    """
    QA handler for a list containing TsysflagResults generated by TsysflagContamination.
    """

    result_cls = collections.abc.Iterable
    child_cls = TsysflagResults
    generating_task = TsysFlagContamination

    def handle(self, context, result):
        # collate the QAScores from each child result, pulling them into our
        # own QAscore list
        collated = utils.flatten([r.qa.pool for r in result])
        result.qa.pool[:] = collated

        caltables = [r.inputs["caltable"] for r in result]
        longmsg = "No extra data was flagged in %s".format(
            utils.commafy(caltables, quotes=False, conjunction="or")
        )
        result.qa.all_unity_longmsg = longmsg
