import collections
import os

import pipeline.infrastructure.logging as logging
import pipeline.infrastructure.pipelineqa as pqa
from pipeline.h.tasks.tsysflag.qa import TsysflagQAHandler, TsysflagListQAHandler
from pipeline.h.tasks.tsysflag.resultobjects import TsysflagResults
from pipeline.qa.scorecalculator import (
    score_tsysflagcontamination_external_heuristic,
    score_tsysflagcontamination_contamination_flagged,
)
from .tsysflagcontamination import TsysFlagContamination

LOG = logging.get_logger(__name__)


class TsysflagContaminationQAHandler(pqa.QAPlugin):
    """
    QA handler for an uncontained TsysflagResult generated by TsysflagContamination.
    """

    result_cls = TsysflagResults
    child_cls = None
    generating_task = TsysFlagContamination

    def handle(self, context, result):
        # we must instantiate rather than extend TsysflagQAHandler as plugin
        # registration only works on classes that directly extend QAPlugin
        delegate = TsysflagQAHandler()
        delegate.handle(context, result)

        # add any QA scores generated during task execution, such as the
        # preflight checks on data. Here we use the qascores_from_task
        # property added on-the-fly by hifa_tsysflagcontamination, which is
        # not an 'official' TsysflagResults property.
        result.qa.pool.extend(result.qascores_from_task)

        # other scores are added following the standard pattern with score
        # heuristics from the scorecalculator module
        qascores_to_adopt = getattr(result, "extern_qascores", [])
        result.qa.pool.extend(
            score_tsysflagcontamination_external_heuristic(qascores_to_adopt)
        )

        # only add a score for line contamination flagging if the heuristic
        # actually ran
        if not result.task_incomplete_reason:
            vis = os.path.basename(result.inputs["vis"])
            caltable = os.path.basename(result.inputs["caltable"])
            summaries = getattr(result, "summaries", {})
            result.qa.pool.append(
                score_tsysflagcontamination_contamination_flagged(
                    vis, caltable, summaries
                )
            )

        # The heuristic cannot operate on some kinds of data (multispec, DSB,
        # etc.). Skipping the task in these cases should not result in a QA
        # -0.1 failure.
        if result.qascores_from_task:
            result.qa.pool = [
                score
                for score in result.qa.pool
                if score.longmsg != "Task ended prematurely"
            ]


class TsysflagContaminationListQAHandler(pqa.QAPlugin):
    """
    QA handler for a list containing TsysflagResults generated by TsysflagContamination.
    """

    result_cls = collections.abc.Iterable
    child_cls = TsysflagResults
    generating_task = TsysFlagContamination

    def handle(self, context, result):
        # Again, we cannot extend TsysflagListQAHandler as plugin registration
        # only works on classes that directly extend QAPlugin
        delegate = TsysflagListQAHandler()
        delegate.handle(context, result)
