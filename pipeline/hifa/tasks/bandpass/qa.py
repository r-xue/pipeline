"""
QA handlers for hifa_bandpass task.
"""

import os

from pipeline.extern import subband_qa
from pipeline.domain import MeasurementSet
from pipeline.infrastructure.launcher import Context
import pipeline.infrastructure.logging as logging
import pipeline.infrastructure.pipelineqa as pqa
import pipeline.infrastructure.renderer.rendererutils as rutils
import pipeline.infrastructure.utils as utils
from pipeline.hif.tasks.bandpass.common import BandpassResults
from pipeline.hif.tasks.bandpass.qa import BandpassQAHandler
from pipeline.hifa.tasks.bandpass.almaphcorbandpass import LowSNRPhaseupSolintOrigin
from pipeline.infrastructure.pipelineqa import QAOrigin
from pipeline.infrastructure.utils import commafy
from pipeline.qa.scorecalculator import linear_score
from .almaphcorbandpass import ALMAPhcorBandpass

LOG = logging.get_logger(__name__)


class AlmaBandpassQAHandler(pqa.QAPlugin):
    """QA handler for a BandpassResults generated by hifa_bandpass."""

    result_cls = BandpassResults
    child_cls = None
    generating_task = ALMAPhcorBandpass

    def handle(self, context, result):
        """Invoke QA handler for base BandpassResults."""
        base_handler = BandpassQAHandler()
        base_handler.handle(context, result)

        # Run local QA handlers which only require the results
        for handler in [
            _phaseup_combine_handler,
            _phaseup_missing_handler,
            _phaseup_snr_handler,
            _low_channel_solutions_handler,
            _adjusted_phaseup_solint_handler,
        ]:
            result.qa.pool.extend(handler(result))

        # Run subband QA handler, which requires the context
        subband_qa_score = _subband_handler(context, result)
        result.qa.pool.extend(subband_qa_score)


def _phaseup_combine_handler(result: BandpassResults) -> list[pqa.QAScore]:
    """
    Generate QA score for whether bandpass phase-up used spw combination.

    Args:
        context: the task Context.
        result: the task Result to inspect.

    Returns:
        A list of QA scores informing about spw combination in phase-up.
    """
    # No QA score if phase-up results are absent.
    if not result.preceding:
        return []

    # Step through every CalApp to find and score the phase-up caltable.
    scores = []
    for calapp_list in result.preceding:
        for calapp in calapp_list:
            # Skip the phase-offset tables (created with solint='inf').
            if utils.get_origin_input_arg(calapp, 'solint') == 'inf':
                continue

            # Evaluate whether CalApp used spw combination.
            combine = utils.get_origin_input_arg(calapp, 'combine')
            # If SpW combination was used, turn this into a blue QA score.
            if combine == 'spw':
                score = rutils.SCORE_THRESHOLD_SUBOPTIMAL
                longmsg = f"{calapp.vis}: Spectral window combination used to improve phase-up solution SNR."
                shortmsg = f"Spw combination used in phase-up"
            else:
                score = 1.0
                longmsg = f"{calapp.vis}: Spectral window combination not used for phase-up solution."
                shortmsg = f"No spw combination used in phase-up"
            qascore = pqa.QAScore(
                score,
                longmsg=longmsg,
                shortmsg=shortmsg,
                weblog_location=pqa.WebLogLocation.ACCORDION,
                origin=pqa.QAOrigin(
                    metric_name='bandpass.phaseup.combine',
                    metric_score=score,
                    metric_units='Score based on whether bandpass phaseup used combine',
                ),
                hierarchy="bandpass.phaseup.combine",
                applies_to=pqa.TargetDataSelection(vis={calapp.vis}),
            )
            scores.append(qascore)

    return scores


def _phaseup_missing_handler(result: BandpassResults) -> list[pqa.QAScore]:
    """
    Generate QA score for whether bandpass phase-up is missing.

    Args:
        context: the task Context.
        result: the task Result to inspect.

    Returns:
        A list of QA scores on presence of bandpass phase-up solutions.
    """
    # No QA score if result.preceding is populated (assumed to be with bandpass
    # phase-up result).
    if result.preceding:
        return []

    # Adjust QA message based on whether it is intentional that the phase-up
    # solution is missing.
    hm_phaseup = result.inputs["hm_phaseup"]
    vis = os.path.basename(result.inputs["vis"])
    if hm_phaseup == '':
        score = 1.0
        longmsg = f"{vis}: skipped bandpass phase-up solution (disabled with hm_phaseup='')."
        shortmsg = f"No phase-up computed"
    else:
        score = 0.0
        longmsg = (f"{vis}: bandpass phase-up solution missing from results, even though it should have been computed"
                   f" (hm_phaseup = {hm_phaseup}).")
        shortmsg = f"No phase-up found"

    qascore = pqa.QAScore(
        score,
        longmsg=longmsg,
        shortmsg=shortmsg,
        weblog_location=pqa.WebLogLocation.ACCORDION,
        origin=pqa.QAOrigin(
            metric_name="bandpass.phaseup.missing",
            metric_score=score,
            metric_units="Presence of bandpass phase-up.",
        ),
        hierarchy="bandpass.phaseup.missing",
        applies_to=pqa.TargetDataSelection(vis={vis}),
    )

    return [qascore]


def _phaseup_snr_handler(result: BandpassResults) -> list[pqa.QAScore]:
    """
    Generate QA score for the expected phase-up SNR for the bandpass calibrator.

    Args:
        context: the task Context.
        result: the task Result to inspect.

    Returns:
        A list of QA scores informing about expected phase-up SNR.
    """
    # No QA score if expected phase-up SNR is absent.
    if not result.phaseup_snr_expected:
        return []

    vis = result.inputs["vis"]
    snr_expected = result.phaseup_snr_expected
    snr_threshold = result.inputs['phaseupsnr']

    if snr_expected <= 0.3 * snr_threshold:
        score = rutils.SCORE_THRESHOLD_ERROR
        shortmsg = 'Low bandpass phase-up SNR'
        longmsg = (f'{vis}: expected bandpass phase-up SNR ({snr_expected:.1f}) is <= 30% of the phase SNR'
                   f' threshold ({snr_threshold:.1f}).')
    elif snr_expected <= 0.5 * snr_threshold:
        score = rutils.SCORE_THRESHOLD_WARNING
        shortmsg = 'Low bandpass phase-up SNR'
        longmsg = (f'{vis}: expected bandpass phase-up SNR ({snr_expected:.1f}) is <= 50% of the phase SNR'
                   f' threshold ({snr_threshold:.1f}).')
    elif snr_expected <= 0.75 * snr_threshold:
        score = rutils.SCORE_THRESHOLD_SUBOPTIMAL
        shortmsg = 'Low bandpass phase-up SNR'
        longmsg = (f'{vis}: expected bandpass phase-up SNR ({snr_expected:.1f}) is <= 75% of the phase SNR'
                   f' threshold ({snr_threshold:.1f}).')
    else:
        score = 1.0
        shortmsg = 'Bandpass phase-up SNR is ok'
        longmsg = (f'{vis}: expected bandpass phase-up SNR ({snr_expected:.1f}) is > 75% of the phase SNR'
                   f' threshold ({snr_threshold:.1f}).')

    qascore = pqa.QAScore(
        score,
        longmsg=longmsg,
        shortmsg=shortmsg,
        weblog_location=pqa.WebLogLocation.ACCORDION,
        origin=pqa.QAOrigin(
            metric_name='bandpass.phaseup.snr',
            metric_score=snr_expected,
            metric_units='Phase-up SNR',
        ),
        hierarchy="bandpass.phaseup.snr",
        applies_to=pqa.TargetDataSelection(vis={vis}),
    )

    return [qascore]


def _low_channel_solutions_handler(result) -> list[pqa.QAScore]:
    """
    Generate QA scores for solutions with fewer than 8 channels.

    :param context: the task Context
    :param result: the task Result to inspect
    :return: a list of QA scores warning about low channel solutions
    """
    if not result.low_channel_solutions:
        return []

    unique_spws = sorted(list(set(result.low_channel_solutions)))
    spws_text = commafy(unique_spws, quotes=False, multi_prefix="s")

    vis = os.path.basename(result.inputs["vis"])
    score = pqa.QAScore(
        0.7,
        longmsg=f"Low SNR heuristics: {vis} would have fewer than 8 channels in its solution for spw{spws_text}.",
        shortmsg="Low SNR heuristics",
        applies_to=pqa.TargetDataSelection(vis={vis}, spw=set(unique_spws)),
        weblog_location=pqa.WebLogLocation.ACCORDION,
        hierarchy="bandpass.low_channel_solutions",
        origin=pqa.QAOrigin(
            metric_name="bandpass.low_channel_solutions",
            metric_score=",".join(map(str, unique_spws)),
            metric_units="IDs of spws with fewer than 8 channels in solution",
        ),
    )
    return [score]


def _adjusted_phaseup_solint_handler(result: BandpassResults) -> list[pqa.QAScore]:
    """
    Generate QA scores for adjusted phase-up solution intervals that could
    indicate a suboptimal calibration.

    These QA scores cover points 2, 3, and 4 in the PIPE-1760 spec.

    :param context: the task Context
    :param result: the task Result to inspect
    :return: a list of QA scores warning about suboptimal solints
    """
    vis = result.inputs['vis']
    qa_scores = []

    # Group adjustments by their key characteristics
    grouped_adjustments = {}
    for adjustment in result.solint_adjustments:
        # Skip adjustments we don't want to handle
        if adjustment.origin not in [
            LowSNRPhaseupSolintOrigin.UNCOMBINED_GT_PHASEUPMAXSOLINT.value,
            LowSNRPhaseupSolintOrigin.COMBINED_GT_PHASEUPMAXSOLINT.value,
            LowSNRPhaseupSolintOrigin.NO_SNR_RESULT.value,
            LowSNRPhaseupSolintOrigin.SPWS_MISSING_DATA.value,
            LowSNRPhaseupSolintOrigin.INSUFFICIENT_POINTS.value,
            LowSNRPhaseupSolintOrigin.TOO_FEW_CHANNELS.value,
        ]:
            continue

        # Create a key that uniquely identifies similar adjustments
        key = (
            adjustment.origin,
            adjustment.adjusted,
            getattr(adjustment, "threshold", None),
        )
        if key not in grouped_adjustments:
            grouped_adjustments[key] = {"adjustment": adjustment, "spws": set()}
        # Combine SPWs from the same type of adjustment
        grouped_adjustments[key]["spws"].update(adjustment.applies_to.spw)

    # Generate QA scores for each group
    for key, group in grouped_adjustments.items():
        adjustment = group["adjustment"]
        applies_to = pqa.TargetDataSelection(vis={vis})

        match adjustment.origin:
            case LowSNRPhaseupSolintOrigin.TOO_FEW_CHANNELS.value:
                # Handles the case where there are too few channels available for reliable smoothing.
                #
                # This covers point 2 in the PIPE-1760 spec
                #       2. "Warning! Too few channels..."
                spws_str = commafy(
                    sorted(group["spws"]), quotes=False, multi_prefix="s"
                )
                longmsg = (
                    f"insufficient channels for smoothing. Changing recommended solint from {adjustment.original} to "
                    f"{adjustment.adjusted} for {vis} spw{spws_str}."
                )
                applies_to.spw |= group["spws"]
                score = 0.7
                origin = pqa.QAOrigin(
                    metric_name=adjustment.origin,
                    metric_score=",".join(map(str, sorted(group["spws"]))),
                    metric_units="Spw with insufficient channels",
                )

            case LowSNRPhaseupSolintOrigin.UNCOMBINED_GT_PHASEUPMAXSOLINT.value:
                spws_str = commafy(
                    sorted(group["spws"]), quotes=False, multi_prefix="s"
                )
                longmsg = (f"optimal solint for {vis} spw{spws_str} is greater than the maximum allowed value "
                           f"({adjustment.threshold}). Solint adjusted to {adjustment.adjusted}.")
                applies_to.spw |= group["spws"]
                score, origin = _score_bandpass_phaseup_solint(
                    adjustment.adjusted, adjustment.integration_time
                )

            case LowSNRPhaseupSolintOrigin.COMBINED_GT_PHASEUPMAXSOLINT.value:
                longmsg = (f"optimal solint for combined spws in {vis} is greater than the maximum allowed value "
                           f"({adjustment.threshold}). Solint adjusted to {adjustment.adjusted}.")
                score, origin = _score_bandpass_phaseup_solint(
                    adjustment.adjusted, adjustment.integration_time
                )

            case LowSNRPhaseupSolintOrigin.NO_SNR_RESULT.value:
                longmsg = (f"no SNR result available for {vis}. Could not calculate optimal phase-up solint; reverted "
                           f"to default solint ({adjustment.adjusted}) which could result in poor solutions.")
                score = rutils.SCORE_THRESHOLD_WARNING
                origin = pqa.QAOrigin(metric_name=adjustment.origin)

            case LowSNRPhaseupSolintOrigin.SPWS_MISSING_DATA.value:
                longmsg = (f"insufficent data in {vis} to calculate optimal phase-up solint; reverted to default "
                           f"solint ({adjustment.adjusted}) which could result in poor solutions.")
                score = rutils.SCORE_THRESHOLD_WARNING
                origin = pqa.QAOrigin(metric_name=adjustment.origin)

            case LowSNRPhaseupSolintOrigin.INSUFFICIENT_POINTS.value:
                spws_str = commafy(
                    sorted(group["spws"]), quotes=False, multi_prefix="s"
                )
                longmsg = (f"insufficient points in phase-up solution for {vis} spw{spws_str}, solint adjusted to "
                           f"{adjustment.adjusted:0.3f}.")
                applies_to.spw |= group["spws"]
                score = rutils.SCORE_THRESHOLD_WARNING
                origin = pqa.QAOrigin(metric_name=adjustment.origin)

        qa_score = pqa.QAScore(
            score,
            longmsg="Low SNR heuristics: " + longmsg,
            shortmsg="Low SNR heuristics",
            applies_to=applies_to,
            weblog_location=pqa.WebLogLocation.ACCORDION,
            hierarchy=adjustment.origin,
            origin=origin,
        )
        qa_scores.append(qa_score)

    return qa_scores


def _score_bandpass_phaseup_solint(
    solint: str | float, int_time: float
) -> tuple[float, QAOrigin]:
    """
    Score the expected phase-up solint for bandpass calibrator.

    Scales the score between 0.66 and 0.9 based on the integration time.

    :param solint: the solution interval used for bandpass phase-up
    :param int_time: the integration time for the bandpass calibrator
    """
    origin = pqa.QAOrigin(
        metric_name='score_bandpass_phaseup_solint',
        metric_score=solint,
        metric_units='Solution interval used for bandpass phase-up',
    )

    match solint:
        case "int":
            score = 1.0
        case _:
            float_solint = float((solint).split("s")[0])
            # limit score to blue INFO range
            score = linear_score(float_solint, 2 * int_time, 60.0, rutils.SCORE_THRESHOLD_SUBOPTIMAL, rutils.SCORE_THRESHOLD_WARNING + 0.01)

    return score, origin


def _fraction_of_impacted_spws(spw_dict: dict, caltable: str, ms: MeasurementSet) -> float:
    """
    Get the fraction of impacted spws out of the total FDM spws
    with valid bandpass solutions. Spws without bandpass
    solutions or non-FDM spws are not included.

    Args:
        spw_dict: dictionary of spws affected by platforming
                 Expected structure: {spw_id: {'failure': str, 'antennas': list[str]}}
        caltable: path to the calibration table

    Returns:
        Fraction of impacted spws out of the total spws
        with valid bandpass solutions in the caltable
    """
    spws_in_caltable = utils.caltable_tools.get_spws_from_table(caltable)

    # Only include FDM spws in the calculation as the heuristic is not evaluated for other modes
    fdm_spws = [spw for spw in spws_in_caltable if 'FDM' in ms.get_spectral_window(spw).type]

    total_fdm_spws = len(fdm_spws)

    if total_fdm_spws == 0:
        return 0.0

    spws_impacted = len(spw_dict)

    return spws_impacted/total_fdm_spws


def _calc_subband_qa_score(spw_dict: dict, ms: MeasurementSet, caltable) -> pqa.QAScore:
    """
    Calculate the QA score for subband issues.

    Args:
        spw_dict: dictionary of spws affected by platforming
                 Expected structure: {spw_id: {'failure': str, 'antennas': list[str]}}
        ms: Measurement set object

    Returns:
        QA score
    """
    # Fraction of impacted spws
    f_spw = _fraction_of_impacted_spws(spw_dict, caltable, ms)

    if f_spw <= 0.0:
        score = 1.0
        shortmsg = "No correlator subband issues detected"
        longmsg = "No correlator subband issues detected"
    else:
        # See PIPE-2103 for more information
        qa_max = 0.65
        qa_min = 0.5

        # Check if reference spw is impacted
        ref_spw_impacted = ms.get_representative_source_spw() in spw_dict

        if ref_spw_impacted:
            qa_ref = 0.15
        else:
            qa_ref = 0.0

        score = qa_max - (qa_max-qa_min) * f_spw - qa_ref

        shortmsg = "Correlator subband issues detected"

        longmsg = f"For {ms.basename}: correlator subband issues may be affecting the following solutions: "

        spw_messages = [
            f"Spw {spw} ({data['failure']}): {', '.join(data['antennas'])}"
            for spw, data in spw_dict.items()
        ]
        longmsg += "; ".join(spw_messages)

    qascore = pqa.QAScore(
        score,
        longmsg=longmsg,
        shortmsg=shortmsg,
        vis=ms.name,
        weblog_location=pqa.WebLogLocation.ACCORDION,
        origin=pqa.QAOrigin(
            metric_name='bandpass.subband',
            metric_score=score,
        ),
        applies_to=pqa.TargetDataSelection(vis={ms.name}),
        )
    return qascore


def _subband_handler(context: Context, result: BandpassResults) -> list[pqa.QAScore]:
    """
    Generate QA score for platforming/sub-band issues.

    See PIPE-1903 for more information.

    Args:
        context: the task Context.
        result: the task Result to inspect.

    Returns:
        A list of QA scores informing about platforming/sub-band issues.
    """
    vis = result.inputs["vis"]
    scores = []
    ms = context.observing_run.get_ms(vis)

    # Heuristics are evaluated only if the data is from BLC FDM mode
    # And there is nothing to evaluate if there is no bandpass result
    if "ALMA_BASELINE" not in ms.correlator_name or not result.final:
        not_blc_qa_score = pqa.QAScore(
            1.0,
            longmsg="No BLC FDM bandpass tables. Bandpass subband QA is not evaluated",
            shortmsg="Bandpass subband QA not evaluated.",
            vis=vis,
            origin=pqa.QAOrigin(
            metric_name='bandpass.subband',
            metric_score=1.0,
            ),
            applies_to=pqa.TargetDataSelection(vis={vis}),
        )
        scores.append(not_blc_qa_score)
        return scores

    # Calculate the QA score
    for calapp in result.final:
        LOG.debug(f"Calculating Bandpass Platforming QA for: {calapp.gaintable}")
        caltable = calapp.gaintable

        # Wrapping the extern call in a try/except to avoid breaking the rest of the QA scoring if it fails
        try:
            LOG.debug(f"Fetching platforming QA info for MS {vis} and caltable {caltable}")
            spw_dict = subband_qa.bandpass_platforming(ms, caltable)
            LOG.debug(f"Spws affected by platforming {spw_dict}")
            qascore = _calc_subband_qa_score(spw_dict, ms, caltable)
            scores.append(qascore)

        except Exception as e:
            LOG.warning(f"Failed to process bandpass QA for {vis}, caltable {caltable}: {e}", exc_info=True)

            failing_qascore = pqa.QAScore(
                0.66,
                longmsg=f"Bandpass subband QA calculation failed for {vis}: {caltable}",
                shortmsg="Bandpass subband QA calculation failed.",
                vis=vis,
                origin=pqa.QAOrigin(
                metric_name='bandpass.subband',
                metric_score=0.66,
                ),
                applies_to=pqa.TargetDataSelection(vis={vis}),
            )
            scores.append(failing_qascore)
            continue

    return scores
